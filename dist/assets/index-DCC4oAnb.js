;(function () {
  const e = document.createElement('link').relList
  if (e && e.supports && e.supports('modulepreload')) return
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i)
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === 'childList')
        for (const o of s.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && r(o)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(i) {
    const s = {}
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : i.crossOrigin === 'anonymous'
        ? (s.credentials = 'omit')
        : (s.credentials = 'same-origin'),
      s
    )
  }
  function r(i) {
    if (i.ep) return
    i.ep = !0
    const s = n(i)
    fetch(i.href, s)
  }
})()
/**
 * @vue/shared v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function yv(t, e) {
  const n = new Set(t.split(','))
  return e ? (r) => n.has(r.toLowerCase()) : (r) => n.has(r)
}
const yt = {},
  Ba = [],
  br = () => {},
  hP = () => !1,
  ap = (t) =>
    t.charCodeAt(0) === 111 &&
    t.charCodeAt(1) === 110 &&
    (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97),
  _v = (t) => t.startsWith('onUpdate:'),
  Gt = Object.assign,
  vv = (t, e) => {
    const n = t.indexOf(e)
    n > -1 && t.splice(n, 1)
  },
  dP = Object.prototype.hasOwnProperty,
  Je = (t, e) => dP.call(t, e),
  ye = Array.isArray,
  Ua = (t) => zu(t) === '[object Map]',
  lp = (t) => zu(t) === '[object Set]',
  bb = (t) => zu(t) === '[object Date]',
  Ae = (t) => typeof t == 'function',
  Pt = (t) => typeof t == 'string',
  Ls = (t) => typeof t == 'symbol',
  ct = (t) => t !== null && typeof t == 'object',
  bv = (t) => (ct(t) || Ae(t)) && Ae(t.then) && Ae(t.catch),
  LI = Object.prototype.toString,
  zu = (t) => LI.call(t),
  fP = (t) => zu(t).slice(8, -1),
  VI = (t) => zu(t) === '[object Object]',
  Ev = (t) => Pt(t) && t !== 'NaN' && t[0] !== '-' && '' + parseInt(t, 10) === t,
  Sc = yv(
    ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
  ),
  cp = (t) => {
    const e = Object.create(null)
    return (n) => e[n] || (e[n] = t(n))
  },
  pP = /-(\w)/g,
  pi = cp((t) => t.replace(pP, (e, n) => (n ? n.toUpperCase() : ''))),
  mP = /\B([A-Z])/g,
  oa = cp((t) => t.replace(mP, '-$1').toLowerCase()),
  up = cp((t) => t.charAt(0).toUpperCase() + t.slice(1)),
  Lm = cp((t) => (t ? `on${up(t)}` : '')),
  Vs = (t, e) => !Object.is(t, e),
  _d = (t, e) => {
    for (let n = 0; n < t.length; n++) t[n](e)
  },
  zd = (t, e, n) => {
    Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value: n })
  },
  hy = (t) => {
    const e = parseFloat(t)
    return isNaN(e) ? t : e
  },
  FI = (t) => {
    const e = Pt(t) ? Number(t) : NaN
    return isNaN(e) ? t : e
  }
let Eb
const BI = () =>
  Eb ||
  (Eb =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
      ? self
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : {})
function No(t) {
  if (ye(t)) {
    const e = {}
    for (let n = 0; n < t.length; n++) {
      const r = t[n],
        i = Pt(r) ? vP(r) : No(r)
      if (i) for (const s in i) e[s] = i[s]
    }
    return e
  } else if (Pt(t) || ct(t)) return t
}
const gP = /;(?![^(]*\))/g,
  yP = /:([^]+)/,
  _P = /\/\*[^]*?\*\//g
function vP(t) {
  const e = {}
  return (
    t
      .replace(_P, '')
      .split(gP)
      .forEach((n) => {
        if (n) {
          const r = n.split(yP)
          r.length > 1 && (e[r[0].trim()] = r[1].trim())
        }
      }),
    e
  )
}
function hp(t) {
  let e = ''
  if (Pt(t)) e = t
  else if (ye(t))
    for (let n = 0; n < t.length; n++) {
      const r = hp(t[n])
      r && (e += r + ' ')
    }
  else if (ct(t)) for (const n in t) t[n] && (e += n + ' ')
  return e.trim()
}
const bP = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
  EP = yv(bP)
function UI(t) {
  return !!t || t === ''
}
function TP(t, e) {
  if (t.length !== e.length) return !1
  let n = !0
  for (let r = 0; n && r < t.length; r++) n = dp(t[r], e[r])
  return n
}
function dp(t, e) {
  if (t === e) return !0
  let n = bb(t),
    r = bb(e)
  if (n || r) return n && r ? t.getTime() === e.getTime() : !1
  if (((n = Ls(t)), (r = Ls(e)), n || r)) return t === e
  if (((n = ye(t)), (r = ye(e)), n || r)) return n && r ? TP(t, e) : !1
  if (((n = ct(t)), (r = ct(e)), n || r)) {
    if (!n || !r) return !1
    const i = Object.keys(t).length,
      s = Object.keys(e).length
    if (i !== s) return !1
    for (const o in t) {
      const a = t.hasOwnProperty(o),
        l = e.hasOwnProperty(o)
      if ((a && !l) || (!a && l) || !dp(t[o], e[o])) return !1
    }
  }
  return String(t) === String(e)
}
function $I(t, e) {
  return t.findIndex((n) => dp(n, e))
}
const It = (t) =>
    Pt(t)
      ? t
      : t == null
      ? ''
      : ye(t) || (ct(t) && (t.toString === LI || !Ae(t.toString)))
      ? JSON.stringify(t, HI, 2)
      : String(t),
  HI = (t, e) =>
    e && e.__v_isRef
      ? HI(t, e.value)
      : Ua(e)
      ? {
          [`Map(${e.size})`]: [...e.entries()].reduce(
            (n, [r, i], s) => ((n[Vm(r, s) + ' =>'] = i), n),
            {}
          )
        }
      : lp(e)
      ? { [`Set(${e.size})`]: [...e.values()].map((n) => Vm(n)) }
      : Ls(e)
      ? Vm(e)
      : ct(e) && !ye(e) && !VI(e)
      ? String(e)
      : e,
  Vm = (t, e = '') => {
    var n
    return Ls(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t
  }
/**
 * @vue/reactivity v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let tr
class zI {
  constructor(e = !1) {
    ;(this.detached = e),
      (this._active = !0),
      (this.effects = []),
      (this.cleanups = []),
      (this.parent = tr),
      !e && tr && (this.index = (tr.scopes || (tr.scopes = [])).push(this) - 1)
  }
  get active() {
    return this._active
  }
  run(e) {
    if (this._active) {
      const n = tr
      try {
        return (tr = this), e()
      } finally {
        tr = n
      }
    }
  }
  on() {
    tr = this
  }
  off() {
    tr = this.parent
  }
  stop(e) {
    if (this._active) {
      let n, r
      for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop()
      for (n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]()
      if (this.scopes) for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0)
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop()
        i && i !== this && ((this.parent.scopes[this.index] = i), (i.index = this.index))
      }
      ;(this.parent = void 0), (this._active = !1)
    }
  }
}
function jI(t) {
  return new zI(t)
}
function wP(t, e = tr) {
  e && e.active && e.effects.push(t)
}
function Tv() {
  return tr
}
function WI(t) {
  tr && tr.cleanups.push(t)
}
let Mo
class wv {
  constructor(e, n, r, i) {
    ;(this.fn = e),
      (this.trigger = n),
      (this.scheduler = r),
      (this.active = !0),
      (this.deps = []),
      (this._dirtyLevel = 4),
      (this._trackId = 0),
      (this._runnings = 0),
      (this._shouldSchedule = !1),
      (this._depsLength = 0),
      wP(this, i)
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      ;(this._dirtyLevel = 1), aa()
      for (let e = 0; e < this._depsLength; e++) {
        const n = this.deps[e]
        if (n.computed && (SP(n.computed), this._dirtyLevel >= 4)) break
      }
      this._dirtyLevel === 1 && (this._dirtyLevel = 0), la()
    }
    return this._dirtyLevel >= 4
  }
  set dirty(e) {
    this._dirtyLevel = e ? 4 : 0
  }
  run() {
    if (((this._dirtyLevel = 0), !this.active)) return this.fn()
    let e = Cs,
      n = Mo
    try {
      return (Cs = !0), (Mo = this), this._runnings++, Tb(this), this.fn()
    } finally {
      wb(this), this._runnings--, (Mo = n), (Cs = e)
    }
  }
  stop() {
    var e
    this.active &&
      (Tb(this), wb(this), (e = this.onStop) == null || e.call(this), (this.active = !1))
  }
}
function SP(t) {
  return t.value
}
function Tb(t) {
  t._trackId++, (t._depsLength = 0)
}
function wb(t) {
  if (t.deps.length > t._depsLength) {
    for (let e = t._depsLength; e < t.deps.length; e++) GI(t.deps[e], t)
    t.deps.length = t._depsLength
  }
}
function GI(t, e) {
  const n = t.get(e)
  n !== void 0 && e._trackId !== n && (t.delete(e), t.size === 0 && t.cleanup())
}
let Cs = !0,
  dy = 0
const qI = []
function aa() {
  qI.push(Cs), (Cs = !1)
}
function la() {
  const t = qI.pop()
  Cs = t === void 0 ? !0 : t
}
function Sv() {
  dy++
}
function Iv() {
  for (dy--; !dy && fy.length; ) fy.shift()()
}
function KI(t, e, n) {
  if (e.get(t) !== t._trackId) {
    e.set(t, t._trackId)
    const r = t.deps[t._depsLength]
    r !== e ? (r && GI(r, t), (t.deps[t._depsLength++] = e)) : t._depsLength++
  }
}
const fy = []
function YI(t, e, n) {
  Sv()
  for (const r of t.keys()) {
    let i
    r._dirtyLevel < e &&
      (i ?? (i = t.get(r) === r._trackId)) &&
      (r._shouldSchedule || (r._shouldSchedule = r._dirtyLevel === 0), (r._dirtyLevel = e)),
      r._shouldSchedule &&
        (i ?? (i = t.get(r) === r._trackId)) &&
        (r.trigger(),
        (!r._runnings || r.allowRecurse) &&
          r._dirtyLevel !== 2 &&
          ((r._shouldSchedule = !1), r.scheduler && fy.push(r.scheduler)))
  }
  Iv()
}
const JI = (t, e) => {
    const n = new Map()
    return (n.cleanup = t), (n.computed = e), n
  },
  jd = new WeakMap(),
  Po = Symbol(''),
  py = Symbol('')
function Qn(t, e, n) {
  if (Cs && Mo) {
    let r = jd.get(t)
    r || jd.set(t, (r = new Map()))
    let i = r.get(n)
    i || r.set(n, (i = JI(() => r.delete(n)))), KI(Mo, i)
  }
}
function Fi(t, e, n, r, i, s) {
  const o = jd.get(t)
  if (!o) return
  let a = []
  if (e === 'clear') a = [...o.values()]
  else if (n === 'length' && ye(t)) {
    const l = Number(r)
    o.forEach((c, u) => {
      ;(u === 'length' || (!Ls(u) && u >= l)) && a.push(c)
    })
  } else
    switch ((n !== void 0 && a.push(o.get(n)), e)) {
      case 'add':
        ye(t) ? Ev(n) && a.push(o.get('length')) : (a.push(o.get(Po)), Ua(t) && a.push(o.get(py)))
        break
      case 'delete':
        ye(t) || (a.push(o.get(Po)), Ua(t) && a.push(o.get(py)))
        break
      case 'set':
        Ua(t) && a.push(o.get(Po))
        break
    }
  Sv()
  for (const l of a) l && YI(l, 4)
  Iv()
}
function IP(t, e) {
  var n
  return (n = jd.get(t)) == null ? void 0 : n.get(e)
}
const AP = yv('__proto__,__v_isRef,__isVue'),
  QI = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter((t) => t !== 'arguments' && t !== 'caller')
      .map((t) => Symbol[t])
      .filter(Ls)
  ),
  Sb = CP()
function CP() {
  const t = {}
  return (
    ['includes', 'indexOf', 'lastIndexOf'].forEach((e) => {
      t[e] = function (...n) {
        const r = Qe(this)
        for (let s = 0, o = this.length; s < o; s++) Qn(r, 'get', s + '')
        const i = r[e](...n)
        return i === -1 || i === !1 ? r[e](...n.map(Qe)) : i
      }
    }),
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((e) => {
      t[e] = function (...n) {
        aa(), Sv()
        const r = Qe(this)[e].apply(this, n)
        return Iv(), la(), r
      }
    }),
    t
  )
}
function RP(t) {
  const e = Qe(this)
  return Qn(e, 'has', t), e.hasOwnProperty(t)
}
class XI {
  constructor(e = !1, n = !1) {
    ;(this._isReadonly = e), (this._isShallow = n)
  }
  get(e, n, r) {
    const i = this._isReadonly,
      s = this._isShallow
    if (n === '__v_isReactive') return !i
    if (n === '__v_isReadonly') return i
    if (n === '__v_isShallow') return s
    if (n === '__v_raw')
      return r === (i ? (s ? $P : nA) : s ? tA : eA).get(e) ||
        Object.getPrototypeOf(e) === Object.getPrototypeOf(r)
        ? e
        : void 0
    const o = ye(e)
    if (!i) {
      if (o && Je(Sb, n)) return Reflect.get(Sb, n, r)
      if (n === 'hasOwnProperty') return RP
    }
    const a = Reflect.get(e, n, r)
    return (Ls(n) ? QI.has(n) : AP(n)) || (i || Qn(e, 'get', n), s)
      ? a
      : rn(a)
      ? o && Ev(n)
        ? a
        : a.value
      : ct(a)
      ? i
        ? Rv(a)
        : ju(a)
      : a
  }
}
class ZI extends XI {
  constructor(e = !1) {
    super(!1, e)
  }
  set(e, n, r, i) {
    let s = e[n]
    if (!this._isShallow) {
      const l = sl(s)
      if ((!Wd(r) && !sl(r) && ((s = Qe(s)), (r = Qe(r))), !ye(e) && rn(s) && !rn(r)))
        return l ? !1 : ((s.value = r), !0)
    }
    const o = ye(e) && Ev(n) ? Number(n) < e.length : Je(e, n),
      a = Reflect.set(e, n, r, i)
    return e === Qe(i) && (o ? Vs(r, s) && Fi(e, 'set', n, r) : Fi(e, 'add', n, r)), a
  }
  deleteProperty(e, n) {
    const r = Je(e, n)
    e[n]
    const i = Reflect.deleteProperty(e, n)
    return i && r && Fi(e, 'delete', n, void 0), i
  }
  has(e, n) {
    const r = Reflect.has(e, n)
    return (!Ls(n) || !QI.has(n)) && Qn(e, 'has', n), r
  }
  ownKeys(e) {
    return Qn(e, 'iterate', ye(e) ? 'length' : Po), Reflect.ownKeys(e)
  }
}
class kP extends XI {
  constructor(e = !1) {
    super(!0, e)
  }
  set(e, n) {
    return !0
  }
  deleteProperty(e, n) {
    return !0
  }
}
const OP = new ZI(),
  NP = new kP(),
  MP = new ZI(!0),
  Av = (t) => t,
  fp = (t) => Reflect.getPrototypeOf(t)
function Mh(t, e, n = !1, r = !1) {
  t = t.__v_raw
  const i = Qe(t),
    s = Qe(e)
  n || (Vs(e, s) && Qn(i, 'get', e), Qn(i, 'get', s))
  const { has: o } = fp(i),
    a = r ? Av : n ? Ov : eu
  if (o.call(i, e)) return a(t.get(e))
  if (o.call(i, s)) return a(t.get(s))
  t !== i && t.get(e)
}
function Ph(t, e = !1) {
  const n = this.__v_raw,
    r = Qe(n),
    i = Qe(t)
  return (
    e || (Vs(t, i) && Qn(r, 'has', t), Qn(r, 'has', i)), t === i ? n.has(t) : n.has(t) || n.has(i)
  )
}
function xh(t, e = !1) {
  return (t = t.__v_raw), !e && Qn(Qe(t), 'iterate', Po), Reflect.get(t, 'size', t)
}
function Ib(t) {
  t = Qe(t)
  const e = Qe(this)
  return fp(e).has.call(e, t) || (e.add(t), Fi(e, 'add', t, t)), this
}
function Ab(t, e) {
  e = Qe(e)
  const n = Qe(this),
    { has: r, get: i } = fp(n)
  let s = r.call(n, t)
  s || ((t = Qe(t)), (s = r.call(n, t)))
  const o = i.call(n, t)
  return n.set(t, e), s ? Vs(e, o) && Fi(n, 'set', t, e) : Fi(n, 'add', t, e), this
}
function Cb(t) {
  const e = Qe(this),
    { has: n, get: r } = fp(e)
  let i = n.call(e, t)
  i || ((t = Qe(t)), (i = n.call(e, t))), r && r.call(e, t)
  const s = e.delete(t)
  return i && Fi(e, 'delete', t, void 0), s
}
function Rb() {
  const t = Qe(this),
    e = t.size !== 0,
    n = t.clear()
  return e && Fi(t, 'clear', void 0, void 0), n
}
function Dh(t, e) {
  return function (r, i) {
    const s = this,
      o = s.__v_raw,
      a = Qe(o),
      l = e ? Av : t ? Ov : eu
    return !t && Qn(a, 'iterate', Po), o.forEach((c, u) => r.call(i, l(c), l(u), s))
  }
}
function Lh(t, e, n) {
  return function (...r) {
    const i = this.__v_raw,
      s = Qe(i),
      o = Ua(s),
      a = t === 'entries' || (t === Symbol.iterator && o),
      l = t === 'keys' && o,
      c = i[t](...r),
      u = n ? Av : e ? Ov : eu
    return (
      !e && Qn(s, 'iterate', l ? py : Po),
      {
        next() {
          const { value: h, done: d } = c.next()
          return d ? { value: h, done: d } : { value: a ? [u(h[0]), u(h[1])] : u(h), done: d }
        },
        [Symbol.iterator]() {
          return this
        }
      }
    )
  }
}
function es(t) {
  return function (...e) {
    return t === 'delete' ? !1 : t === 'clear' ? void 0 : this
  }
}
function PP() {
  const t = {
      get(s) {
        return Mh(this, s)
      },
      get size() {
        return xh(this)
      },
      has: Ph,
      add: Ib,
      set: Ab,
      delete: Cb,
      clear: Rb,
      forEach: Dh(!1, !1)
    },
    e = {
      get(s) {
        return Mh(this, s, !1, !0)
      },
      get size() {
        return xh(this)
      },
      has: Ph,
      add: Ib,
      set: Ab,
      delete: Cb,
      clear: Rb,
      forEach: Dh(!1, !0)
    },
    n = {
      get(s) {
        return Mh(this, s, !0)
      },
      get size() {
        return xh(this, !0)
      },
      has(s) {
        return Ph.call(this, s, !0)
      },
      add: es('add'),
      set: es('set'),
      delete: es('delete'),
      clear: es('clear'),
      forEach: Dh(!0, !1)
    },
    r = {
      get(s) {
        return Mh(this, s, !0, !0)
      },
      get size() {
        return xh(this, !0)
      },
      has(s) {
        return Ph.call(this, s, !0)
      },
      add: es('add'),
      set: es('set'),
      delete: es('delete'),
      clear: es('clear'),
      forEach: Dh(!0, !0)
    }
  return (
    ['keys', 'values', 'entries', Symbol.iterator].forEach((s) => {
      ;(t[s] = Lh(s, !1, !1)),
        (n[s] = Lh(s, !0, !1)),
        (e[s] = Lh(s, !1, !0)),
        (r[s] = Lh(s, !0, !0))
    }),
    [t, n, e, r]
  )
}
const [xP, DP, LP, VP] = PP()
function Cv(t, e) {
  const n = e ? (t ? VP : LP) : t ? DP : xP
  return (r, i, s) =>
    i === '__v_isReactive'
      ? !t
      : i === '__v_isReadonly'
      ? t
      : i === '__v_raw'
      ? r
      : Reflect.get(Je(n, i) && i in r ? n : r, i, s)
}
const FP = { get: Cv(!1, !1) },
  BP = { get: Cv(!1, !0) },
  UP = { get: Cv(!0, !1) },
  eA = new WeakMap(),
  tA = new WeakMap(),
  nA = new WeakMap(),
  $P = new WeakMap()
function HP(t) {
  switch (t) {
    case 'Object':
    case 'Array':
      return 1
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
    default:
      return 0
  }
}
function zP(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : HP(fP(t))
}
function ju(t) {
  return sl(t) ? t : kv(t, !1, OP, FP, eA)
}
function rA(t) {
  return kv(t, !1, MP, BP, tA)
}
function Rv(t) {
  return kv(t, !0, NP, UP, nA)
}
function kv(t, e, n, r, i) {
  if (!ct(t) || (t.__v_raw && !(e && t.__v_isReactive))) return t
  const s = i.get(t)
  if (s) return s
  const o = zP(t)
  if (o === 0) return t
  const a = new Proxy(t, o === 2 ? r : n)
  return i.set(t, a), a
}
function $a(t) {
  return sl(t) ? $a(t.__v_raw) : !!(t && t.__v_isReactive)
}
function sl(t) {
  return !!(t && t.__v_isReadonly)
}
function Wd(t) {
  return !!(t && t.__v_isShallow)
}
function iA(t) {
  return $a(t) || sl(t)
}
function Qe(t) {
  const e = t && t.__v_raw
  return e ? Qe(e) : t
}
function pp(t) {
  return Object.isExtensible(t) && zd(t, '__v_skip', !0), t
}
const eu = (t) => (ct(t) ? ju(t) : t),
  Ov = (t) => (ct(t) ? Rv(t) : t)
class sA {
  constructor(e, n, r, i) {
    ;(this.getter = e),
      (this._setter = n),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this.__v_isReadonly = !1),
      (this.effect = new wv(
        () => e(this._value),
        () => Ic(this, this.effect._dirtyLevel === 2 ? 2 : 3)
      )),
      (this.effect.computed = this),
      (this.effect.active = this._cacheable = !i),
      (this.__v_isReadonly = r)
  }
  get value() {
    const e = Qe(this)
    return (
      (!e._cacheable || e.effect.dirty) && Vs(e._value, (e._value = e.effect.run())) && Ic(e, 4),
      Nv(e),
      e.effect._dirtyLevel >= 2 && Ic(e, 2),
      e._value
    )
  }
  set value(e) {
    this._setter(e)
  }
  get _dirty() {
    return this.effect.dirty
  }
  set _dirty(e) {
    this.effect.dirty = e
  }
}
function jP(t, e, n = !1) {
  let r, i
  const s = Ae(t)
  return s ? ((r = t), (i = br)) : ((r = t.get), (i = t.set)), new sA(r, i, s || !i, n)
}
function Nv(t) {
  var e
  Cs &&
    Mo &&
    ((t = Qe(t)),
    KI(
      Mo,
      (e = t.dep) != null ? e : (t.dep = JI(() => (t.dep = void 0), t instanceof sA ? t : void 0))
    ))
}
function Ic(t, e = 4, n) {
  t = Qe(t)
  const r = t.dep
  r && YI(r, e)
}
function rn(t) {
  return !!(t && t.__v_isRef === !0)
}
function Ue(t) {
  return aA(t, !1)
}
function oA(t) {
  return aA(t, !0)
}
function aA(t, e) {
  return rn(t) ? t : new WP(t, e)
}
class WP {
  constructor(e, n) {
    ;(this.__v_isShallow = n),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this._rawValue = n ? e : Qe(e)),
      (this._value = n ? e : eu(e))
  }
  get value() {
    return Nv(this), this._value
  }
  set value(e) {
    const n = this.__v_isShallow || Wd(e) || sl(e)
    ;(e = n ? e : Qe(e)),
      Vs(e, this._rawValue) && ((this._rawValue = e), (this._value = n ? e : eu(e)), Ic(this, 4))
  }
}
function Xe(t) {
  return rn(t) ? t.value : t
}
function Oi(t) {
  return Ae(t) ? t() : Xe(t)
}
const GP = {
  get: (t, e, n) => Xe(Reflect.get(t, e, n)),
  set: (t, e, n, r) => {
    const i = t[e]
    return rn(i) && !rn(n) ? ((i.value = n), !0) : Reflect.set(t, e, n, r)
  }
}
function lA(t) {
  return $a(t) ? t : new Proxy(t, GP)
}
class qP {
  constructor(e) {
    ;(this.dep = void 0), (this.__v_isRef = !0)
    const { get: n, set: r } = e(
      () => Nv(this),
      () => Ic(this)
    )
    ;(this._get = n), (this._set = r)
  }
  get value() {
    return this._get()
  }
  set value(e) {
    this._set(e)
  }
}
function cA(t) {
  return new qP(t)
}
class KP {
  constructor(e, n, r) {
    ;(this._object = e), (this._key = n), (this._defaultValue = r), (this.__v_isRef = !0)
  }
  get value() {
    const e = this._object[this._key]
    return e === void 0 ? this._defaultValue : e
  }
  set value(e) {
    this._object[this._key] = e
  }
  get dep() {
    return IP(Qe(this._object), this._key)
  }
}
class YP {
  constructor(e) {
    ;(this._getter = e), (this.__v_isRef = !0), (this.__v_isReadonly = !0)
  }
  get value() {
    return this._getter()
  }
}
function JP(t, e, n) {
  return rn(t) ? t : Ae(t) ? new YP(t) : ct(t) && arguments.length > 1 ? QP(t, e, n) : Ue(t)
}
function QP(t, e, n) {
  const r = t[e]
  return rn(r) ? r : new KP(t, e, n)
}
/**
 * @vue/runtime-core v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function Rs(t, e, n, r) {
  try {
    return r ? t(...r) : t()
  } catch (i) {
    Wu(i, e, n)
  }
}
function Sr(t, e, n, r) {
  if (Ae(t)) {
    const s = Rs(t, e, n, r)
    return (
      s &&
        bv(s) &&
        s.catch((o) => {
          Wu(o, e, n)
        }),
      s
    )
  }
  const i = []
  for (let s = 0; s < t.length; s++) i.push(Sr(t[s], e, n, r))
  return i
}
function Wu(t, e, n, r = !0) {
  const i = e ? e.vnode : null
  if (e) {
    let s = e.parent
    const o = e.proxy,
      a = `https://vuejs.org/error-reference/#runtime-${n}`
    for (; s; ) {
      const c = s.ec
      if (c) {
        for (let u = 0; u < c.length; u++) if (c[u](t, o, a) === !1) return
      }
      s = s.parent
    }
    const l = e.appContext.config.errorHandler
    if (l) {
      Rs(l, null, 10, [t, o, a])
      return
    }
  }
  XP(t, n, i, r)
}
function XP(t, e, n, r = !0) {
  console.error(t)
}
let tu = !1,
  my = !1
const On = []
let Jr = 0
const Ha = []
let cs = null,
  po = 0
const uA = Promise.resolve()
let Mv = null
function Pl(t) {
  const e = Mv || uA
  return t ? e.then(this ? t.bind(this) : t) : e
}
function ZP(t) {
  let e = Jr + 1,
    n = On.length
  for (; e < n; ) {
    const r = (e + n) >>> 1,
      i = On[r],
      s = nu(i)
    s < t || (s === t && i.pre) ? (e = r + 1) : (n = r)
  }
  return e
}
function Pv(t) {
  ;(!On.length || !On.includes(t, tu && t.allowRecurse ? Jr + 1 : Jr)) &&
    (t.id == null ? On.push(t) : On.splice(ZP(t.id), 0, t), hA())
}
function hA() {
  !tu && !my && ((my = !0), (Mv = uA.then(fA)))
}
function ex(t) {
  const e = On.indexOf(t)
  e > Jr && On.splice(e, 1)
}
function gy(t) {
  ye(t) ? Ha.push(...t) : (!cs || !cs.includes(t, t.allowRecurse ? po + 1 : po)) && Ha.push(t), hA()
}
function kb(t, e, n = tu ? Jr + 1 : 0) {
  for (; n < On.length; n++) {
    const r = On[n]
    if (r && r.pre) {
      if (t && r.id !== t.uid) continue
      On.splice(n, 1), n--, r()
    }
  }
}
function dA(t) {
  if (Ha.length) {
    const e = [...new Set(Ha)].sort((n, r) => nu(n) - nu(r))
    if (((Ha.length = 0), cs)) {
      cs.push(...e)
      return
    }
    for (cs = e, po = 0; po < cs.length; po++) cs[po]()
    ;(cs = null), (po = 0)
  }
}
const nu = (t) => (t.id == null ? 1 / 0 : t.id),
  tx = (t, e) => {
    const n = nu(t) - nu(e)
    if (n === 0) {
      if (t.pre && !e.pre) return -1
      if (e.pre && !t.pre) return 1
    }
    return n
  }
function fA(t) {
  ;(my = !1), (tu = !0), On.sort(tx)
  try {
    for (Jr = 0; Jr < On.length; Jr++) {
      const e = On[Jr]
      e && e.active !== !1 && Rs(e, null, 14)
    }
  } finally {
    ;(Jr = 0), (On.length = 0), dA(), (tu = !1), (Mv = null), (On.length || Ha.length) && fA()
  }
}
function nx(t, e, ...n) {
  if (t.isUnmounted) return
  const r = t.vnode.props || yt
  let i = n
  const s = e.startsWith('update:'),
    o = s && e.slice(7)
  if (o && o in r) {
    const u = `${o === 'modelValue' ? 'model' : o}Modifiers`,
      { number: h, trim: d } = r[u] || yt
    d && (i = n.map((f) => (Pt(f) ? f.trim() : f))), h && (i = n.map(hy))
  }
  let a,
    l = r[(a = Lm(e))] || r[(a = Lm(pi(e)))]
  !l && s && (l = r[(a = Lm(oa(e)))]), l && Sr(l, t, 6, i)
  const c = r[a + 'Once']
  if (c) {
    if (!t.emitted) t.emitted = {}
    else if (t.emitted[a]) return
    ;(t.emitted[a] = !0), Sr(c, t, 6, i)
  }
}
function pA(t, e, n = !1) {
  const r = e.emitsCache,
    i = r.get(t)
  if (i !== void 0) return i
  const s = t.emits
  let o = {},
    a = !1
  if (!Ae(t)) {
    const l = (c) => {
      const u = pA(c, e, !0)
      u && ((a = !0), Gt(o, u))
    }
    !n && e.mixins.length && e.mixins.forEach(l),
      t.extends && l(t.extends),
      t.mixins && t.mixins.forEach(l)
  }
  return !s && !a
    ? (ct(t) && r.set(t, null), null)
    : (ye(s) ? s.forEach((l) => (o[l] = null)) : Gt(o, s), ct(t) && r.set(t, o), o)
}
function mp(t, e) {
  return !t || !ap(e)
    ? !1
    : ((e = e.slice(2).replace(/Once$/, '')),
      Je(t, e[0].toLowerCase() + e.slice(1)) || Je(t, oa(e)) || Je(t, e))
}
let Wt = null,
  gp = null
function Gd(t) {
  const e = Wt
  return (Wt = t), (gp = (t && t.type.__scopeId) || null), e
}
function yp(t) {
  gp = t
}
function _p() {
  gp = null
}
function xo(t, e = Wt, n) {
  if (!e || t._n) return t
  const r = (...i) => {
    r._d && jb(-1)
    const s = Gd(e)
    let o
    try {
      o = t(...i)
    } finally {
      Gd(s), r._d && jb(1)
    }
    return o
  }
  return (r._n = !0), (r._c = !0), (r._d = !0), r
}
function Fm(t) {
  const {
    type: e,
    vnode: n,
    proxy: r,
    withProxy: i,
    props: s,
    propsOptions: [o],
    slots: a,
    attrs: l,
    emit: c,
    render: u,
    renderCache: h,
    data: d,
    setupState: f,
    ctx: p,
    inheritAttrs: m
  } = t
  let g, _
  const v = Gd(t)
  try {
    if (n.shapeFlag & 4) {
      const S = i || r,
        I = S
      ;(g = Nr(u.call(I, S, h, s, f, d, p))), (_ = l)
    } else {
      const S = e
      ;(g = Nr(S.length > 1 ? S(s, { attrs: l, slots: a, emit: c }) : S(s, null))),
        (_ = e.props ? l : ix(l))
    }
  } catch (S) {
    ;(Oc.length = 0), Wu(S, t, 1), (g = Be(Yn))
  }
  let T = g
  if (_ && m !== !1) {
    const S = Object.keys(_),
      { shapeFlag: I } = T
    S.length && I & 7 && (o && S.some(_v) && (_ = sx(_, o)), (T = Bs(T, _)))
  }
  return (
    n.dirs && ((T = Bs(T)), (T.dirs = T.dirs ? T.dirs.concat(n.dirs) : n.dirs)),
    n.transition && (T.transition = n.transition),
    (g = T),
    Gd(v),
    g
  )
}
function rx(t, e = !0) {
  let n
  for (let r = 0; r < t.length; r++) {
    const i = t[r]
    if (iu(i)) {
      if (i.type !== Yn || i.children === 'v-if') {
        if (n) return
        n = i
      }
    } else return
  }
  return n
}
const ix = (t) => {
    let e
    for (const n in t) (n === 'class' || n === 'style' || ap(n)) && ((e || (e = {}))[n] = t[n])
    return e
  },
  sx = (t, e) => {
    const n = {}
    for (const r in t) (!_v(r) || !(r.slice(9) in e)) && (n[r] = t[r])
    return n
  }
function ox(t, e, n) {
  const { props: r, children: i, component: s } = t,
    { props: o, children: a, patchFlag: l } = e,
    c = s.emitsOptions
  if (e.dirs || e.transition) return !0
  if (n && l >= 0) {
    if (l & 1024) return !0
    if (l & 16) return r ? Ob(r, o, c) : !!o
    if (l & 8) {
      const u = e.dynamicProps
      for (let h = 0; h < u.length; h++) {
        const d = u[h]
        if (o[d] !== r[d] && !mp(c, d)) return !0
      }
    }
  } else
    return (i || a) && (!a || !a.$stable) ? !0 : r === o ? !1 : r ? (o ? Ob(r, o, c) : !0) : !!o
  return !1
}
function Ob(t, e, n) {
  const r = Object.keys(e)
  if (r.length !== Object.keys(t).length) return !0
  for (let i = 0; i < r.length; i++) {
    const s = r[i]
    if (e[s] !== t[s] && !mp(n, s)) return !0
  }
  return !1
}
function xv({ vnode: t, parent: e }, n) {
  for (; e; ) {
    const r = e.subTree
    if ((r.suspense && r.suspense.activeBranch === t && (r.el = t.el), r === t))
      ((t = e.vnode).el = n), (e = e.parent)
    else break
  }
}
const mA = 'components'
function ax(t, e) {
  return cx(mA, t, !0, e) || t
}
const lx = Symbol.for('v-ndc')
function cx(t, e, n = !0, r = !1) {
  const i = Wt || yn
  if (i) {
    const s = i.type
    if (t === mA) {
      const a = fD(s, !1)
      if (a && (a === e || a === pi(e) || a === up(pi(e)))) return s
    }
    const o = Nb(i[t] || s[t], e) || Nb(i.appContext[t], e)
    return !o && r ? s : o
  }
}
function Nb(t, e) {
  return t && (t[e] || t[pi(e)] || t[up(pi(e))])
}
const ux = (t) => t.__isSuspense
let yy = 0
const hx = {
    name: 'Suspense',
    __isSuspense: !0,
    process(t, e, n, r, i, s, o, a, l, c) {
      if (t == null) fx(e, n, r, i, s, o, a, l, c)
      else {
        if (s && s.deps > 0 && !t.suspense.isInFallback) {
          ;(e.suspense = t.suspense), (e.suspense.vnode = e), (e.el = t.el)
          return
        }
        px(t, e, n, r, i, o, a, l, c)
      }
    },
    hydrate: mx,
    create: Dv,
    normalize: gx
  },
  dx = hx
function ru(t, e) {
  const n = t.props && t.props[e]
  Ae(n) && n()
}
function fx(t, e, n, r, i, s, o, a, l) {
  const {
      p: c,
      o: { createElement: u }
    } = l,
    h = u('div'),
    d = (t.suspense = Dv(t, i, r, e, h, n, s, o, a, l))
  c(null, (d.pendingBranch = t.ssContent), h, null, r, d, s, o),
    d.deps > 0
      ? (ru(t, 'onPending'),
        ru(t, 'onFallback'),
        c(null, t.ssFallback, e, n, r, null, s, o),
        za(d, t.ssFallback))
      : d.resolve(!1, !0)
}
function px(t, e, n, r, i, s, o, a, { p: l, um: c, o: { createElement: u } }) {
  const h = (e.suspense = t.suspense)
  ;(h.vnode = e), (e.el = t.el)
  const d = e.ssContent,
    f = e.ssFallback,
    { activeBranch: p, pendingBranch: m, isInFallback: g, isHydrating: _ } = h
  if (m)
    (h.pendingBranch = d),
      Qr(d, m)
        ? (l(m, d, h.hiddenContainer, null, i, h, s, o, a),
          h.deps <= 0 ? h.resolve() : g && (_ || (l(p, f, n, r, i, null, s, o, a), za(h, f))))
        : ((h.pendingId = yy++),
          _ ? ((h.isHydrating = !1), (h.activeBranch = m)) : c(m, i, h),
          (h.deps = 0),
          (h.effects.length = 0),
          (h.hiddenContainer = u('div')),
          g
            ? (l(null, d, h.hiddenContainer, null, i, h, s, o, a),
              h.deps <= 0 ? h.resolve() : (l(p, f, n, r, i, null, s, o, a), za(h, f)))
            : p && Qr(d, p)
            ? (l(p, d, n, r, i, h, s, o, a), h.resolve(!0))
            : (l(null, d, h.hiddenContainer, null, i, h, s, o, a), h.deps <= 0 && h.resolve()))
  else if (p && Qr(d, p)) l(p, d, n, r, i, h, s, o, a), za(h, d)
  else if (
    (ru(e, 'onPending'),
    (h.pendingBranch = d),
    d.shapeFlag & 512 ? (h.pendingId = d.component.suspenseId) : (h.pendingId = yy++),
    l(null, d, h.hiddenContainer, null, i, h, s, o, a),
    h.deps <= 0)
  )
    h.resolve()
  else {
    const { timeout: v, pendingId: T } = h
    v > 0
      ? setTimeout(() => {
          h.pendingId === T && h.fallback(f)
        }, v)
      : v === 0 && h.fallback(f)
  }
}
function Dv(t, e, n, r, i, s, o, a, l, c, u = !1) {
  const {
    p: h,
    m: d,
    um: f,
    n: p,
    o: { parentNode: m, remove: g }
  } = c
  let _
  const v = _x(t)
  v && e != null && e.pendingBranch && ((_ = e.pendingId), e.deps++)
  const T = t.props ? FI(t.props.timeout) : void 0,
    S = s,
    I = {
      vnode: t,
      parent: e,
      parentComponent: n,
      namespace: o,
      container: r,
      hiddenContainer: i,
      deps: 0,
      pendingId: yy++,
      timeout: typeof T == 'number' ? T : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !u,
      isHydrating: u,
      isUnmounted: !1,
      effects: [],
      resolve(w = !1, O = !1) {
        const {
          vnode: P,
          activeBranch: k,
          pendingBranch: U,
          pendingId: F,
          effects: $,
          parentComponent: pe,
          container: q
        } = I
        let z = !1
        I.isHydrating
          ? (I.isHydrating = !1)
          : w ||
            ((z = k && U.transition && U.transition.mode === 'out-in'),
            z &&
              (k.transition.afterLeave = () => {
                F === I.pendingId && (d(U, q, s === S ? p(k) : s, 0), gy($))
              }),
            k && (m(k.el) !== I.hiddenContainer && (s = p(k)), f(k, pe, I, !0)),
            z || d(U, q, s, 0)),
          za(I, U),
          (I.pendingBranch = null),
          (I.isInFallback = !1)
        let N = I.parent,
          B = !1
        for (; N; ) {
          if (N.pendingBranch) {
            N.effects.push(...$), (B = !0)
            break
          }
          N = N.parent
        }
        !B && !z && gy($),
          (I.effects = []),
          v &&
            e &&
            e.pendingBranch &&
            _ === e.pendingId &&
            (e.deps--, e.deps === 0 && !O && e.resolve()),
          ru(P, 'onResolve')
      },
      fallback(w) {
        if (!I.pendingBranch) return
        const { vnode: O, activeBranch: P, parentComponent: k, container: U, namespace: F } = I
        ru(O, 'onFallback')
        const $ = p(P),
          pe = () => {
            I.isInFallback && (h(null, w, U, $, k, null, F, a, l), za(I, w))
          },
          q = w.transition && w.transition.mode === 'out-in'
        q && (P.transition.afterLeave = pe), (I.isInFallback = !0), f(P, k, null, !0), q || pe()
      },
      move(w, O, P) {
        I.activeBranch && d(I.activeBranch, w, O, P), (I.container = w)
      },
      next() {
        return I.activeBranch && p(I.activeBranch)
      },
      registerDep(w, O) {
        const P = !!I.pendingBranch
        P && I.deps++
        const k = w.vnode.el
        w.asyncDep
          .catch((U) => {
            Wu(U, w, 0)
          })
          .then((U) => {
            if (w.isUnmounted || I.isUnmounted || I.pendingId !== w.suspenseId) return
            w.asyncResolved = !0
            const { vnode: F } = w
            Ry(w, U, !1), k && (F.el = k)
            const $ = !k && w.subTree.el
            O(w, F, m(k || w.subTree.el), k ? null : p(w.subTree), I, o, l),
              $ && g($),
              xv(w, F.el),
              P && --I.deps === 0 && I.resolve()
          })
      },
      unmount(w, O) {
        ;(I.isUnmounted = !0),
          I.activeBranch && f(I.activeBranch, n, w, O),
          I.pendingBranch && f(I.pendingBranch, n, w, O)
      }
    }
  return I
}
function mx(t, e, n, r, i, s, o, a, l) {
  const c = (e.suspense = Dv(
      e,
      r,
      n,
      t.parentNode,
      document.createElement('div'),
      null,
      i,
      s,
      o,
      a,
      !0
    )),
    u = l(t, (c.pendingBranch = e.ssContent), n, c, s, o)
  return c.deps === 0 && c.resolve(!1, !0), u
}
function gx(t) {
  const { shapeFlag: e, children: n } = t,
    r = e & 32
  ;(t.ssContent = Mb(r ? n.default : n)), (t.ssFallback = r ? Mb(n.fallback) : Be(Yn))
}
function Mb(t) {
  let e
  if (Ae(t)) {
    const n = ol && t._c
    n && ((t._d = !1), de()), (t = t()), n && ((t._d = !0), (e = Er), PA())
  }
  return (
    ye(t) && (t = rx(t)),
    (t = Nr(t)),
    e && !t.dynamicChildren && (t.dynamicChildren = e.filter((n) => n !== t)),
    t
  )
}
function yx(t, e) {
  e && e.pendingBranch ? (ye(t) ? e.effects.push(...t) : e.effects.push(t)) : gy(t)
}
function za(t, e) {
  t.activeBranch = e
  const { vnode: n, parentComponent: r } = t
  let i = e.el
  for (; !i && e.component; ) (e = e.component.subTree), (i = e.el)
  ;(n.el = i), r && r.subTree === n && ((r.vnode.el = i), xv(r, i))
}
function _x(t) {
  var e
  return ((e = t.props) == null ? void 0 : e.suspensible) != null && t.props.suspensible !== !1
}
const vx = Symbol.for('v-scx'),
  bx = () => Kn(vx)
function Ex(t, e) {
  return Lv(t, null, e)
}
const Vh = {}
function Bi(t, e, n) {
  return Lv(t, e, n)
}
function Lv(t, e, { immediate: n, deep: r, flush: i, once: s, onTrack: o, onTrigger: a } = yt) {
  if (e && s) {
    const w = e
    e = (...O) => {
      w(...O), I()
    }
  }
  const l = yn,
    c = (w) => (r === !0 ? w : vo(w, r === !1 ? 1 : void 0))
  let u,
    h = !1,
    d = !1
  if (
    (rn(t)
      ? ((u = () => t.value), (h = Wd(t)))
      : $a(t)
      ? ((u = () => c(t)), (h = !0))
      : ye(t)
      ? ((d = !0),
        (h = t.some((w) => $a(w) || Wd(w))),
        (u = () =>
          t.map((w) => {
            if (rn(w)) return w.value
            if ($a(w)) return c(w)
            if (Ae(w)) return Rs(w, l, 2)
          })))
      : Ae(t)
      ? e
        ? (u = () => Rs(t, l, 2))
        : (u = () => (f && f(), Sr(t, l, 3, [p])))
      : (u = br),
    e && r)
  ) {
    const w = u
    u = () => vo(w())
  }
  let f,
    p = (w) => {
      f = T.onStop = () => {
        Rs(w, l, 4), (f = T.onStop = void 0)
      }
    },
    m
  if (wp)
    if (((p = br), e ? n && Sr(e, l, 3, [u(), d ? [] : void 0, p]) : u(), i === 'sync')) {
      const w = bx()
      m = w.__watcherHandles || (w.__watcherHandles = [])
    } else return br
  let g = d ? new Array(t.length).fill(Vh) : Vh
  const _ = () => {
    if (!(!T.active || !T.dirty))
      if (e) {
        const w = T.run()
        ;(r || h || (d ? w.some((O, P) => Vs(O, g[P])) : Vs(w, g))) &&
          (f && f(), Sr(e, l, 3, [w, g === Vh ? void 0 : d && g[0] === Vh ? [] : g, p]), (g = w))
      } else T.run()
  }
  _.allowRecurse = !!e
  let v
  i === 'sync'
    ? (v = _)
    : i === 'post'
    ? (v = () => Gn(_, l && l.suspense))
    : ((_.pre = !0), l && (_.id = l.uid), (v = () => Pv(_)))
  const T = new wv(u, br, v),
    S = Tv(),
    I = () => {
      T.stop(), S && vv(S.effects, T)
    }
  return (
    e ? (n ? _() : (g = T.run())) : i === 'post' ? Gn(T.run.bind(T), l && l.suspense) : T.run(),
    m && m.push(I),
    I
  )
}
function Tx(t, e, n) {
  const r = this.proxy,
    i = Pt(t) ? (t.includes('.') ? gA(r, t) : () => r[t]) : t.bind(r, r)
  let s
  Ae(e) ? (s = e) : ((s = e.handler), (n = e))
  const o = Wo(this),
    a = Lv(i, s.bind(r), n)
  return o(), a
}
function gA(t, e) {
  const n = e.split('.')
  return () => {
    let r = t
    for (let i = 0; i < n.length && r; i++) r = r[n[i]]
    return r
  }
}
function vo(t, e, n = 0, r) {
  if (!ct(t) || t.__v_skip) return t
  if (e && e > 0) {
    if (n >= e) return t
    n++
  }
  if (((r = r || new Set()), r.has(t))) return t
  if ((r.add(t), rn(t))) vo(t.value, e, n, r)
  else if (ye(t)) for (let i = 0; i < t.length; i++) vo(t[i], e, n, r)
  else if (lp(t) || Ua(t))
    t.forEach((i) => {
      vo(i, e, n, r)
    })
  else if (VI(t)) for (const i in t) vo(t[i], e, n, r)
  return t
}
function Sn(t, e) {
  if (Wt === null) return t
  const n = Sp(Wt) || Wt.proxy,
    r = t.dirs || (t.dirs = [])
  for (let i = 0; i < e.length; i++) {
    let [s, o, a, l = yt] = e[i]
    s &&
      (Ae(s) && (s = { mounted: s, updated: s }),
      s.deep && vo(o),
      r.push({ dir: s, instance: n, value: o, oldValue: void 0, arg: a, modifiers: l }))
  }
  return t
}
function io(t, e, n, r) {
  const i = t.dirs,
    s = e && e.dirs
  for (let o = 0; o < i.length; o++) {
    const a = i[o]
    s && (a.oldValue = s[o].value)
    let l = a.dir[r]
    l && (aa(), Sr(l, n, 8, [t.el, a, t, e]), la())
  }
}
const us = Symbol('_leaveCb'),
  Fh = Symbol('_enterCb')
function wx() {
  const t = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() }
  return (
    Gu(() => {
      t.isMounted = !0
    }),
    qu(() => {
      t.isUnmounting = !0
    }),
    t
  )
}
const mr = [Function, Array],
  yA = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: mr,
    onEnter: mr,
    onAfterEnter: mr,
    onEnterCancelled: mr,
    onBeforeLeave: mr,
    onLeave: mr,
    onAfterLeave: mr,
    onLeaveCancelled: mr,
    onBeforeAppear: mr,
    onAppear: mr,
    onAfterAppear: mr,
    onAppearCancelled: mr
  },
  Sx = {
    name: 'BaseTransition',
    props: yA,
    setup(t, { slots: e }) {
      const n = ca(),
        r = wx()
      return () => {
        const i = e.default && vA(e.default(), !0)
        if (!i || !i.length) return
        let s = i[0]
        if (i.length > 1) {
          for (const d of i)
            if (d.type !== Yn) {
              s = d
              break
            }
        }
        const o = Qe(t),
          { mode: a } = o
        if (r.isLeaving) return Bm(s)
        const l = Pb(s)
        if (!l) return Bm(s)
        const c = _y(l, o, r, n)
        vy(l, c)
        const u = n.subTree,
          h = u && Pb(u)
        if (h && h.type !== Yn && !Qr(l, h)) {
          const d = _y(h, o, r, n)
          if ((vy(h, d), a === 'out-in'))
            return (
              (r.isLeaving = !0),
              (d.afterLeave = () => {
                ;(r.isLeaving = !1), n.update.active !== !1 && ((n.effect.dirty = !0), n.update())
              }),
              Bm(s)
            )
          a === 'in-out' &&
            l.type !== Yn &&
            (d.delayLeave = (f, p, m) => {
              const g = _A(r, h)
              ;(g[String(h.key)] = h),
                (f[us] = () => {
                  p(), (f[us] = void 0), delete c.delayedLeave
                }),
                (c.delayedLeave = m)
            })
        }
        return s
      }
    }
  },
  Ix = Sx
function _A(t, e) {
  const { leavingVNodes: n } = t
  let r = n.get(e.type)
  return r || ((r = Object.create(null)), n.set(e.type, r)), r
}
function _y(t, e, n, r) {
  const {
      appear: i,
      mode: s,
      persisted: o = !1,
      onBeforeEnter: a,
      onEnter: l,
      onAfterEnter: c,
      onEnterCancelled: u,
      onBeforeLeave: h,
      onLeave: d,
      onAfterLeave: f,
      onLeaveCancelled: p,
      onBeforeAppear: m,
      onAppear: g,
      onAfterAppear: _,
      onAppearCancelled: v
    } = e,
    T = String(t.key),
    S = _A(n, t),
    I = (P, k) => {
      P && Sr(P, r, 9, k)
    },
    w = (P, k) => {
      const U = k[1]
      I(P, k), ye(P) ? P.every((F) => F.length <= 1) && U() : P.length <= 1 && U()
    },
    O = {
      mode: s,
      persisted: o,
      beforeEnter(P) {
        let k = a
        if (!n.isMounted)
          if (i) k = m || a
          else return
        P[us] && P[us](!0)
        const U = S[T]
        U && Qr(t, U) && U.el[us] && U.el[us](), I(k, [P])
      },
      enter(P) {
        let k = l,
          U = c,
          F = u
        if (!n.isMounted)
          if (i) (k = g || l), (U = _ || c), (F = v || u)
          else return
        let $ = !1
        const pe = (P[Fh] = (q) => {
          $ ||
            (($ = !0),
            q ? I(F, [P]) : I(U, [P]),
            O.delayedLeave && O.delayedLeave(),
            (P[Fh] = void 0))
        })
        k ? w(k, [P, pe]) : pe()
      },
      leave(P, k) {
        const U = String(t.key)
        if ((P[Fh] && P[Fh](!0), n.isUnmounting)) return k()
        I(h, [P])
        let F = !1
        const $ = (P[us] = (pe) => {
          F ||
            ((F = !0), k(), pe ? I(p, [P]) : I(f, [P]), (P[us] = void 0), S[U] === t && delete S[U])
        })
        ;(S[U] = t), d ? w(d, [P, $]) : $()
      },
      clone(P) {
        return _y(P, e, n, r)
      }
    }
  return O
}
function Bm(t) {
  if (vp(t)) return (t = Bs(t)), (t.children = null), t
}
function Pb(t) {
  return vp(t) ? (t.children ? t.children[0] : void 0) : t
}
function vy(t, e) {
  t.shapeFlag & 6 && t.component
    ? vy(t.component.subTree, e)
    : t.shapeFlag & 128
    ? ((t.ssContent.transition = e.clone(t.ssContent)),
      (t.ssFallback.transition = e.clone(t.ssFallback)))
    : (t.transition = e)
}
function vA(t, e = !1, n) {
  let r = [],
    i = 0
  for (let s = 0; s < t.length; s++) {
    let o = t[s]
    const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s)
    o.type === pt
      ? (o.patchFlag & 128 && i++, (r = r.concat(vA(o.children, e, a))))
      : (e || o.type !== Yn) && r.push(a != null ? Bs(o, { key: a }) : o)
  }
  if (i > 1) for (let s = 0; s < r.length; s++) r[s].patchFlag = -2
  return r
}
/*! #__NO_SIDE_EFFECTS__ */ function Wr(t, e) {
  return Ae(t) ? Gt({ name: t.name }, e, { setup: t }) : t
}
const Ac = (t) => !!t.type.__asyncLoader,
  vp = (t) => t.type.__isKeepAlive
function Ax(t, e) {
  bA(t, 'a', e)
}
function Cx(t, e) {
  bA(t, 'da', e)
}
function bA(t, e, n = yn) {
  const r =
    t.__wdc ||
    (t.__wdc = () => {
      let i = n
      for (; i; ) {
        if (i.isDeactivated) return
        i = i.parent
      }
      return t()
    })
  if ((bp(e, r, n), n)) {
    let i = n.parent
    for (; i && i.parent; ) vp(i.parent.vnode) && Rx(r, e, n, i), (i = i.parent)
  }
}
function Rx(t, e, n, r) {
  const i = bp(e, t, r, !0)
  EA(() => {
    vv(r[e], i)
  }, n)
}
function bp(t, e, n = yn, r = !1) {
  if (n) {
    const i = n[t] || (n[t] = []),
      s =
        e.__weh ||
        (e.__weh = (...o) => {
          if (n.isUnmounted) return
          aa()
          const a = Wo(n),
            l = Sr(e, n, t, o)
          return a(), la(), l
        })
    return r ? i.unshift(s) : i.push(s), s
  }
}
const Ji =
    (t) =>
    (e, n = yn) =>
      (!wp || t === 'sp') && bp(t, (...r) => e(...r), n),
  kx = Ji('bm'),
  Gu = Ji('m'),
  Ox = Ji('bu'),
  Nx = Ji('u'),
  qu = Ji('bum'),
  EA = Ji('um'),
  TA = Ji('sp'),
  Mx = Ji('rtg'),
  Px = Ji('rtc')
function xx(t, e = yn) {
  bp('ec', t, e)
}
function Fs(t, e, n, r) {
  let i
  const s = n && n[r]
  if (ye(t) || Pt(t)) {
    i = new Array(t.length)
    for (let o = 0, a = t.length; o < a; o++) i[o] = e(t[o], o, void 0, s && s[o])
  } else if (typeof t == 'number') {
    i = new Array(t)
    for (let o = 0; o < t; o++) i[o] = e(o + 1, o, void 0, s && s[o])
  } else if (ct(t))
    if (t[Symbol.iterator]) i = Array.from(t, (o, a) => e(o, a, void 0, s && s[a]))
    else {
      const o = Object.keys(t)
      i = new Array(o.length)
      for (let a = 0, l = o.length; a < l; a++) {
        const c = o[a]
        i[a] = e(t[c], c, a, s && s[a])
      }
    }
  else i = []
  return n && (n[r] = i), i
}
function Jt(t, e, n = {}, r, i) {
  if (Wt.isCE || (Wt.parent && Ac(Wt.parent) && Wt.parent.isCE))
    return e !== 'default' && (n.name = e), Be('slot', n, r && r())
  let s = t[e]
  s && s._c && (s._d = !1), de()
  const o = s && wA(s(n)),
    a = dn(
      pt,
      { key: n.key || (o && o.key) || `_${e}` },
      o || (r ? r() : []),
      o && t._ === 1 ? 64 : -2
    )
  return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + '-s']), s && s._c && (s._d = !0), a
}
function wA(t) {
  return t.some((e) => (iu(e) ? !(e.type === Yn || (e.type === pt && !wA(e.children))) : !0))
    ? t
    : null
}
const by = (t) => (t ? (LA(t) ? Sp(t) || t.proxy : by(t.parent)) : null),
  Cc = Gt(Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => t.props,
    $attrs: (t) => t.attrs,
    $slots: (t) => t.slots,
    $refs: (t) => t.refs,
    $parent: (t) => by(t.parent),
    $root: (t) => by(t.root),
    $emit: (t) => t.emit,
    $options: (t) => Vv(t),
    $forceUpdate: (t) =>
      t.f ||
      (t.f = () => {
        ;(t.effect.dirty = !0), Pv(t.update)
      }),
    $nextTick: (t) => t.n || (t.n = Pl.bind(t.proxy)),
    $watch: (t) => Tx.bind(t)
  }),
  Um = (t, e) => t !== yt && !t.__isScriptSetup && Je(t, e),
  Dx = {
    get({ _: t }, e) {
      const { ctx: n, setupState: r, data: i, props: s, accessCache: o, type: a, appContext: l } = t
      let c
      if (e[0] !== '$') {
        const f = o[e]
        if (f !== void 0)
          switch (f) {
            case 1:
              return r[e]
            case 2:
              return i[e]
            case 4:
              return n[e]
            case 3:
              return s[e]
          }
        else {
          if (Um(r, e)) return (o[e] = 1), r[e]
          if (i !== yt && Je(i, e)) return (o[e] = 2), i[e]
          if ((c = t.propsOptions[0]) && Je(c, e)) return (o[e] = 3), s[e]
          if (n !== yt && Je(n, e)) return (o[e] = 4), n[e]
          Ey && (o[e] = 0)
        }
      }
      const u = Cc[e]
      let h, d
      if (u) return e === '$attrs' && Qn(t, 'get', e), u(t)
      if ((h = a.__cssModules) && (h = h[e])) return h
      if (n !== yt && Je(n, e)) return (o[e] = 4), n[e]
      if (((d = l.config.globalProperties), Je(d, e))) return d[e]
    },
    set({ _: t }, e, n) {
      const { data: r, setupState: i, ctx: s } = t
      return Um(i, e)
        ? ((i[e] = n), !0)
        : r !== yt && Je(r, e)
        ? ((r[e] = n), !0)
        : Je(t.props, e) || (e[0] === '$' && e.slice(1) in t)
        ? !1
        : ((s[e] = n), !0)
    },
    has(
      { _: { data: t, setupState: e, accessCache: n, ctx: r, appContext: i, propsOptions: s } },
      o
    ) {
      let a
      return (
        !!n[o] ||
        (t !== yt && Je(t, o)) ||
        Um(e, o) ||
        ((a = s[0]) && Je(a, o)) ||
        Je(r, o) ||
        Je(Cc, o) ||
        Je(i.config.globalProperties, o)
      )
    },
    defineProperty(t, e, n) {
      return (
        n.get != null ? (t._.accessCache[e] = 0) : Je(n, 'value') && this.set(t, e, n.value, null),
        Reflect.defineProperty(t, e, n)
      )
    }
  }
function xb(t) {
  return ye(t) ? t.reduce((e, n) => ((e[n] = null), e), {}) : t
}
function qd(t) {
  const e = ca()
  let n = t()
  return (
    Cy(),
    bv(n) &&
      (n = n.catch((r) => {
        throw (Wo(e), r)
      })),
    [n, () => Wo(e)]
  )
}
let Ey = !0
function Lx(t) {
  const e = Vv(t),
    n = t.proxy,
    r = t.ctx
  ;(Ey = !1), e.beforeCreate && Db(e.beforeCreate, t, 'bc')
  const {
    data: i,
    computed: s,
    methods: o,
    watch: a,
    provide: l,
    inject: c,
    created: u,
    beforeMount: h,
    mounted: d,
    beforeUpdate: f,
    updated: p,
    activated: m,
    deactivated: g,
    beforeDestroy: _,
    beforeUnmount: v,
    destroyed: T,
    unmounted: S,
    render: I,
    renderTracked: w,
    renderTriggered: O,
    errorCaptured: P,
    serverPrefetch: k,
    expose: U,
    inheritAttrs: F,
    components: $,
    directives: pe,
    filters: q
  } = e
  if ((c && Vx(c, r, null), o))
    for (const B in o) {
      const D = o[B]
      Ae(D) && (r[B] = D.bind(n))
    }
  if (i) {
    const B = i.call(n, n)
    ct(B) && (t.data = ju(B))
  }
  if (((Ey = !0), s))
    for (const B in s) {
      const D = s[B],
        se = Ae(D) ? D.bind(n, n) : Ae(D.get) ? D.get.bind(n, n) : br,
        he = !Ae(D) && Ae(D.set) ? D.set.bind(n) : br,
        Ie = Bt({ get: se, set: he })
      Object.defineProperty(r, B, {
        enumerable: !0,
        configurable: !0,
        get: () => Ie.value,
        set: (xe) => (Ie.value = xe)
      })
    }
  if (a) for (const B in a) SA(a[B], r, n, B)
  if (l) {
    const B = Ae(l) ? l.call(n) : l
    Reflect.ownKeys(B).forEach((D) => {
      vd(D, B[D])
    })
  }
  u && Db(u, t, 'c')
  function N(B, D) {
    ye(D) ? D.forEach((se) => B(se.bind(n))) : D && B(D.bind(n))
  }
  if (
    (N(kx, h),
    N(Gu, d),
    N(Ox, f),
    N(Nx, p),
    N(Ax, m),
    N(Cx, g),
    N(xx, P),
    N(Px, w),
    N(Mx, O),
    N(qu, v),
    N(EA, S),
    N(TA, k),
    ye(U))
  )
    if (U.length) {
      const B = t.exposed || (t.exposed = {})
      U.forEach((D) => {
        Object.defineProperty(B, D, { get: () => n[D], set: (se) => (n[D] = se) })
      })
    } else t.exposed || (t.exposed = {})
  I && t.render === br && (t.render = I),
    F != null && (t.inheritAttrs = F),
    $ && (t.components = $),
    pe && (t.directives = pe)
}
function Vx(t, e, n = br) {
  ye(t) && (t = Ty(t))
  for (const r in t) {
    const i = t[r]
    let s
    ct(i)
      ? 'default' in i
        ? (s = Kn(i.from || r, i.default, !0))
        : (s = Kn(i.from || r))
      : (s = Kn(i)),
      rn(s)
        ? Object.defineProperty(e, r, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: (o) => (s.value = o)
          })
        : (e[r] = s)
  }
}
function Db(t, e, n) {
  Sr(ye(t) ? t.map((r) => r.bind(e.proxy)) : t.bind(e.proxy), e, n)
}
function SA(t, e, n, r) {
  const i = r.includes('.') ? gA(n, r) : () => n[r]
  if (Pt(t)) {
    const s = e[t]
    Ae(s) && Bi(i, s)
  } else if (Ae(t)) Bi(i, t.bind(n))
  else if (ct(t))
    if (ye(t)) t.forEach((s) => SA(s, e, n, r))
    else {
      const s = Ae(t.handler) ? t.handler.bind(n) : e[t.handler]
      Ae(s) && Bi(i, s, t)
    }
}
function Vv(t) {
  const e = t.type,
    { mixins: n, extends: r } = e,
    {
      mixins: i,
      optionsCache: s,
      config: { optionMergeStrategies: o }
    } = t.appContext,
    a = s.get(e)
  let l
  return (
    a
      ? (l = a)
      : !i.length && !n && !r
      ? (l = e)
      : ((l = {}), i.length && i.forEach((c) => Kd(l, c, o, !0)), Kd(l, e, o)),
    ct(e) && s.set(e, l),
    l
  )
}
function Kd(t, e, n, r = !1) {
  const { mixins: i, extends: s } = e
  s && Kd(t, s, n, !0), i && i.forEach((o) => Kd(t, o, n, !0))
  for (const o in e)
    if (!(r && o === 'expose')) {
      const a = Fx[o] || (n && n[o])
      t[o] = a ? a(t[o], e[o]) : e[o]
    }
  return t
}
const Fx = {
  data: Lb,
  props: Vb,
  emits: Vb,
  methods: lc,
  computed: lc,
  beforeCreate: Ln,
  created: Ln,
  beforeMount: Ln,
  mounted: Ln,
  beforeUpdate: Ln,
  updated: Ln,
  beforeDestroy: Ln,
  beforeUnmount: Ln,
  destroyed: Ln,
  unmounted: Ln,
  activated: Ln,
  deactivated: Ln,
  errorCaptured: Ln,
  serverPrefetch: Ln,
  components: lc,
  directives: lc,
  watch: Ux,
  provide: Lb,
  inject: Bx
}
function Lb(t, e) {
  return e
    ? t
      ? function () {
          return Gt(Ae(t) ? t.call(this, this) : t, Ae(e) ? e.call(this, this) : e)
        }
      : e
    : t
}
function Bx(t, e) {
  return lc(Ty(t), Ty(e))
}
function Ty(t) {
  if (ye(t)) {
    const e = {}
    for (let n = 0; n < t.length; n++) e[t[n]] = t[n]
    return e
  }
  return t
}
function Ln(t, e) {
  return t ? [...new Set([].concat(t, e))] : e
}
function lc(t, e) {
  return t ? Gt(Object.create(null), t, e) : e
}
function Vb(t, e) {
  return t
    ? ye(t) && ye(e)
      ? [...new Set([...t, ...e])]
      : Gt(Object.create(null), xb(t), xb(e ?? {}))
    : e
}
function Ux(t, e) {
  if (!t) return e
  if (!e) return t
  const n = Gt(Object.create(null), t)
  for (const r in e) n[r] = Ln(t[r], e[r])
  return n
}
function IA() {
  return {
    app: null,
    config: {
      isNativeTag: hP,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  }
}
let $x = 0
function Hx(t, e) {
  return function (r, i = null) {
    Ae(r) || (r = Gt({}, r)), i != null && !ct(i) && (i = null)
    const s = IA(),
      o = new WeakSet()
    let a = !1
    const l = (s.app = {
      _uid: $x++,
      _component: r,
      _props: i,
      _container: null,
      _context: s,
      _instance: null,
      version: mD,
      get config() {
        return s.config
      },
      set config(c) {},
      use(c, ...u) {
        return (
          o.has(c) ||
            (c && Ae(c.install) ? (o.add(c), c.install(l, ...u)) : Ae(c) && (o.add(c), c(l, ...u))),
          l
        )
      },
      mixin(c) {
        return s.mixins.includes(c) || s.mixins.push(c), l
      },
      component(c, u) {
        return u ? ((s.components[c] = u), l) : s.components[c]
      },
      directive(c, u) {
        return u ? ((s.directives[c] = u), l) : s.directives[c]
      },
      mount(c, u, h) {
        if (!a) {
          const d = Be(r, i)
          return (
            (d.appContext = s),
            h === !0 ? (h = 'svg') : h === !1 && (h = void 0),
            u && e ? e(d, c) : t(d, c, h),
            (a = !0),
            (l._container = c),
            (c.__vue_app__ = l),
            Sp(d.component) || d.component.proxy
          )
        }
      },
      unmount() {
        a && (t(null, l._container), delete l._container.__vue_app__)
      },
      provide(c, u) {
        return (s.provides[c] = u), l
      },
      runWithContext(c) {
        const u = Rc
        Rc = l
        try {
          return c()
        } finally {
          Rc = u
        }
      }
    })
    return l
  }
}
let Rc = null
function vd(t, e) {
  if (yn) {
    let n = yn.provides
    const r = yn.parent && yn.parent.provides
    r === n && (n = yn.provides = Object.create(r)), (n[t] = e)
  }
}
function Kn(t, e, n = !1) {
  const r = yn || Wt
  if (r || Rc) {
    const i = r
      ? r.parent == null
        ? r.vnode.appContext && r.vnode.appContext.provides
        : r.parent.provides
      : Rc._context.provides
    if (i && t in i) return i[t]
    if (arguments.length > 1) return n && Ae(e) ? e.call(r && r.proxy) : e
  }
}
function zx(t, e, n, r = !1) {
  const i = {},
    s = {}
  zd(s, Tp, 1), (t.propsDefaults = Object.create(null)), AA(t, e, i, s)
  for (const o in t.propsOptions[0]) o in i || (i[o] = void 0)
  n ? (t.props = r ? i : rA(i)) : t.type.props ? (t.props = i) : (t.props = s), (t.attrs = s)
}
function jx(t, e, n, r) {
  const {
      props: i,
      attrs: s,
      vnode: { patchFlag: o }
    } = t,
    a = Qe(i),
    [l] = t.propsOptions
  let c = !1
  if ((r || o > 0) && !(o & 16)) {
    if (o & 8) {
      const u = t.vnode.dynamicProps
      for (let h = 0; h < u.length; h++) {
        let d = u[h]
        if (mp(t.emitsOptions, d)) continue
        const f = e[d]
        if (l)
          if (Je(s, d)) f !== s[d] && ((s[d] = f), (c = !0))
          else {
            const p = pi(d)
            i[p] = wy(l, a, p, f, t, !1)
          }
        else f !== s[d] && ((s[d] = f), (c = !0))
      }
    }
  } else {
    AA(t, e, i, s) && (c = !0)
    let u
    for (const h in a)
      (!e || (!Je(e, h) && ((u = oa(h)) === h || !Je(e, u)))) &&
        (l
          ? n && (n[h] !== void 0 || n[u] !== void 0) && (i[h] = wy(l, a, h, void 0, t, !0))
          : delete i[h])
    if (s !== a) for (const h in s) (!e || !Je(e, h)) && (delete s[h], (c = !0))
  }
  c && Fi(t, 'set', '$attrs')
}
function AA(t, e, n, r) {
  const [i, s] = t.propsOptions
  let o = !1,
    a
  if (e)
    for (let l in e) {
      if (Sc(l)) continue
      const c = e[l]
      let u
      i && Je(i, (u = pi(l)))
        ? !s || !s.includes(u)
          ? (n[u] = c)
          : ((a || (a = {}))[u] = c)
        : mp(t.emitsOptions, l) || ((!(l in r) || c !== r[l]) && ((r[l] = c), (o = !0)))
    }
  if (s) {
    const l = Qe(n),
      c = a || yt
    for (let u = 0; u < s.length; u++) {
      const h = s[u]
      n[h] = wy(i, l, h, c[h], t, !Je(c, h))
    }
  }
  return o
}
function wy(t, e, n, r, i, s) {
  const o = t[n]
  if (o != null) {
    const a = Je(o, 'default')
    if (a && r === void 0) {
      const l = o.default
      if (o.type !== Function && !o.skipFactory && Ae(l)) {
        const { propsDefaults: c } = i
        if (n in c) r = c[n]
        else {
          const u = Wo(i)
          ;(r = c[n] = l.call(null, e)), u()
        }
      } else r = l
    }
    o[0] && (s && !a ? (r = !1) : o[1] && (r === '' || r === oa(n)) && (r = !0))
  }
  return r
}
function CA(t, e, n = !1) {
  const r = e.propsCache,
    i = r.get(t)
  if (i) return i
  const s = t.props,
    o = {},
    a = []
  let l = !1
  if (!Ae(t)) {
    const u = (h) => {
      l = !0
      const [d, f] = CA(h, e, !0)
      Gt(o, d), f && a.push(...f)
    }
    !n && e.mixins.length && e.mixins.forEach(u),
      t.extends && u(t.extends),
      t.mixins && t.mixins.forEach(u)
  }
  if (!s && !l) return ct(t) && r.set(t, Ba), Ba
  if (ye(s))
    for (let u = 0; u < s.length; u++) {
      const h = pi(s[u])
      Fb(h) && (o[h] = yt)
    }
  else if (s)
    for (const u in s) {
      const h = pi(u)
      if (Fb(h)) {
        const d = s[u],
          f = (o[h] = ye(d) || Ae(d) ? { type: d } : Gt({}, d))
        if (f) {
          const p = $b(Boolean, f.type),
            m = $b(String, f.type)
          ;(f[0] = p > -1), (f[1] = m < 0 || p < m), (p > -1 || Je(f, 'default')) && a.push(h)
        }
      }
    }
  const c = [o, a]
  return ct(t) && r.set(t, c), c
}
function Fb(t) {
  return t[0] !== '$' && !Sc(t)
}
function Bb(t) {
  return t === null
    ? 'null'
    : typeof t == 'function'
    ? t.name || ''
    : (typeof t == 'object' && t.constructor && t.constructor.name) || ''
}
function Ub(t, e) {
  return Bb(t) === Bb(e)
}
function $b(t, e) {
  return ye(e) ? e.findIndex((n) => Ub(n, t)) : Ae(e) && Ub(e, t) ? 0 : -1
}
const RA = (t) => t[0] === '_' || t === '$stable',
  Fv = (t) => (ye(t) ? t.map(Nr) : [Nr(t)]),
  Wx = (t, e, n) => {
    if (e._n) return e
    const r = xo((...i) => Fv(e(...i)), n)
    return (r._c = !1), r
  },
  kA = (t, e, n) => {
    const r = t._ctx
    for (const i in t) {
      if (RA(i)) continue
      const s = t[i]
      if (Ae(s)) e[i] = Wx(i, s, r)
      else if (s != null) {
        const o = Fv(s)
        e[i] = () => o
      }
    }
  },
  OA = (t, e) => {
    const n = Fv(e)
    t.slots.default = () => n
  },
  Gx = (t, e) => {
    if (t.vnode.shapeFlag & 32) {
      const n = e._
      n ? ((t.slots = Qe(e)), zd(e, '_', n)) : kA(e, (t.slots = {}))
    } else (t.slots = {}), e && OA(t, e)
    zd(t.slots, Tp, 1)
  },
  qx = (t, e, n) => {
    const { vnode: r, slots: i } = t
    let s = !0,
      o = yt
    if (r.shapeFlag & 32) {
      const a = e._
      a
        ? n && a === 1
          ? (s = !1)
          : (Gt(i, e), !n && a === 1 && delete i._)
        : ((s = !e.$stable), kA(e, i)),
        (o = e)
    } else e && (OA(t, e), (o = { default: 1 }))
    if (s) for (const a in i) !RA(a) && o[a] == null && delete i[a]
  }
function Sy(t, e, n, r, i = !1) {
  if (ye(t)) {
    t.forEach((d, f) => Sy(d, e && (ye(e) ? e[f] : e), n, r, i))
    return
  }
  if (Ac(r) && !i) return
  const s = r.shapeFlag & 4 ? Sp(r.component) || r.component.proxy : r.el,
    o = i ? null : s,
    { i: a, r: l } = t,
    c = e && e.r,
    u = a.refs === yt ? (a.refs = {}) : a.refs,
    h = a.setupState
  if (
    (c != null &&
      c !== l &&
      (Pt(c) ? ((u[c] = null), Je(h, c) && (h[c] = null)) : rn(c) && (c.value = null)),
    Ae(l))
  )
    Rs(l, a, 12, [o, u])
  else {
    const d = Pt(l),
      f = rn(l)
    if (d || f) {
      const p = () => {
        if (t.f) {
          const m = d ? (Je(h, l) ? h[l] : u[l]) : l.value
          i
            ? ye(m) && vv(m, s)
            : ye(m)
            ? m.includes(s) || m.push(s)
            : d
            ? ((u[l] = [s]), Je(h, l) && (h[l] = u[l]))
            : ((l.value = [s]), t.k && (u[t.k] = l.value))
        } else d ? ((u[l] = o), Je(h, l) && (h[l] = o)) : f && ((l.value = o), t.k && (u[t.k] = o))
      }
      o ? ((p.id = -1), Gn(p, n)) : p()
    }
  }
}
const Gn = yx
function Kx(t) {
  return Yx(t)
}
function Yx(t, e) {
  const n = BI()
  n.__VUE__ = !0
  const {
      insert: r,
      remove: i,
      patchProp: s,
      createElement: o,
      createText: a,
      createComment: l,
      setText: c,
      setElementText: u,
      parentNode: h,
      nextSibling: d,
      setScopeId: f = br,
      insertStaticContent: p
    } = t,
    m = (y, E, A, x = null, M = null, Y = null, re = void 0, K = null, Z = !!E.dynamicChildren) => {
      if (y === E) return
      y && !Qr(y, E) && ((x = R(y)), xe(y, M, Y, !0), (y = null)),
        E.patchFlag === -2 && ((Z = !1), (E.dynamicChildren = null))
      const { type: j, ref: ae, shapeFlag: be } = E
      switch (j) {
        case Ep:
          g(y, E, A, x)
          break
        case Yn:
          _(y, E, A, x)
          break
        case bd:
          y == null && v(E, A, x, re)
          break
        case pt:
          $(y, E, A, x, M, Y, re, K, Z)
          break
        default:
          be & 1
            ? I(y, E, A, x, M, Y, re, K, Z)
            : be & 6
            ? pe(y, E, A, x, M, Y, re, K, Z)
            : (be & 64 || be & 128) && j.process(y, E, A, x, M, Y, re, K, Z, J)
      }
      ae != null && M && Sy(ae, y && y.ref, Y, E || y, !E)
    },
    g = (y, E, A, x) => {
      if (y == null) r((E.el = a(E.children)), A, x)
      else {
        const M = (E.el = y.el)
        E.children !== y.children && c(M, E.children)
      }
    },
    _ = (y, E, A, x) => {
      y == null ? r((E.el = l(E.children || '')), A, x) : (E.el = y.el)
    },
    v = (y, E, A, x) => {
      ;[y.el, y.anchor] = p(y.children, E, A, x, y.el, y.anchor)
    },
    T = ({ el: y, anchor: E }, A, x) => {
      let M
      for (; y && y !== E; ) (M = d(y)), r(y, A, x), (y = M)
      r(E, A, x)
    },
    S = ({ el: y, anchor: E }) => {
      let A
      for (; y && y !== E; ) (A = d(y)), i(y), (y = A)
      i(E)
    },
    I = (y, E, A, x, M, Y, re, K, Z) => {
      E.type === 'svg' ? (re = 'svg') : E.type === 'math' && (re = 'mathml'),
        y == null ? w(E, A, x, M, Y, re, K, Z) : k(y, E, M, Y, re, K, Z)
    },
    w = (y, E, A, x, M, Y, re, K) => {
      let Z, j
      const { props: ae, shapeFlag: be, transition: ge, dirs: ke } = y
      if (
        ((Z = y.el = o(y.type, Y, ae && ae.is, ae)),
        be & 8 ? u(Z, y.children) : be & 16 && P(y.children, Z, null, x, M, $m(y, Y), re, K),
        ke && io(y, null, x, 'created'),
        O(Z, y, y.scopeId, re, x),
        ae)
      ) {
        for (const ot in ae)
          ot !== 'value' && !Sc(ot) && s(Z, ot, null, ae[ot], Y, y.children, x, M, G)
        'value' in ae && s(Z, 'value', null, ae.value, Y),
          (j = ae.onVnodeBeforeMount) && qr(j, x, y)
      }
      ke && io(y, null, x, 'beforeMount')
      const $e = Jx(M, ge)
      $e && ge.beforeEnter(Z),
        r(Z, E, A),
        ((j = ae && ae.onVnodeMounted) || $e || ke) &&
          Gn(() => {
            j && qr(j, x, y), $e && ge.enter(Z), ke && io(y, null, x, 'mounted')
          }, M)
    },
    O = (y, E, A, x, M) => {
      if ((A && f(y, A), x)) for (let Y = 0; Y < x.length; Y++) f(y, x[Y])
      if (M) {
        let Y = M.subTree
        if (E === Y) {
          const re = M.vnode
          O(y, re, re.scopeId, re.slotScopeIds, M.parent)
        }
      }
    },
    P = (y, E, A, x, M, Y, re, K, Z = 0) => {
      for (let j = Z; j < y.length; j++) {
        const ae = (y[j] = K ? hs(y[j]) : Nr(y[j]))
        m(null, ae, E, A, x, M, Y, re, K)
      }
    },
    k = (y, E, A, x, M, Y, re) => {
      const K = (E.el = y.el)
      let { patchFlag: Z, dynamicChildren: j, dirs: ae } = E
      Z |= y.patchFlag & 16
      const be = y.props || yt,
        ge = E.props || yt
      let ke
      if (
        (A && so(A, !1),
        (ke = ge.onVnodeBeforeUpdate) && qr(ke, A, E, y),
        ae && io(E, y, A, 'beforeUpdate'),
        A && so(A, !0),
        j
          ? U(y.dynamicChildren, j, K, A, x, $m(E, M), Y)
          : re || D(y, E, K, null, A, x, $m(E, M), Y, !1),
        Z > 0)
      ) {
        if (Z & 16) F(K, E, be, ge, A, x, M)
        else if (
          (Z & 2 && be.class !== ge.class && s(K, 'class', null, ge.class, M),
          Z & 4 && s(K, 'style', be.style, ge.style, M),
          Z & 8)
        ) {
          const $e = E.dynamicProps
          for (let ot = 0; ot < $e.length; ot++) {
            const wt = $e[ot],
              Yt = be[wt],
              Rr = ge[wt]
            ;(Rr !== Yt || wt === 'value') && s(K, wt, Yt, Rr, M, y.children, A, x, G)
          }
        }
        Z & 1 && y.children !== E.children && u(K, E.children)
      } else !re && j == null && F(K, E, be, ge, A, x, M)
      ;((ke = ge.onVnodeUpdated) || ae) &&
        Gn(() => {
          ke && qr(ke, A, E, y), ae && io(E, y, A, 'updated')
        }, x)
    },
    U = (y, E, A, x, M, Y, re) => {
      for (let K = 0; K < E.length; K++) {
        const Z = y[K],
          j = E[K],
          ae = Z.el && (Z.type === pt || !Qr(Z, j) || Z.shapeFlag & 70) ? h(Z.el) : A
        m(Z, j, ae, null, x, M, Y, re, !0)
      }
    },
    F = (y, E, A, x, M, Y, re) => {
      if (A !== x) {
        if (A !== yt)
          for (const K in A) !Sc(K) && !(K in x) && s(y, K, A[K], null, re, E.children, M, Y, G)
        for (const K in x) {
          if (Sc(K)) continue
          const Z = x[K],
            j = A[K]
          Z !== j && K !== 'value' && s(y, K, j, Z, re, E.children, M, Y, G)
        }
        'value' in x && s(y, 'value', A.value, x.value, re)
      }
    },
    $ = (y, E, A, x, M, Y, re, K, Z) => {
      const j = (E.el = y ? y.el : a('')),
        ae = (E.anchor = y ? y.anchor : a(''))
      let { patchFlag: be, dynamicChildren: ge, slotScopeIds: ke } = E
      ke && (K = K ? K.concat(ke) : ke),
        y == null
          ? (r(j, A, x), r(ae, A, x), P(E.children || [], A, ae, M, Y, re, K, Z))
          : be > 0 && be & 64 && ge && y.dynamicChildren
          ? (U(y.dynamicChildren, ge, A, M, Y, re, K),
            (E.key != null || (M && E === M.subTree)) && Bv(y, E, !0))
          : D(y, E, A, ae, M, Y, re, K, Z)
    },
    pe = (y, E, A, x, M, Y, re, K, Z) => {
      ;(E.slotScopeIds = K),
        y == null
          ? E.shapeFlag & 512
            ? M.ctx.activate(E, A, x, re, Z)
            : q(E, A, x, M, Y, re, Z)
          : z(y, E, Z)
    },
    q = (y, E, A, x, M, Y, re) => {
      const K = (y.component = lD(y, x, M))
      if ((vp(y) && (K.ctx.renderer = J), cD(K), K.asyncDep)) {
        if ((M && M.registerDep(K, N), !y.el)) {
          const Z = (K.subTree = Be(Yn))
          _(null, Z, E, A)
        }
      } else N(K, y, E, A, M, Y, re)
    },
    z = (y, E, A) => {
      const x = (E.component = y.component)
      if (ox(y, E, A))
        if (x.asyncDep && !x.asyncResolved) {
          B(x, E, A)
          return
        } else (x.next = E), ex(x.update), (x.effect.dirty = !0), x.update()
      else (E.el = y.el), (x.vnode = E)
    },
    N = (y, E, A, x, M, Y, re) => {
      const K = () => {
          if (y.isMounted) {
            let { next: ae, bu: be, u: ge, parent: ke, vnode: $e } = y
            {
              const ya = NA(y)
              if (ya) {
                ae && ((ae.el = $e.el), B(y, ae, re)),
                  ya.asyncDep.then(() => {
                    y.isUnmounted || K()
                  })
                return
              }
            }
            let ot = ae,
              wt
            so(y, !1),
              ae ? ((ae.el = $e.el), B(y, ae, re)) : (ae = $e),
              be && _d(be),
              (wt = ae.props && ae.props.onVnodeBeforeUpdate) && qr(wt, ke, ae, $e),
              so(y, !0)
            const Yt = Fm(y),
              Rr = y.subTree
            ;(y.subTree = Yt),
              m(Rr, Yt, h(Rr.el), R(Rr), y, M, Y),
              (ae.el = Yt.el),
              ot === null && xv(y, Yt.el),
              ge && Gn(ge, M),
              (wt = ae.props && ae.props.onVnodeUpdated) && Gn(() => qr(wt, ke, ae, $e), M)
          } else {
            let ae
            const { el: be, props: ge } = E,
              { bm: ke, m: $e, parent: ot } = y,
              wt = Ac(E)
            if (
              (so(y, !1),
              ke && _d(ke),
              !wt && (ae = ge && ge.onVnodeBeforeMount) && qr(ae, ot, E),
              so(y, !0),
              be && ve)
            ) {
              const Yt = () => {
                ;(y.subTree = Fm(y)), ve(be, y.subTree, y, M, null)
              }
              wt ? E.type.__asyncLoader().then(() => !y.isUnmounted && Yt()) : Yt()
            } else {
              const Yt = (y.subTree = Fm(y))
              m(null, Yt, A, x, y, M, Y), (E.el = Yt.el)
            }
            if (($e && Gn($e, M), !wt && (ae = ge && ge.onVnodeMounted))) {
              const Yt = E
              Gn(() => qr(ae, ot, Yt), M)
            }
            ;(E.shapeFlag & 256 || (ot && Ac(ot.vnode) && ot.vnode.shapeFlag & 256)) &&
              y.a &&
              Gn(y.a, M),
              (y.isMounted = !0),
              (E = A = x = null)
          }
        },
        Z = (y.effect = new wv(K, br, () => Pv(j), y.scope)),
        j = (y.update = () => {
          Z.dirty && Z.run()
        })
      ;(j.id = y.uid), so(y, !0), j()
    },
    B = (y, E, A) => {
      E.component = y
      const x = y.vnode.props
      ;(y.vnode = E), (y.next = null), jx(y, E.props, x, A), qx(y, E.children, A), aa(), kb(y), la()
    },
    D = (y, E, A, x, M, Y, re, K, Z = !1) => {
      const j = y && y.children,
        ae = y ? y.shapeFlag : 0,
        be = E.children,
        { patchFlag: ge, shapeFlag: ke } = E
      if (ge > 0) {
        if (ge & 128) {
          he(j, be, A, x, M, Y, re, K, Z)
          return
        } else if (ge & 256) {
          se(j, be, A, x, M, Y, re, K, Z)
          return
        }
      }
      ke & 8
        ? (ae & 16 && G(j, M, Y), be !== j && u(A, be))
        : ae & 16
        ? ke & 16
          ? he(j, be, A, x, M, Y, re, K, Z)
          : G(j, M, Y, !0)
        : (ae & 8 && u(A, ''), ke & 16 && P(be, A, x, M, Y, re, K, Z))
    },
    se = (y, E, A, x, M, Y, re, K, Z) => {
      ;(y = y || Ba), (E = E || Ba)
      const j = y.length,
        ae = E.length,
        be = Math.min(j, ae)
      let ge
      for (ge = 0; ge < be; ge++) {
        const ke = (E[ge] = Z ? hs(E[ge]) : Nr(E[ge]))
        m(y[ge], ke, A, null, M, Y, re, K, Z)
      }
      j > ae ? G(y, M, Y, !0, !1, be) : P(E, A, x, M, Y, re, K, Z, be)
    },
    he = (y, E, A, x, M, Y, re, K, Z) => {
      let j = 0
      const ae = E.length
      let be = y.length - 1,
        ge = ae - 1
      for (; j <= be && j <= ge; ) {
        const ke = y[j],
          $e = (E[j] = Z ? hs(E[j]) : Nr(E[j]))
        if (Qr(ke, $e)) m(ke, $e, A, null, M, Y, re, K, Z)
        else break
        j++
      }
      for (; j <= be && j <= ge; ) {
        const ke = y[be],
          $e = (E[ge] = Z ? hs(E[ge]) : Nr(E[ge]))
        if (Qr(ke, $e)) m(ke, $e, A, null, M, Y, re, K, Z)
        else break
        be--, ge--
      }
      if (j > be) {
        if (j <= ge) {
          const ke = ge + 1,
            $e = ke < ae ? E[ke].el : x
          for (; j <= ge; ) m(null, (E[j] = Z ? hs(E[j]) : Nr(E[j])), A, $e, M, Y, re, K, Z), j++
        }
      } else if (j > ge) for (; j <= be; ) xe(y[j], M, Y, !0), j++
      else {
        const ke = j,
          $e = j,
          ot = new Map()
        for (j = $e; j <= ge; j++) {
          const Xn = (E[j] = Z ? hs(E[j]) : Nr(E[j]))
          Xn.key != null && ot.set(Xn.key, j)
        }
        let wt,
          Yt = 0
        const Rr = ge - $e + 1
        let ya = !1,
          yb = 0
        const Yl = new Array(Rr)
        for (j = 0; j < Rr; j++) Yl[j] = 0
        for (j = ke; j <= be; j++) {
          const Xn = y[j]
          if (Yt >= Rr) {
            xe(Xn, M, Y, !0)
            continue
          }
          let Gr
          if (Xn.key != null) Gr = ot.get(Xn.key)
          else
            for (wt = $e; wt <= ge; wt++)
              if (Yl[wt - $e] === 0 && Qr(Xn, E[wt])) {
                Gr = wt
                break
              }
          Gr === void 0
            ? xe(Xn, M, Y, !0)
            : ((Yl[Gr - $e] = j + 1),
              Gr >= yb ? (yb = Gr) : (ya = !0),
              m(Xn, E[Gr], A, null, M, Y, re, K, Z),
              Yt++)
        }
        const _b = ya ? Qx(Yl) : Ba
        for (wt = _b.length - 1, j = Rr - 1; j >= 0; j--) {
          const Xn = $e + j,
            Gr = E[Xn],
            vb = Xn + 1 < ae ? E[Xn + 1].el : x
          Yl[j] === 0
            ? m(null, Gr, A, vb, M, Y, re, K, Z)
            : ya && (wt < 0 || j !== _b[wt] ? Ie(Gr, A, vb, 2) : wt--)
        }
      }
    },
    Ie = (y, E, A, x, M = null) => {
      const { el: Y, type: re, transition: K, children: Z, shapeFlag: j } = y
      if (j & 6) {
        Ie(y.component.subTree, E, A, x)
        return
      }
      if (j & 128) {
        y.suspense.move(E, A, x)
        return
      }
      if (j & 64) {
        re.move(y, E, A, J)
        return
      }
      if (re === pt) {
        r(Y, E, A)
        for (let be = 0; be < Z.length; be++) Ie(Z[be], E, A, x)
        r(y.anchor, E, A)
        return
      }
      if (re === bd) {
        T(y, E, A)
        return
      }
      if (x !== 2 && j & 1 && K)
        if (x === 0) K.beforeEnter(Y), r(Y, E, A), Gn(() => K.enter(Y), M)
        else {
          const { leave: be, delayLeave: ge, afterLeave: ke } = K,
            $e = () => r(Y, E, A),
            ot = () => {
              be(Y, () => {
                $e(), ke && ke()
              })
            }
          ge ? ge(Y, $e, ot) : ot()
        }
      else r(Y, E, A)
    },
    xe = (y, E, A, x = !1, M = !1) => {
      const {
        type: Y,
        props: re,
        ref: K,
        children: Z,
        dynamicChildren: j,
        shapeFlag: ae,
        patchFlag: be,
        dirs: ge
      } = y
      if ((K != null && Sy(K, null, A, y, !0), ae & 256)) {
        E.ctx.deactivate(y)
        return
      }
      const ke = ae & 1 && ge,
        $e = !Ac(y)
      let ot
      if (($e && (ot = re && re.onVnodeBeforeUnmount) && qr(ot, E, y), ae & 6))
        me(y.component, A, x)
      else {
        if (ae & 128) {
          y.suspense.unmount(A, x)
          return
        }
        ke && io(y, null, E, 'beforeUnmount'),
          ae & 64
            ? y.type.remove(y, E, A, M, J, x)
            : j && (Y !== pt || (be > 0 && be & 64))
            ? G(j, E, A, !1, !0)
            : ((Y === pt && be & 384) || (!M && ae & 16)) && G(Z, E, A),
          x && tt(y)
      }
      ;(($e && (ot = re && re.onVnodeUnmounted)) || ke) &&
        Gn(() => {
          ot && qr(ot, E, y), ke && io(y, null, E, 'unmounted')
        }, A)
    },
    tt = (y) => {
      const { type: E, el: A, anchor: x, transition: M } = y
      if (E === pt) {
        st(A, x)
        return
      }
      if (E === bd) {
        S(y)
        return
      }
      const Y = () => {
        i(A), M && !M.persisted && M.afterLeave && M.afterLeave()
      }
      if (y.shapeFlag & 1 && M && !M.persisted) {
        const { leave: re, delayLeave: K } = M,
          Z = () => re(A, Y)
        K ? K(y.el, Y, Z) : Z()
      } else Y()
    },
    st = (y, E) => {
      let A
      for (; y !== E; ) (A = d(y)), i(y), (y = A)
      i(E)
    },
    me = (y, E, A) => {
      const { bum: x, scope: M, update: Y, subTree: re, um: K } = y
      x && _d(x),
        M.stop(),
        Y && ((Y.active = !1), xe(re, y, E, A)),
        K && Gn(K, E),
        Gn(() => {
          y.isUnmounted = !0
        }, E),
        E &&
          E.pendingBranch &&
          !E.isUnmounted &&
          y.asyncDep &&
          !y.asyncResolved &&
          y.suspenseId === E.pendingId &&
          (E.deps--, E.deps === 0 && E.resolve())
    },
    G = (y, E, A, x = !1, M = !1, Y = 0) => {
      for (let re = Y; re < y.length; re++) xe(y[re], E, A, x, M)
    },
    R = (y) =>
      y.shapeFlag & 6
        ? R(y.component.subTree)
        : y.shapeFlag & 128
        ? y.suspense.next()
        : d(y.anchor || y.el)
  let X = !1
  const W = (y, E, A) => {
      y == null
        ? E._vnode && xe(E._vnode, null, null, !0)
        : m(E._vnode || null, y, E, null, null, null, A),
        X || ((X = !0), kb(), dA(), (X = !1)),
        (E._vnode = y)
    },
    J = { p: m, um: xe, m: Ie, r: tt, mt: q, mc: P, pc: D, pbc: U, n: R, o: t }
  let Te, ve
  return e && ([Te, ve] = e(J)), { render: W, hydrate: Te, createApp: Hx(W, Te) }
}
function $m({ type: t, props: e }, n) {
  return (n === 'svg' && t === 'foreignObject') ||
    (n === 'mathml' && t === 'annotation-xml' && e && e.encoding && e.encoding.includes('html'))
    ? void 0
    : n
}
function so({ effect: t, update: e }, n) {
  t.allowRecurse = e.allowRecurse = n
}
function Jx(t, e) {
  return (!t || (t && !t.pendingBranch)) && e && !e.persisted
}
function Bv(t, e, n = !1) {
  const r = t.children,
    i = e.children
  if (ye(r) && ye(i))
    for (let s = 0; s < r.length; s++) {
      const o = r[s]
      let a = i[s]
      a.shapeFlag & 1 &&
        !a.dynamicChildren &&
        ((a.patchFlag <= 0 || a.patchFlag === 32) && ((a = i[s] = hs(i[s])), (a.el = o.el)),
        n || Bv(o, a)),
        a.type === Ep && (a.el = o.el)
    }
}
function Qx(t) {
  const e = t.slice(),
    n = [0]
  let r, i, s, o, a
  const l = t.length
  for (r = 0; r < l; r++) {
    const c = t[r]
    if (c !== 0) {
      if (((i = n[n.length - 1]), t[i] < c)) {
        ;(e[r] = i), n.push(r)
        continue
      }
      for (s = 0, o = n.length - 1; s < o; ) (a = (s + o) >> 1), t[n[a]] < c ? (s = a + 1) : (o = a)
      c < t[n[s]] && (s > 0 && (e[r] = n[s - 1]), (n[s] = r))
    }
  }
  for (s = n.length, o = n[s - 1]; s-- > 0; ) (n[s] = o), (o = e[o])
  return n
}
function NA(t) {
  const e = t.subTree.component
  if (e) return e.asyncDep && !e.asyncResolved ? e : NA(e)
}
const Xx = (t) => t.__isTeleport,
  kc = (t) => t && (t.disabled || t.disabled === ''),
  Hb = (t) => typeof SVGElement < 'u' && t instanceof SVGElement,
  zb = (t) => typeof MathMLElement == 'function' && t instanceof MathMLElement,
  Iy = (t, e) => {
    const n = t && t.to
    return Pt(n) ? (e ? e(n) : null) : n
  },
  Zx = {
    name: 'Teleport',
    __isTeleport: !0,
    process(t, e, n, r, i, s, o, a, l, c) {
      const {
          mc: u,
          pc: h,
          pbc: d,
          o: { insert: f, querySelector: p, createText: m, createComment: g }
        } = c,
        _ = kc(e.props)
      let { shapeFlag: v, children: T, dynamicChildren: S } = e
      if (t == null) {
        const I = (e.el = m('')),
          w = (e.anchor = m(''))
        f(I, n, r), f(w, n, r)
        const O = (e.target = Iy(e.props, p)),
          P = (e.targetAnchor = m(''))
        O &&
          (f(P, O),
          o === 'svg' || Hb(O) ? (o = 'svg') : (o === 'mathml' || zb(O)) && (o = 'mathml'))
        const k = (U, F) => {
          v & 16 && u(T, U, F, i, s, o, a, l)
        }
        _ ? k(n, w) : O && k(O, P)
      } else {
        e.el = t.el
        const I = (e.anchor = t.anchor),
          w = (e.target = t.target),
          O = (e.targetAnchor = t.targetAnchor),
          P = kc(t.props),
          k = P ? n : w,
          U = P ? I : O
        if (
          (o === 'svg' || Hb(w) ? (o = 'svg') : (o === 'mathml' || zb(w)) && (o = 'mathml'),
          S
            ? (d(t.dynamicChildren, S, k, i, s, o, a), Bv(t, e, !0))
            : l || h(t, e, k, U, i, s, o, a, !1),
          _)
        )
          P
            ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to)
            : Bh(e, n, I, c, 1)
        else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
          const F = (e.target = Iy(e.props, p))
          F && Bh(e, F, null, c, 0)
        } else P && Bh(e, w, O, c, 1)
      }
      MA(e)
    },
    remove(t, e, n, r, { um: i, o: { remove: s } }, o) {
      const { shapeFlag: a, children: l, anchor: c, targetAnchor: u, target: h, props: d } = t
      if ((h && s(u), o && s(c), a & 16)) {
        const f = o || !kc(d)
        for (let p = 0; p < l.length; p++) {
          const m = l[p]
          i(m, e, n, f, !!m.dynamicChildren)
        }
      }
    },
    move: Bh,
    hydrate: eD
  }
function Bh(t, e, n, { o: { insert: r }, m: i }, s = 2) {
  s === 0 && r(t.targetAnchor, e, n)
  const { el: o, anchor: a, shapeFlag: l, children: c, props: u } = t,
    h = s === 2
  if ((h && r(o, e, n), (!h || kc(u)) && l & 16))
    for (let d = 0; d < c.length; d++) i(c[d], e, n, 2)
  h && r(a, e, n)
}
function eD(t, e, n, r, i, s, { o: { nextSibling: o, parentNode: a, querySelector: l } }, c) {
  const u = (e.target = Iy(e.props, l))
  if (u) {
    const h = u._lpa || u.firstChild
    if (e.shapeFlag & 16)
      if (kc(e.props)) (e.anchor = c(o(t), e, a(t), n, r, i, s)), (e.targetAnchor = h)
      else {
        e.anchor = o(t)
        let d = h
        for (; d; )
          if (((d = o(d)), d && d.nodeType === 8 && d.data === 'teleport anchor')) {
            ;(e.targetAnchor = d), (u._lpa = e.targetAnchor && o(e.targetAnchor))
            break
          }
        c(h, e, u, n, r, i, s)
      }
    MA(e)
  }
  return e.anchor && o(e.anchor)
}
const tD = Zx
function MA(t) {
  const e = t.ctx
  if (e && e.ut) {
    let n = t.children[0].el
    for (; n && n !== t.targetAnchor; )
      n.nodeType === 1 && n.setAttribute('data-v-owner', e.uid), (n = n.nextSibling)
    e.ut()
  }
}
const pt = Symbol.for('v-fgt'),
  Ep = Symbol.for('v-txt'),
  Yn = Symbol.for('v-cmt'),
  bd = Symbol.for('v-stc'),
  Oc = []
let Er = null
function de(t = !1) {
  Oc.push((Er = t ? null : []))
}
function PA() {
  Oc.pop(), (Er = Oc[Oc.length - 1] || null)
}
let ol = 1
function jb(t) {
  ol += t
}
function xA(t) {
  return (t.dynamicChildren = ol > 0 ? Er || Ba : null), PA(), ol > 0 && Er && Er.push(t), t
}
function De(t, e, n, r, i, s) {
  return xA(C(t, e, n, r, i, s, !0))
}
function dn(t, e, n, r, i) {
  return xA(Be(t, e, n, r, i, !0))
}
function iu(t) {
  return t ? t.__v_isVNode === !0 : !1
}
function Qr(t, e) {
  return t.type === e.type && t.key === e.key
}
const Tp = '__vInternal',
  DA = ({ key: t }) => t ?? null,
  Ed = ({ ref: t, ref_key: e, ref_for: n }) => (
    typeof t == 'number' && (t = '' + t),
    t != null ? (Pt(t) || rn(t) || Ae(t) ? { i: Wt, r: t, k: e, f: !!n } : t) : null
  )
function C(t, e = null, n = null, r = 0, i = null, s = t === pt ? 0 : 1, o = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && DA(e),
    ref: e && Ed(e),
    scopeId: gp,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: r,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: Wt
  }
  return (
    a ? (Uv(l, n), s & 128 && t.normalize(l)) : n && (l.shapeFlag |= Pt(n) ? 8 : 16),
    ol > 0 && !o && Er && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && Er.push(l),
    l
  )
}
const Be = nD
function nD(t, e = null, n = null, r = 0, i = null, s = !1) {
  if (((!t || t === lx) && (t = Yn), iu(t))) {
    const a = Bs(t, e, !0)
    return (
      n && Uv(a, n),
      ol > 0 && !s && Er && (a.shapeFlag & 6 ? (Er[Er.indexOf(t)] = a) : Er.push(a)),
      (a.patchFlag |= -2),
      a
    )
  }
  if ((pD(t) && (t = t.__vccOpts), e)) {
    e = rD(e)
    let { class: a, style: l } = e
    a && !Pt(a) && (e.class = hp(a)),
      ct(l) && (iA(l) && !ye(l) && (l = Gt({}, l)), (e.style = No(l)))
  }
  const o = Pt(t) ? 1 : ux(t) ? 128 : Xx(t) ? 64 : ct(t) ? 4 : Ae(t) ? 2 : 0
  return C(t, e, n, r, i, o, s, !0)
}
function rD(t) {
  return t ? (iA(t) || Tp in t ? Gt({}, t) : t) : null
}
function Bs(t, e, n = !1) {
  const { props: r, ref: i, patchFlag: s, children: o } = t,
    a = e ? sD(r || {}, e) : r
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: a,
    key: a && DA(a),
    ref: e && e.ref ? (n && i ? (ye(i) ? i.concat(Ed(e)) : [i, Ed(e)]) : Ed(e)) : i,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: o,
    target: t.target,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    patchFlag: e && t.type !== pt ? (s === -1 ? 16 : s | 16) : s,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: t.transition,
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && Bs(t.ssContent),
    ssFallback: t.ssFallback && Bs(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  }
}
function dt(t = ' ', e = 0) {
  return Be(Ep, null, t, e)
}
function iD(t, e) {
  const n = Be(bd, null, t)
  return (n.staticCount = e), n
}
function ft(t = '', e = !1) {
  return e ? (de(), dn(Yn, null, t)) : Be(Yn, null, t)
}
function Nr(t) {
  return t == null || typeof t == 'boolean'
    ? Be(Yn)
    : ye(t)
    ? Be(pt, null, t.slice())
    : typeof t == 'object'
    ? hs(t)
    : Be(Ep, null, String(t))
}
function hs(t) {
  return (t.el === null && t.patchFlag !== -1) || t.memo ? t : Bs(t)
}
function Uv(t, e) {
  let n = 0
  const { shapeFlag: r } = t
  if (e == null) e = null
  else if (ye(e)) n = 16
  else if (typeof e == 'object')
    if (r & 65) {
      const i = e.default
      i && (i._c && (i._d = !1), Uv(t, i()), i._c && (i._d = !0))
      return
    } else {
      n = 32
      const i = e._
      !i && !(Tp in e)
        ? (e._ctx = Wt)
        : i === 3 && Wt && (Wt.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (t.patchFlag |= 1024)))
    }
  else
    Ae(e)
      ? ((e = { default: e, _ctx: Wt }), (n = 32))
      : ((e = String(e)), r & 64 ? ((n = 16), (e = [dt(e)])) : (n = 8))
  ;(t.children = e), (t.shapeFlag |= n)
}
function sD(...t) {
  const e = {}
  for (let n = 0; n < t.length; n++) {
    const r = t[n]
    for (const i in r)
      if (i === 'class') e.class !== r.class && (e.class = hp([e.class, r.class]))
      else if (i === 'style') e.style = No([e.style, r.style])
      else if (ap(i)) {
        const s = e[i],
          o = r[i]
        o && s !== o && !(ye(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o)
      } else i !== '' && (e[i] = r[i])
  }
  return e
}
function qr(t, e, n, r = null) {
  Sr(t, e, 7, [n, r])
}
const oD = IA()
let aD = 0
function lD(t, e, n) {
  const r = t.type,
    i = (e ? e.appContext : t.appContext) || oD,
    s = {
      uid: aD++,
      vnode: t,
      type: r,
      parent: e,
      appContext: i,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new zI(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: e ? e.provides : Object.create(i.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: CA(r, i),
      emitsOptions: pA(r, i),
      emit: null,
      emitted: null,
      propsDefaults: yt,
      inheritAttrs: r.inheritAttrs,
      ctx: yt,
      data: yt,
      props: yt,
      attrs: yt,
      slots: yt,
      refs: yt,
      setupState: yt,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    }
  return (
    (s.ctx = { _: s }), (s.root = e ? e.root : s), (s.emit = nx.bind(null, s)), t.ce && t.ce(s), s
  )
}
let yn = null
const ca = () => yn || Wt
let Yd, Ay
{
  const t = BI(),
    e = (n, r) => {
      let i
      return (
        (i = t[n]) || (i = t[n] = []),
        i.push(r),
        (s) => {
          i.length > 1 ? i.forEach((o) => o(s)) : i[0](s)
        }
      )
    }
  ;(Yd = e('__VUE_INSTANCE_SETTERS__', (n) => (yn = n))),
    (Ay = e('__VUE_SSR_SETTERS__', (n) => (wp = n)))
}
const Wo = (t) => {
    const e = yn
    return (
      Yd(t),
      t.scope.on(),
      () => {
        t.scope.off(), Yd(e)
      }
    )
  },
  Cy = () => {
    yn && yn.scope.off(), Yd(null)
  }
function LA(t) {
  return t.vnode.shapeFlag & 4
}
let wp = !1
function cD(t, e = !1) {
  e && Ay(e)
  const { props: n, children: r } = t.vnode,
    i = LA(t)
  zx(t, n, i, e), Gx(t, r)
  const s = i ? uD(t, e) : void 0
  return e && Ay(!1), s
}
function uD(t, e) {
  const n = t.type
  ;(t.accessCache = Object.create(null)), (t.proxy = pp(new Proxy(t.ctx, Dx)))
  const { setup: r } = n
  if (r) {
    const i = (t.setupContext = r.length > 1 ? dD(t) : null),
      s = Wo(t)
    aa()
    const o = Rs(r, t, 0, [t.props, i])
    if ((la(), s(), bv(o))) {
      if ((o.then(Cy, Cy), e))
        return o
          .then((a) => {
            Ry(t, a, e)
          })
          .catch((a) => {
            Wu(a, t, 0)
          })
      t.asyncDep = o
    } else Ry(t, o, e)
  } else VA(t, e)
}
function Ry(t, e, n) {
  Ae(e)
    ? t.type.__ssrInlineRender
      ? (t.ssrRender = e)
      : (t.render = e)
    : ct(e) && (t.setupState = lA(e)),
    VA(t, n)
}
let Wb
function VA(t, e, n) {
  const r = t.type
  if (!t.render) {
    if (!e && Wb && !r.render) {
      const i = r.template || Vv(t).template
      if (i) {
        const { isCustomElement: s, compilerOptions: o } = t.appContext.config,
          { delimiters: a, compilerOptions: l } = r,
          c = Gt(Gt({ isCustomElement: s, delimiters: a }, o), l)
        r.render = Wb(i, c)
      }
    }
    t.render = r.render || br
  }
  {
    const i = Wo(t)
    aa()
    try {
      Lx(t)
    } finally {
      la(), i()
    }
  }
}
function hD(t) {
  return (
    t.attrsProxy ||
    (t.attrsProxy = new Proxy(t.attrs, {
      get(e, n) {
        return Qn(t, 'get', '$attrs'), e[n]
      }
    }))
  )
}
function dD(t) {
  const e = (n) => {
    t.exposed = n || {}
  }
  return {
    get attrs() {
      return hD(t)
    },
    slots: t.slots,
    emit: t.emit,
    expose: e
  }
}
function Sp(t) {
  if (t.exposed)
    return (
      t.exposeProxy ||
      (t.exposeProxy = new Proxy(lA(pp(t.exposed)), {
        get(e, n) {
          if (n in e) return e[n]
          if (n in Cc) return Cc[n](t)
        },
        has(e, n) {
          return n in e || n in Cc
        }
      }))
    )
}
function fD(t, e = !0) {
  return Ae(t) ? t.displayName || t.name : t.name || (e && t.__name)
}
function pD(t) {
  return Ae(t) && '__vccOpts' in t
}
const Bt = (t, e) => jP(t, e, wp)
function Do(t, e, n) {
  const r = arguments.length
  return r === 2
    ? ct(e) && !ye(e)
      ? iu(e)
        ? Be(t, null, [e])
        : Be(t, e)
      : Be(t, null, e)
    : (r > 3 ? (n = Array.prototype.slice.call(arguments, 2)) : r === 3 && iu(n) && (n = [n]),
      Be(t, e, n))
}
const mD = '3.4.21'
/**
 * @vue/runtime-dom v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ const gD = 'http://www.w3.org/2000/svg',
  yD = 'http://www.w3.org/1998/Math/MathML',
  ds = typeof document < 'u' ? document : null,
  Gb = ds && ds.createElement('template'),
  _D = {
    insert: (t, e, n) => {
      e.insertBefore(t, n || null)
    },
    remove: (t) => {
      const e = t.parentNode
      e && e.removeChild(t)
    },
    createElement: (t, e, n, r) => {
      const i =
        e === 'svg'
          ? ds.createElementNS(gD, t)
          : e === 'mathml'
          ? ds.createElementNS(yD, t)
          : ds.createElement(t, n ? { is: n } : void 0)
      return t === 'select' && r && r.multiple != null && i.setAttribute('multiple', r.multiple), i
    },
    createText: (t) => ds.createTextNode(t),
    createComment: (t) => ds.createComment(t),
    setText: (t, e) => {
      t.nodeValue = e
    },
    setElementText: (t, e) => {
      t.textContent = e
    },
    parentNode: (t) => t.parentNode,
    nextSibling: (t) => t.nextSibling,
    querySelector: (t) => ds.querySelector(t),
    setScopeId(t, e) {
      t.setAttribute(e, '')
    },
    insertStaticContent(t, e, n, r, i, s) {
      const o = n ? n.previousSibling : e.lastChild
      if (i && (i === s || i.nextSibling))
        for (; e.insertBefore(i.cloneNode(!0), n), !(i === s || !(i = i.nextSibling)); );
      else {
        Gb.innerHTML = r === 'svg' ? `<svg>${t}</svg>` : r === 'mathml' ? `<math>${t}</math>` : t
        const a = Gb.content
        if (r === 'svg' || r === 'mathml') {
          const l = a.firstChild
          for (; l.firstChild; ) a.appendChild(l.firstChild)
          a.removeChild(l)
        }
        e.insertBefore(a, n)
      }
      return [o ? o.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
    }
  },
  ts = 'transition',
  Jl = 'animation',
  su = Symbol('_vtc'),
  Jd = (t, { slots: e }) => Do(Ix, vD(t), e)
Jd.displayName = 'Transition'
const FA = {
  name: String,
  type: String,
  css: { type: Boolean, default: !0 },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}
Jd.props = Gt({}, yA, FA)
const oo = (t, e = []) => {
    ye(t) ? t.forEach((n) => n(...e)) : t && t(...e)
  },
  qb = (t) => (t ? (ye(t) ? t.some((e) => e.length > 1) : t.length > 1) : !1)
function vD(t) {
  const e = {}
  for (const $ in t) $ in FA || (e[$] = t[$])
  if (t.css === !1) return e
  const {
      name: n = 'v',
      type: r,
      duration: i,
      enterFromClass: s = `${n}-enter-from`,
      enterActiveClass: o = `${n}-enter-active`,
      enterToClass: a = `${n}-enter-to`,
      appearFromClass: l = s,
      appearActiveClass: c = o,
      appearToClass: u = a,
      leaveFromClass: h = `${n}-leave-from`,
      leaveActiveClass: d = `${n}-leave-active`,
      leaveToClass: f = `${n}-leave-to`
    } = t,
    p = bD(i),
    m = p && p[0],
    g = p && p[1],
    {
      onBeforeEnter: _,
      onEnter: v,
      onEnterCancelled: T,
      onLeave: S,
      onLeaveCancelled: I,
      onBeforeAppear: w = _,
      onAppear: O = v,
      onAppearCancelled: P = T
    } = e,
    k = ($, pe, q) => {
      ao($, pe ? u : a), ao($, pe ? c : o), q && q()
    },
    U = ($, pe) => {
      ;($._isLeaving = !1), ao($, h), ao($, f), ao($, d), pe && pe()
    },
    F = ($) => (pe, q) => {
      const z = $ ? O : v,
        N = () => k(pe, $, q)
      oo(z, [pe, N]),
        Kb(() => {
          ao(pe, $ ? l : s), ns(pe, $ ? u : a), qb(z) || Yb(pe, r, m, N)
        })
    }
  return Gt(e, {
    onBeforeEnter($) {
      oo(_, [$]), ns($, s), ns($, o)
    },
    onBeforeAppear($) {
      oo(w, [$]), ns($, l), ns($, c)
    },
    onEnter: F(!1),
    onAppear: F(!0),
    onLeave($, pe) {
      $._isLeaving = !0
      const q = () => U($, pe)
      ns($, h),
        wD(),
        ns($, d),
        Kb(() => {
          $._isLeaving && (ao($, h), ns($, f), qb(S) || Yb($, r, g, q))
        }),
        oo(S, [$, q])
    },
    onEnterCancelled($) {
      k($, !1), oo(T, [$])
    },
    onAppearCancelled($) {
      k($, !0), oo(P, [$])
    },
    onLeaveCancelled($) {
      U($), oo(I, [$])
    }
  })
}
function bD(t) {
  if (t == null) return null
  if (ct(t)) return [Hm(t.enter), Hm(t.leave)]
  {
    const e = Hm(t)
    return [e, e]
  }
}
function Hm(t) {
  return FI(t)
}
function ns(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.add(n)), (t[su] || (t[su] = new Set())).add(e)
}
function ao(t, e) {
  e.split(/\s+/).forEach((r) => r && t.classList.remove(r))
  const n = t[su]
  n && (n.delete(e), n.size || (t[su] = void 0))
}
function Kb(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t)
  })
}
let ED = 0
function Yb(t, e, n, r) {
  const i = (t._endId = ++ED),
    s = () => {
      i === t._endId && r()
    }
  if (n) return setTimeout(s, n)
  const { type: o, timeout: a, propCount: l } = TD(t, e)
  if (!o) return r()
  const c = o + 'end'
  let u = 0
  const h = () => {
      t.removeEventListener(c, d), s()
    },
    d = (f) => {
      f.target === t && ++u >= l && h()
    }
  setTimeout(() => {
    u < l && h()
  }, a + 1),
    t.addEventListener(c, d)
}
function TD(t, e) {
  const n = window.getComputedStyle(t),
    r = (p) => (n[p] || '').split(', '),
    i = r(`${ts}Delay`),
    s = r(`${ts}Duration`),
    o = Jb(i, s),
    a = r(`${Jl}Delay`),
    l = r(`${Jl}Duration`),
    c = Jb(a, l)
  let u = null,
    h = 0,
    d = 0
  e === ts
    ? o > 0 && ((u = ts), (h = o), (d = s.length))
    : e === Jl
    ? c > 0 && ((u = Jl), (h = c), (d = l.length))
    : ((h = Math.max(o, c)),
      (u = h > 0 ? (o > c ? ts : Jl) : null),
      (d = u ? (u === ts ? s.length : l.length) : 0))
  const f = u === ts && /\b(transform|all)(,|$)/.test(r(`${ts}Property`).toString())
  return { type: u, timeout: h, propCount: d, hasTransform: f }
}
function Jb(t, e) {
  for (; t.length < e.length; ) t = t.concat(t)
  return Math.max(...e.map((n, r) => Qb(n) + Qb(t[r])))
}
function Qb(t) {
  return t === 'auto' ? 0 : Number(t.slice(0, -1).replace(',', '.')) * 1e3
}
function wD() {
  return document.body.offsetHeight
}
function SD(t, e, n) {
  const r = t[su]
  r && (e = (e ? [e, ...r] : [...r]).join(' ')),
    e == null ? t.removeAttribute('class') : n ? t.setAttribute('class', e) : (t.className = e)
}
const Qd = Symbol('_vod'),
  BA = Symbol('_vsh'),
  Ql = {
    beforeMount(t, { value: e }, { transition: n }) {
      ;(t[Qd] = t.style.display === 'none' ? '' : t.style.display),
        n && e ? n.beforeEnter(t) : Xl(t, e)
    },
    mounted(t, { value: e }, { transition: n }) {
      n && e && n.enter(t)
    },
    updated(t, { value: e, oldValue: n }, { transition: r }) {
      !e != !n &&
        (r
          ? e
            ? (r.beforeEnter(t), Xl(t, !0), r.enter(t))
            : r.leave(t, () => {
                Xl(t, !1)
              })
          : Xl(t, e))
    },
    beforeUnmount(t, { value: e }) {
      Xl(t, e)
    }
  }
function Xl(t, e) {
  ;(t.style.display = e ? t[Qd] : 'none'), (t[BA] = !e)
}
const ID = Symbol(''),
  AD = /(^|;)\s*display\s*:/
function CD(t, e, n) {
  const r = t.style,
    i = Pt(n)
  let s = !1
  if (n && !i) {
    if (e)
      if (Pt(e))
        for (const o of e.split(';')) {
          const a = o.slice(0, o.indexOf(':')).trim()
          n[a] == null && Td(r, a, '')
        }
      else for (const o in e) n[o] == null && Td(r, o, '')
    for (const o in n) o === 'display' && (s = !0), Td(r, o, n[o])
  } else if (i) {
    if (e !== n) {
      const o = r[ID]
      o && (n += ';' + o), (r.cssText = n), (s = AD.test(n))
    }
  } else e && t.removeAttribute('style')
  Qd in t && ((t[Qd] = s ? r.display : ''), t[BA] && (r.display = 'none'))
}
const Xb = /\s*!important$/
function Td(t, e, n) {
  if (ye(n)) n.forEach((r) => Td(t, e, r))
  else if ((n == null && (n = ''), e.startsWith('--'))) t.setProperty(e, n)
  else {
    const r = RD(t, e)
    Xb.test(n) ? t.setProperty(oa(r), n.replace(Xb, ''), 'important') : (t[r] = n)
  }
}
const Zb = ['Webkit', 'Moz', 'ms'],
  zm = {}
function RD(t, e) {
  const n = zm[e]
  if (n) return n
  let r = pi(e)
  if (r !== 'filter' && r in t) return (zm[e] = r)
  r = up(r)
  for (let i = 0; i < Zb.length; i++) {
    const s = Zb[i] + r
    if (s in t) return (zm[e] = s)
  }
  return e
}
const eE = 'http://www.w3.org/1999/xlink'
function kD(t, e, n, r, i) {
  if (r && e.startsWith('xlink:'))
    n == null ? t.removeAttributeNS(eE, e.slice(6, e.length)) : t.setAttributeNS(eE, e, n)
  else {
    const s = EP(e)
    n == null || (s && !UI(n)) ? t.removeAttribute(e) : t.setAttribute(e, s ? '' : n)
  }
}
function OD(t, e, n, r, i, s, o) {
  if (e === 'innerHTML' || e === 'textContent') {
    r && o(r, i, s), (t[e] = n ?? '')
    return
  }
  const a = t.tagName
  if (e === 'value' && a !== 'PROGRESS' && !a.includes('-')) {
    const c = a === 'OPTION' ? t.getAttribute('value') || '' : t.value,
      u = n ?? ''
    ;(c !== u || !('_value' in t)) && (t.value = u),
      n == null && t.removeAttribute(e),
      (t._value = n)
    return
  }
  let l = !1
  if (n === '' || n == null) {
    const c = typeof t[e]
    c === 'boolean'
      ? (n = UI(n))
      : n == null && c === 'string'
      ? ((n = ''), (l = !0))
      : c === 'number' && ((n = 0), (l = !0))
  }
  try {
    t[e] = n
  } catch {}
  l && t.removeAttribute(e)
}
function mo(t, e, n, r) {
  t.addEventListener(e, n, r)
}
function ND(t, e, n, r) {
  t.removeEventListener(e, n, r)
}
const tE = Symbol('_vei')
function MD(t, e, n, r, i = null) {
  const s = t[tE] || (t[tE] = {}),
    o = s[e]
  if (r && o) o.value = r
  else {
    const [a, l] = PD(e)
    if (r) {
      const c = (s[e] = LD(r, i))
      mo(t, a, c, l)
    } else o && (ND(t, a, o, l), (s[e] = void 0))
  }
}
const nE = /(?:Once|Passive|Capture)$/
function PD(t) {
  let e
  if (nE.test(t)) {
    e = {}
    let r
    for (; (r = t.match(nE)); )
      (t = t.slice(0, t.length - r[0].length)), (e[r[0].toLowerCase()] = !0)
  }
  return [t[2] === ':' ? t.slice(3) : oa(t.slice(2)), e]
}
let jm = 0
const xD = Promise.resolve(),
  DD = () => jm || (xD.then(() => (jm = 0)), (jm = Date.now()))
function LD(t, e) {
  const n = (r) => {
    if (!r._vts) r._vts = Date.now()
    else if (r._vts <= n.attached) return
    Sr(VD(r, n.value), e, 5, [r])
  }
  return (n.value = t), (n.attached = DD()), n
}
function VD(t, e) {
  if (ye(e)) {
    const n = t.stopImmediatePropagation
    return (
      (t.stopImmediatePropagation = () => {
        n.call(t), (t._stopped = !0)
      }),
      e.map((r) => (i) => !i._stopped && r && r(i))
    )
  } else return e
}
const rE = (t) =>
    t.charCodeAt(0) === 111 &&
    t.charCodeAt(1) === 110 &&
    t.charCodeAt(2) > 96 &&
    t.charCodeAt(2) < 123,
  FD = (t, e, n, r, i, s, o, a, l) => {
    const c = i === 'svg'
    e === 'class'
      ? SD(t, r, c)
      : e === 'style'
      ? CD(t, n, r)
      : ap(e)
      ? _v(e) || MD(t, e, n, r, o)
      : (
          e[0] === '.'
            ? ((e = e.slice(1)), !0)
            : e[0] === '^'
            ? ((e = e.slice(1)), !1)
            : BD(t, e, r, c)
        )
      ? OD(t, e, r, s, o, a, l)
      : (e === 'true-value' ? (t._trueValue = r) : e === 'false-value' && (t._falseValue = r),
        kD(t, e, r, c))
  }
function BD(t, e, n, r) {
  if (r) return !!(e === 'innerHTML' || e === 'textContent' || (e in t && rE(e) && Ae(n)))
  if (
    e === 'spellcheck' ||
    e === 'draggable' ||
    e === 'translate' ||
    e === 'form' ||
    (e === 'list' && t.tagName === 'INPUT') ||
    (e === 'type' && t.tagName === 'TEXTAREA')
  )
    return !1
  if (e === 'width' || e === 'height') {
    const i = t.tagName
    if (i === 'IMG' || i === 'VIDEO' || i === 'CANVAS' || i === 'SOURCE') return !1
  }
  return rE(e) && Pt(n) ? !1 : e in t
}
const Xd = (t) => {
  const e = t.props['onUpdate:modelValue'] || !1
  return ye(e) ? (n) => _d(e, n) : e
}
function UD(t) {
  t.target.composing = !0
}
function iE(t) {
  const e = t.target
  e.composing && ((e.composing = !1), e.dispatchEvent(new Event('input')))
}
const ja = Symbol('_assign'),
  ki = {
    created(t, { modifiers: { lazy: e, trim: n, number: r } }, i) {
      t[ja] = Xd(i)
      const s = r || (i.props && i.props.type === 'number')
      mo(t, e ? 'change' : 'input', (o) => {
        if (o.target.composing) return
        let a = t.value
        n && (a = a.trim()), s && (a = hy(a)), t[ja](a)
      }),
        n &&
          mo(t, 'change', () => {
            t.value = t.value.trim()
          }),
        e || (mo(t, 'compositionstart', UD), mo(t, 'compositionend', iE), mo(t, 'change', iE))
    },
    mounted(t, { value: e }) {
      t.value = e ?? ''
    },
    beforeUpdate(t, { value: e, modifiers: { lazy: n, trim: r, number: i } }, s) {
      if (((t[ja] = Xd(s)), t.composing)) return
      const o = i || t.type === 'number' ? hy(t.value) : t.value,
        a = e ?? ''
      o !== a &&
        ((document.activeElement === t &&
          t.type !== 'range' &&
          (n || (r && t.value.trim() === a))) ||
          (t.value = a))
    }
  },
  sE = {
    deep: !0,
    created(t, e, n) {
      ;(t[ja] = Xd(n)),
        mo(t, 'change', () => {
          const r = t._modelValue,
            i = $D(t),
            s = t.checked,
            o = t[ja]
          if (ye(r)) {
            const a = $I(r, i),
              l = a !== -1
            if (s && !l) o(r.concat(i))
            else if (!s && l) {
              const c = [...r]
              c.splice(a, 1), o(c)
            }
          } else if (lp(r)) {
            const a = new Set(r)
            s ? a.add(i) : a.delete(i), o(a)
          } else o(UA(t, s))
        })
    },
    mounted: oE,
    beforeUpdate(t, e, n) {
      ;(t[ja] = Xd(n)), oE(t, e, n)
    }
  }
function oE(t, { value: e, oldValue: n }, r) {
  ;(t._modelValue = e),
    ye(e)
      ? (t.checked = $I(e, r.props.value) > -1)
      : lp(e)
      ? (t.checked = e.has(r.props.value))
      : e !== n && (t.checked = dp(e, UA(t, !0)))
}
function $D(t) {
  return '_value' in t ? t._value : t.value
}
function UA(t, e) {
  const n = e ? '_trueValue' : '_falseValue'
  return n in t ? t[n] : e
}
const HD = ['ctrl', 'shift', 'alt', 'meta'],
  zD = {
    stop: (t) => t.stopPropagation(),
    prevent: (t) => t.preventDefault(),
    self: (t) => t.target !== t.currentTarget,
    ctrl: (t) => !t.ctrlKey,
    shift: (t) => !t.shiftKey,
    alt: (t) => !t.altKey,
    meta: (t) => !t.metaKey,
    left: (t) => 'button' in t && t.button !== 0,
    middle: (t) => 'button' in t && t.button !== 1,
    right: (t) => 'button' in t && t.button !== 2,
    exact: (t, e) => HD.some((n) => t[`${n}Key`] && !e.includes(n))
  },
  ht = (t, e) => {
    const n = t._withMods || (t._withMods = {}),
      r = e.join('.')
    return (
      n[r] ||
      (n[r] = (i, ...s) => {
        for (let o = 0; o < e.length; o++) {
          const a = zD[e[o]]
          if (a && a(i, e)) return
        }
        return t(i, ...s)
      })
    )
  },
  jD = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
  },
  Kr = (t, e) => {
    const n = t._withKeys || (t._withKeys = {}),
      r = e.join('.')
    return (
      n[r] ||
      (n[r] = (i) => {
        if (!('key' in i)) return
        const s = oa(i.key)
        if (e.some((o) => o === s || jD[o] === s)) return t(i)
      })
    )
  },
  WD = Gt({ patchProp: FD }, _D)
let aE
function GD() {
  return aE || (aE = Kx(WD))
}
const qD = (...t) => {
  const e = GD().createApp(...t),
    { mount: n } = e
  return (
    (e.mount = (r) => {
      const i = YD(r)
      if (!i) return
      const s = e._component
      !Ae(s) && !s.render && !s.template && (s.template = i.innerHTML), (i.innerHTML = '')
      const o = n(i, !1, KD(i))
      return (
        i instanceof Element && (i.removeAttribute('v-cloak'), i.setAttribute('data-v-app', '')), o
      )
    }),
    e
  )
}
function KD(t) {
  if (t instanceof SVGElement) return 'svg'
  if (typeof MathMLElement == 'function' && t instanceof MathMLElement) return 'mathml'
}
function YD(t) {
  return Pt(t) ? document.querySelector(t) : t
}
var JD = !1
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */ const QD = Symbol()
var lE
;(function (t) {
  ;(t.direct = 'direct'), (t.patchObject = 'patch object'), (t.patchFunction = 'patch function')
})(lE || (lE = {}))
function XD() {
  const t = jI(!0),
    e = t.run(() => Ue({}))
  let n = [],
    r = []
  const i = pp({
    install(s) {
      ;(i._a = s),
        s.provide(QD, i),
        (s.config.globalProperties.$pinia = i),
        r.forEach((o) => n.push(o)),
        (r = [])
    },
    use(s) {
      return !this._a && !JD ? r.push(s) : n.push(s), this
    },
    _p: n,
    _a: null,
    _e: t,
    _s: new Map(),
    state: e
  })
  return i
}
var cE = {}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const $A = { NODE_CLIENT: !1, NODE_ADMIN: !1, SDK_VERSION: '${JSCORE_VERSION}' }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const te = function (t, e) {
    if (!t) throw xl(e)
  },
  xl = function (t) {
    return new Error('Firebase Database (' + $A.SDK_VERSION + ') INTERNAL ASSERT FAILED: ' + t)
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const HA = function (t) {
    const e = []
    let n = 0
    for (let r = 0; r < t.length; r++) {
      let i = t.charCodeAt(r)
      i < 128
        ? (e[n++] = i)
        : i < 2048
        ? ((e[n++] = (i >> 6) | 192), (e[n++] = (i & 63) | 128))
        : (i & 64512) === 55296 && r + 1 < t.length && (t.charCodeAt(r + 1) & 64512) === 56320
        ? ((i = 65536 + ((i & 1023) << 10) + (t.charCodeAt(++r) & 1023)),
          (e[n++] = (i >> 18) | 240),
          (e[n++] = ((i >> 12) & 63) | 128),
          (e[n++] = ((i >> 6) & 63) | 128),
          (e[n++] = (i & 63) | 128))
        : ((e[n++] = (i >> 12) | 224), (e[n++] = ((i >> 6) & 63) | 128), (e[n++] = (i & 63) | 128))
    }
    return e
  },
  ZD = function (t) {
    const e = []
    let n = 0,
      r = 0
    for (; n < t.length; ) {
      const i = t[n++]
      if (i < 128) e[r++] = String.fromCharCode(i)
      else if (i > 191 && i < 224) {
        const s = t[n++]
        e[r++] = String.fromCharCode(((i & 31) << 6) | (s & 63))
      } else if (i > 239 && i < 365) {
        const s = t[n++],
          o = t[n++],
          a = t[n++],
          l = (((i & 7) << 18) | ((s & 63) << 12) | ((o & 63) << 6) | (a & 63)) - 65536
        ;(e[r++] = String.fromCharCode(55296 + (l >> 10))),
          (e[r++] = String.fromCharCode(56320 + (l & 1023)))
      } else {
        const s = t[n++],
          o = t[n++]
        e[r++] = String.fromCharCode(((i & 15) << 12) | ((s & 63) << 6) | (o & 63))
      }
    }
    return e.join('')
  },
  Ip = {
    byteToCharMap_: null,
    charToByteMap_: null,
    byteToCharMapWebSafe_: null,
    charToByteMapWebSafe_: null,
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
    get ENCODED_VALS() {
      return this.ENCODED_VALS_BASE + '+/='
    },
    get ENCODED_VALS_WEBSAFE() {
      return this.ENCODED_VALS_BASE + '-_.'
    },
    HAS_NATIVE_SUPPORT: typeof atob == 'function',
    encodeByteArray(t, e) {
      if (!Array.isArray(t)) throw Error('encodeByteArray takes an array as a parameter')
      this.init_()
      const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
        r = []
      for (let i = 0; i < t.length; i += 3) {
        const s = t[i],
          o = i + 1 < t.length,
          a = o ? t[i + 1] : 0,
          l = i + 2 < t.length,
          c = l ? t[i + 2] : 0,
          u = s >> 2,
          h = ((s & 3) << 4) | (a >> 4)
        let d = ((a & 15) << 2) | (c >> 6),
          f = c & 63
        l || ((f = 64), o || (d = 64)), r.push(n[u], n[h], n[d], n[f])
      }
      return r.join('')
    },
    encodeString(t, e) {
      return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(HA(t), e)
    },
    decodeString(t, e) {
      return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : ZD(this.decodeStringToByteArray(t, e))
    },
    decodeStringToByteArray(t, e) {
      this.init_()
      const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_,
        r = []
      for (let i = 0; i < t.length; ) {
        const s = n[t.charAt(i++)],
          a = i < t.length ? n[t.charAt(i)] : 0
        ++i
        const c = i < t.length ? n[t.charAt(i)] : 64
        ++i
        const h = i < t.length ? n[t.charAt(i)] : 64
        if ((++i, s == null || a == null || c == null || h == null)) throw new e4()
        const d = (s << 2) | (a >> 4)
        if ((r.push(d), c !== 64)) {
          const f = ((a << 4) & 240) | (c >> 2)
          if ((r.push(f), h !== 64)) {
            const p = ((c << 6) & 192) | h
            r.push(p)
          }
        }
      }
      return r
    },
    init_() {
      if (!this.byteToCharMap_) {
        ;(this.byteToCharMap_ = {}),
          (this.charToByteMap_ = {}),
          (this.byteToCharMapWebSafe_ = {}),
          (this.charToByteMapWebSafe_ = {})
        for (let t = 0; t < this.ENCODED_VALS.length; t++)
          (this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t)),
            (this.charToByteMap_[this.byteToCharMap_[t]] = t),
            (this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t)),
            (this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t),
            t >= this.ENCODED_VALS_BASE.length &&
              ((this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t),
              (this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t))
      }
    }
  }
class e4 extends Error {
  constructor() {
    super(...arguments), (this.name = 'DecodeBase64StringError')
  }
}
const zA = function (t) {
    const e = HA(t)
    return Ip.encodeByteArray(e, !0)
  },
  Zd = function (t) {
    return zA(t).replace(/\./g, '')
  },
  ef = function (t) {
    try {
      return Ip.decodeString(t, !0)
    } catch (e) {
      console.error('base64Decode failed: ', e)
    }
    return null
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function t4(t) {
  return jA(void 0, t)
}
function jA(t, e) {
  if (!(e instanceof Object)) return e
  switch (e.constructor) {
    case Date:
      const n = e
      return new Date(n.getTime())
    case Object:
      t === void 0 && (t = {})
      break
    case Array:
      t = []
      break
    default:
      return e
  }
  for (const n in e) !e.hasOwnProperty(n) || !n4(n) || (t[n] = jA(t[n], e[n]))
  return t
}
function n4(t) {
  return t !== '__proto__'
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function r4() {
  if (typeof self < 'u') return self
  if (typeof window < 'u') return window
  if (typeof global < 'u') return global
  throw new Error('Unable to locate global object.')
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const i4 = () => r4().__FIREBASE_DEFAULTS__,
  s4 = () => {
    if (typeof process > 'u' || typeof cE > 'u') return
    const t = cE.__FIREBASE_DEFAULTS__
    if (t) return JSON.parse(t)
  },
  o4 = () => {
    if (typeof document > 'u') return
    let t
    try {
      t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
    } catch {
      return
    }
    const e = t && ef(t[1])
    return e && JSON.parse(e)
  },
  Ap = () => {
    try {
      return i4() || s4() || o4()
    } catch (t) {
      console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`)
      return
    }
  },
  a4 = (t) => {
    var e, n
    return (n = (e = Ap()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null ||
      n === void 0
      ? void 0
      : n[t]
  },
  l4 = (t) => {
    const e = a4(t)
    if (!e) return
    const n = e.lastIndexOf(':')
    if (n <= 0 || n + 1 === e.length)
      throw new Error(`Invalid host ${e} with no separate hostname and port!`)
    const r = parseInt(e.substring(n + 1), 10)
    return e[0] === '[' ? [e.substring(1, n - 1), r] : [e.substring(0, n), r]
  },
  WA = () => {
    var t
    return (t = Ap()) === null || t === void 0 ? void 0 : t.config
  },
  c4 = (t) => {
    var e
    return (e = Ap()) === null || e === void 0 ? void 0 : e[`_${t}`]
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ou {
  constructor() {
    ;(this.reject = () => {}),
      (this.resolve = () => {}),
      (this.promise = new Promise((e, n) => {
        ;(this.resolve = e), (this.reject = n)
      }))
  }
  wrapCallback(e) {
    return (n, r) => {
      n ? this.reject(n) : this.resolve(r),
        typeof e == 'function' && (this.promise.catch(() => {}), e.length === 1 ? e(n) : e(n, r))
    }
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function u4(t, e) {
  if (t.uid)
    throw new Error(
      'The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'
    )
  const n = { alg: 'none', type: 'JWT' },
    r = e || 'demo-project',
    i = t.iat || 0,
    s = t.sub || t.user_id
  if (!s) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!")
  const o = Object.assign(
    {
      iss: `https://securetoken.google.com/${r}`,
      aud: r,
      iat: i,
      exp: i + 3600,
      auth_time: i,
      sub: s,
      user_id: s,
      firebase: { sign_in_provider: 'custom', identities: {} }
    },
    t
  )
  return [Zd(JSON.stringify(n)), Zd(JSON.stringify(o)), ''].join('.')
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Ht() {
  return typeof navigator < 'u' && typeof navigator.userAgent == 'string' ? navigator.userAgent : ''
}
function $v() {
  return (
    typeof window < 'u' &&
    !!(window.cordova || window.phonegap || window.PhoneGap) &&
    /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Ht())
  )
}
function h4() {
  var t
  const e = (t = Ap()) === null || t === void 0 ? void 0 : t.forceEnvironment
  if (e === 'node') return !0
  if (e === 'browser') return !1
  try {
    return Object.prototype.toString.call(global.process) === '[object process]'
  } catch {
    return !1
  }
}
function d4() {
  const t =
    typeof chrome == 'object'
      ? chrome.runtime
      : typeof browser == 'object'
      ? browser.runtime
      : void 0
  return typeof t == 'object' && t.id !== void 0
}
function GA() {
  return typeof navigator == 'object' && navigator.product === 'ReactNative'
}
function f4() {
  const t = Ht()
  return t.indexOf('MSIE ') >= 0 || t.indexOf('Trident/') >= 0
}
function qA() {
  return $A.NODE_ADMIN === !0
}
function p4() {
  return (
    !h4() &&
    !!navigator.userAgent &&
    navigator.userAgent.includes('Safari') &&
    !navigator.userAgent.includes('Chrome')
  )
}
function Hv() {
  try {
    return typeof indexedDB == 'object'
  } catch {
    return !1
  }
}
function m4() {
  return new Promise((t, e) => {
    try {
      let n = !0
      const r = 'validate-browser-context-for-indexeddb-analytics-module',
        i = self.indexedDB.open(r)
      ;(i.onsuccess = () => {
        i.result.close(), n || self.indexedDB.deleteDatabase(r), t(!0)
      }),
        (i.onupgradeneeded = () => {
          n = !1
        }),
        (i.onerror = () => {
          var s
          e(((s = i.error) === null || s === void 0 ? void 0 : s.message) || '')
        })
    } catch (n) {
      e(n)
    }
  })
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const g4 = 'FirebaseError'
class Ii extends Error {
  constructor(e, n, r) {
    super(n),
      (this.code = e),
      (this.customData = r),
      (this.name = g4),
      Object.setPrototypeOf(this, Ii.prototype),
      Error.captureStackTrace && Error.captureStackTrace(this, Dl.prototype.create)
  }
}
class Dl {
  constructor(e, n, r) {
    ;(this.service = e), (this.serviceName = n), (this.errors = r)
  }
  create(e, ...n) {
    const r = n[0] || {},
      i = `${this.service}/${e}`,
      s = this.errors[e],
      o = s ? y4(s, r) : 'Error',
      a = `${this.serviceName}: ${o} (${i}).`
    return new Ii(i, a, r)
  }
}
function y4(t, e) {
  return t.replace(_4, (n, r) => {
    const i = e[r]
    return i != null ? String(i) : `<${r}?>`
  })
}
const _4 = /\{\$([^}]+)}/g
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function au(t) {
  return JSON.parse(t)
}
function _n(t) {
  return JSON.stringify(t)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const KA = function (t) {
    let e = {},
      n = {},
      r = {},
      i = ''
    try {
      const s = t.split('.')
      ;(e = au(ef(s[0]) || '')), (n = au(ef(s[1]) || '')), (i = s[2]), (r = n.d || {}), delete n.d
    } catch {}
    return { header: e, claims: n, data: r, signature: i }
  },
  v4 = function (t) {
    const e = KA(t),
      n = e.claims
    return !!n && typeof n == 'object' && n.hasOwnProperty('iat')
  },
  b4 = function (t) {
    const e = KA(t).claims
    return typeof e == 'object' && e.admin === !0
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Qi(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e)
}
function al(t, e) {
  if (Object.prototype.hasOwnProperty.call(t, e)) return t[e]
}
function ky(t) {
  for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1
  return !0
}
function tf(t, e, n) {
  const r = {}
  for (const i in t) Object.prototype.hasOwnProperty.call(t, i) && (r[i] = e.call(n, t[i], i, t))
  return r
}
function lu(t, e) {
  if (t === e) return !0
  const n = Object.keys(t),
    r = Object.keys(e)
  for (const i of n) {
    if (!r.includes(i)) return !1
    const s = t[i],
      o = e[i]
    if (uE(s) && uE(o)) {
      if (!lu(s, o)) return !1
    } else if (s !== o) return !1
  }
  for (const i of r) if (!n.includes(i)) return !1
  return !0
}
function uE(t) {
  return t !== null && typeof t == 'object'
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Ll(t) {
  const e = []
  for (const [n, r] of Object.entries(t))
    Array.isArray(r)
      ? r.forEach((i) => {
          e.push(encodeURIComponent(n) + '=' + encodeURIComponent(i))
        })
      : e.push(encodeURIComponent(n) + '=' + encodeURIComponent(r))
  return e.length ? '&' + e.join('&') : ''
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class E4 {
  constructor() {
    ;(this.chain_ = []),
      (this.buf_ = []),
      (this.W_ = []),
      (this.pad_ = []),
      (this.inbuf_ = 0),
      (this.total_ = 0),
      (this.blockSize = 512 / 8),
      (this.pad_[0] = 128)
    for (let e = 1; e < this.blockSize; ++e) this.pad_[e] = 0
    this.reset()
  }
  reset() {
    ;(this.chain_[0] = 1732584193),
      (this.chain_[1] = 4023233417),
      (this.chain_[2] = 2562383102),
      (this.chain_[3] = 271733878),
      (this.chain_[4] = 3285377520),
      (this.inbuf_ = 0),
      (this.total_ = 0)
  }
  compress_(e, n) {
    n || (n = 0)
    const r = this.W_
    if (typeof e == 'string')
      for (let h = 0; h < 16; h++)
        (r[h] =
          (e.charCodeAt(n) << 24) |
          (e.charCodeAt(n + 1) << 16) |
          (e.charCodeAt(n + 2) << 8) |
          e.charCodeAt(n + 3)),
          (n += 4)
    else
      for (let h = 0; h < 16; h++)
        (r[h] = (e[n] << 24) | (e[n + 1] << 16) | (e[n + 2] << 8) | e[n + 3]), (n += 4)
    for (let h = 16; h < 80; h++) {
      const d = r[h - 3] ^ r[h - 8] ^ r[h - 14] ^ r[h - 16]
      r[h] = ((d << 1) | (d >>> 31)) & 4294967295
    }
    let i = this.chain_[0],
      s = this.chain_[1],
      o = this.chain_[2],
      a = this.chain_[3],
      l = this.chain_[4],
      c,
      u
    for (let h = 0; h < 80; h++) {
      h < 40
        ? h < 20
          ? ((c = a ^ (s & (o ^ a))), (u = 1518500249))
          : ((c = s ^ o ^ a), (u = 1859775393))
        : h < 60
        ? ((c = (s & o) | (a & (s | o))), (u = 2400959708))
        : ((c = s ^ o ^ a), (u = 3395469782))
      const d = (((i << 5) | (i >>> 27)) + c + l + u + r[h]) & 4294967295
      ;(l = a), (a = o), (o = ((s << 30) | (s >>> 2)) & 4294967295), (s = i), (i = d)
    }
    ;(this.chain_[0] = (this.chain_[0] + i) & 4294967295),
      (this.chain_[1] = (this.chain_[1] + s) & 4294967295),
      (this.chain_[2] = (this.chain_[2] + o) & 4294967295),
      (this.chain_[3] = (this.chain_[3] + a) & 4294967295),
      (this.chain_[4] = (this.chain_[4] + l) & 4294967295)
  }
  update(e, n) {
    if (e == null) return
    n === void 0 && (n = e.length)
    const r = n - this.blockSize
    let i = 0
    const s = this.buf_
    let o = this.inbuf_
    for (; i < n; ) {
      if (o === 0) for (; i <= r; ) this.compress_(e, i), (i += this.blockSize)
      if (typeof e == 'string') {
        for (; i < n; )
          if (((s[o] = e.charCodeAt(i)), ++o, ++i, o === this.blockSize)) {
            this.compress_(s), (o = 0)
            break
          }
      } else
        for (; i < n; )
          if (((s[o] = e[i]), ++o, ++i, o === this.blockSize)) {
            this.compress_(s), (o = 0)
            break
          }
    }
    ;(this.inbuf_ = o), (this.total_ += n)
  }
  digest() {
    const e = []
    let n = this.total_ * 8
    this.inbuf_ < 56
      ? this.update(this.pad_, 56 - this.inbuf_)
      : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56))
    for (let i = this.blockSize - 1; i >= 56; i--) (this.buf_[i] = n & 255), (n /= 256)
    this.compress_(this.buf_)
    let r = 0
    for (let i = 0; i < 5; i++)
      for (let s = 24; s >= 0; s -= 8) (e[r] = (this.chain_[i] >> s) & 255), ++r
    return e
  }
}
function T4(t, e) {
  const n = new w4(t, e)
  return n.subscribe.bind(n)
}
class w4 {
  constructor(e, n) {
    ;(this.observers = []),
      (this.unsubscribes = []),
      (this.observerCount = 0),
      (this.task = Promise.resolve()),
      (this.finalized = !1),
      (this.onNoObservers = n),
      this.task
        .then(() => {
          e(this)
        })
        .catch((r) => {
          this.error(r)
        })
  }
  next(e) {
    this.forEachObserver((n) => {
      n.next(e)
    })
  }
  error(e) {
    this.forEachObserver((n) => {
      n.error(e)
    }),
      this.close(e)
  }
  complete() {
    this.forEachObserver((e) => {
      e.complete()
    }),
      this.close()
  }
  subscribe(e, n, r) {
    let i
    if (e === void 0 && n === void 0 && r === void 0) throw new Error('Missing Observer.')
    S4(e, ['next', 'error', 'complete']) ? (i = e) : (i = { next: e, error: n, complete: r }),
      i.next === void 0 && (i.next = Wm),
      i.error === void 0 && (i.error = Wm),
      i.complete === void 0 && (i.complete = Wm)
    const s = this.unsubscribeOne.bind(this, this.observers.length)
    return (
      this.finalized &&
        this.task.then(() => {
          try {
            this.finalError ? i.error(this.finalError) : i.complete()
          } catch {}
        }),
      this.observers.push(i),
      s
    )
  }
  unsubscribeOne(e) {
    this.observers === void 0 ||
      this.observers[e] === void 0 ||
      (delete this.observers[e],
      (this.observerCount -= 1),
      this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this))
  }
  forEachObserver(e) {
    if (!this.finalized) for (let n = 0; n < this.observers.length; n++) this.sendOne(n, e)
  }
  sendOne(e, n) {
    this.task.then(() => {
      if (this.observers !== void 0 && this.observers[e] !== void 0)
        try {
          n(this.observers[e])
        } catch (r) {
          typeof console < 'u' && console.error && console.error(r)
        }
    })
  }
  close(e) {
    this.finalized ||
      ((this.finalized = !0),
      e !== void 0 && (this.finalError = e),
      this.task.then(() => {
        ;(this.observers = void 0), (this.onNoObservers = void 0)
      }))
  }
}
function S4(t, e) {
  if (typeof t != 'object' || t === null) return !1
  for (const n of e) if (n in t && typeof t[n] == 'function') return !0
  return !1
}
function Wm() {}
function I4(t, e) {
  return `${t} failed: ${e} argument `
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const A4 = function (t) {
    const e = []
    let n = 0
    for (let r = 0; r < t.length; r++) {
      let i = t.charCodeAt(r)
      if (i >= 55296 && i <= 56319) {
        const s = i - 55296
        r++, te(r < t.length, 'Surrogate pair missing trail surrogate.')
        const o = t.charCodeAt(r) - 56320
        i = 65536 + (s << 10) + o
      }
      i < 128
        ? (e[n++] = i)
        : i < 2048
        ? ((e[n++] = (i >> 6) | 192), (e[n++] = (i & 63) | 128))
        : i < 65536
        ? ((e[n++] = (i >> 12) | 224), (e[n++] = ((i >> 6) & 63) | 128), (e[n++] = (i & 63) | 128))
        : ((e[n++] = (i >> 18) | 240),
          (e[n++] = ((i >> 12) & 63) | 128),
          (e[n++] = ((i >> 6) & 63) | 128),
          (e[n++] = (i & 63) | 128))
    }
    return e
  },
  Cp = function (t) {
    let e = 0
    for (let n = 0; n < t.length; n++) {
      const r = t.charCodeAt(n)
      r < 128 ? e++ : r < 2048 ? (e += 2) : r >= 55296 && r <= 56319 ? ((e += 4), n++) : (e += 3)
    }
    return e
  }
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function sn(t) {
  return t && t._delegate ? t._delegate : t
}
class Ur {
  constructor(e, n, r) {
    ;(this.name = e),
      (this.instanceFactory = n),
      (this.type = r),
      (this.multipleInstances = !1),
      (this.serviceProps = {}),
      (this.instantiationMode = 'LAZY'),
      (this.onInstanceCreated = null)
  }
  setInstantiationMode(e) {
    return (this.instantiationMode = e), this
  }
  setMultipleInstances(e) {
    return (this.multipleInstances = e), this
  }
  setServiceProps(e) {
    return (this.serviceProps = e), this
  }
  setInstanceCreatedCallback(e) {
    return (this.onInstanceCreated = e), this
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const uo = '[DEFAULT]'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class C4 {
  constructor(e, n) {
    ;(this.name = e),
      (this.container = n),
      (this.component = null),
      (this.instances = new Map()),
      (this.instancesDeferred = new Map()),
      (this.instancesOptions = new Map()),
      (this.onInitCallbacks = new Map())
  }
  get(e) {
    const n = this.normalizeInstanceIdentifier(e)
    if (!this.instancesDeferred.has(n)) {
      const r = new ou()
      if ((this.instancesDeferred.set(n, r), this.isInitialized(n) || this.shouldAutoInitialize()))
        try {
          const i = this.getOrInitializeService({ instanceIdentifier: n })
          i && r.resolve(i)
        } catch {}
    }
    return this.instancesDeferred.get(n).promise
  }
  getImmediate(e) {
    var n
    const r = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier),
      i = (n = e == null ? void 0 : e.optional) !== null && n !== void 0 ? n : !1
    if (this.isInitialized(r) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({ instanceIdentifier: r })
      } catch (s) {
        if (i) return null
        throw s
      }
    else {
      if (i) return null
      throw Error(`Service ${this.name} is not available`)
    }
  }
  getComponent() {
    return this.component
  }
  setComponent(e) {
    if (e.name !== this.name)
      throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`)
    if (this.component) throw Error(`Component for ${this.name} has already been provided`)
    if (((this.component = e), !!this.shouldAutoInitialize())) {
      if (k4(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: uo })
        } catch {}
      for (const [n, r] of this.instancesDeferred.entries()) {
        const i = this.normalizeInstanceIdentifier(n)
        try {
          const s = this.getOrInitializeService({ instanceIdentifier: i })
          r.resolve(s)
        } catch {}
      }
    }
  }
  clearInstance(e = uo) {
    this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e)
  }
  async delete() {
    const e = Array.from(this.instances.values())
    await Promise.all([
      ...e.filter((n) => 'INTERNAL' in n).map((n) => n.INTERNAL.delete()),
      ...e.filter((n) => '_delete' in n).map((n) => n._delete())
    ])
  }
  isComponentSet() {
    return this.component != null
  }
  isInitialized(e = uo) {
    return this.instances.has(e)
  }
  getOptions(e = uo) {
    return this.instancesOptions.get(e) || {}
  }
  initialize(e = {}) {
    const { options: n = {} } = e,
      r = this.normalizeInstanceIdentifier(e.instanceIdentifier)
    if (this.isInitialized(r)) throw Error(`${this.name}(${r}) has already been initialized`)
    if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`)
    const i = this.getOrInitializeService({ instanceIdentifier: r, options: n })
    for (const [s, o] of this.instancesDeferred.entries()) {
      const a = this.normalizeInstanceIdentifier(s)
      r === a && o.resolve(i)
    }
    return i
  }
  onInit(e, n) {
    var r
    const i = this.normalizeInstanceIdentifier(n),
      s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : new Set()
    s.add(e), this.onInitCallbacks.set(i, s)
    const o = this.instances.get(i)
    return (
      o && e(o, i),
      () => {
        s.delete(e)
      }
    )
  }
  invokeOnInitCallbacks(e, n) {
    const r = this.onInitCallbacks.get(n)
    if (r)
      for (const i of r)
        try {
          i(e, n)
        } catch {}
  }
  getOrInitializeService({ instanceIdentifier: e, options: n = {} }) {
    let r = this.instances.get(e)
    if (
      !r &&
      this.component &&
      ((r = this.component.instanceFactory(this.container, {
        instanceIdentifier: R4(e),
        options: n
      })),
      this.instances.set(e, r),
      this.instancesOptions.set(e, n),
      this.invokeOnInitCallbacks(r, e),
      this.component.onInstanceCreated)
    )
      try {
        this.component.onInstanceCreated(this.container, e, r)
      } catch {}
    return r || null
  }
  normalizeInstanceIdentifier(e = uo) {
    return this.component ? (this.component.multipleInstances ? e : uo) : e
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== 'EXPLICIT'
  }
}
function R4(t) {
  return t === uo ? void 0 : t
}
function k4(t) {
  return t.instantiationMode === 'EAGER'
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class O4 {
  constructor(e) {
    ;(this.name = e), (this.providers = new Map())
  }
  addComponent(e) {
    const n = this.getProvider(e.name)
    if (n.isComponentSet())
      throw new Error(`Component ${e.name} has already been registered with ${this.name}`)
    n.setComponent(e)
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e)
  }
  getProvider(e) {
    if (this.providers.has(e)) return this.providers.get(e)
    const n = new C4(e, this)
    return this.providers.set(e, n), n
  }
  getProviders() {
    return Array.from(this.providers.values())
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var He
;(function (t) {
  ;(t[(t.DEBUG = 0)] = 'DEBUG'),
    (t[(t.VERBOSE = 1)] = 'VERBOSE'),
    (t[(t.INFO = 2)] = 'INFO'),
    (t[(t.WARN = 3)] = 'WARN'),
    (t[(t.ERROR = 4)] = 'ERROR'),
    (t[(t.SILENT = 5)] = 'SILENT')
})(He || (He = {}))
const N4 = {
    debug: He.DEBUG,
    verbose: He.VERBOSE,
    info: He.INFO,
    warn: He.WARN,
    error: He.ERROR,
    silent: He.SILENT
  },
  M4 = He.INFO,
  P4 = {
    [He.DEBUG]: 'log',
    [He.VERBOSE]: 'log',
    [He.INFO]: 'info',
    [He.WARN]: 'warn',
    [He.ERROR]: 'error'
  },
  x4 = (t, e, ...n) => {
    if (e < t.logLevel) return
    const r = new Date().toISOString(),
      i = P4[e]
    if (i) console[i](`[${r}]  ${t.name}:`, ...n)
    else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`)
  }
class Ku {
  constructor(e) {
    ;(this.name = e), (this._logLevel = M4), (this._logHandler = x4), (this._userLogHandler = null)
  }
  get logLevel() {
    return this._logLevel
  }
  set logLevel(e) {
    if (!(e in He)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``)
    this._logLevel = e
  }
  setLogLevel(e) {
    this._logLevel = typeof e == 'string' ? N4[e] : e
  }
  get logHandler() {
    return this._logHandler
  }
  set logHandler(e) {
    if (typeof e != 'function')
      throw new TypeError('Value assigned to `logHandler` must be a function')
    this._logHandler = e
  }
  get userLogHandler() {
    return this._userLogHandler
  }
  set userLogHandler(e) {
    this._userLogHandler = e
  }
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, He.DEBUG, ...e),
      this._logHandler(this, He.DEBUG, ...e)
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, He.VERBOSE, ...e),
      this._logHandler(this, He.VERBOSE, ...e)
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, He.INFO, ...e),
      this._logHandler(this, He.INFO, ...e)
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, He.WARN, ...e),
      this._logHandler(this, He.WARN, ...e)
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, He.ERROR, ...e),
      this._logHandler(this, He.ERROR, ...e)
  }
}
const D4 = (t, e) => e.some((n) => t instanceof n)
let hE, dE
function L4() {
  return hE || (hE = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}
function V4() {
  return (
    dE ||
    (dE = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ])
  )
}
const YA = new WeakMap(),
  Oy = new WeakMap(),
  JA = new WeakMap(),
  Gm = new WeakMap(),
  zv = new WeakMap()
function F4(t) {
  const e = new Promise((n, r) => {
    const i = () => {
        t.removeEventListener('success', s), t.removeEventListener('error', o)
      },
      s = () => {
        n(ks(t.result)), i()
      },
      o = () => {
        r(t.error), i()
      }
    t.addEventListener('success', s), t.addEventListener('error', o)
  })
  return (
    e
      .then((n) => {
        n instanceof IDBCursor && YA.set(n, t)
      })
      .catch(() => {}),
    zv.set(e, t),
    e
  )
}
function B4(t) {
  if (Oy.has(t)) return
  const e = new Promise((n, r) => {
    const i = () => {
        t.removeEventListener('complete', s),
          t.removeEventListener('error', o),
          t.removeEventListener('abort', o)
      },
      s = () => {
        n(), i()
      },
      o = () => {
        r(t.error || new DOMException('AbortError', 'AbortError')), i()
      }
    t.addEventListener('complete', s),
      t.addEventListener('error', o),
      t.addEventListener('abort', o)
  })
  Oy.set(t, e)
}
let Ny = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === 'done') return Oy.get(t)
      if (e === 'objectStoreNames') return t.objectStoreNames || JA.get(t)
      if (e === 'store')
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
    }
    return ks(t[e])
  },
  set(t, e, n) {
    return (t[e] = n), !0
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === 'done' || e === 'store') ? !0 : e in t
  }
}
function U4(t) {
  Ny = t(Ny)
}
function $4(t) {
  return t === IDBDatabase.prototype.transaction &&
    !('objectStoreNames' in IDBTransaction.prototype)
    ? function (e, ...n) {
        const r = t.call(qm(this), e, ...n)
        return JA.set(r, e.sort ? e.sort() : [e]), ks(r)
      }
    : V4().includes(t)
    ? function (...e) {
        return t.apply(qm(this), e), ks(YA.get(this))
      }
    : function (...e) {
        return ks(t.apply(qm(this), e))
      }
}
function H4(t) {
  return typeof t == 'function'
    ? $4(t)
    : (t instanceof IDBTransaction && B4(t), D4(t, L4()) ? new Proxy(t, Ny) : t)
}
function ks(t) {
  if (t instanceof IDBRequest) return F4(t)
  if (Gm.has(t)) return Gm.get(t)
  const e = H4(t)
  return e !== t && (Gm.set(t, e), zv.set(e, t)), e
}
const qm = (t) => zv.get(t)
function z4(t, e, { blocked: n, upgrade: r, blocking: i, terminated: s } = {}) {
  const o = indexedDB.open(t, e),
    a = ks(o)
  return (
    r &&
      o.addEventListener('upgradeneeded', (l) => {
        r(ks(o.result), l.oldVersion, l.newVersion, ks(o.transaction), l)
      }),
    n && o.addEventListener('blocked', (l) => n(l.oldVersion, l.newVersion, l)),
    a
      .then((l) => {
        s && l.addEventListener('close', () => s()),
          i && l.addEventListener('versionchange', (c) => i(c.oldVersion, c.newVersion, c))
      })
      .catch(() => {}),
    a
  )
}
const j4 = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'],
  W4 = ['put', 'add', 'delete', 'clear'],
  Km = new Map()
function fE(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == 'string')) return
  if (Km.get(e)) return Km.get(e)
  const n = e.replace(/FromIndex$/, ''),
    r = e !== n,
    i = W4.includes(n)
  if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || j4.includes(n))) return
  const s = async function (o, ...a) {
    const l = this.transaction(o, i ? 'readwrite' : 'readonly')
    let c = l.store
    return r && (c = c.index(a.shift())), (await Promise.all([c[n](...a), i && l.done]))[0]
  }
  return Km.set(e, s), s
}
U4((t) => ({
  ...t,
  get: (e, n, r) => fE(e, n) || t.get(e, n, r),
  has: (e, n) => !!fE(e, n) || t.has(e, n)
}))
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class G4 {
  constructor(e) {
    this.container = e
  }
  getPlatformInfoString() {
    return this.container
      .getProviders()
      .map((n) => {
        if (q4(n)) {
          const r = n.getImmediate()
          return `${r.library}/${r.version}`
        } else return null
      })
      .filter((n) => n)
      .join(' ')
  }
}
function q4(t) {
  const e = t.getComponent()
  return (e == null ? void 0 : e.type) === 'VERSION'
}
const My = '@firebase/app',
  pE = '0.9.29'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Go = new Ku('@firebase/app'),
  K4 = '@firebase/app-compat',
  Y4 = '@firebase/analytics-compat',
  J4 = '@firebase/analytics',
  Q4 = '@firebase/app-check-compat',
  X4 = '@firebase/app-check',
  Z4 = '@firebase/auth',
  e3 = '@firebase/auth-compat',
  t3 = '@firebase/database',
  n3 = '@firebase/database-compat',
  r3 = '@firebase/functions',
  i3 = '@firebase/functions-compat',
  s3 = '@firebase/installations',
  o3 = '@firebase/installations-compat',
  a3 = '@firebase/messaging',
  l3 = '@firebase/messaging-compat',
  c3 = '@firebase/performance',
  u3 = '@firebase/performance-compat',
  h3 = '@firebase/remote-config',
  d3 = '@firebase/remote-config-compat',
  f3 = '@firebase/storage',
  p3 = '@firebase/storage-compat',
  m3 = '@firebase/firestore',
  g3 = '@firebase/firestore-compat',
  y3 = 'firebase',
  _3 = '10.9.0'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Py = '[DEFAULT]',
  v3 = {
    [My]: 'fire-core',
    [K4]: 'fire-core-compat',
    [J4]: 'fire-analytics',
    [Y4]: 'fire-analytics-compat',
    [X4]: 'fire-app-check',
    [Q4]: 'fire-app-check-compat',
    [Z4]: 'fire-auth',
    [e3]: 'fire-auth-compat',
    [t3]: 'fire-rtdb',
    [n3]: 'fire-rtdb-compat',
    [r3]: 'fire-fn',
    [i3]: 'fire-fn-compat',
    [s3]: 'fire-iid',
    [o3]: 'fire-iid-compat',
    [a3]: 'fire-fcm',
    [l3]: 'fire-fcm-compat',
    [c3]: 'fire-perf',
    [u3]: 'fire-perf-compat',
    [h3]: 'fire-rc',
    [d3]: 'fire-rc-compat',
    [f3]: 'fire-gcs',
    [p3]: 'fire-gcs-compat',
    [m3]: 'fire-fst',
    [g3]: 'fire-fst-compat',
    'fire-js': 'fire-js',
    [y3]: 'fire-js-all'
  }
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const nf = new Map(),
  xy = new Map()
function b3(t, e) {
  try {
    t.container.addComponent(e)
  } catch (n) {
    Go.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, n)
  }
}
function mi(t) {
  const e = t.name
  if (xy.has(e)) return Go.debug(`There were multiple attempts to register component ${e}.`), !1
  xy.set(e, t)
  for (const n of nf.values()) b3(n, t)
  return !0
}
function QA(t, e) {
  const n = t.container.getProvider('heartbeat').getImmediate({ optional: !0 })
  return n && n.triggerHeartbeat(), t.container.getProvider(e)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const E3 = {
    'no-app': "No Firebase App '{$appName}' has been created - call initializeApp() first",
    'bad-app-name': "Illegal App name: '{$appName}",
    'duplicate-app':
      "Firebase App named '{$appName}' already exists with different options or config",
    'app-deleted': "Firebase App named '{$appName}' already deleted",
    'no-options': 'Need to provide options, when not being deployed to hosting via source.',
    'invalid-app-argument':
      'firebase.{$appName}() takes either no argument or a Firebase App instance.',
    'invalid-log-argument': 'First argument to `onLog` must be null or a function.',
    'idb-open': 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',
    'idb-get': 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',
    'idb-set': 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',
    'idb-delete':
      'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.'
  },
  Os = new Dl('app', 'Firebase', E3)
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class T3 {
  constructor(e, n, r) {
    ;(this._isDeleted = !1),
      (this._options = Object.assign({}, e)),
      (this._config = Object.assign({}, n)),
      (this._name = n.name),
      (this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled),
      (this._container = r),
      this.container.addComponent(new Ur('app', () => this, 'PUBLIC'))
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), (this._automaticDataCollectionEnabled = e)
  }
  get name() {
    return this.checkDestroyed(), this._name
  }
  get options() {
    return this.checkDestroyed(), this._options
  }
  get config() {
    return this.checkDestroyed(), this._config
  }
  get container() {
    return this._container
  }
  get isDeleted() {
    return this._isDeleted
  }
  set isDeleted(e) {
    this._isDeleted = e
  }
  checkDestroyed() {
    if (this.isDeleted) throw Os.create('app-deleted', { appName: this._name })
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Ys = _3
function XA(t, e = {}) {
  let n = t
  typeof e != 'object' && (e = { name: e })
  const r = Object.assign({ name: Py, automaticDataCollectionEnabled: !1 }, e),
    i = r.name
  if (typeof i != 'string' || !i) throw Os.create('bad-app-name', { appName: String(i) })
  if ((n || (n = WA()), !n)) throw Os.create('no-options')
  const s = nf.get(i)
  if (s) {
    if (lu(n, s.options) && lu(r, s.config)) return s
    throw Os.create('duplicate-app', { appName: i })
  }
  const o = new O4(i)
  for (const l of xy.values()) o.addComponent(l)
  const a = new T3(n, r, o)
  return nf.set(i, a), a
}
function ZA(t = Py) {
  const e = nf.get(t)
  if (!e && t === Py && WA()) return XA()
  if (!e) throw Os.create('no-app', { appName: t })
  return e
}
function ar(t, e, n) {
  var r
  let i = (r = v3[t]) !== null && r !== void 0 ? r : t
  n && (i += `-${n}`)
  const s = i.match(/\s|\//),
    o = e.match(/\s|\//)
  if (s || o) {
    const a = [`Unable to register library "${i}" with version "${e}":`]
    s && a.push(`library name "${i}" contains illegal characters (whitespace or "/")`),
      s && o && a.push('and'),
      o && a.push(`version name "${e}" contains illegal characters (whitespace or "/")`),
      Go.warn(a.join(' '))
    return
  }
  mi(new Ur(`${i}-version`, () => ({ library: i, version: e }), 'VERSION'))
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const w3 = 'firebase-heartbeat-database',
  S3 = 1,
  cu = 'firebase-heartbeat-store'
let Ym = null
function eC() {
  return (
    Ym ||
      (Ym = z4(w3, S3, {
        upgrade: (t, e) => {
          switch (e) {
            case 0:
              try {
                t.createObjectStore(cu)
              } catch (n) {
                console.warn(n)
              }
          }
        }
      }).catch((t) => {
        throw Os.create('idb-open', { originalErrorMessage: t.message })
      })),
    Ym
  )
}
async function I3(t) {
  try {
    const n = (await eC()).transaction(cu),
      r = await n.objectStore(cu).get(tC(t))
    return await n.done, r
  } catch (e) {
    if (e instanceof Ii) Go.warn(e.message)
    else {
      const n = Os.create('idb-get', { originalErrorMessage: e == null ? void 0 : e.message })
      Go.warn(n.message)
    }
  }
}
async function mE(t, e) {
  try {
    const r = (await eC()).transaction(cu, 'readwrite')
    await r.objectStore(cu).put(e, tC(t)), await r.done
  } catch (n) {
    if (n instanceof Ii) Go.warn(n.message)
    else {
      const r = Os.create('idb-set', { originalErrorMessage: n == null ? void 0 : n.message })
      Go.warn(r.message)
    }
  }
}
function tC(t) {
  return `${t.name}!${t.options.appId}`
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const A3 = 1024,
  C3 = 30 * 24 * 60 * 60 * 1e3
class R3 {
  constructor(e) {
    ;(this.container = e), (this._heartbeatsCache = null)
    const n = this.container.getProvider('app').getImmediate()
    ;(this._storage = new O3(n)),
      (this._heartbeatsCachePromise = this._storage
        .read()
        .then((r) => ((this._heartbeatsCache = r), r)))
  }
  async triggerHeartbeat() {
    var e, n
    const i = this.container.getProvider('platform-logger').getImmediate().getPlatformInfoString(),
      s = gE()
    if (
      !(
        ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null &&
        ((this._heartbeatsCache = await this._heartbeatsCachePromise),
        ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null)
      ) &&
      !(
        this._heartbeatsCache.lastSentHeartbeatDate === s ||
        this._heartbeatsCache.heartbeats.some((o) => o.date === s)
      )
    )
      return (
        this._heartbeatsCache.heartbeats.push({ date: s, agent: i }),
        (this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((o) => {
          const a = new Date(o.date).valueOf()
          return Date.now() - a <= C3
        })),
        this._storage.overwrite(this._heartbeatsCache)
      )
  }
  async getHeartbeatsHeader() {
    var e
    if (
      (this._heartbeatsCache === null && (await this._heartbeatsCachePromise),
      ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null ||
        this._heartbeatsCache.heartbeats.length === 0)
    )
      return ''
    const n = gE(),
      { heartbeatsToSend: r, unsentEntries: i } = k3(this._heartbeatsCache.heartbeats),
      s = Zd(JSON.stringify({ version: 2, heartbeats: r }))
    return (
      (this._heartbeatsCache.lastSentHeartbeatDate = n),
      i.length > 0
        ? ((this._heartbeatsCache.heartbeats = i),
          await this._storage.overwrite(this._heartbeatsCache))
        : ((this._heartbeatsCache.heartbeats = []), this._storage.overwrite(this._heartbeatsCache)),
      s
    )
  }
}
function gE() {
  return new Date().toISOString().substring(0, 10)
}
function k3(t, e = A3) {
  const n = []
  let r = t.slice()
  for (const i of t) {
    const s = n.find((o) => o.agent === i.agent)
    if (s) {
      if ((s.dates.push(i.date), yE(n) > e)) {
        s.dates.pop()
        break
      }
    } else if ((n.push({ agent: i.agent, dates: [i.date] }), yE(n) > e)) {
      n.pop()
      break
    }
    r = r.slice(1)
  }
  return { heartbeatsToSend: n, unsentEntries: r }
}
class O3 {
  constructor(e) {
    ;(this.app = e), (this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck())
  }
  async runIndexedDBEnvironmentCheck() {
    return Hv()
      ? m4()
          .then(() => !0)
          .catch(() => !1)
      : !1
  }
  async read() {
    if (await this._canUseIndexedDBPromise) {
      const n = await I3(this.app)
      return n != null && n.heartbeats ? n : { heartbeats: [] }
    } else return { heartbeats: [] }
  }
  async overwrite(e) {
    var n
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read()
      return mE(this.app, {
        lastSentHeartbeatDate:
          (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
        heartbeats: e.heartbeats
      })
    } else return
  }
  async add(e) {
    var n
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read()
      return mE(this.app, {
        lastSentHeartbeatDate:
          (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
        heartbeats: [...i.heartbeats, ...e.heartbeats]
      })
    } else return
  }
}
function yE(t) {
  return Zd(JSON.stringify({ version: 2, heartbeats: t })).length
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function N3(t) {
  mi(new Ur('platform-logger', (e) => new G4(e), 'PRIVATE')),
    mi(new Ur('heartbeat', (e) => new R3(e), 'PRIVATE')),
    ar(My, pE, t),
    ar(My, pE, 'esm2017'),
    ar('fire-js', '')
}
N3('')
function jv(t, e) {
  var n = {}
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
  if (t != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]])
  return n
}
function nC() {
  return {
    'dependent-sdk-initialized-before-auth':
      'Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.'
  }
}
const M3 = nC,
  rC = new Dl('auth', 'Firebase', nC())
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const rf = new Ku('@firebase/auth')
function P3(t, ...e) {
  rf.logLevel <= He.WARN && rf.warn(`Auth (${Ys}): ${t}`, ...e)
}
function wd(t, ...e) {
  rf.logLevel <= He.ERROR && rf.error(`Auth (${Ys}): ${t}`, ...e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function gi(t, ...e) {
  throw Wv(t, ...e)
}
function li(t, ...e) {
  return Wv(t, ...e)
}
function iC(t, e, n) {
  const r = Object.assign(Object.assign({}, M3()), { [e]: n })
  return new Dl('auth', 'Firebase', r).create(e, { appName: t.name })
}
function x3(t, e, n) {
  const r = n
  if (!(e instanceof r))
    throw (
      (r.name !== e.constructor.name && gi(t, 'argument-error'),
      iC(
        t,
        'argument-error',
        `Type of ${e.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`
      ))
    )
}
function Wv(t, ...e) {
  if (typeof t != 'string') {
    const n = e[0],
      r = [...e.slice(1)]
    return r[0] && (r[0].appName = t.name), t._errorFactory.create(n, ...r)
  }
  return rC.create(t, ...e)
}
function Le(t, e, ...n) {
  if (!t) throw Wv(e, ...n)
}
function xi(t) {
  const e = 'INTERNAL ASSERTION FAILED: ' + t
  throw (wd(e), new Error(e))
}
function zi(t, e) {
  t || xi(e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Dy() {
  var t
  return (
    (typeof self < 'u' && ((t = self.location) === null || t === void 0 ? void 0 : t.href)) || ''
  )
}
function D3() {
  return _E() === 'http:' || _E() === 'https:'
}
function _E() {
  var t
  return (
    (typeof self < 'u' && ((t = self.location) === null || t === void 0 ? void 0 : t.protocol)) ||
    null
  )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function L3() {
  return typeof navigator < 'u' &&
    navigator &&
    'onLine' in navigator &&
    typeof navigator.onLine == 'boolean' &&
    (D3() || d4() || 'connection' in navigator)
    ? navigator.onLine
    : !0
}
function V3() {
  if (typeof navigator > 'u') return null
  const t = navigator
  return (t.languages && t.languages[0]) || t.language || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Yu {
  constructor(e, n) {
    ;(this.shortDelay = e),
      (this.longDelay = n),
      zi(n > e, 'Short delay should be less than long delay!'),
      (this.isMobile = $v() || GA())
  }
  get() {
    return L3()
      ? this.isMobile
        ? this.longDelay
        : this.shortDelay
      : Math.min(5e3, this.shortDelay)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Gv(t, e) {
  zi(t.emulator, 'Emulator should always be set here')
  const { url: n } = t.emulator
  return e ? `${n}${e.startsWith('/') ? e.slice(1) : e}` : n
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class sC {
  static initialize(e, n, r) {
    ;(this.fetchImpl = e), n && (this.headersImpl = n), r && (this.responseImpl = r)
  }
  static fetch() {
    if (this.fetchImpl) return this.fetchImpl
    if (typeof self < 'u' && 'fetch' in self) return self.fetch
    if (typeof globalThis < 'u' && globalThis.fetch) return globalThis.fetch
    if (typeof fetch < 'u') return fetch
    xi(
      'Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill'
    )
  }
  static headers() {
    if (this.headersImpl) return this.headersImpl
    if (typeof self < 'u' && 'Headers' in self) return self.Headers
    if (typeof globalThis < 'u' && globalThis.Headers) return globalThis.Headers
    if (typeof Headers < 'u') return Headers
    xi(
      'Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill'
    )
  }
  static response() {
    if (this.responseImpl) return this.responseImpl
    if (typeof self < 'u' && 'Response' in self) return self.Response
    if (typeof globalThis < 'u' && globalThis.Response) return globalThis.Response
    if (typeof Response < 'u') return Response
    xi(
      'Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill'
    )
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const F3 = {
  CREDENTIAL_MISMATCH: 'custom-token-mismatch',
  MISSING_CUSTOM_TOKEN: 'internal-error',
  INVALID_IDENTIFIER: 'invalid-email',
  MISSING_CONTINUE_URI: 'internal-error',
  INVALID_PASSWORD: 'wrong-password',
  MISSING_PASSWORD: 'missing-password',
  INVALID_LOGIN_CREDENTIALS: 'invalid-credential',
  EMAIL_EXISTS: 'email-already-in-use',
  PASSWORD_LOGIN_DISABLED: 'operation-not-allowed',
  INVALID_IDP_RESPONSE: 'invalid-credential',
  INVALID_PENDING_TOKEN: 'invalid-credential',
  FEDERATED_USER_ID_ALREADY_LINKED: 'credential-already-in-use',
  MISSING_REQ_TYPE: 'internal-error',
  EMAIL_NOT_FOUND: 'user-not-found',
  RESET_PASSWORD_EXCEED_LIMIT: 'too-many-requests',
  EXPIRED_OOB_CODE: 'expired-action-code',
  INVALID_OOB_CODE: 'invalid-action-code',
  MISSING_OOB_CODE: 'internal-error',
  CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'requires-recent-login',
  INVALID_ID_TOKEN: 'invalid-user-token',
  TOKEN_EXPIRED: 'user-token-expired',
  USER_NOT_FOUND: 'user-token-expired',
  TOO_MANY_ATTEMPTS_TRY_LATER: 'too-many-requests',
  PASSWORD_DOES_NOT_MEET_REQUIREMENTS: 'password-does-not-meet-requirements',
  INVALID_CODE: 'invalid-verification-code',
  INVALID_SESSION_INFO: 'invalid-verification-id',
  INVALID_TEMPORARY_PROOF: 'invalid-credential',
  MISSING_SESSION_INFO: 'missing-verification-id',
  SESSION_EXPIRED: 'code-expired',
  MISSING_ANDROID_PACKAGE_NAME: 'missing-android-pkg-name',
  UNAUTHORIZED_DOMAIN: 'unauthorized-continue-uri',
  INVALID_OAUTH_CLIENT_ID: 'invalid-oauth-client-id',
  ADMIN_ONLY_OPERATION: 'admin-restricted-operation',
  INVALID_MFA_PENDING_CREDENTIAL: 'invalid-multi-factor-session',
  MFA_ENROLLMENT_NOT_FOUND: 'multi-factor-info-not-found',
  MISSING_MFA_ENROLLMENT_ID: 'missing-multi-factor-info',
  MISSING_MFA_PENDING_CREDENTIAL: 'missing-multi-factor-session',
  SECOND_FACTOR_EXISTS: 'second-factor-already-in-use',
  SECOND_FACTOR_LIMIT_EXCEEDED: 'maximum-second-factor-count-exceeded',
  BLOCKING_FUNCTION_ERROR_RESPONSE: 'internal-error',
  RECAPTCHA_NOT_ENABLED: 'recaptcha-not-enabled',
  MISSING_RECAPTCHA_TOKEN: 'missing-recaptcha-token',
  INVALID_RECAPTCHA_TOKEN: 'invalid-recaptcha-token',
  INVALID_RECAPTCHA_ACTION: 'invalid-recaptcha-action',
  MISSING_CLIENT_TYPE: 'missing-client-type',
  MISSING_RECAPTCHA_VERSION: 'missing-recaptcha-version',
  INVALID_RECAPTCHA_VERSION: 'invalid-recaptcha-version',
  INVALID_REQ_TYPE: 'invalid-req-type'
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const B3 = new Yu(3e4, 6e4)
function qv(t, e) {
  return t.tenantId && !e.tenantId
    ? Object.assign(Object.assign({}, e), { tenantId: t.tenantId })
    : e
}
async function Vl(t, e, n, r, i = {}) {
  return oC(t, i, async () => {
    let s = {},
      o = {}
    r && (e === 'GET' ? (o = r) : (s = { body: JSON.stringify(r) }))
    const a = Ll(Object.assign({ key: t.config.apiKey }, o)).slice(1),
      l = await t._getAdditionalHeaders()
    return (
      (l['Content-Type'] = 'application/json'),
      t.languageCode && (l['X-Firebase-Locale'] = t.languageCode),
      sC.fetch()(
        aC(t, t.config.apiHost, n, a),
        Object.assign({ method: e, headers: l, referrerPolicy: 'no-referrer' }, s)
      )
    )
  })
}
async function oC(t, e, n) {
  t._canInitEmulator = !1
  const r = Object.assign(Object.assign({}, F3), e)
  try {
    const i = new $3(t),
      s = await Promise.race([n(), i.promise])
    i.clearNetworkTimeout()
    const o = await s.json()
    if ('needConfirmation' in o) throw Uh(t, 'account-exists-with-different-credential', o)
    if (s.ok && !('errorMessage' in o)) return o
    {
      const a = s.ok ? o.errorMessage : o.error.message,
        [l, c] = a.split(' : ')
      if (l === 'FEDERATED_USER_ID_ALREADY_LINKED') throw Uh(t, 'credential-already-in-use', o)
      if (l === 'EMAIL_EXISTS') throw Uh(t, 'email-already-in-use', o)
      if (l === 'USER_DISABLED') throw Uh(t, 'user-disabled', o)
      const u = r[l] || l.toLowerCase().replace(/[_\s]+/g, '-')
      if (c) throw iC(t, u, c)
      gi(t, u)
    }
  } catch (i) {
    if (i instanceof Ii) throw i
    gi(t, 'network-request-failed', { message: String(i) })
  }
}
async function U3(t, e, n, r, i = {}) {
  const s = await Vl(t, e, n, r, i)
  return (
    'mfaPendingCredential' in s && gi(t, 'multi-factor-auth-required', { _serverResponse: s }), s
  )
}
function aC(t, e, n, r) {
  const i = `${e}${n}?${r}`
  return t.config.emulator ? Gv(t.config, i) : `${t.config.apiScheme}://${i}`
}
class $3 {
  constructor(e) {
    ;(this.auth = e),
      (this.timer = null),
      (this.promise = new Promise((n, r) => {
        this.timer = setTimeout(() => r(li(this.auth, 'network-request-failed')), B3.get())
      }))
  }
  clearNetworkTimeout() {
    clearTimeout(this.timer)
  }
}
function Uh(t, e, n) {
  const r = { appName: t.name }
  n.email && (r.email = n.email), n.phoneNumber && (r.phoneNumber = n.phoneNumber)
  const i = li(t, e, r)
  return (i.customData._tokenResponse = n), i
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function H3(t, e) {
  return Vl(t, 'POST', '/v1/accounts:delete', e)
}
async function z3(t, e) {
  return Vl(t, 'POST', '/v1/accounts:lookup', e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Nc(t) {
  if (t)
    try {
      const e = new Date(Number(t))
      if (!isNaN(e.getTime())) return e.toUTCString()
    } catch {}
}
async function j3(t, e = !1) {
  const n = sn(t),
    r = await n.getIdToken(e),
    i = Kv(r)
  Le(i && i.exp && i.auth_time && i.iat, n.auth, 'internal-error')
  const s = typeof i.firebase == 'object' ? i.firebase : void 0,
    o = s == null ? void 0 : s.sign_in_provider
  return {
    claims: i,
    token: r,
    authTime: Nc(Jm(i.auth_time)),
    issuedAtTime: Nc(Jm(i.iat)),
    expirationTime: Nc(Jm(i.exp)),
    signInProvider: o || null,
    signInSecondFactor: (s == null ? void 0 : s.sign_in_second_factor) || null
  }
}
function Jm(t) {
  return Number(t) * 1e3
}
function Kv(t) {
  const [e, n, r] = t.split('.')
  if (e === void 0 || n === void 0 || r === void 0)
    return wd('JWT malformed, contained fewer than 3 sections'), null
  try {
    const i = ef(n)
    return i ? JSON.parse(i) : (wd('Failed to decode base64 JWT payload'), null)
  } catch (i) {
    return wd('Caught error parsing JWT payload as JSON', i == null ? void 0 : i.toString()), null
  }
}
function W3(t) {
  const e = Kv(t)
  return (
    Le(e, 'internal-error'),
    Le(typeof e.exp < 'u', 'internal-error'),
    Le(typeof e.iat < 'u', 'internal-error'),
    Number(e.exp) - Number(e.iat)
  )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function uu(t, e, n = !1) {
  if (n) return e
  try {
    return await e
  } catch (r) {
    throw (r instanceof Ii && G3(r) && t.auth.currentUser === t && (await t.auth.signOut()), r)
  }
}
function G3({ code: t }) {
  return t === 'auth/user-disabled' || t === 'auth/user-token-expired'
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class q3 {
  constructor(e) {
    ;(this.user = e), (this.isRunning = !1), (this.timerId = null), (this.errorBackoff = 3e4)
  }
  _start() {
    this.isRunning || ((this.isRunning = !0), this.schedule())
  }
  _stop() {
    this.isRunning && ((this.isRunning = !1), this.timerId !== null && clearTimeout(this.timerId))
  }
  getInterval(e) {
    var n
    if (e) {
      const r = this.errorBackoff
      return (this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4)), r
    } else {
      this.errorBackoff = 3e4
      const i =
        ((n = this.user.stsTokenManager.expirationTime) !== null && n !== void 0 ? n : 0) -
        Date.now() -
        3e5
      return Math.max(0, i)
    }
  }
  schedule(e = !1) {
    if (!this.isRunning) return
    const n = this.getInterval(e)
    this.timerId = setTimeout(async () => {
      await this.iteration()
    }, n)
  }
  async iteration() {
    try {
      await this.user.getIdToken(!0)
    } catch (e) {
      ;(e == null ? void 0 : e.code) === 'auth/network-request-failed' && this.schedule(!0)
      return
    }
    this.schedule()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class lC {
  constructor(e, n) {
    ;(this.createdAt = e), (this.lastLoginAt = n), this._initializeTime()
  }
  _initializeTime() {
    ;(this.lastSignInTime = Nc(this.lastLoginAt)), (this.creationTime = Nc(this.createdAt))
  }
  _copy(e) {
    ;(this.createdAt = e.createdAt), (this.lastLoginAt = e.lastLoginAt), this._initializeTime()
  }
  toJSON() {
    return { createdAt: this.createdAt, lastLoginAt: this.lastLoginAt }
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function sf(t) {
  var e
  const n = t.auth,
    r = await t.getIdToken(),
    i = await uu(t, z3(n, { idToken: r }))
  Le(i == null ? void 0 : i.users.length, n, 'internal-error')
  const s = i.users[0]
  t._notifyReloadListener(s)
  const o =
      !((e = s.providerUserInfo) === null || e === void 0) && e.length
        ? J3(s.providerUserInfo)
        : [],
    a = Y3(t.providerData, o),
    l = t.isAnonymous,
    c = !(t.email && s.passwordHash) && !(a != null && a.length),
    u = l ? c : !1,
    h = {
      uid: s.localId,
      displayName: s.displayName || null,
      photoURL: s.photoUrl || null,
      email: s.email || null,
      emailVerified: s.emailVerified || !1,
      phoneNumber: s.phoneNumber || null,
      tenantId: s.tenantId || null,
      providerData: a,
      metadata: new lC(s.createdAt, s.lastLoginAt),
      isAnonymous: u
    }
  Object.assign(t, h)
}
async function K3(t) {
  const e = sn(t)
  await sf(e), await e.auth._persistUserIfCurrent(e), e.auth._notifyListenersIfCurrent(e)
}
function Y3(t, e) {
  return [...t.filter((r) => !e.some((i) => i.providerId === r.providerId)), ...e]
}
function J3(t) {
  return t.map((e) => {
    var { providerId: n } = e,
      r = jv(e, ['providerId'])
    return {
      providerId: n,
      uid: r.rawId || '',
      displayName: r.displayName || null,
      email: r.email || null,
      phoneNumber: r.phoneNumber || null,
      photoURL: r.photoUrl || null
    }
  })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Q3(t, e) {
  const n = await oC(t, {}, async () => {
    const r = Ll({ grant_type: 'refresh_token', refresh_token: e }).slice(1),
      { tokenApiHost: i, apiKey: s } = t.config,
      o = aC(t, i, '/v1/token', `key=${s}`),
      a = await t._getAdditionalHeaders()
    return (
      (a['Content-Type'] = 'application/x-www-form-urlencoded'),
      sC.fetch()(o, { method: 'POST', headers: a, body: r })
    )
  })
  return { accessToken: n.access_token, expiresIn: n.expires_in, refreshToken: n.refresh_token }
}
async function X3(t, e) {
  return Vl(t, 'POST', '/v2/accounts:revokeToken', qv(t, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class hu {
  constructor() {
    ;(this.refreshToken = null), (this.accessToken = null), (this.expirationTime = null)
  }
  get isExpired() {
    return !this.expirationTime || Date.now() > this.expirationTime - 3e4
  }
  updateFromServerResponse(e) {
    Le(e.idToken, 'internal-error'),
      Le(typeof e.idToken < 'u', 'internal-error'),
      Le(typeof e.refreshToken < 'u', 'internal-error')
    const n = 'expiresIn' in e && typeof e.expiresIn < 'u' ? Number(e.expiresIn) : W3(e.idToken)
    this.updateTokensAndExpiration(e.idToken, e.refreshToken, n)
  }
  async getToken(e, n = !1) {
    return (
      Le(!this.accessToken || this.refreshToken, e, 'user-token-expired'),
      !n && this.accessToken && !this.isExpired
        ? this.accessToken
        : this.refreshToken
        ? (await this.refresh(e, this.refreshToken), this.accessToken)
        : null
    )
  }
  clearRefreshToken() {
    this.refreshToken = null
  }
  async refresh(e, n) {
    const { accessToken: r, refreshToken: i, expiresIn: s } = await Q3(e, n)
    this.updateTokensAndExpiration(r, i, Number(s))
  }
  updateTokensAndExpiration(e, n, r) {
    ;(this.refreshToken = n || null),
      (this.accessToken = e || null),
      (this.expirationTime = Date.now() + r * 1e3)
  }
  static fromJSON(e, n) {
    const { refreshToken: r, accessToken: i, expirationTime: s } = n,
      o = new hu()
    return (
      r && (Le(typeof r == 'string', 'internal-error', { appName: e }), (o.refreshToken = r)),
      i && (Le(typeof i == 'string', 'internal-error', { appName: e }), (o.accessToken = i)),
      s && (Le(typeof s == 'number', 'internal-error', { appName: e }), (o.expirationTime = s)),
      o
    )
  }
  toJSON() {
    return {
      refreshToken: this.refreshToken,
      accessToken: this.accessToken,
      expirationTime: this.expirationTime
    }
  }
  _assign(e) {
    ;(this.accessToken = e.accessToken),
      (this.refreshToken = e.refreshToken),
      (this.expirationTime = e.expirationTime)
  }
  _clone() {
    return Object.assign(new hu(), this.toJSON())
  }
  _performRefresh() {
    return xi('not implemented')
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function rs(t, e) {
  Le(typeof t == 'string' || typeof t > 'u', 'internal-error', { appName: e })
}
class Lo {
  constructor(e) {
    var { uid: n, auth: r, stsTokenManager: i } = e,
      s = jv(e, ['uid', 'auth', 'stsTokenManager'])
    ;(this.providerId = 'firebase'),
      (this.proactiveRefresh = new q3(this)),
      (this.reloadUserInfo = null),
      (this.reloadListener = null),
      (this.uid = n),
      (this.auth = r),
      (this.stsTokenManager = i),
      (this.accessToken = i.accessToken),
      (this.displayName = s.displayName || null),
      (this.email = s.email || null),
      (this.emailVerified = s.emailVerified || !1),
      (this.phoneNumber = s.phoneNumber || null),
      (this.photoURL = s.photoURL || null),
      (this.isAnonymous = s.isAnonymous || !1),
      (this.tenantId = s.tenantId || null),
      (this.providerData = s.providerData ? [...s.providerData] : []),
      (this.metadata = new lC(s.createdAt || void 0, s.lastLoginAt || void 0))
  }
  async getIdToken(e) {
    const n = await uu(this, this.stsTokenManager.getToken(this.auth, e))
    return (
      Le(n, this.auth, 'internal-error'),
      this.accessToken !== n &&
        ((this.accessToken = n),
        await this.auth._persistUserIfCurrent(this),
        this.auth._notifyListenersIfCurrent(this)),
      n
    )
  }
  getIdTokenResult(e) {
    return j3(this, e)
  }
  reload() {
    return K3(this)
  }
  _assign(e) {
    this !== e &&
      (Le(this.uid === e.uid, this.auth, 'internal-error'),
      (this.displayName = e.displayName),
      (this.photoURL = e.photoURL),
      (this.email = e.email),
      (this.emailVerified = e.emailVerified),
      (this.phoneNumber = e.phoneNumber),
      (this.isAnonymous = e.isAnonymous),
      (this.tenantId = e.tenantId),
      (this.providerData = e.providerData.map((n) => Object.assign({}, n))),
      this.metadata._copy(e.metadata),
      this.stsTokenManager._assign(e.stsTokenManager))
  }
  _clone(e) {
    const n = new Lo(
      Object.assign(Object.assign({}, this), {
        auth: e,
        stsTokenManager: this.stsTokenManager._clone()
      })
    )
    return n.metadata._copy(this.metadata), n
  }
  _onReload(e) {
    Le(!this.reloadListener, this.auth, 'internal-error'),
      (this.reloadListener = e),
      this.reloadUserInfo &&
        (this._notifyReloadListener(this.reloadUserInfo), (this.reloadUserInfo = null))
  }
  _notifyReloadListener(e) {
    this.reloadListener ? this.reloadListener(e) : (this.reloadUserInfo = e)
  }
  _startProactiveRefresh() {
    this.proactiveRefresh._start()
  }
  _stopProactiveRefresh() {
    this.proactiveRefresh._stop()
  }
  async _updateTokensIfNecessary(e, n = !1) {
    let r = !1
    e.idToken &&
      e.idToken !== this.stsTokenManager.accessToken &&
      (this.stsTokenManager.updateFromServerResponse(e), (r = !0)),
      n && (await sf(this)),
      await this.auth._persistUserIfCurrent(this),
      r && this.auth._notifyListenersIfCurrent(this)
  }
  async delete() {
    const e = await this.getIdToken()
    return (
      await uu(this, H3(this.auth, { idToken: e })),
      this.stsTokenManager.clearRefreshToken(),
      this.auth.signOut()
    )
  }
  toJSON() {
    return Object.assign(
      Object.assign(
        {
          uid: this.uid,
          email: this.email || void 0,
          emailVerified: this.emailVerified,
          displayName: this.displayName || void 0,
          isAnonymous: this.isAnonymous,
          photoURL: this.photoURL || void 0,
          phoneNumber: this.phoneNumber || void 0,
          tenantId: this.tenantId || void 0,
          providerData: this.providerData.map((e) => Object.assign({}, e)),
          stsTokenManager: this.stsTokenManager.toJSON(),
          _redirectEventId: this._redirectEventId
        },
        this.metadata.toJSON()
      ),
      { apiKey: this.auth.config.apiKey, appName: this.auth.name }
    )
  }
  get refreshToken() {
    return this.stsTokenManager.refreshToken || ''
  }
  static _fromJSON(e, n) {
    var r, i, s, o, a, l, c, u
    const h = (r = n.displayName) !== null && r !== void 0 ? r : void 0,
      d = (i = n.email) !== null && i !== void 0 ? i : void 0,
      f = (s = n.phoneNumber) !== null && s !== void 0 ? s : void 0,
      p = (o = n.photoURL) !== null && o !== void 0 ? o : void 0,
      m = (a = n.tenantId) !== null && a !== void 0 ? a : void 0,
      g = (l = n._redirectEventId) !== null && l !== void 0 ? l : void 0,
      _ = (c = n.createdAt) !== null && c !== void 0 ? c : void 0,
      v = (u = n.lastLoginAt) !== null && u !== void 0 ? u : void 0,
      { uid: T, emailVerified: S, isAnonymous: I, providerData: w, stsTokenManager: O } = n
    Le(T && O, e, 'internal-error')
    const P = hu.fromJSON(this.name, O)
    Le(typeof T == 'string', e, 'internal-error'),
      rs(h, e.name),
      rs(d, e.name),
      Le(typeof S == 'boolean', e, 'internal-error'),
      Le(typeof I == 'boolean', e, 'internal-error'),
      rs(f, e.name),
      rs(p, e.name),
      rs(m, e.name),
      rs(g, e.name),
      rs(_, e.name),
      rs(v, e.name)
    const k = new Lo({
      uid: T,
      auth: e,
      email: d,
      emailVerified: S,
      displayName: h,
      isAnonymous: I,
      photoURL: p,
      phoneNumber: f,
      tenantId: m,
      stsTokenManager: P,
      createdAt: _,
      lastLoginAt: v
    })
    return (
      w && Array.isArray(w) && (k.providerData = w.map((U) => Object.assign({}, U))),
      g && (k._redirectEventId = g),
      k
    )
  }
  static async _fromIdTokenResponse(e, n, r = !1) {
    const i = new hu()
    i.updateFromServerResponse(n)
    const s = new Lo({ uid: n.localId, auth: e, stsTokenManager: i, isAnonymous: r })
    return await sf(s), s
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const vE = new Map()
function Di(t) {
  zi(t instanceof Function, 'Expected a class definition')
  let e = vE.get(t)
  return e
    ? (zi(e instanceof t, 'Instance stored in cache mismatched with class'), e)
    : ((e = new t()), vE.set(t, e), e)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class cC {
  constructor() {
    ;(this.type = 'NONE'), (this.storage = {})
  }
  async _isAvailable() {
    return !0
  }
  async _set(e, n) {
    this.storage[e] = n
  }
  async _get(e) {
    const n = this.storage[e]
    return n === void 0 ? null : n
  }
  async _remove(e) {
    delete this.storage[e]
  }
  _addListener(e, n) {}
  _removeListener(e, n) {}
}
cC.type = 'NONE'
const bE = cC
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Sd(t, e, n) {
  return `firebase:${t}:${e}:${n}`
}
class Wa {
  constructor(e, n, r) {
    ;(this.persistence = e), (this.auth = n), (this.userKey = r)
    const { config: i, name: s } = this.auth
    ;(this.fullUserKey = Sd(this.userKey, i.apiKey, s)),
      (this.fullPersistenceKey = Sd('persistence', i.apiKey, s)),
      (this.boundEventHandler = n._onStorageEvent.bind(n)),
      this.persistence._addListener(this.fullUserKey, this.boundEventHandler)
  }
  setCurrentUser(e) {
    return this.persistence._set(this.fullUserKey, e.toJSON())
  }
  async getCurrentUser() {
    const e = await this.persistence._get(this.fullUserKey)
    return e ? Lo._fromJSON(this.auth, e) : null
  }
  removeCurrentUser() {
    return this.persistence._remove(this.fullUserKey)
  }
  savePersistenceForRedirect() {
    return this.persistence._set(this.fullPersistenceKey, this.persistence.type)
  }
  async setPersistence(e) {
    if (this.persistence === e) return
    const n = await this.getCurrentUser()
    if ((await this.removeCurrentUser(), (this.persistence = e), n)) return this.setCurrentUser(n)
  }
  delete() {
    this.persistence._removeListener(this.fullUserKey, this.boundEventHandler)
  }
  static async create(e, n, r = 'authUser') {
    if (!n.length) return new Wa(Di(bE), e, r)
    const i = (
      await Promise.all(
        n.map(async (c) => {
          if (await c._isAvailable()) return c
        })
      )
    ).filter((c) => c)
    let s = i[0] || Di(bE)
    const o = Sd(r, e.config.apiKey, e.name)
    let a = null
    for (const c of n)
      try {
        const u = await c._get(o)
        if (u) {
          const h = Lo._fromJSON(e, u)
          c !== s && (a = h), (s = c)
          break
        }
      } catch {}
    const l = i.filter((c) => c._shouldAllowMigration)
    return !s._shouldAllowMigration || !l.length
      ? new Wa(s, e, r)
      : ((s = l[0]),
        a && (await s._set(o, a.toJSON())),
        await Promise.all(
          n.map(async (c) => {
            if (c !== s)
              try {
                await c._remove(o)
              } catch {}
          })
        ),
        new Wa(s, e, r))
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function EE(t) {
  const e = t.toLowerCase()
  if (e.includes('opera/') || e.includes('opr/') || e.includes('opios/')) return 'Opera'
  if (dC(e)) return 'IEMobile'
  if (e.includes('msie') || e.includes('trident/')) return 'IE'
  if (e.includes('edge/')) return 'Edge'
  if (uC(e)) return 'Firefox'
  if (e.includes('silk/')) return 'Silk'
  if (pC(e)) return 'Blackberry'
  if (mC(e)) return 'Webos'
  if (Yv(e)) return 'Safari'
  if ((e.includes('chrome/') || hC(e)) && !e.includes('edge/')) return 'Chrome'
  if (fC(e)) return 'Android'
  {
    const n = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,
      r = t.match(n)
    if ((r == null ? void 0 : r.length) === 2) return r[1]
  }
  return 'Other'
}
function uC(t = Ht()) {
  return /firefox\//i.test(t)
}
function Yv(t = Ht()) {
  const e = t.toLowerCase()
  return (
    e.includes('safari/') &&
    !e.includes('chrome/') &&
    !e.includes('crios/') &&
    !e.includes('android')
  )
}
function hC(t = Ht()) {
  return /crios\//i.test(t)
}
function dC(t = Ht()) {
  return /iemobile/i.test(t)
}
function fC(t = Ht()) {
  return /android/i.test(t)
}
function pC(t = Ht()) {
  return /blackberry/i.test(t)
}
function mC(t = Ht()) {
  return /webos/i.test(t)
}
function Rp(t = Ht()) {
  return /iphone|ipad|ipod/i.test(t) || (/macintosh/i.test(t) && /mobile/i.test(t))
}
function Z3(t = Ht()) {
  var e
  return Rp(t) && !!(!((e = window.navigator) === null || e === void 0) && e.standalone)
}
function eL() {
  return f4() && document.documentMode === 10
}
function gC(t = Ht()) {
  return Rp(t) || fC(t) || mC(t) || pC(t) || /windows phone/i.test(t) || dC(t)
}
function tL() {
  try {
    return !!(window && window !== window.top)
  } catch {
    return !1
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function yC(t, e = []) {
  let n
  switch (t) {
    case 'Browser':
      n = EE(Ht())
      break
    case 'Worker':
      n = `${EE(Ht())}-${t}`
      break
    default:
      n = t
  }
  const r = e.length ? e.join(',') : 'FirebaseCore-web'
  return `${n}/JsCore/${Ys}/${r}`
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class nL {
  constructor(e) {
    ;(this.auth = e), (this.queue = [])
  }
  pushCallback(e, n) {
    const r = (s) =>
      new Promise((o, a) => {
        try {
          const l = e(s)
          o(l)
        } catch (l) {
          a(l)
        }
      })
    ;(r.onAbort = n), this.queue.push(r)
    const i = this.queue.length - 1
    return () => {
      this.queue[i] = () => Promise.resolve()
    }
  }
  async runMiddleware(e) {
    if (this.auth.currentUser === e) return
    const n = []
    try {
      for (const r of this.queue) await r(e), r.onAbort && n.push(r.onAbort)
    } catch (r) {
      n.reverse()
      for (const i of n)
        try {
          i()
        } catch {}
      throw this.auth._errorFactory.create('login-blocked', {
        originalMessage: r == null ? void 0 : r.message
      })
    }
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function rL(t, e = {}) {
  return Vl(t, 'GET', '/v2/passwordPolicy', qv(t, e))
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const iL = 6
class sL {
  constructor(e) {
    var n, r, i, s
    const o = e.customStrengthOptions
    ;(this.customStrengthOptions = {}),
      (this.customStrengthOptions.minPasswordLength =
        (n = o.minPasswordLength) !== null && n !== void 0 ? n : iL),
      o.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = o.maxPasswordLength),
      o.containsLowercaseCharacter !== void 0 &&
        (this.customStrengthOptions.containsLowercaseLetter = o.containsLowercaseCharacter),
      o.containsUppercaseCharacter !== void 0 &&
        (this.customStrengthOptions.containsUppercaseLetter = o.containsUppercaseCharacter),
      o.containsNumericCharacter !== void 0 &&
        (this.customStrengthOptions.containsNumericCharacter = o.containsNumericCharacter),
      o.containsNonAlphanumericCharacter !== void 0 &&
        (this.customStrengthOptions.containsNonAlphanumericCharacter =
          o.containsNonAlphanumericCharacter),
      (this.enforcementState = e.enforcementState),
      this.enforcementState === 'ENFORCEMENT_STATE_UNSPECIFIED' && (this.enforcementState = 'OFF'),
      (this.allowedNonAlphanumericCharacters =
        (i =
          (r = e.allowedNonAlphanumericCharacters) === null || r === void 0
            ? void 0
            : r.join('')) !== null && i !== void 0
          ? i
          : ''),
      (this.forceUpgradeOnSignin = (s = e.forceUpgradeOnSignin) !== null && s !== void 0 ? s : !1),
      (this.schemaVersion = e.schemaVersion)
  }
  validatePassword(e) {
    var n, r, i, s, o, a
    const l = { isValid: !0, passwordPolicy: this }
    return (
      this.validatePasswordLengthOptions(e, l),
      this.validatePasswordCharacterOptions(e, l),
      l.isValid && (l.isValid = (n = l.meetsMinPasswordLength) !== null && n !== void 0 ? n : !0),
      l.isValid && (l.isValid = (r = l.meetsMaxPasswordLength) !== null && r !== void 0 ? r : !0),
      l.isValid && (l.isValid = (i = l.containsLowercaseLetter) !== null && i !== void 0 ? i : !0),
      l.isValid && (l.isValid = (s = l.containsUppercaseLetter) !== null && s !== void 0 ? s : !0),
      l.isValid && (l.isValid = (o = l.containsNumericCharacter) !== null && o !== void 0 ? o : !0),
      l.isValid &&
        (l.isValid = (a = l.containsNonAlphanumericCharacter) !== null && a !== void 0 ? a : !0),
      l
    )
  }
  validatePasswordLengthOptions(e, n) {
    const r = this.customStrengthOptions.minPasswordLength,
      i = this.customStrengthOptions.maxPasswordLength
    r && (n.meetsMinPasswordLength = e.length >= r), i && (n.meetsMaxPasswordLength = e.length <= i)
  }
  validatePasswordCharacterOptions(e, n) {
    this.updatePasswordCharacterOptionsStatuses(n, !1, !1, !1, !1)
    let r
    for (let i = 0; i < e.length; i++)
      (r = e.charAt(i)),
        this.updatePasswordCharacterOptionsStatuses(
          n,
          r >= 'a' && r <= 'z',
          r >= 'A' && r <= 'Z',
          r >= '0' && r <= '9',
          this.allowedNonAlphanumericCharacters.includes(r)
        )
  }
  updatePasswordCharacterOptionsStatuses(e, n, r, i, s) {
    this.customStrengthOptions.containsLowercaseLetter &&
      (e.containsLowercaseLetter || (e.containsLowercaseLetter = n)),
      this.customStrengthOptions.containsUppercaseLetter &&
        (e.containsUppercaseLetter || (e.containsUppercaseLetter = r)),
      this.customStrengthOptions.containsNumericCharacter &&
        (e.containsNumericCharacter || (e.containsNumericCharacter = i)),
      this.customStrengthOptions.containsNonAlphanumericCharacter &&
        (e.containsNonAlphanumericCharacter || (e.containsNonAlphanumericCharacter = s))
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class oL {
  constructor(e, n, r, i) {
    ;(this.app = e),
      (this.heartbeatServiceProvider = n),
      (this.appCheckServiceProvider = r),
      (this.config = i),
      (this.currentUser = null),
      (this.emulatorConfig = null),
      (this.operations = Promise.resolve()),
      (this.authStateSubscription = new TE(this)),
      (this.idTokenSubscription = new TE(this)),
      (this.beforeStateQueue = new nL(this)),
      (this.redirectUser = null),
      (this.isProactiveRefreshEnabled = !1),
      (this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1),
      (this._canInitEmulator = !0),
      (this._isInitialized = !1),
      (this._deleted = !1),
      (this._initializationPromise = null),
      (this._popupRedirectResolver = null),
      (this._errorFactory = rC),
      (this._agentRecaptchaConfig = null),
      (this._tenantRecaptchaConfigs = {}),
      (this._projectPasswordPolicy = null),
      (this._tenantPasswordPolicies = {}),
      (this.lastNotifiedUid = void 0),
      (this.languageCode = null),
      (this.tenantId = null),
      (this.settings = { appVerificationDisabledForTesting: !1 }),
      (this.frameworks = []),
      (this.name = e.name),
      (this.clientVersion = i.sdkClientVersion)
  }
  _initializeWithPersistence(e, n) {
    return (
      n && (this._popupRedirectResolver = Di(n)),
      (this._initializationPromise = this.queue(async () => {
        var r, i
        if (
          !this._deleted &&
          ((this.persistenceManager = await Wa.create(this, e)), !this._deleted)
        ) {
          if (
            !((r = this._popupRedirectResolver) === null || r === void 0) &&
            r._shouldInitProactively
          )
            try {
              await this._popupRedirectResolver._initialize(this)
            } catch {}
          await this.initializeCurrentUser(n),
            (this.lastNotifiedUid =
              ((i = this.currentUser) === null || i === void 0 ? void 0 : i.uid) || null),
            !this._deleted && (this._isInitialized = !0)
        }
      })),
      this._initializationPromise
    )
  }
  async _onStorageEvent() {
    if (this._deleted) return
    const e = await this.assertedPersistence.getCurrentUser()
    if (!(!this.currentUser && !e)) {
      if (this.currentUser && e && this.currentUser.uid === e.uid) {
        this._currentUser._assign(e), await this.currentUser.getIdToken()
        return
      }
      await this._updateCurrentUser(e, !0)
    }
  }
  async initializeCurrentUser(e) {
    var n
    const r = await this.assertedPersistence.getCurrentUser()
    let i = r,
      s = !1
    if (e && this.config.authDomain) {
      await this.getOrInitRedirectPersistenceManager()
      const o = (n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId,
        a = i == null ? void 0 : i._redirectEventId,
        l = await this.tryRedirectSignIn(e)
      ;(!o || o === a) && l != null && l.user && ((i = l.user), (s = !0))
    }
    if (!i) return this.directlySetCurrentUser(null)
    if (!i._redirectEventId) {
      if (s)
        try {
          await this.beforeStateQueue.runMiddleware(i)
        } catch (o) {
          ;(i = r),
            this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(o))
        }
      return i ? this.reloadAndSetCurrentUserOrClear(i) : this.directlySetCurrentUser(null)
    }
    return (
      Le(this._popupRedirectResolver, this, 'argument-error'),
      await this.getOrInitRedirectPersistenceManager(),
      this.redirectUser && this.redirectUser._redirectEventId === i._redirectEventId
        ? this.directlySetCurrentUser(i)
        : this.reloadAndSetCurrentUserOrClear(i)
    )
  }
  async tryRedirectSignIn(e) {
    let n = null
    try {
      n = await this._popupRedirectResolver._completeRedirectFn(this, e, !0)
    } catch {
      await this._setRedirectUser(null)
    }
    return n
  }
  async reloadAndSetCurrentUserOrClear(e) {
    try {
      await sf(e)
    } catch (n) {
      if ((n == null ? void 0 : n.code) !== 'auth/network-request-failed')
        return this.directlySetCurrentUser(null)
    }
    return this.directlySetCurrentUser(e)
  }
  useDeviceLanguage() {
    this.languageCode = V3()
  }
  async _delete() {
    this._deleted = !0
  }
  async updateCurrentUser(e) {
    const n = e ? sn(e) : null
    return (
      n && Le(n.auth.config.apiKey === this.config.apiKey, this, 'invalid-user-token'),
      this._updateCurrentUser(n && n._clone(this))
    )
  }
  async _updateCurrentUser(e, n = !1) {
    if (!this._deleted)
      return (
        e && Le(this.tenantId === e.tenantId, this, 'tenant-id-mismatch'),
        n || (await this.beforeStateQueue.runMiddleware(e)),
        this.queue(async () => {
          await this.directlySetCurrentUser(e), this.notifyAuthListeners()
        })
      )
  }
  async signOut() {
    return (
      await this.beforeStateQueue.runMiddleware(null),
      (this.redirectPersistenceManager || this._popupRedirectResolver) &&
        (await this._setRedirectUser(null)),
      this._updateCurrentUser(null, !0)
    )
  }
  setPersistence(e) {
    return this.queue(async () => {
      await this.assertedPersistence.setPersistence(Di(e))
    })
  }
  _getRecaptchaConfig() {
    return this.tenantId == null
      ? this._agentRecaptchaConfig
      : this._tenantRecaptchaConfigs[this.tenantId]
  }
  async validatePassword(e) {
    this._getPasswordPolicyInternal() || (await this._updatePasswordPolicy())
    const n = this._getPasswordPolicyInternal()
    return n.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION
      ? Promise.reject(this._errorFactory.create('unsupported-password-policy-schema-version', {}))
      : n.validatePassword(e)
  }
  _getPasswordPolicyInternal() {
    return this.tenantId === null
      ? this._projectPasswordPolicy
      : this._tenantPasswordPolicies[this.tenantId]
  }
  async _updatePasswordPolicy() {
    const e = await rL(this),
      n = new sL(e)
    this.tenantId === null
      ? (this._projectPasswordPolicy = n)
      : (this._tenantPasswordPolicies[this.tenantId] = n)
  }
  _getPersistence() {
    return this.assertedPersistence.persistence.type
  }
  _updateErrorMap(e) {
    this._errorFactory = new Dl('auth', 'Firebase', e())
  }
  onAuthStateChanged(e, n, r) {
    return this.registerStateListener(this.authStateSubscription, e, n, r)
  }
  beforeAuthStateChanged(e, n) {
    return this.beforeStateQueue.pushCallback(e, n)
  }
  onIdTokenChanged(e, n, r) {
    return this.registerStateListener(this.idTokenSubscription, e, n, r)
  }
  authStateReady() {
    return new Promise((e, n) => {
      if (this.currentUser) e()
      else {
        const r = this.onAuthStateChanged(() => {
          r(), e()
        }, n)
      }
    })
  }
  async revokeAccessToken(e) {
    if (this.currentUser) {
      const n = await this.currentUser.getIdToken(),
        r = { providerId: 'apple.com', tokenType: 'ACCESS_TOKEN', token: e, idToken: n }
      this.tenantId != null && (r.tenantId = this.tenantId), await X3(this, r)
    }
  }
  toJSON() {
    var e
    return {
      apiKey: this.config.apiKey,
      authDomain: this.config.authDomain,
      appName: this.name,
      currentUser: (e = this._currentUser) === null || e === void 0 ? void 0 : e.toJSON()
    }
  }
  async _setRedirectUser(e, n) {
    const r = await this.getOrInitRedirectPersistenceManager(n)
    return e === null ? r.removeCurrentUser() : r.setCurrentUser(e)
  }
  async getOrInitRedirectPersistenceManager(e) {
    if (!this.redirectPersistenceManager) {
      const n = (e && Di(e)) || this._popupRedirectResolver
      Le(n, this, 'argument-error'),
        (this.redirectPersistenceManager = await Wa.create(
          this,
          [Di(n._redirectPersistence)],
          'redirectUser'
        )),
        (this.redirectUser = await this.redirectPersistenceManager.getCurrentUser())
    }
    return this.redirectPersistenceManager
  }
  async _redirectUserForId(e) {
    var n, r
    return (
      this._isInitialized && (await this.queue(async () => {})),
      ((n = this._currentUser) === null || n === void 0 ? void 0 : n._redirectEventId) === e
        ? this._currentUser
        : ((r = this.redirectUser) === null || r === void 0 ? void 0 : r._redirectEventId) === e
        ? this.redirectUser
        : null
    )
  }
  async _persistUserIfCurrent(e) {
    if (e === this.currentUser) return this.queue(async () => this.directlySetCurrentUser(e))
  }
  _notifyListenersIfCurrent(e) {
    e === this.currentUser && this.notifyAuthListeners()
  }
  _key() {
    return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`
  }
  _startProactiveRefresh() {
    ;(this.isProactiveRefreshEnabled = !0),
      this.currentUser && this._currentUser._startProactiveRefresh()
  }
  _stopProactiveRefresh() {
    ;(this.isProactiveRefreshEnabled = !1),
      this.currentUser && this._currentUser._stopProactiveRefresh()
  }
  get _currentUser() {
    return this.currentUser
  }
  notifyAuthListeners() {
    var e, n
    if (!this._isInitialized) return
    this.idTokenSubscription.next(this.currentUser)
    const r =
      (n = (e = this.currentUser) === null || e === void 0 ? void 0 : e.uid) !== null &&
      n !== void 0
        ? n
        : null
    this.lastNotifiedUid !== r &&
      ((this.lastNotifiedUid = r), this.authStateSubscription.next(this.currentUser))
  }
  registerStateListener(e, n, r, i) {
    if (this._deleted) return () => {}
    const s = typeof n == 'function' ? n : n.next.bind(n)
    let o = !1
    const a = this._isInitialized ? Promise.resolve() : this._initializationPromise
    if (
      (Le(a, this, 'internal-error'),
      a.then(() => {
        o || s(this.currentUser)
      }),
      typeof n == 'function')
    ) {
      const l = e.addObserver(n, r, i)
      return () => {
        ;(o = !0), l()
      }
    } else {
      const l = e.addObserver(n)
      return () => {
        ;(o = !0), l()
      }
    }
  }
  async directlySetCurrentUser(e) {
    this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(),
      e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(),
      (this.currentUser = e),
      e
        ? await this.assertedPersistence.setCurrentUser(e)
        : await this.assertedPersistence.removeCurrentUser()
  }
  queue(e) {
    return (this.operations = this.operations.then(e, e)), this.operations
  }
  get assertedPersistence() {
    return Le(this.persistenceManager, this, 'internal-error'), this.persistenceManager
  }
  _logFramework(e) {
    !e ||
      this.frameworks.includes(e) ||
      (this.frameworks.push(e),
      this.frameworks.sort(),
      (this.clientVersion = yC(this.config.clientPlatform, this._getFrameworks())))
  }
  _getFrameworks() {
    return this.frameworks
  }
  async _getAdditionalHeaders() {
    var e
    const n = { 'X-Client-Version': this.clientVersion }
    this.app.options.appId && (n['X-Firebase-gmpid'] = this.app.options.appId)
    const r = await ((e = this.heartbeatServiceProvider.getImmediate({ optional: !0 })) === null ||
    e === void 0
      ? void 0
      : e.getHeartbeatsHeader())
    r && (n['X-Firebase-Client'] = r)
    const i = await this._getAppCheckToken()
    return i && (n['X-Firebase-AppCheck'] = i), n
  }
  async _getAppCheckToken() {
    var e
    const n = await ((e = this.appCheckServiceProvider.getImmediate({ optional: !0 })) === null ||
    e === void 0
      ? void 0
      : e.getToken())
    return (
      n != null && n.error && P3(`Error while retrieving App Check token: ${n.error}`),
      n == null ? void 0 : n.token
    )
  }
}
function Jv(t) {
  return sn(t)
}
class TE {
  constructor(e) {
    ;(this.auth = e), (this.observer = null), (this.addObserver = T4((n) => (this.observer = n)))
  }
  get next() {
    return Le(this.observer, this.auth, 'internal-error'), this.observer.next.bind(this.observer)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Qv = {
  async loadJS() {
    throw new Error('Unable to load external scripts')
  },
  recaptchaV2Script: '',
  recaptchaEnterpriseScript: '',
  gapiScript: ''
}
function aL(t) {
  Qv = t
}
function lL(t) {
  return Qv.loadJS(t)
}
function cL() {
  return Qv.gapiScript
}
function uL(t) {
  return `__${t}${Math.floor(Math.random() * 1e6)}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function hL(t, e) {
  const n = QA(t, 'auth')
  if (n.isInitialized()) {
    const i = n.getImmediate(),
      s = n.getOptions()
    if (lu(s, e ?? {})) return i
    gi(i, 'already-initialized')
  }
  return n.initialize({ options: e })
}
function dL(t, e) {
  const n = (e == null ? void 0 : e.persistence) || [],
    r = (Array.isArray(n) ? n : [n]).map(Di)
  e != null && e.errorMap && t._updateErrorMap(e.errorMap),
    t._initializeWithPersistence(r, e == null ? void 0 : e.popupRedirectResolver)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _C {
  constructor(e, n) {
    ;(this.providerId = e), (this.signInMethod = n)
  }
  toJSON() {
    return xi('not implemented')
  }
  _getIdTokenResponse(e) {
    return xi('not implemented')
  }
  _linkToIdToken(e, n) {
    return xi('not implemented')
  }
  _getReauthenticationResolver(e) {
    return xi('not implemented')
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Ga(t, e) {
  return U3(t, 'POST', '/v1/accounts:signInWithIdp', qv(t, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const fL = 'http://localhost'
class qo extends _C {
  constructor() {
    super(...arguments), (this.pendingToken = null)
  }
  static _fromParams(e) {
    const n = new qo(e.providerId, e.signInMethod)
    return (
      e.idToken || e.accessToken
        ? (e.idToken && (n.idToken = e.idToken),
          e.accessToken && (n.accessToken = e.accessToken),
          e.nonce && !e.pendingToken && (n.nonce = e.nonce),
          e.pendingToken && (n.pendingToken = e.pendingToken))
        : e.oauthToken && e.oauthTokenSecret
        ? ((n.accessToken = e.oauthToken), (n.secret = e.oauthTokenSecret))
        : gi('argument-error'),
      n
    )
  }
  toJSON() {
    return {
      idToken: this.idToken,
      accessToken: this.accessToken,
      secret: this.secret,
      nonce: this.nonce,
      pendingToken: this.pendingToken,
      providerId: this.providerId,
      signInMethod: this.signInMethod
    }
  }
  static fromJSON(e) {
    const n = typeof e == 'string' ? JSON.parse(e) : e,
      { providerId: r, signInMethod: i } = n,
      s = jv(n, ['providerId', 'signInMethod'])
    if (!r || !i) return null
    const o = new qo(r, i)
    return (
      (o.idToken = s.idToken || void 0),
      (o.accessToken = s.accessToken || void 0),
      (o.secret = s.secret),
      (o.nonce = s.nonce),
      (o.pendingToken = s.pendingToken || null),
      o
    )
  }
  _getIdTokenResponse(e) {
    const n = this.buildRequest()
    return Ga(e, n)
  }
  _linkToIdToken(e, n) {
    const r = this.buildRequest()
    return (r.idToken = n), Ga(e, r)
  }
  _getReauthenticationResolver(e) {
    const n = this.buildRequest()
    return (n.autoCreate = !1), Ga(e, n)
  }
  buildRequest() {
    const e = { requestUri: fL, returnSecureToken: !0 }
    if (this.pendingToken) e.pendingToken = this.pendingToken
    else {
      const n = {}
      this.idToken && (n.id_token = this.idToken),
        this.accessToken && (n.access_token = this.accessToken),
        this.secret && (n.oauth_token_secret = this.secret),
        (n.providerId = this.providerId),
        this.nonce && !this.pendingToken && (n.nonce = this.nonce),
        (e.postBody = Ll(n))
    }
    return e
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Xv {
  constructor(e) {
    ;(this.providerId = e), (this.defaultLanguageCode = null), (this.customParameters = {})
  }
  setDefaultLanguage(e) {
    this.defaultLanguageCode = e
  }
  setCustomParameters(e) {
    return (this.customParameters = e), this
  }
  getCustomParameters() {
    return this.customParameters
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ju extends Xv {
  constructor() {
    super(...arguments), (this.scopes = [])
  }
  addScope(e) {
    return this.scopes.includes(e) || this.scopes.push(e), this
  }
  getScopes() {
    return [...this.scopes]
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ys extends Ju {
  constructor() {
    super('facebook.com')
  }
  static credential(e) {
    return qo._fromParams({
      providerId: ys.PROVIDER_ID,
      signInMethod: ys.FACEBOOK_SIGN_IN_METHOD,
      accessToken: e
    })
  }
  static credentialFromResult(e) {
    return ys.credentialFromTaggedObject(e)
  }
  static credentialFromError(e) {
    return ys.credentialFromTaggedObject(e.customData || {})
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e || !('oauthAccessToken' in e) || !e.oauthAccessToken) return null
    try {
      return ys.credential(e.oauthAccessToken)
    } catch {
      return null
    }
  }
}
ys.FACEBOOK_SIGN_IN_METHOD = 'facebook.com'
ys.PROVIDER_ID = 'facebook.com'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Mi extends Ju {
  constructor() {
    super('google.com'), this.addScope('profile')
  }
  static credential(e, n) {
    return qo._fromParams({
      providerId: Mi.PROVIDER_ID,
      signInMethod: Mi.GOOGLE_SIGN_IN_METHOD,
      idToken: e,
      accessToken: n
    })
  }
  static credentialFromResult(e) {
    return Mi.credentialFromTaggedObject(e)
  }
  static credentialFromError(e) {
    return Mi.credentialFromTaggedObject(e.customData || {})
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e) return null
    const { oauthIdToken: n, oauthAccessToken: r } = e
    if (!n && !r) return null
    try {
      return Mi.credential(n, r)
    } catch {
      return null
    }
  }
}
Mi.GOOGLE_SIGN_IN_METHOD = 'google.com'
Mi.PROVIDER_ID = 'google.com'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _s extends Ju {
  constructor() {
    super('github.com')
  }
  static credential(e) {
    return qo._fromParams({
      providerId: _s.PROVIDER_ID,
      signInMethod: _s.GITHUB_SIGN_IN_METHOD,
      accessToken: e
    })
  }
  static credentialFromResult(e) {
    return _s.credentialFromTaggedObject(e)
  }
  static credentialFromError(e) {
    return _s.credentialFromTaggedObject(e.customData || {})
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e || !('oauthAccessToken' in e) || !e.oauthAccessToken) return null
    try {
      return _s.credential(e.oauthAccessToken)
    } catch {
      return null
    }
  }
}
_s.GITHUB_SIGN_IN_METHOD = 'github.com'
_s.PROVIDER_ID = 'github.com'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class vs extends Ju {
  constructor() {
    super('twitter.com')
  }
  static credential(e, n) {
    return qo._fromParams({
      providerId: vs.PROVIDER_ID,
      signInMethod: vs.TWITTER_SIGN_IN_METHOD,
      oauthToken: e,
      oauthTokenSecret: n
    })
  }
  static credentialFromResult(e) {
    return vs.credentialFromTaggedObject(e)
  }
  static credentialFromError(e) {
    return vs.credentialFromTaggedObject(e.customData || {})
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e) return null
    const { oauthAccessToken: n, oauthTokenSecret: r } = e
    if (!n || !r) return null
    try {
      return vs.credential(n, r)
    } catch {
      return null
    }
  }
}
vs.TWITTER_SIGN_IN_METHOD = 'twitter.com'
vs.PROVIDER_ID = 'twitter.com'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ll {
  constructor(e) {
    ;(this.user = e.user),
      (this.providerId = e.providerId),
      (this._tokenResponse = e._tokenResponse),
      (this.operationType = e.operationType)
  }
  static async _fromIdTokenResponse(e, n, r, i = !1) {
    const s = await Lo._fromIdTokenResponse(e, r, i),
      o = wE(r)
    return new ll({ user: s, providerId: o, _tokenResponse: r, operationType: n })
  }
  static async _forOperation(e, n, r) {
    await e._updateTokensIfNecessary(r, !0)
    const i = wE(r)
    return new ll({ user: e, providerId: i, _tokenResponse: r, operationType: n })
  }
}
function wE(t) {
  return t.providerId ? t.providerId : 'phoneNumber' in t ? 'phone' : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class of extends Ii {
  constructor(e, n, r, i) {
    var s
    super(n.code, n.message),
      (this.operationType = r),
      (this.user = i),
      Object.setPrototypeOf(this, of.prototype),
      (this.customData = {
        appName: e.name,
        tenantId: (s = e.tenantId) !== null && s !== void 0 ? s : void 0,
        _serverResponse: n.customData._serverResponse,
        operationType: r
      })
  }
  static _fromErrorAndOperation(e, n, r, i) {
    return new of(e, n, r, i)
  }
}
function vC(t, e, n, r) {
  return (
    e === 'reauthenticate' ? n._getReauthenticationResolver(t) : n._getIdTokenResponse(t)
  ).catch((s) => {
    throw s.code === 'auth/multi-factor-auth-required' ? of._fromErrorAndOperation(t, s, e, r) : s
  })
}
async function pL(t, e, n = !1) {
  const r = await uu(t, e._linkToIdToken(t.auth, await t.getIdToken()), n)
  return ll._forOperation(t, 'link', r)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function mL(t, e, n = !1) {
  const { auth: r } = t,
    i = 'reauthenticate'
  try {
    const s = await uu(t, vC(r, i, e, t), n)
    Le(s.idToken, r, 'internal-error')
    const o = Kv(s.idToken)
    Le(o, r, 'internal-error')
    const { sub: a } = o
    return Le(t.uid === a, r, 'user-mismatch'), ll._forOperation(t, i, s)
  } catch (s) {
    throw ((s == null ? void 0 : s.code) === 'auth/user-not-found' && gi(r, 'user-mismatch'), s)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function gL(t, e, n = !1) {
  const r = 'signIn',
    i = await vC(t, r, e),
    s = await ll._fromIdTokenResponse(t, r, i)
  return n || (await t._updateCurrentUser(s.user)), s
}
function yL(t, e, n, r) {
  return sn(t).onIdTokenChanged(e, n, r)
}
function _L(t) {
  return sn(t).signOut()
}
const af = '__sak'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class bC {
  constructor(e, n) {
    ;(this.storageRetriever = e), (this.type = n)
  }
  _isAvailable() {
    try {
      return this.storage
        ? (this.storage.setItem(af, '1'), this.storage.removeItem(af), Promise.resolve(!0))
        : Promise.resolve(!1)
    } catch {
      return Promise.resolve(!1)
    }
  }
  _set(e, n) {
    return this.storage.setItem(e, JSON.stringify(n)), Promise.resolve()
  }
  _get(e) {
    const n = this.storage.getItem(e)
    return Promise.resolve(n ? JSON.parse(n) : null)
  }
  _remove(e) {
    return this.storage.removeItem(e), Promise.resolve()
  }
  get storage() {
    return this.storageRetriever()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function vL() {
  const t = Ht()
  return Yv(t) || Rp(t)
}
const bL = 1e3,
  EL = 10
class EC extends bC {
  constructor() {
    super(() => window.localStorage, 'LOCAL'),
      (this.boundEventHandler = (e, n) => this.onStorageEvent(e, n)),
      (this.listeners = {}),
      (this.localCache = {}),
      (this.pollTimer = null),
      (this.safariLocalStorageNotSynced = vL() && tL()),
      (this.fallbackToPolling = gC()),
      (this._shouldAllowMigration = !0)
  }
  forAllChangedKeys(e) {
    for (const n of Object.keys(this.listeners)) {
      const r = this.storage.getItem(n),
        i = this.localCache[n]
      r !== i && e(n, i, r)
    }
  }
  onStorageEvent(e, n = !1) {
    if (!e.key) {
      this.forAllChangedKeys((o, a, l) => {
        this.notifyListeners(o, l)
      })
      return
    }
    const r = e.key
    if ((n ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced)) {
      const o = this.storage.getItem(r)
      if (e.newValue !== o)
        e.newValue !== null ? this.storage.setItem(r, e.newValue) : this.storage.removeItem(r)
      else if (this.localCache[r] === e.newValue && !n) return
    }
    const i = () => {
        const o = this.storage.getItem(r)
        ;(!n && this.localCache[r] === o) || this.notifyListeners(r, o)
      },
      s = this.storage.getItem(r)
    eL() && s !== e.newValue && e.newValue !== e.oldValue ? setTimeout(i, EL) : i()
  }
  notifyListeners(e, n) {
    this.localCache[e] = n
    const r = this.listeners[e]
    if (r) for (const i of Array.from(r)) i(n && JSON.parse(n))
  }
  startPolling() {
    this.stopPolling(),
      (this.pollTimer = setInterval(() => {
        this.forAllChangedKeys((e, n, r) => {
          this.onStorageEvent(new StorageEvent('storage', { key: e, oldValue: n, newValue: r }), !0)
        })
      }, bL))
  }
  stopPolling() {
    this.pollTimer && (clearInterval(this.pollTimer), (this.pollTimer = null))
  }
  attachListener() {
    window.addEventListener('storage', this.boundEventHandler)
  }
  detachListener() {
    window.removeEventListener('storage', this.boundEventHandler)
  }
  _addListener(e, n) {
    Object.keys(this.listeners).length === 0 &&
      (this.fallbackToPolling ? this.startPolling() : this.attachListener()),
      this.listeners[e] ||
        ((this.listeners[e] = new Set()), (this.localCache[e] = this.storage.getItem(e))),
      this.listeners[e].add(n)
  }
  _removeListener(e, n) {
    this.listeners[e] &&
      (this.listeners[e].delete(n), this.listeners[e].size === 0 && delete this.listeners[e]),
      Object.keys(this.listeners).length === 0 && (this.detachListener(), this.stopPolling())
  }
  async _set(e, n) {
    await super._set(e, n), (this.localCache[e] = JSON.stringify(n))
  }
  async _get(e) {
    const n = await super._get(e)
    return (this.localCache[e] = JSON.stringify(n)), n
  }
  async _remove(e) {
    await super._remove(e), delete this.localCache[e]
  }
}
EC.type = 'LOCAL'
const TL = EC
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class TC extends bC {
  constructor() {
    super(() => window.sessionStorage, 'SESSION')
  }
  _addListener(e, n) {}
  _removeListener(e, n) {}
}
TC.type = 'SESSION'
const wC = TC
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function wL(t) {
  return Promise.all(
    t.map(async (e) => {
      try {
        return { fulfilled: !0, value: await e }
      } catch (n) {
        return { fulfilled: !1, reason: n }
      }
    })
  )
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class kp {
  constructor(e) {
    ;(this.eventTarget = e),
      (this.handlersMap = {}),
      (this.boundEventHandler = this.handleEvent.bind(this))
  }
  static _getInstance(e) {
    const n = this.receivers.find((i) => i.isListeningto(e))
    if (n) return n
    const r = new kp(e)
    return this.receivers.push(r), r
  }
  isListeningto(e) {
    return this.eventTarget === e
  }
  async handleEvent(e) {
    const n = e,
      { eventId: r, eventType: i, data: s } = n.data,
      o = this.handlersMap[i]
    if (!(o != null && o.size)) return
    n.ports[0].postMessage({ status: 'ack', eventId: r, eventType: i })
    const a = Array.from(o).map(async (c) => c(n.origin, s)),
      l = await wL(a)
    n.ports[0].postMessage({ status: 'done', eventId: r, eventType: i, response: l })
  }
  _subscribe(e, n) {
    Object.keys(this.handlersMap).length === 0 &&
      this.eventTarget.addEventListener('message', this.boundEventHandler),
      this.handlersMap[e] || (this.handlersMap[e] = new Set()),
      this.handlersMap[e].add(n)
  }
  _unsubscribe(e, n) {
    this.handlersMap[e] && n && this.handlersMap[e].delete(n),
      (!n || this.handlersMap[e].size === 0) && delete this.handlersMap[e],
      Object.keys(this.handlersMap).length === 0 &&
        this.eventTarget.removeEventListener('message', this.boundEventHandler)
  }
}
kp.receivers = []
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Zv(t = '', e = 10) {
  let n = ''
  for (let r = 0; r < e; r++) n += Math.floor(Math.random() * 10)
  return t + n
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class SL {
  constructor(e) {
    ;(this.target = e), (this.handlers = new Set())
  }
  removeMessageHandler(e) {
    e.messageChannel &&
      (e.messageChannel.port1.removeEventListener('message', e.onMessage),
      e.messageChannel.port1.close()),
      this.handlers.delete(e)
  }
  async _send(e, n, r = 50) {
    const i = typeof MessageChannel < 'u' ? new MessageChannel() : null
    if (!i) throw new Error('connection_unavailable')
    let s, o
    return new Promise((a, l) => {
      const c = Zv('', 20)
      i.port1.start()
      const u = setTimeout(() => {
        l(new Error('unsupported_event'))
      }, r)
      ;(o = {
        messageChannel: i,
        onMessage(h) {
          const d = h
          if (d.data.eventId === c)
            switch (d.data.status) {
              case 'ack':
                clearTimeout(u),
                  (s = setTimeout(() => {
                    l(new Error('timeout'))
                  }, 3e3))
                break
              case 'done':
                clearTimeout(s), a(d.data.response)
                break
              default:
                clearTimeout(u), clearTimeout(s), l(new Error('invalid_response'))
                break
            }
        }
      }),
        this.handlers.add(o),
        i.port1.addEventListener('message', o.onMessage),
        this.target.postMessage({ eventType: e, eventId: c, data: n }, [i.port2])
    }).finally(() => {
      o && this.removeMessageHandler(o)
    })
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function ci() {
  return window
}
function IL(t) {
  ci().location.href = t
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function SC() {
  return typeof ci().WorkerGlobalScope < 'u' && typeof ci().importScripts == 'function'
}
async function AL() {
  if (!(navigator != null && navigator.serviceWorker)) return null
  try {
    return (await navigator.serviceWorker.ready).active
  } catch {
    return null
  }
}
function CL() {
  var t
  return (
    ((t = navigator == null ? void 0 : navigator.serviceWorker) === null || t === void 0
      ? void 0
      : t.controller) || null
  )
}
function RL() {
  return SC() ? self : null
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const IC = 'firebaseLocalStorageDb',
  kL = 1,
  lf = 'firebaseLocalStorage',
  AC = 'fbase_key'
class Qu {
  constructor(e) {
    this.request = e
  }
  toPromise() {
    return new Promise((e, n) => {
      this.request.addEventListener('success', () => {
        e(this.request.result)
      }),
        this.request.addEventListener('error', () => {
          n(this.request.error)
        })
    })
  }
}
function Op(t, e) {
  return t.transaction([lf], e ? 'readwrite' : 'readonly').objectStore(lf)
}
function OL() {
  const t = indexedDB.deleteDatabase(IC)
  return new Qu(t).toPromise()
}
function Ly() {
  const t = indexedDB.open(IC, kL)
  return new Promise((e, n) => {
    t.addEventListener('error', () => {
      n(t.error)
    }),
      t.addEventListener('upgradeneeded', () => {
        const r = t.result
        try {
          r.createObjectStore(lf, { keyPath: AC })
        } catch (i) {
          n(i)
        }
      }),
      t.addEventListener('success', async () => {
        const r = t.result
        r.objectStoreNames.contains(lf) ? e(r) : (r.close(), await OL(), e(await Ly()))
      })
  })
}
async function SE(t, e, n) {
  const r = Op(t, !0).put({ [AC]: e, value: n })
  return new Qu(r).toPromise()
}
async function NL(t, e) {
  const n = Op(t, !1).get(e),
    r = await new Qu(n).toPromise()
  return r === void 0 ? null : r.value
}
function IE(t, e) {
  const n = Op(t, !0).delete(e)
  return new Qu(n).toPromise()
}
const ML = 800,
  PL = 3
class CC {
  constructor() {
    ;(this.type = 'LOCAL'),
      (this._shouldAllowMigration = !0),
      (this.listeners = {}),
      (this.localCache = {}),
      (this.pollTimer = null),
      (this.pendingWrites = 0),
      (this.receiver = null),
      (this.sender = null),
      (this.serviceWorkerReceiverAvailable = !1),
      (this.activeServiceWorker = null),
      (this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(
        () => {},
        () => {}
      ))
  }
  async _openDb() {
    return this.db ? this.db : ((this.db = await Ly()), this.db)
  }
  async _withRetries(e) {
    let n = 0
    for (;;)
      try {
        const r = await this._openDb()
        return await e(r)
      } catch (r) {
        if (n++ > PL) throw r
        this.db && (this.db.close(), (this.db = void 0))
      }
  }
  async initializeServiceWorkerMessaging() {
    return SC() ? this.initializeReceiver() : this.initializeSender()
  }
  async initializeReceiver() {
    ;(this.receiver = kp._getInstance(RL())),
      this.receiver._subscribe('keyChanged', async (e, n) => ({
        keyProcessed: (await this._poll()).includes(n.key)
      })),
      this.receiver._subscribe('ping', async (e, n) => ['keyChanged'])
  }
  async initializeSender() {
    var e, n
    if (((this.activeServiceWorker = await AL()), !this.activeServiceWorker)) return
    this.sender = new SL(this.activeServiceWorker)
    const r = await this.sender._send('ping', {}, 800)
    r &&
      !((e = r[0]) === null || e === void 0) &&
      e.fulfilled &&
      !((n = r[0]) === null || n === void 0) &&
      n.value.includes('keyChanged') &&
      (this.serviceWorkerReceiverAvailable = !0)
  }
  async notifyServiceWorker(e) {
    if (!(!this.sender || !this.activeServiceWorker || CL() !== this.activeServiceWorker))
      try {
        await this.sender._send(
          'keyChanged',
          { key: e },
          this.serviceWorkerReceiverAvailable ? 800 : 50
        )
      } catch {}
  }
  async _isAvailable() {
    try {
      if (!indexedDB) return !1
      const e = await Ly()
      return await SE(e, af, '1'), await IE(e, af), !0
    } catch {}
    return !1
  }
  async _withPendingWrite(e) {
    this.pendingWrites++
    try {
      await e()
    } finally {
      this.pendingWrites--
    }
  }
  async _set(e, n) {
    return this._withPendingWrite(
      async () => (
        await this._withRetries((r) => SE(r, e, n)),
        (this.localCache[e] = n),
        this.notifyServiceWorker(e)
      )
    )
  }
  async _get(e) {
    const n = await this._withRetries((r) => NL(r, e))
    return (this.localCache[e] = n), n
  }
  async _remove(e) {
    return this._withPendingWrite(
      async () => (
        await this._withRetries((n) => IE(n, e)),
        delete this.localCache[e],
        this.notifyServiceWorker(e)
      )
    )
  }
  async _poll() {
    const e = await this._withRetries((i) => {
      const s = Op(i, !1).getAll()
      return new Qu(s).toPromise()
    })
    if (!e) return []
    if (this.pendingWrites !== 0) return []
    const n = [],
      r = new Set()
    if (e.length !== 0)
      for (const { fbase_key: i, value: s } of e)
        r.add(i),
          JSON.stringify(this.localCache[i]) !== JSON.stringify(s) &&
            (this.notifyListeners(i, s), n.push(i))
    for (const i of Object.keys(this.localCache))
      this.localCache[i] && !r.has(i) && (this.notifyListeners(i, null), n.push(i))
    return n
  }
  notifyListeners(e, n) {
    this.localCache[e] = n
    const r = this.listeners[e]
    if (r) for (const i of Array.from(r)) i(n)
  }
  startPolling() {
    this.stopPolling(), (this.pollTimer = setInterval(async () => this._poll(), ML))
  }
  stopPolling() {
    this.pollTimer && (clearInterval(this.pollTimer), (this.pollTimer = null))
  }
  _addListener(e, n) {
    Object.keys(this.listeners).length === 0 && this.startPolling(),
      this.listeners[e] || ((this.listeners[e] = new Set()), this._get(e)),
      this.listeners[e].add(n)
  }
  _removeListener(e, n) {
    this.listeners[e] &&
      (this.listeners[e].delete(n), this.listeners[e].size === 0 && delete this.listeners[e]),
      Object.keys(this.listeners).length === 0 && this.stopPolling()
  }
}
CC.type = 'LOCAL'
const xL = CC
new Yu(3e4, 6e4)
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function RC(t, e) {
  return e ? Di(e) : (Le(t._popupRedirectResolver, t, 'argument-error'), t._popupRedirectResolver)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class e0 extends _C {
  constructor(e) {
    super('custom', 'custom'), (this.params = e)
  }
  _getIdTokenResponse(e) {
    return Ga(e, this._buildIdpRequest())
  }
  _linkToIdToken(e, n) {
    return Ga(e, this._buildIdpRequest(n))
  }
  _getReauthenticationResolver(e) {
    return Ga(e, this._buildIdpRequest())
  }
  _buildIdpRequest(e) {
    const n = {
      requestUri: this.params.requestUri,
      sessionId: this.params.sessionId,
      postBody: this.params.postBody,
      tenantId: this.params.tenantId,
      pendingToken: this.params.pendingToken,
      returnSecureToken: !0,
      returnIdpCredential: !0
    }
    return e && (n.idToken = e), n
  }
}
function DL(t) {
  return gL(t.auth, new e0(t), t.bypassAuthState)
}
function LL(t) {
  const { auth: e, user: n } = t
  return Le(n, e, 'internal-error'), mL(n, new e0(t), t.bypassAuthState)
}
async function VL(t) {
  const { auth: e, user: n } = t
  return Le(n, e, 'internal-error'), pL(n, new e0(t), t.bypassAuthState)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class kC {
  constructor(e, n, r, i, s = !1) {
    ;(this.auth = e),
      (this.resolver = r),
      (this.user = i),
      (this.bypassAuthState = s),
      (this.pendingPromise = null),
      (this.eventManager = null),
      (this.filter = Array.isArray(n) ? n : [n])
  }
  execute() {
    return new Promise(async (e, n) => {
      this.pendingPromise = { resolve: e, reject: n }
      try {
        ;(this.eventManager = await this.resolver._initialize(this.auth)),
          await this.onExecution(),
          this.eventManager.registerConsumer(this)
      } catch (r) {
        this.reject(r)
      }
    })
  }
  async onAuthEvent(e) {
    const { urlResponse: n, sessionId: r, postBody: i, tenantId: s, error: o, type: a } = e
    if (o) {
      this.reject(o)
      return
    }
    const l = {
      auth: this.auth,
      requestUri: n,
      sessionId: r,
      tenantId: s || void 0,
      postBody: i || void 0,
      user: this.user,
      bypassAuthState: this.bypassAuthState
    }
    try {
      this.resolve(await this.getIdpTask(a)(l))
    } catch (c) {
      this.reject(c)
    }
  }
  onError(e) {
    this.reject(e)
  }
  getIdpTask(e) {
    switch (e) {
      case 'signInViaPopup':
      case 'signInViaRedirect':
        return DL
      case 'linkViaPopup':
      case 'linkViaRedirect':
        return VL
      case 'reauthViaPopup':
      case 'reauthViaRedirect':
        return LL
      default:
        gi(this.auth, 'internal-error')
    }
  }
  resolve(e) {
    zi(this.pendingPromise, 'Pending promise was never set'),
      this.pendingPromise.resolve(e),
      this.unregisterAndCleanUp()
  }
  reject(e) {
    zi(this.pendingPromise, 'Pending promise was never set'),
      this.pendingPromise.reject(e),
      this.unregisterAndCleanUp()
  }
  unregisterAndCleanUp() {
    this.eventManager && this.eventManager.unregisterConsumer(this),
      (this.pendingPromise = null),
      this.cleanUp()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const FL = new Yu(2e3, 1e4)
async function BL(t, e, n) {
  const r = Jv(t)
  x3(t, e, Xv)
  const i = RC(r, n)
  return new bo(r, 'signInViaPopup', e, i).executeNotNull()
}
class bo extends kC {
  constructor(e, n, r, i, s) {
    super(e, n, i, s),
      (this.provider = r),
      (this.authWindow = null),
      (this.pollId = null),
      bo.currentPopupAction && bo.currentPopupAction.cancel(),
      (bo.currentPopupAction = this)
  }
  async executeNotNull() {
    const e = await this.execute()
    return Le(e, this.auth, 'internal-error'), e
  }
  async onExecution() {
    zi(this.filter.length === 1, 'Popup operations only handle one event')
    const e = Zv()
    ;(this.authWindow = await this.resolver._openPopup(
      this.auth,
      this.provider,
      this.filter[0],
      e
    )),
      (this.authWindow.associatedEvent = e),
      this.resolver._originValidation(this.auth).catch((n) => {
        this.reject(n)
      }),
      this.resolver._isIframeWebStorageSupported(this.auth, (n) => {
        n || this.reject(li(this.auth, 'web-storage-unsupported'))
      }),
      this.pollUserCancellation()
  }
  get eventId() {
    var e
    return ((e = this.authWindow) === null || e === void 0 ? void 0 : e.associatedEvent) || null
  }
  cancel() {
    this.reject(li(this.auth, 'cancelled-popup-request'))
  }
  cleanUp() {
    this.authWindow && this.authWindow.close(),
      this.pollId && window.clearTimeout(this.pollId),
      (this.authWindow = null),
      (this.pollId = null),
      (bo.currentPopupAction = null)
  }
  pollUserCancellation() {
    const e = () => {
      var n, r
      if (
        !(
          (r = (n = this.authWindow) === null || n === void 0 ? void 0 : n.window) === null ||
          r === void 0
        ) &&
        r.closed
      ) {
        this.pollId = window.setTimeout(() => {
          ;(this.pollId = null), this.reject(li(this.auth, 'popup-closed-by-user'))
        }, 8e3)
        return
      }
      this.pollId = window.setTimeout(e, FL.get())
    }
    e()
  }
}
bo.currentPopupAction = null
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const UL = 'pendingRedirect',
  Id = new Map()
class $L extends kC {
  constructor(e, n, r = !1) {
    super(
      e,
      ['signInViaRedirect', 'linkViaRedirect', 'reauthViaRedirect', 'unknown'],
      n,
      void 0,
      r
    ),
      (this.eventId = null)
  }
  async execute() {
    let e = Id.get(this.auth._key())
    if (!e) {
      try {
        const r = (await HL(this.resolver, this.auth)) ? await super.execute() : null
        e = () => Promise.resolve(r)
      } catch (n) {
        e = () => Promise.reject(n)
      }
      Id.set(this.auth._key(), e)
    }
    return this.bypassAuthState || Id.set(this.auth._key(), () => Promise.resolve(null)), e()
  }
  async onAuthEvent(e) {
    if (e.type === 'signInViaRedirect') return super.onAuthEvent(e)
    if (e.type === 'unknown') {
      this.resolve(null)
      return
    }
    if (e.eventId) {
      const n = await this.auth._redirectUserForId(e.eventId)
      if (n) return (this.user = n), super.onAuthEvent(e)
      this.resolve(null)
    }
  }
  async onExecution() {}
  cleanUp() {}
}
async function HL(t, e) {
  const n = WL(e),
    r = jL(t)
  if (!(await r._isAvailable())) return !1
  const i = (await r._get(n)) === 'true'
  return await r._remove(n), i
}
function zL(t, e) {
  Id.set(t._key(), e)
}
function jL(t) {
  return Di(t._redirectPersistence)
}
function WL(t) {
  return Sd(UL, t.config.apiKey, t.name)
}
async function GL(t, e, n = !1) {
  const r = Jv(t),
    i = RC(r, e),
    o = await new $L(r, i, n).execute()
  return (
    o &&
      !n &&
      (delete o.user._redirectEventId,
      await r._persistUserIfCurrent(o.user),
      await r._setRedirectUser(null, e)),
    o
  )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const qL = 10 * 60 * 1e3
class KL {
  constructor(e) {
    ;(this.auth = e),
      (this.cachedEventUids = new Set()),
      (this.consumers = new Set()),
      (this.queuedRedirectEvent = null),
      (this.hasHandledPotentialRedirect = !1),
      (this.lastProcessedEventTime = Date.now())
  }
  registerConsumer(e) {
    this.consumers.add(e),
      this.queuedRedirectEvent &&
        this.isEventForConsumer(this.queuedRedirectEvent, e) &&
        (this.sendToConsumer(this.queuedRedirectEvent, e),
        this.saveEventToCache(this.queuedRedirectEvent),
        (this.queuedRedirectEvent = null))
  }
  unregisterConsumer(e) {
    this.consumers.delete(e)
  }
  onEvent(e) {
    if (this.hasEventBeenHandled(e)) return !1
    let n = !1
    return (
      this.consumers.forEach((r) => {
        this.isEventForConsumer(e, r) &&
          ((n = !0), this.sendToConsumer(e, r), this.saveEventToCache(e))
      }),
      this.hasHandledPotentialRedirect ||
        !YL(e) ||
        ((this.hasHandledPotentialRedirect = !0), n || ((this.queuedRedirectEvent = e), (n = !0))),
      n
    )
  }
  sendToConsumer(e, n) {
    var r
    if (e.error && !OC(e)) {
      const i =
        ((r = e.error.code) === null || r === void 0 ? void 0 : r.split('auth/')[1]) ||
        'internal-error'
      n.onError(li(this.auth, i))
    } else n.onAuthEvent(e)
  }
  isEventForConsumer(e, n) {
    const r = n.eventId === null || (!!e.eventId && e.eventId === n.eventId)
    return n.filter.includes(e.type) && r
  }
  hasEventBeenHandled(e) {
    return (
      Date.now() - this.lastProcessedEventTime >= qL && this.cachedEventUids.clear(),
      this.cachedEventUids.has(AE(e))
    )
  }
  saveEventToCache(e) {
    this.cachedEventUids.add(AE(e)), (this.lastProcessedEventTime = Date.now())
  }
}
function AE(t) {
  return [t.type, t.eventId, t.sessionId, t.tenantId].filter((e) => e).join('-')
}
function OC({ type: t, error: e }) {
  return t === 'unknown' && (e == null ? void 0 : e.code) === 'auth/no-auth-event'
}
function YL(t) {
  switch (t.type) {
    case 'signInViaRedirect':
    case 'linkViaRedirect':
    case 'reauthViaRedirect':
      return !0
    case 'unknown':
      return OC(t)
    default:
      return !1
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function JL(t, e = {}) {
  return Vl(t, 'GET', '/v1/projects', e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const QL = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
  XL = /^https?/
async function ZL(t) {
  if (t.config.emulator) return
  const { authorizedDomains: e } = await JL(t)
  for (const n of e)
    try {
      if (e6(n)) return
    } catch {}
  gi(t, 'unauthorized-domain')
}
function e6(t) {
  const e = Dy(),
    { protocol: n, hostname: r } = new URL(e)
  if (t.startsWith('chrome-extension://')) {
    const o = new URL(t)
    return o.hostname === '' && r === ''
      ? n === 'chrome-extension:' &&
          t.replace('chrome-extension://', '') === e.replace('chrome-extension://', '')
      : n === 'chrome-extension:' && o.hostname === r
  }
  if (!XL.test(n)) return !1
  if (QL.test(t)) return r === t
  const i = t.replace(/\./g, '\\.')
  return new RegExp('^(.+\\.' + i + '|' + i + ')$', 'i').test(r)
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const t6 = new Yu(3e4, 6e4)
function CE() {
  const t = ci().___jsl
  if (t != null && t.H) {
    for (const e of Object.keys(t.H))
      if (
        ((t.H[e].r = t.H[e].r || []), (t.H[e].L = t.H[e].L || []), (t.H[e].r = [...t.H[e].L]), t.CP)
      )
        for (let n = 0; n < t.CP.length; n++) t.CP[n] = null
  }
}
function n6(t) {
  return new Promise((e, n) => {
    var r, i, s
    function o() {
      CE(),
        gapi.load('gapi.iframes', {
          callback: () => {
            e(gapi.iframes.getContext())
          },
          ontimeout: () => {
            CE(), n(li(t, 'network-request-failed'))
          },
          timeout: t6.get()
        })
    }
    if (
      !(
        (i = (r = ci().gapi) === null || r === void 0 ? void 0 : r.iframes) === null || i === void 0
      ) &&
      i.Iframe
    )
      e(gapi.iframes.getContext())
    else if (!((s = ci().gapi) === null || s === void 0) && s.load) o()
    else {
      const a = uL('iframefcb')
      return (
        (ci()[a] = () => {
          gapi.load ? o() : n(li(t, 'network-request-failed'))
        }),
        lL(`${cL()}?onload=${a}`).catch((l) => n(l))
      )
    }
  }).catch((e) => {
    throw ((Ad = null), e)
  })
}
let Ad = null
function r6(t) {
  return (Ad = Ad || n6(t)), Ad
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const i6 = new Yu(5e3, 15e3),
  s6 = '__/auth/iframe',
  o6 = 'emulator/auth/iframe',
  a6 = {
    style: { position: 'absolute', top: '-100px', width: '1px', height: '1px' },
    'aria-hidden': 'true',
    tabindex: '-1'
  },
  l6 = new Map([
    ['identitytoolkit.googleapis.com', 'p'],
    ['staging-identitytoolkit.sandbox.googleapis.com', 's'],
    ['test-identitytoolkit.sandbox.googleapis.com', 't']
  ])
function c6(t) {
  const e = t.config
  Le(e.authDomain, t, 'auth-domain-config-required')
  const n = e.emulator ? Gv(e, o6) : `https://${t.config.authDomain}/${s6}`,
    r = { apiKey: e.apiKey, appName: t.name, v: Ys },
    i = l6.get(t.config.apiHost)
  i && (r.eid = i)
  const s = t._getFrameworks()
  return s.length && (r.fw = s.join(',')), `${n}?${Ll(r).slice(1)}`
}
async function u6(t) {
  const e = await r6(t),
    n = ci().gapi
  return (
    Le(n, t, 'internal-error'),
    e.open(
      {
        where: document.body,
        url: c6(t),
        messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
        attributes: a6,
        dontclear: !0
      },
      (r) =>
        new Promise(async (i, s) => {
          await r.restyle({ setHideOnLeave: !1 })
          const o = li(t, 'network-request-failed'),
            a = ci().setTimeout(() => {
              s(o)
            }, i6.get())
          function l() {
            ci().clearTimeout(a), i(r)
          }
          r.ping(l).then(l, () => {
            s(o)
          })
        })
    )
  )
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const h6 = { location: 'yes', resizable: 'yes', statusbar: 'yes', toolbar: 'no' },
  d6 = 500,
  f6 = 600,
  p6 = '_blank',
  m6 = 'http://localhost'
class RE {
  constructor(e) {
    ;(this.window = e), (this.associatedEvent = null)
  }
  close() {
    if (this.window)
      try {
        this.window.close()
      } catch {}
  }
}
function g6(t, e, n, r = d6, i = f6) {
  const s = Math.max((window.screen.availHeight - i) / 2, 0).toString(),
    o = Math.max((window.screen.availWidth - r) / 2, 0).toString()
  let a = ''
  const l = Object.assign(Object.assign({}, h6), {
      width: r.toString(),
      height: i.toString(),
      top: s,
      left: o
    }),
    c = Ht().toLowerCase()
  n && (a = hC(c) ? p6 : n), uC(c) && ((e = e || m6), (l.scrollbars = 'yes'))
  const u = Object.entries(l).reduce((d, [f, p]) => `${d}${f}=${p},`, '')
  if (Z3(c) && a !== '_self') return y6(e || '', a), new RE(null)
  const h = window.open(e || '', a, u)
  Le(h, t, 'popup-blocked')
  try {
    h.focus()
  } catch {}
  return new RE(h)
}
function y6(t, e) {
  const n = document.createElement('a')
  ;(n.href = t), (n.target = e)
  const r = document.createEvent('MouseEvent')
  r.initMouseEvent('click', !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null),
    n.dispatchEvent(r)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const _6 = '__/auth/handler',
  v6 = 'emulator/auth/handler',
  b6 = encodeURIComponent('fac')
async function kE(t, e, n, r, i, s) {
  Le(t.config.authDomain, t, 'auth-domain-config-required'),
    Le(t.config.apiKey, t, 'invalid-api-key')
  const o = {
    apiKey: t.config.apiKey,
    appName: t.name,
    authType: n,
    redirectUrl: r,
    v: Ys,
    eventId: i
  }
  if (e instanceof Xv) {
    e.setDefaultLanguage(t.languageCode),
      (o.providerId = e.providerId || ''),
      ky(e.getCustomParameters()) || (o.customParameters = JSON.stringify(e.getCustomParameters()))
    for (const [u, h] of Object.entries(s || {})) o[u] = h
  }
  if (e instanceof Ju) {
    const u = e.getScopes().filter((h) => h !== '')
    u.length > 0 && (o.scopes = u.join(','))
  }
  t.tenantId && (o.tid = t.tenantId)
  const a = o
  for (const u of Object.keys(a)) a[u] === void 0 && delete a[u]
  const l = await t._getAppCheckToken(),
    c = l ? `#${b6}=${encodeURIComponent(l)}` : ''
  return `${E6(t)}?${Ll(a).slice(1)}${c}`
}
function E6({ config: t }) {
  return t.emulator ? Gv(t, v6) : `https://${t.authDomain}/${_6}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Qm = 'webStorageSupport'
class T6 {
  constructor() {
    ;(this.eventManagers = {}),
      (this.iframes = {}),
      (this.originValidationPromises = {}),
      (this._redirectPersistence = wC),
      (this._completeRedirectFn = GL),
      (this._overrideRedirectResult = zL)
  }
  async _openPopup(e, n, r, i) {
    var s
    zi(
      (s = this.eventManagers[e._key()]) === null || s === void 0 ? void 0 : s.manager,
      '_initialize() not called before _openPopup()'
    )
    const o = await kE(e, n, r, Dy(), i)
    return g6(e, o, Zv())
  }
  async _openRedirect(e, n, r, i) {
    await this._originValidation(e)
    const s = await kE(e, n, r, Dy(), i)
    return IL(s), new Promise(() => {})
  }
  _initialize(e) {
    const n = e._key()
    if (this.eventManagers[n]) {
      const { manager: i, promise: s } = this.eventManagers[n]
      return i ? Promise.resolve(i) : (zi(s, 'If manager is not set, promise should be'), s)
    }
    const r = this.initAndGetManager(e)
    return (
      (this.eventManagers[n] = { promise: r }),
      r.catch(() => {
        delete this.eventManagers[n]
      }),
      r
    )
  }
  async initAndGetManager(e) {
    const n = await u6(e),
      r = new KL(e)
    return (
      n.register(
        'authEvent',
        (i) => (
          Le(i == null ? void 0 : i.authEvent, e, 'invalid-auth-event'),
          { status: r.onEvent(i.authEvent) ? 'ACK' : 'ERROR' }
        ),
        gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER
      ),
      (this.eventManagers[e._key()] = { manager: r }),
      (this.iframes[e._key()] = n),
      r
    )
  }
  _isIframeWebStorageSupported(e, n) {
    this.iframes[e._key()].send(
      Qm,
      { type: Qm },
      (i) => {
        var s
        const o = (s = i == null ? void 0 : i[0]) === null || s === void 0 ? void 0 : s[Qm]
        o !== void 0 && n(!!o), gi(e, 'internal-error')
      },
      gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER
    )
  }
  _originValidation(e) {
    const n = e._key()
    return (
      this.originValidationPromises[n] || (this.originValidationPromises[n] = ZL(e)),
      this.originValidationPromises[n]
    )
  }
  get _shouldInitProactively() {
    return gC() || Yv() || Rp()
  }
}
const w6 = T6
var OE = '@firebase/auth',
  NE = '1.6.2'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class S6 {
  constructor(e) {
    ;(this.auth = e), (this.internalListeners = new Map())
  }
  getUid() {
    var e
    return (
      this.assertAuthConfigured(),
      ((e = this.auth.currentUser) === null || e === void 0 ? void 0 : e.uid) || null
    )
  }
  async getToken(e) {
    return (
      this.assertAuthConfigured(),
      await this.auth._initializationPromise,
      this.auth.currentUser ? { accessToken: await this.auth.currentUser.getIdToken(e) } : null
    )
  }
  addAuthTokenListener(e) {
    if ((this.assertAuthConfigured(), this.internalListeners.has(e))) return
    const n = this.auth.onIdTokenChanged((r) => {
      e((r == null ? void 0 : r.stsTokenManager.accessToken) || null)
    })
    this.internalListeners.set(e, n), this.updateProactiveRefresh()
  }
  removeAuthTokenListener(e) {
    this.assertAuthConfigured()
    const n = this.internalListeners.get(e)
    n && (this.internalListeners.delete(e), n(), this.updateProactiveRefresh())
  }
  assertAuthConfigured() {
    Le(this.auth._initializationPromise, 'dependent-sdk-initialized-before-auth')
  }
  updateProactiveRefresh() {
    this.internalListeners.size > 0
      ? this.auth._startProactiveRefresh()
      : this.auth._stopProactiveRefresh()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function I6(t) {
  switch (t) {
    case 'Node':
      return 'node'
    case 'ReactNative':
      return 'rn'
    case 'Worker':
      return 'webworker'
    case 'Cordova':
      return 'cordova'
    case 'WebExtension':
      return 'web-extension'
    default:
      return
  }
}
function A6(t) {
  mi(
    new Ur(
      'auth',
      (e, { options: n }) => {
        const r = e.getProvider('app').getImmediate(),
          i = e.getProvider('heartbeat'),
          s = e.getProvider('app-check-internal'),
          { apiKey: o, authDomain: a } = r.options
        Le(o && !o.includes(':'), 'invalid-api-key', { appName: r.name })
        const l = {
            apiKey: o,
            authDomain: a,
            clientPlatform: t,
            apiHost: 'identitytoolkit.googleapis.com',
            tokenApiHost: 'securetoken.googleapis.com',
            apiScheme: 'https',
            sdkClientVersion: yC(t)
          },
          c = new oL(r, i, s, l)
        return dL(c, n), c
      },
      'PUBLIC'
    )
      .setInstantiationMode('EXPLICIT')
      .setInstanceCreatedCallback((e, n, r) => {
        e.getProvider('auth-internal').initialize()
      })
  ),
    mi(
      new Ur(
        'auth-internal',
        (e) => {
          const n = Jv(e.getProvider('auth').getImmediate())
          return ((r) => new S6(r))(n)
        },
        'PRIVATE'
      ).setInstantiationMode('EXPLICIT')
    ),
    ar(OE, NE, I6(t)),
    ar(OE, NE, 'esm2017')
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const C6 = 5 * 60
c4('authIdTokenMaxAge')
function R6() {
  var t, e
  return (e =
    (t = document.getElementsByTagName('head')) === null || t === void 0 ? void 0 : t[0]) !==
    null && e !== void 0
    ? e
    : document
}
aL({
  loadJS(t) {
    return new Promise((e, n) => {
      const r = document.createElement('script')
      r.setAttribute('src', t),
        (r.onload = e),
        (r.onerror = (i) => {
          const s = li('internal-error')
          ;(s.customData = i), n(s)
        }),
        (r.type = 'text/javascript'),
        (r.charset = 'UTF-8'),
        R6().appendChild(r)
    })
  },
  gapiScript: 'https://apis.google.com/js/api.js',
  recaptchaV2Script: 'https://www.google.com/recaptcha/api.js',
  recaptchaEnterpriseScript: 'https://www.google.com/recaptcha/enterprise.js?render='
})
A6('Browser')
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const k6 = new Map(),
  O6 = { activated: !1, tokenObservers: [] }
function $r(t) {
  return k6.get(t) || Object.assign({}, O6)
}
const ME = {
  OFFSET_DURATION: 5 * 60 * 1e3,
  RETRIAL_MIN_WAIT: 30 * 1e3,
  RETRIAL_MAX_WAIT: 16 * 60 * 1e3
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class N6 {
  constructor(e, n, r, i, s) {
    if (
      ((this.operation = e),
      (this.retryPolicy = n),
      (this.getWaitDuration = r),
      (this.lowerBound = i),
      (this.upperBound = s),
      (this.pending = null),
      (this.nextErrorWaitInterval = i),
      i > s)
    )
      throw new Error('Proactive refresh lower bound greater than upper bound!')
  }
  start() {
    ;(this.nextErrorWaitInterval = this.lowerBound), this.process(!0).catch(() => {})
  }
  stop() {
    this.pending && (this.pending.reject('cancelled'), (this.pending = null))
  }
  isRunning() {
    return !!this.pending
  }
  async process(e) {
    this.stop()
    try {
      ;(this.pending = new ou()),
        this.pending.promise.catch((n) => {}),
        await M6(this.getNextRun(e)),
        this.pending.resolve(),
        await this.pending.promise,
        (this.pending = new ou()),
        this.pending.promise.catch((n) => {}),
        await this.operation(),
        this.pending.resolve(),
        await this.pending.promise,
        this.process(!0).catch(() => {})
    } catch (n) {
      this.retryPolicy(n) ? this.process(!1).catch(() => {}) : this.stop()
    }
  }
  getNextRun(e) {
    if (e) return (this.nextErrorWaitInterval = this.lowerBound), this.getWaitDuration()
    {
      const n = this.nextErrorWaitInterval
      return (
        (this.nextErrorWaitInterval *= 2),
        this.nextErrorWaitInterval > this.upperBound &&
          (this.nextErrorWaitInterval = this.upperBound),
        n
      )
    }
  }
}
function M6(t) {
  return new Promise((e) => {
    setTimeout(e, t)
  })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const P6 = {
    'already-initialized':
      'You have already called initializeAppCheck() for FirebaseApp {$appName} with different options. To avoid this error, call initializeAppCheck() with the same options as when it was originally called. This will return the already initialized instance.',
    'use-before-activation':
      'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. Call initializeAppCheck() before instantiating other Firebase services.',
    'fetch-network-error':
      'Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.',
    'fetch-parse-error':
      'Fetch client could not parse response. Original error: {$originalErrorMessage}.',
    'fetch-status-error': 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',
    'storage-open': 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',
    'storage-get':
      'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',
    'storage-set': 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',
    'recaptcha-error': 'ReCAPTCHA error.',
    throttled: 'Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}'
  },
  cf = new Dl('appCheck', 'AppCheck', P6)
function NC(t) {
  if (!$r(t).activated) throw cf.create('use-before-activation', { appName: t.name })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const x6 = 'firebase-app-check-database',
  D6 = 1,
  Vy = 'firebase-app-check-store'
let $h = null
function L6() {
  return (
    $h ||
    (($h = new Promise((t, e) => {
      try {
        const n = indexedDB.open(x6, D6)
        ;(n.onsuccess = (r) => {
          t(r.target.result)
        }),
          (n.onerror = (r) => {
            var i
            e(
              cf.create('storage-open', {
                originalErrorMessage:
                  (i = r.target.error) === null || i === void 0 ? void 0 : i.message
              })
            )
          }),
          (n.onupgradeneeded = (r) => {
            const i = r.target.result
            switch (r.oldVersion) {
              case 0:
                i.createObjectStore(Vy, { keyPath: 'compositeKey' })
            }
          })
      } catch (n) {
        e(cf.create('storage-open', { originalErrorMessage: n == null ? void 0 : n.message }))
      }
    })),
    $h)
  )
}
function V6(t, e) {
  return F6(B6(t), e)
}
async function F6(t, e) {
  const r = (await L6()).transaction(Vy, 'readwrite'),
    s = r.objectStore(Vy).put({ compositeKey: t, value: e })
  return new Promise((o, a) => {
    ;(s.onsuccess = (l) => {
      o()
    }),
      (r.onerror = (l) => {
        var c
        a(
          cf.create('storage-set', {
            originalErrorMessage: (c = l.target.error) === null || c === void 0 ? void 0 : c.message
          })
        )
      })
  })
}
function B6(t) {
  return `${t.options.appId}-${t.name}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Fy = new Ku('@firebase/app-check')
function PE(t, e) {
  return Hv()
    ? V6(t, e).catch((n) => {
        Fy.warn(`Failed to write token to IndexedDB. Error: ${n}`)
      })
    : Promise.resolve()
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const U6 = { error: 'UNKNOWN_ERROR' }
function $6(t) {
  return Ip.encodeString(JSON.stringify(t), !1)
}
async function By(t, e = !1) {
  const n = t.app
  NC(n)
  const r = $r(n)
  let i = r.token,
    s
  if ((i && !cc(i) && ((r.token = void 0), (i = void 0)), !i)) {
    const l = await r.cachedTokenPromise
    l && (cc(l) ? (i = l) : await PE(n, void 0))
  }
  if (!e && i && cc(i)) return { token: i.token }
  let o = !1
  try {
    r.exchangeTokenPromise ||
      ((r.exchangeTokenPromise = r.provider.getToken().finally(() => {
        r.exchangeTokenPromise = void 0
      })),
      (o = !0)),
      (i = await $r(n).exchangeTokenPromise)
  } catch (l) {
    l.code === 'appCheck/throttled' ? Fy.warn(l.message) : Fy.error(l), (s = l)
  }
  let a
  return (
    i
      ? s
        ? cc(i)
          ? (a = { token: i.token, internalError: s })
          : (a = DE(s))
        : ((a = { token: i.token }), (r.token = i), await PE(n, i))
      : (a = DE(s)),
    o && W6(n, a),
    a
  )
}
async function H6(t) {
  const e = t.app
  NC(e)
  const { provider: n } = $r(e)
  {
    const { token: r } = await n.getToken()
    return { token: r }
  }
}
function z6(t, e, n, r) {
  const { app: i } = t,
    s = $r(i),
    o = { next: n, error: r, type: e }
  if (((s.tokenObservers = [...s.tokenObservers, o]), s.token && cc(s.token))) {
    const a = s.token
    Promise.resolve()
      .then(() => {
        n({ token: a.token }), xE(t)
      })
      .catch(() => {})
  }
  s.cachedTokenPromise.then(() => xE(t))
}
function MC(t, e) {
  const n = $r(t),
    r = n.tokenObservers.filter((i) => i.next !== e)
  r.length === 0 && n.tokenRefresher && n.tokenRefresher.isRunning() && n.tokenRefresher.stop(),
    (n.tokenObservers = r)
}
function xE(t) {
  const { app: e } = t,
    n = $r(e)
  let r = n.tokenRefresher
  r || ((r = j6(t)), (n.tokenRefresher = r)),
    !r.isRunning() && n.isTokenAutoRefreshEnabled && r.start()
}
function j6(t) {
  const { app: e } = t
  return new N6(
    async () => {
      const n = $r(e)
      let r
      if ((n.token ? (r = await By(t, !0)) : (r = await By(t)), r.error)) throw r.error
      if (r.internalError) throw r.internalError
    },
    () => !0,
    () => {
      const n = $r(e)
      if (n.token) {
        let r =
          n.token.issuedAtTimeMillis +
          (n.token.expireTimeMillis - n.token.issuedAtTimeMillis) * 0.5 +
          3e5
        const i = n.token.expireTimeMillis - 5 * 60 * 1e3
        return (r = Math.min(r, i)), Math.max(0, r - Date.now())
      } else return 0
    },
    ME.RETRIAL_MIN_WAIT,
    ME.RETRIAL_MAX_WAIT
  )
}
function W6(t, e) {
  const n = $r(t).tokenObservers
  for (const r of n)
    try {
      r.type === 'EXTERNAL' && e.error != null ? r.error(e.error) : r.next(e)
    } catch {}
}
function cc(t) {
  return t.expireTimeMillis - Date.now() > 0
}
function DE(t) {
  return { token: $6(U6), error: t }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class G6 {
  constructor(e, n) {
    ;(this.app = e), (this.heartbeatServiceProvider = n)
  }
  _delete() {
    const { tokenObservers: e } = $r(this.app)
    for (const n of e) MC(this.app, n.next)
    return Promise.resolve()
  }
}
function q6(t, e) {
  return new G6(t, e)
}
function K6(t) {
  return {
    getToken: (e) => By(t, e),
    getLimitedUseToken: () => H6(t),
    addTokenListener: (e) => z6(t, 'INTERNAL', e),
    removeTokenListener: (e) => MC(t.app, e)
  }
}
const Y6 = '@firebase/app-check',
  J6 = '0.8.2',
  Q6 = 'app-check',
  LE = 'app-check-internal'
function X6() {
  mi(
    new Ur(
      Q6,
      (t) => {
        const e = t.getProvider('app').getImmediate(),
          n = t.getProvider('heartbeat')
        return q6(e, n)
      },
      'PUBLIC'
    )
      .setInstantiationMode('EXPLICIT')
      .setInstanceCreatedCallback((t, e, n) => {
        t.getProvider(LE).initialize()
      })
  ),
    mi(
      new Ur(
        LE,
        (t) => {
          const e = t.getProvider('app-check').getImmediate()
          return K6(e)
        },
        'PUBLIC'
      ).setInstantiationMode('EXPLICIT')
    ),
    ar(Y6, J6)
}
X6()
var Z6 = 'firebase',
  e5 = '10.9.0'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ ar(Z6, e5, 'app')
const PC = Symbol('firebaseApp')
function Np(t) {
  return (ca() && Kn(PC, null)) || ZA(t)
}
const ei = () => {},
  t5 = typeof window < 'u'
function t0(t, e) {
  return e.split('.').reduce((n, r) => n && n[r], t)
}
function n5(t, e, n) {
  const r = ('' + e).split('.'),
    i = r.pop(),
    s = r.reduce((o, a) => o && o[a], t)
  if (s != null) return Array.isArray(s) ? s.splice(Number(i), 1, n) : (s[i] = n)
}
function ua(t) {
  return !!t && typeof t == 'object'
}
const r5 = Object.prototype
function i5(t) {
  return ua(t) && Object.getPrototypeOf(t) === r5
}
function n0(t) {
  return ua(t) && t.type === 'document'
}
function s5(t) {
  return ua(t) && t.type === 'collection'
}
function o5(t) {
  return n0(t) || s5(t)
}
function a5(t) {
  return ua(t) && t.type === 'query'
}
function l5(t) {
  return ua(t) && 'ref' in t
}
function c5(t) {
  return ua(t) && typeof t.bucket == 'string'
}
function u5(t, e) {
  let n
  return () => {
    if (!n) return (n = !0), t(e())
  }
}
const h5 = Symbol.for('v-scx')
function d5() {
  return !!Kn(h5, 0)
}
const Hh = new WeakMap()
function f5(t, e) {
  if (!Hh.has(t)) {
    const n = jI(!0)
    Hh.set(t, n)
    const { unmount: r } = e
    e.unmount = () => {
      r.call(e), n.stop(), Hh.delete(t)
    }
  }
  return Hh.get(t)
}
const xC = new WeakMap()
function DC(t) {
  return xC.get(Np(t))
}
const zh = new WeakMap()
function LC(t) {
  const e = Np(t)
  if (!zh.has(e)) {
    let n
    const i = [
      new Promise((s) => {
        n = s
      }),
      (s) => {
        zh.set(e, s), n(s.value)
      }
    ]
    zh.set(e, i)
  }
  return zh.get(e)
}
function p5(t) {
  const e = LC(t)
  return Array.isArray(e) ? e[0] : Promise.resolve(e.value)
}
function m5(t, e) {
  yL(e, (n) => {
    const r = LC()
    ;(t.value = n), Array.isArray(r) && r[1](t)
  })
}
var VE = {}
const FE = '@firebase/database',
  BE = '1.0.3'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let VC = ''
function g5(t) {
  VC = t
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class y5 {
  constructor(e) {
    ;(this.domStorage_ = e), (this.prefix_ = 'firebase:')
  }
  set(e, n) {
    n == null
      ? this.domStorage_.removeItem(this.prefixedName_(e))
      : this.domStorage_.setItem(this.prefixedName_(e), _n(n))
  }
  get(e) {
    const n = this.domStorage_.getItem(this.prefixedName_(e))
    return n == null ? null : au(n)
  }
  remove(e) {
    this.domStorage_.removeItem(this.prefixedName_(e))
  }
  prefixedName_(e) {
    return this.prefix_ + e
  }
  toString() {
    return this.domStorage_.toString()
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _5 {
  constructor() {
    ;(this.cache_ = {}), (this.isInMemoryStorage = !0)
  }
  set(e, n) {
    n == null ? delete this.cache_[e] : (this.cache_[e] = n)
  }
  get(e) {
    return Qi(this.cache_, e) ? this.cache_[e] : null
  }
  remove(e) {
    delete this.cache_[e]
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const FC = function (t) {
    try {
      if (typeof window < 'u' && typeof window[t] < 'u') {
        const e = window[t]
        return e.setItem('firebase:sentinel', 'cache'), e.removeItem('firebase:sentinel'), new y5(e)
      }
    } catch {}
    return new _5()
  },
  Eo = FC('localStorage'),
  Uy = FC('sessionStorage')
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const qa = new Ku('@firebase/database'),
  v5 = (function () {
    let t = 1
    return function () {
      return t++
    }
  })(),
  BC = function (t) {
    const e = A4(t),
      n = new E4()
    n.update(e)
    const r = n.digest()
    return Ip.encodeByteArray(r)
  },
  Xu = function (...t) {
    let e = ''
    for (let n = 0; n < t.length; n++) {
      const r = t[n]
      Array.isArray(r) || (r && typeof r == 'object' && typeof r.length == 'number')
        ? (e += Xu.apply(null, r))
        : typeof r == 'object'
        ? (e += _n(r))
        : (e += r),
        (e += ' ')
    }
    return e
  }
let Vo = null,
  UE = !0
const b5 = function (t, e) {
    te(!e || t === !0 || t === !1, "Can't turn on custom loggers persistently."),
      t === !0
        ? ((qa.logLevel = He.VERBOSE), (Vo = qa.log.bind(qa)), e && Uy.set('logging_enabled', !0))
        : typeof t == 'function'
        ? (Vo = t)
        : ((Vo = null), Uy.remove('logging_enabled'))
  },
  Cn = function (...t) {
    if ((UE === !0 && ((UE = !1), Vo === null && Uy.get('logging_enabled') === !0 && b5(!0)), Vo)) {
      const e = Xu.apply(null, t)
      Vo(e)
    }
  },
  Zu = function (t) {
    return function (...e) {
      Cn(t, ...e)
    }
  },
  $y = function (...t) {
    const e = 'FIREBASE INTERNAL ERROR: ' + Xu(...t)
    qa.error(e)
  },
  Ko = function (...t) {
    const e = `FIREBASE FATAL ERROR: ${Xu(...t)}`
    throw (qa.error(e), new Error(e))
  },
  lr = function (...t) {
    const e = 'FIREBASE WARNING: ' + Xu(...t)
    qa.warn(e)
  },
  E5 = function () {
    typeof window < 'u' &&
      window.location &&
      window.location.protocol &&
      window.location.protocol.indexOf('https:') !== -1 &&
      lr(
        'Insecure Firebase access from a secure page. Please use https in calls to new Firebase().'
      )
  },
  UC = function (t) {
    return (
      typeof t == 'number' &&
      (t !== t || t === Number.POSITIVE_INFINITY || t === Number.NEGATIVE_INFINITY)
    )
  },
  T5 = function (t) {
    if (document.readyState === 'complete') t()
    else {
      let e = !1
      const n = function () {
        if (!document.body) {
          setTimeout(n, Math.floor(10))
          return
        }
        e || ((e = !0), t())
      }
      document.addEventListener
        ? (document.addEventListener('DOMContentLoaded', n, !1),
          window.addEventListener('load', n, !1))
        : document.attachEvent &&
          (document.attachEvent('onreadystatechange', () => {
            document.readyState === 'complete' && n()
          }),
          window.attachEvent('onload', n))
    }
  },
  cl = '[MIN_NAME]',
  Yo = '[MAX_NAME]',
  Fl = function (t, e) {
    if (t === e) return 0
    if (t === cl || e === Yo) return -1
    if (e === cl || t === Yo) return 1
    {
      const n = $E(t),
        r = $E(e)
      return n !== null
        ? r !== null
          ? n - r === 0
            ? t.length - e.length
            : n - r
          : -1
        : r !== null
        ? 1
        : t < e
        ? -1
        : 1
    }
  },
  w5 = function (t, e) {
    return t === e ? 0 : t < e ? -1 : 1
  },
  Zl = function (t, e) {
    if (e && t in e) return e[t]
    throw new Error('Missing required key (' + t + ') in object: ' + _n(e))
  },
  r0 = function (t) {
    if (typeof t != 'object' || t === null) return _n(t)
    const e = []
    for (const r in t) e.push(r)
    e.sort()
    let n = '{'
    for (let r = 0; r < e.length; r++)
      r !== 0 && (n += ','), (n += _n(e[r])), (n += ':'), (n += r0(t[e[r]]))
    return (n += '}'), n
  },
  $C = function (t, e) {
    const n = t.length
    if (n <= e) return [t]
    const r = []
    for (let i = 0; i < n; i += e)
      i + e > n ? r.push(t.substring(i, n)) : r.push(t.substring(i, i + e))
    return r
  }
function Ar(t, e) {
  for (const n in t) t.hasOwnProperty(n) && e(n, t[n])
}
const HC = function (t) {
    te(!UC(t), 'Invalid JSON number')
    const e = 11,
      n = 52,
      r = (1 << (e - 1)) - 1
    let i, s, o, a, l
    t === 0
      ? ((s = 0), (o = 0), (i = 1 / t === -1 / 0 ? 1 : 0))
      : ((i = t < 0),
        (t = Math.abs(t)),
        t >= Math.pow(2, 1 - r)
          ? ((a = Math.min(Math.floor(Math.log(t) / Math.LN2), r)),
            (s = a + r),
            (o = Math.round(t * Math.pow(2, n - a) - Math.pow(2, n))))
          : ((s = 0), (o = Math.round(t / Math.pow(2, 1 - r - n)))))
    const c = []
    for (l = n; l; l -= 1) c.push(o % 2 ? 1 : 0), (o = Math.floor(o / 2))
    for (l = e; l; l -= 1) c.push(s % 2 ? 1 : 0), (s = Math.floor(s / 2))
    c.push(i ? 1 : 0), c.reverse()
    const u = c.join('')
    let h = ''
    for (l = 0; l < 64; l += 8) {
      let d = parseInt(u.substr(l, 8), 2).toString(16)
      d.length === 1 && (d = '0' + d), (h = h + d)
    }
    return h.toLowerCase()
  },
  S5 = function () {
    return !!(
      typeof window == 'object' &&
      window.chrome &&
      window.chrome.extension &&
      !/^chrome/.test(window.location.href)
    )
  },
  I5 = function () {
    return typeof Windows == 'object' && typeof Windows.UI == 'object'
  },
  A5 = new RegExp('^-?(0*)\\d{1,10}$'),
  C5 = -2147483648,
  R5 = 2147483647,
  $E = function (t) {
    if (A5.test(t)) {
      const e = Number(t)
      if (e >= C5 && e <= R5) return e
    }
    return null
  },
  eh = function (t) {
    try {
      t()
    } catch (e) {
      setTimeout(() => {
        const n = e.stack || ''
        throw (lr('Exception was thrown by user callback.', n), e)
      }, Math.floor(0))
    }
  },
  k5 = function () {
    return (
      ((typeof window == 'object' && window.navigator && window.navigator.userAgent) || '').search(
        /googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i
      ) >= 0
    )
  },
  Mc = function (t, e) {
    const n = setTimeout(t, e)
    return (
      typeof n == 'number' && typeof Deno < 'u' && Deno.unrefTimer
        ? Deno.unrefTimer(n)
        : typeof n == 'object' && n.unref && n.unref(),
      n
    )
  }
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class O5 {
  constructor(e, n) {
    ;(this.appName_ = e),
      (this.appCheckProvider = n),
      (this.appCheck = n == null ? void 0 : n.getImmediate({ optional: !0 })),
      this.appCheck || n == null || n.get().then((r) => (this.appCheck = r))
  }
  getToken(e) {
    return this.appCheck
      ? this.appCheck.getToken(e)
      : new Promise((n, r) => {
          setTimeout(() => {
            this.appCheck ? this.getToken(e).then(n, r) : n(null)
          }, 0)
        })
  }
  addTokenChangeListener(e) {
    var n
    ;(n = this.appCheckProvider) === null ||
      n === void 0 ||
      n.get().then((r) => r.addTokenListener(e))
  }
  notifyForInvalidToken() {
    lr(
      `Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class N5 {
  constructor(e, n, r) {
    ;(this.appName_ = e),
      (this.firebaseOptions_ = n),
      (this.authProvider_ = r),
      (this.auth_ = null),
      (this.auth_ = r.getImmediate({ optional: !0 })),
      this.auth_ || r.onInit((i) => (this.auth_ = i))
  }
  getToken(e) {
    return this.auth_
      ? this.auth_
          .getToken(e)
          .catch((n) =>
            n && n.code === 'auth/token-not-initialized'
              ? (Cn('Got auth/token-not-initialized error.  Treating as null token.'), null)
              : Promise.reject(n)
          )
      : new Promise((n, r) => {
          setTimeout(() => {
            this.auth_ ? this.getToken(e).then(n, r) : n(null)
          }, 0)
        })
  }
  addTokenChangeListener(e) {
    this.auth_
      ? this.auth_.addAuthTokenListener(e)
      : this.authProvider_.get().then((n) => n.addAuthTokenListener(e))
  }
  removeTokenChangeListener(e) {
    this.authProvider_.get().then((n) => n.removeAuthTokenListener(e))
  }
  notifyForInvalidToken() {
    let e =
      'Provided authentication credentials for the app named "' +
      this.appName_ +
      '" are invalid. This usually indicates your app was not initialized correctly. '
    'credential' in this.firebaseOptions_
      ? (e +=
          'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.')
      : 'serviceAccount' in this.firebaseOptions_
      ? (e +=
          'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.')
      : (e +=
          'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.'),
      lr(e)
  }
}
class Hy {
  constructor(e) {
    this.accessToken = e
  }
  getToken(e) {
    return Promise.resolve({ accessToken: this.accessToken })
  }
  addTokenChangeListener(e) {
    e(this.accessToken)
  }
  removeTokenChangeListener(e) {}
  notifyForInvalidToken() {}
}
Hy.OWNER = 'owner'
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const i0 = '5',
  zC = 'v',
  jC = 's',
  WC = 'r',
  GC = 'f',
  qC = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/,
  KC = 'ls',
  YC = 'p',
  zy = 'ac',
  JC = 'websocket',
  QC = 'long_polling'
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class M5 {
  constructor(e, n, r, i, s = !1, o = '', a = !1, l = !1) {
    ;(this.secure = n),
      (this.namespace = r),
      (this.webSocketOnly = i),
      (this.nodeAdmin = s),
      (this.persistenceKey = o),
      (this.includeNamespaceInQueryParams = a),
      (this.isUsingEmulator = l),
      (this._host = e.toLowerCase()),
      (this._domain = this._host.substr(this._host.indexOf('.') + 1)),
      (this.internalHost = Eo.get('host:' + e) || this._host)
  }
  isCacheableHost() {
    return this.internalHost.substr(0, 2) === 's-'
  }
  isCustomHost() {
    return this._domain !== 'firebaseio.com' && this._domain !== 'firebaseio-demo.com'
  }
  get host() {
    return this._host
  }
  set host(e) {
    e !== this.internalHost &&
      ((this.internalHost = e),
      this.isCacheableHost() && Eo.set('host:' + this._host, this.internalHost))
  }
  toString() {
    let e = this.toURLString()
    return this.persistenceKey && (e += '<' + this.persistenceKey + '>'), e
  }
  toURLString() {
    const e = this.secure ? 'https://' : 'http://',
      n = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : ''
    return `${e}${this.host}/${n}`
  }
}
function P5(t) {
  return t.host !== t.internalHost || t.isCustomHost() || t.includeNamespaceInQueryParams
}
function XC(t, e, n) {
  te(typeof e == 'string', 'typeof type must == string'),
    te(typeof n == 'object', 'typeof params must == object')
  let r
  if (e === JC) r = (t.secure ? 'wss://' : 'ws://') + t.internalHost + '/.ws?'
  else if (e === QC) r = (t.secure ? 'https://' : 'http://') + t.internalHost + '/.lp?'
  else throw new Error('Unknown connection type: ' + e)
  P5(t) && (n.ns = t.namespace)
  const i = []
  return (
    Ar(n, (s, o) => {
      i.push(s + '=' + o)
    }),
    r + i.join('&')
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class x5 {
  constructor() {
    this.counters_ = {}
  }
  incrementCounter(e, n = 1) {
    Qi(this.counters_, e) || (this.counters_[e] = 0), (this.counters_[e] += n)
  }
  get() {
    return t4(this.counters_)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Xm = {},
  Zm = {}
function s0(t) {
  const e = t.toString()
  return Xm[e] || (Xm[e] = new x5()), Xm[e]
}
function D5(t, e) {
  const n = t.toString()
  return Zm[n] || (Zm[n] = e()), Zm[n]
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class L5 {
  constructor(e) {
    ;(this.onMessage_ = e),
      (this.pendingResponses = []),
      (this.currentResponseNum = 0),
      (this.closeAfterResponse = -1),
      (this.onClose = null)
  }
  closeAfter(e, n) {
    ;(this.closeAfterResponse = e),
      (this.onClose = n),
      this.closeAfterResponse < this.currentResponseNum && (this.onClose(), (this.onClose = null))
  }
  handleResponse(e, n) {
    for (this.pendingResponses[e] = n; this.pendingResponses[this.currentResponseNum]; ) {
      const r = this.pendingResponses[this.currentResponseNum]
      delete this.pendingResponses[this.currentResponseNum]
      for (let i = 0; i < r.length; ++i)
        r[i] &&
          eh(() => {
            this.onMessage_(r[i])
          })
      if (this.currentResponseNum === this.closeAfterResponse) {
        this.onClose && (this.onClose(), (this.onClose = null))
        break
      }
      this.currentResponseNum++
    }
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const HE = 'start',
  V5 = 'close',
  F5 = 'pLPCommand',
  B5 = 'pRTLPCB',
  ZC = 'id',
  eR = 'pw',
  tR = 'ser',
  U5 = 'cb',
  $5 = 'seg',
  H5 = 'ts',
  z5 = 'd',
  j5 = 'dframe',
  nR = 1870,
  rR = 30,
  W5 = nR - rR,
  G5 = 25e3,
  q5 = 3e4
class Na {
  constructor(e, n, r, i, s, o, a) {
    ;(this.connId = e),
      (this.repoInfo = n),
      (this.applicationId = r),
      (this.appCheckToken = i),
      (this.authToken = s),
      (this.transportSessionId = o),
      (this.lastSessionId = a),
      (this.bytesSent = 0),
      (this.bytesReceived = 0),
      (this.everConnected_ = !1),
      (this.log_ = Zu(e)),
      (this.stats_ = s0(n)),
      (this.urlFn = (l) => (this.appCheckToken && (l[zy] = this.appCheckToken), XC(n, QC, l)))
  }
  open(e, n) {
    ;(this.curSegmentNum = 0),
      (this.onDisconnect_ = n),
      (this.myPacketOrderer = new L5(e)),
      (this.isClosed_ = !1),
      (this.connectTimeoutTimer_ = setTimeout(() => {
        this.log_('Timed out trying to connect.'),
          this.onClosed_(),
          (this.connectTimeoutTimer_ = null)
      }, Math.floor(q5))),
      T5(() => {
        if (this.isClosed_) return
        this.scriptTagHolder = new o0(
          (...s) => {
            const [o, a, l, c, u] = s
            if ((this.incrementIncomingBytes_(s), !!this.scriptTagHolder))
              if (
                (this.connectTimeoutTimer_ &&
                  (clearTimeout(this.connectTimeoutTimer_), (this.connectTimeoutTimer_ = null)),
                (this.everConnected_ = !0),
                o === HE)
              )
                (this.id = a), (this.password = l)
              else if (o === V5)
                a
                  ? ((this.scriptTagHolder.sendNewPolls = !1),
                    this.myPacketOrderer.closeAfter(a, () => {
                      this.onClosed_()
                    }))
                  : this.onClosed_()
              else throw new Error('Unrecognized command received: ' + o)
          },
          (...s) => {
            const [o, a] = s
            this.incrementIncomingBytes_(s), this.myPacketOrderer.handleResponse(o, a)
          },
          () => {
            this.onClosed_()
          },
          this.urlFn
        )
        const r = {}
        ;(r[HE] = 't'),
          (r[tR] = Math.floor(Math.random() * 1e8)),
          this.scriptTagHolder.uniqueCallbackIdentifier &&
            (r[U5] = this.scriptTagHolder.uniqueCallbackIdentifier),
          (r[zC] = i0),
          this.transportSessionId && (r[jC] = this.transportSessionId),
          this.lastSessionId && (r[KC] = this.lastSessionId),
          this.applicationId && (r[YC] = this.applicationId),
          this.appCheckToken && (r[zy] = this.appCheckToken),
          typeof location < 'u' && location.hostname && qC.test(location.hostname) && (r[WC] = GC)
        const i = this.urlFn(r)
        this.log_('Connecting via long-poll to ' + i), this.scriptTagHolder.addTag(i, () => {})
      })
  }
  start() {
    this.scriptTagHolder.startLongPoll(this.id, this.password),
      this.addDisconnectPingFrame(this.id, this.password)
  }
  static forceAllow() {
    Na.forceAllow_ = !0
  }
  static forceDisallow() {
    Na.forceDisallow_ = !0
  }
  static isAvailable() {
    return Na.forceAllow_
      ? !0
      : !Na.forceDisallow_ &&
          typeof document < 'u' &&
          document.createElement != null &&
          !S5() &&
          !I5()
  }
  markConnectionHealthy() {}
  shutdown_() {
    ;(this.isClosed_ = !0),
      this.scriptTagHolder && (this.scriptTagHolder.close(), (this.scriptTagHolder = null)),
      this.myDisconnFrame &&
        (document.body.removeChild(this.myDisconnFrame), (this.myDisconnFrame = null)),
      this.connectTimeoutTimer_ &&
        (clearTimeout(this.connectTimeoutTimer_), (this.connectTimeoutTimer_ = null))
  }
  onClosed_() {
    this.isClosed_ ||
      (this.log_('Longpoll is closing itself'),
      this.shutdown_(),
      this.onDisconnect_ && (this.onDisconnect_(this.everConnected_), (this.onDisconnect_ = null)))
  }
  close() {
    this.isClosed_ || (this.log_('Longpoll is being closed.'), this.shutdown_())
  }
  send(e) {
    const n = _n(e)
    ;(this.bytesSent += n.length), this.stats_.incrementCounter('bytes_sent', n.length)
    const r = zA(n),
      i = $C(r, W5)
    for (let s = 0; s < i.length; s++)
      this.scriptTagHolder.enqueueSegment(this.curSegmentNum, i.length, i[s]), this.curSegmentNum++
  }
  addDisconnectPingFrame(e, n) {
    this.myDisconnFrame = document.createElement('iframe')
    const r = {}
    ;(r[j5] = 't'),
      (r[ZC] = e),
      (r[eR] = n),
      (this.myDisconnFrame.src = this.urlFn(r)),
      (this.myDisconnFrame.style.display = 'none'),
      document.body.appendChild(this.myDisconnFrame)
  }
  incrementIncomingBytes_(e) {
    const n = _n(e).length
    ;(this.bytesReceived += n), this.stats_.incrementCounter('bytes_received', n)
  }
}
class o0 {
  constructor(e, n, r, i) {
    ;(this.onDisconnect = r),
      (this.urlFn = i),
      (this.outstandingRequests = new Set()),
      (this.pendingSegs = []),
      (this.currentSerial = Math.floor(Math.random() * 1e8)),
      (this.sendNewPolls = !0)
    {
      ;(this.uniqueCallbackIdentifier = v5()),
        (window[F5 + this.uniqueCallbackIdentifier] = e),
        (window[B5 + this.uniqueCallbackIdentifier] = n),
        (this.myIFrame = o0.createIFrame_())
      let s = ''
      this.myIFrame.src &&
        this.myIFrame.src.substr(0, 11) === 'javascript:' &&
        (s = '<script>document.domain="' + document.domain + '";</script>')
      const o = '<html><body>' + s + '</body></html>'
      try {
        this.myIFrame.doc.open(), this.myIFrame.doc.write(o), this.myIFrame.doc.close()
      } catch (a) {
        Cn('frame writing exception'), a.stack && Cn(a.stack), Cn(a)
      }
    }
  }
  static createIFrame_() {
    const e = document.createElement('iframe')
    if (((e.style.display = 'none'), document.body)) {
      document.body.appendChild(e)
      try {
        e.contentWindow.document || Cn('No IE domain setting required')
      } catch {
        const r = document.domain
        e.src =
          "javascript:void((function(){document.open();document.domain='" +
          r +
          "';document.close();})())"
      }
    } else
      throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.'
    return (
      e.contentDocument
        ? (e.doc = e.contentDocument)
        : e.contentWindow
        ? (e.doc = e.contentWindow.document)
        : e.document && (e.doc = e.document),
      e
    )
  }
  close() {
    ;(this.alive = !1),
      this.myIFrame &&
        ((this.myIFrame.doc.body.textContent = ''),
        setTimeout(() => {
          this.myIFrame !== null &&
            (document.body.removeChild(this.myIFrame), (this.myIFrame = null))
        }, Math.floor(0)))
    const e = this.onDisconnect
    e && ((this.onDisconnect = null), e())
  }
  startLongPoll(e, n) {
    for (this.myID = e, this.myPW = n, this.alive = !0; this.newRequest_(); );
  }
  newRequest_() {
    if (
      this.alive &&
      this.sendNewPolls &&
      this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)
    ) {
      this.currentSerial++
      const e = {}
      ;(e[ZC] = this.myID), (e[eR] = this.myPW), (e[tR] = this.currentSerial)
      let n = this.urlFn(e),
        r = '',
        i = 0
      for (; this.pendingSegs.length > 0 && this.pendingSegs[0].d.length + rR + r.length <= nR; ) {
        const o = this.pendingSegs.shift()
        ;(r =
          r + '&' + $5 + i + '=' + o.seg + '&' + H5 + i + '=' + o.ts + '&' + z5 + i + '=' + o.d),
          i++
      }
      return (n = n + r), this.addLongPollTag_(n, this.currentSerial), !0
    } else return !1
  }
  enqueueSegment(e, n, r) {
    this.pendingSegs.push({ seg: e, ts: n, d: r }), this.alive && this.newRequest_()
  }
  addLongPollTag_(e, n) {
    this.outstandingRequests.add(n)
    const r = () => {
        this.outstandingRequests.delete(n), this.newRequest_()
      },
      i = setTimeout(r, Math.floor(G5)),
      s = () => {
        clearTimeout(i), r()
      }
    this.addTag(e, s)
  }
  addTag(e, n) {
    setTimeout(() => {
      try {
        if (!this.sendNewPolls) return
        const r = this.myIFrame.doc.createElement('script')
        ;(r.type = 'text/javascript'),
          (r.async = !0),
          (r.src = e),
          (r.onload = r.onreadystatechange =
            function () {
              const i = r.readyState
              ;(!i || i === 'loaded' || i === 'complete') &&
                ((r.onload = r.onreadystatechange = null),
                r.parentNode && r.parentNode.removeChild(r),
                n())
            }),
          (r.onerror = () => {
            Cn('Long-poll script failed to load: ' + e), (this.sendNewPolls = !1), this.close()
          }),
          this.myIFrame.doc.body.appendChild(r)
      } catch {}
    }, Math.floor(1))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const K5 = 16384,
  Y5 = 45e3
let uf = null
typeof MozWebSocket < 'u' ? (uf = MozWebSocket) : typeof WebSocket < 'u' && (uf = WebSocket)
class Pr {
  constructor(e, n, r, i, s, o, a) {
    ;(this.connId = e),
      (this.applicationId = r),
      (this.appCheckToken = i),
      (this.authToken = s),
      (this.keepaliveTimer = null),
      (this.frames = null),
      (this.totalFrames = 0),
      (this.bytesSent = 0),
      (this.bytesReceived = 0),
      (this.log_ = Zu(this.connId)),
      (this.stats_ = s0(n)),
      (this.connURL = Pr.connectionURL_(n, o, a, i, r)),
      (this.nodeAdmin = n.nodeAdmin)
  }
  static connectionURL_(e, n, r, i, s) {
    const o = {}
    return (
      (o[zC] = i0),
      typeof location < 'u' && location.hostname && qC.test(location.hostname) && (o[WC] = GC),
      n && (o[jC] = n),
      r && (o[KC] = r),
      i && (o[zy] = i),
      s && (o[YC] = s),
      XC(e, JC, o)
    )
  }
  open(e, n) {
    ;(this.onDisconnect = n),
      (this.onMessage = e),
      this.log_('Websocket connecting to ' + this.connURL),
      (this.everConnected_ = !1),
      Eo.set('previous_websocket_failure', !0)
    try {
      let r
      qA(), (this.mySock = new uf(this.connURL, [], r))
    } catch (r) {
      this.log_('Error instantiating WebSocket.')
      const i = r.message || r.data
      i && this.log_(i), this.onClosed_()
      return
    }
    ;(this.mySock.onopen = () => {
      this.log_('Websocket connected.'), (this.everConnected_ = !0)
    }),
      (this.mySock.onclose = () => {
        this.log_('Websocket connection was disconnected.'), (this.mySock = null), this.onClosed_()
      }),
      (this.mySock.onmessage = (r) => {
        this.handleIncomingFrame(r)
      }),
      (this.mySock.onerror = (r) => {
        this.log_('WebSocket error.  Closing connection.')
        const i = r.message || r.data
        i && this.log_(i), this.onClosed_()
      })
  }
  start() {}
  static forceDisallow() {
    Pr.forceDisallow_ = !0
  }
  static isAvailable() {
    let e = !1
    if (typeof navigator < 'u' && navigator.userAgent) {
      const n = /Android ([0-9]{0,}\.[0-9]{0,})/,
        r = navigator.userAgent.match(n)
      r && r.length > 1 && parseFloat(r[1]) < 4.4 && (e = !0)
    }
    return !e && uf !== null && !Pr.forceDisallow_
  }
  static previouslyFailed() {
    return Eo.isInMemoryStorage || Eo.get('previous_websocket_failure') === !0
  }
  markConnectionHealthy() {
    Eo.remove('previous_websocket_failure')
  }
  appendFrame_(e) {
    if ((this.frames.push(e), this.frames.length === this.totalFrames)) {
      const n = this.frames.join('')
      this.frames = null
      const r = au(n)
      this.onMessage(r)
    }
  }
  handleNewFrameCount_(e) {
    ;(this.totalFrames = e), (this.frames = [])
  }
  extractFrameCount_(e) {
    if ((te(this.frames === null, 'We already have a frame buffer'), e.length <= 6)) {
      const n = Number(e)
      if (!isNaN(n)) return this.handleNewFrameCount_(n), null
    }
    return this.handleNewFrameCount_(1), e
  }
  handleIncomingFrame(e) {
    if (this.mySock === null) return
    const n = e.data
    if (
      ((this.bytesReceived += n.length),
      this.stats_.incrementCounter('bytes_received', n.length),
      this.resetKeepAlive(),
      this.frames !== null)
    )
      this.appendFrame_(n)
    else {
      const r = this.extractFrameCount_(n)
      r !== null && this.appendFrame_(r)
    }
  }
  send(e) {
    this.resetKeepAlive()
    const n = _n(e)
    ;(this.bytesSent += n.length), this.stats_.incrementCounter('bytes_sent', n.length)
    const r = $C(n, K5)
    r.length > 1 && this.sendString_(String(r.length))
    for (let i = 0; i < r.length; i++) this.sendString_(r[i])
  }
  shutdown_() {
    ;(this.isClosed_ = !0),
      this.keepaliveTimer && (clearInterval(this.keepaliveTimer), (this.keepaliveTimer = null)),
      this.mySock && (this.mySock.close(), (this.mySock = null))
  }
  onClosed_() {
    this.isClosed_ ||
      (this.log_('WebSocket is closing itself'),
      this.shutdown_(),
      this.onDisconnect && (this.onDisconnect(this.everConnected_), (this.onDisconnect = null)))
  }
  close() {
    this.isClosed_ || (this.log_('WebSocket is being closed'), this.shutdown_())
  }
  resetKeepAlive() {
    clearInterval(this.keepaliveTimer),
      (this.keepaliveTimer = setInterval(() => {
        this.mySock && this.sendString_('0'), this.resetKeepAlive()
      }, Math.floor(Y5)))
  }
  sendString_(e) {
    try {
      this.mySock.send(e)
    } catch (n) {
      this.log_(
        'Exception thrown from WebSocket.send():',
        n.message || n.data,
        'Closing connection.'
      ),
        setTimeout(this.onClosed_.bind(this), 0)
    }
  }
}
Pr.responsesRequiredToBeHealthy = 2
Pr.healthyTimeout = 3e4
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class du {
  constructor(e) {
    this.initTransports_(e)
  }
  static get ALL_TRANSPORTS() {
    return [Na, Pr]
  }
  static get IS_TRANSPORT_INITIALIZED() {
    return this.globalTransportInitialized_
  }
  initTransports_(e) {
    const n = Pr && Pr.isAvailable()
    let r = n && !Pr.previouslyFailed()
    if (
      (e.webSocketOnly &&
        (n || lr("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),
        (r = !0)),
      r)
    )
      this.transports_ = [Pr]
    else {
      const i = (this.transports_ = [])
      for (const s of du.ALL_TRANSPORTS) s && s.isAvailable() && i.push(s)
      du.globalTransportInitialized_ = !0
    }
  }
  initialTransport() {
    if (this.transports_.length > 0) return this.transports_[0]
    throw new Error('No transports available')
  }
  upgradeTransport() {
    return this.transports_.length > 1 ? this.transports_[1] : null
  }
}
du.globalTransportInitialized_ = !1
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const J5 = 6e4,
  Q5 = 5e3,
  X5 = 10 * 1024,
  Z5 = 100 * 1024,
  eg = 't',
  zE = 'd',
  eV = 's',
  jE = 'r',
  tV = 'e',
  WE = 'o',
  GE = 'a',
  qE = 'n',
  KE = 'p',
  nV = 'h'
class rV {
  constructor(e, n, r, i, s, o, a, l, c, u) {
    ;(this.id = e),
      (this.repoInfo_ = n),
      (this.applicationId_ = r),
      (this.appCheckToken_ = i),
      (this.authToken_ = s),
      (this.onMessage_ = o),
      (this.onReady_ = a),
      (this.onDisconnect_ = l),
      (this.onKill_ = c),
      (this.lastSessionId = u),
      (this.connectionCount = 0),
      (this.pendingDataMessages = []),
      (this.state_ = 0),
      (this.log_ = Zu('c:' + this.id + ':')),
      (this.transportManager_ = new du(n)),
      this.log_('Connection created'),
      this.start_()
  }
  start_() {
    const e = this.transportManager_.initialTransport()
    ;(this.conn_ = new e(
      this.nextTransportId_(),
      this.repoInfo_,
      this.applicationId_,
      this.appCheckToken_,
      this.authToken_,
      null,
      this.lastSessionId
    )),
      (this.primaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0)
    const n = this.connReceiver_(this.conn_),
      r = this.disconnReceiver_(this.conn_)
    ;(this.tx_ = this.conn_),
      (this.rx_ = this.conn_),
      (this.secondaryConn_ = null),
      (this.isHealthy_ = !1),
      setTimeout(() => {
        this.conn_ && this.conn_.open(n, r)
      }, Math.floor(0))
    const i = e.healthyTimeout || 0
    i > 0 &&
      (this.healthyTimeout_ = Mc(() => {
        ;(this.healthyTimeout_ = null),
          this.isHealthy_ ||
            (this.conn_ && this.conn_.bytesReceived > Z5
              ? (this.log_(
                  'Connection exceeded healthy timeout but has received ' +
                    this.conn_.bytesReceived +
                    ' bytes.  Marking connection healthy.'
                ),
                (this.isHealthy_ = !0),
                this.conn_.markConnectionHealthy())
              : this.conn_ && this.conn_.bytesSent > X5
              ? this.log_(
                  'Connection exceeded healthy timeout but has sent ' +
                    this.conn_.bytesSent +
                    ' bytes.  Leaving connection alive.'
                )
              : (this.log_('Closing unhealthy connection after timeout.'), this.close()))
      }, Math.floor(i)))
  }
  nextTransportId_() {
    return 'c:' + this.id + ':' + this.connectionCount++
  }
  disconnReceiver_(e) {
    return (n) => {
      e === this.conn_
        ? this.onConnectionLost_(n)
        : e === this.secondaryConn_
        ? (this.log_('Secondary connection lost.'), this.onSecondaryConnectionLost_())
        : this.log_('closing an old connection')
    }
  }
  connReceiver_(e) {
    return (n) => {
      this.state_ !== 2 &&
        (e === this.rx_
          ? this.onPrimaryMessageReceived_(n)
          : e === this.secondaryConn_
          ? this.onSecondaryMessageReceived_(n)
          : this.log_('message on old connection'))
    }
  }
  sendRequest(e) {
    const n = { t: 'd', d: e }
    this.sendData_(n)
  }
  tryCleanupConnection() {
    this.tx_ === this.secondaryConn_ &&
      this.rx_ === this.secondaryConn_ &&
      (this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId),
      (this.conn_ = this.secondaryConn_),
      (this.secondaryConn_ = null))
  }
  onSecondaryControl_(e) {
    if (eg in e) {
      const n = e[eg]
      n === GE
        ? this.upgradeIfSecondaryHealthy_()
        : n === jE
        ? (this.log_('Got a reset on secondary, closing it'),
          this.secondaryConn_.close(),
          (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) && this.close())
        : n === WE &&
          (this.log_('got pong on secondary.'),
          this.secondaryResponsesRequired_--,
          this.upgradeIfSecondaryHealthy_())
    }
  }
  onSecondaryMessageReceived_(e) {
    const n = Zl('t', e),
      r = Zl('d', e)
    if (n === 'c') this.onSecondaryControl_(r)
    else if (n === 'd') this.pendingDataMessages.push(r)
    else throw new Error('Unknown protocol layer: ' + n)
  }
  upgradeIfSecondaryHealthy_() {
    this.secondaryResponsesRequired_ <= 0
      ? (this.log_('Secondary connection is healthy.'),
        (this.isHealthy_ = !0),
        this.secondaryConn_.markConnectionHealthy(),
        this.proceedWithUpgrade_())
      : (this.log_('sending ping on secondary.'),
        this.secondaryConn_.send({ t: 'c', d: { t: KE, d: {} } }))
  }
  proceedWithUpgrade_() {
    this.secondaryConn_.start(),
      this.log_('sending client ack on secondary'),
      this.secondaryConn_.send({ t: 'c', d: { t: GE, d: {} } }),
      this.log_('Ending transmission on primary'),
      this.conn_.send({ t: 'c', d: { t: qE, d: {} } }),
      (this.tx_ = this.secondaryConn_),
      this.tryCleanupConnection()
  }
  onPrimaryMessageReceived_(e) {
    const n = Zl('t', e),
      r = Zl('d', e)
    n === 'c' ? this.onControl_(r) : n === 'd' && this.onDataMessage_(r)
  }
  onDataMessage_(e) {
    this.onPrimaryResponse_(), this.onMessage_(e)
  }
  onPrimaryResponse_() {
    this.isHealthy_ ||
      (this.primaryResponsesRequired_--,
      this.primaryResponsesRequired_ <= 0 &&
        (this.log_('Primary connection is healthy.'),
        (this.isHealthy_ = !0),
        this.conn_.markConnectionHealthy()))
  }
  onControl_(e) {
    const n = Zl(eg, e)
    if (zE in e) {
      const r = e[zE]
      if (n === nV) {
        const i = Object.assign({}, r)
        this.repoInfo_.isUsingEmulator && (i.h = this.repoInfo_.host), this.onHandshake_(i)
      } else if (n === qE) {
        this.log_('recvd end transmission on primary'), (this.rx_ = this.secondaryConn_)
        for (let i = 0; i < this.pendingDataMessages.length; ++i)
          this.onDataMessage_(this.pendingDataMessages[i])
        ;(this.pendingDataMessages = []), this.tryCleanupConnection()
      } else
        n === eV
          ? this.onConnectionShutdown_(r)
          : n === jE
          ? this.onReset_(r)
          : n === tV
          ? $y('Server Error: ' + r)
          : n === WE
          ? (this.log_('got pong on primary.'),
            this.onPrimaryResponse_(),
            this.sendPingOnPrimaryIfNecessary_())
          : $y('Unknown control packet command: ' + n)
    }
  }
  onHandshake_(e) {
    const n = e.ts,
      r = e.v,
      i = e.h
    ;(this.sessionId = e.s),
      (this.repoInfo_.host = i),
      this.state_ === 0 &&
        (this.conn_.start(),
        this.onConnectionEstablished_(this.conn_, n),
        i0 !== r && lr('Protocol version mismatch detected'),
        this.tryStartUpgrade_())
  }
  tryStartUpgrade_() {
    const e = this.transportManager_.upgradeTransport()
    e && this.startUpgrade_(e)
  }
  startUpgrade_(e) {
    ;(this.secondaryConn_ = new e(
      this.nextTransportId_(),
      this.repoInfo_,
      this.applicationId_,
      this.appCheckToken_,
      this.authToken_,
      this.sessionId
    )),
      (this.secondaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0)
    const n = this.connReceiver_(this.secondaryConn_),
      r = this.disconnReceiver_(this.secondaryConn_)
    this.secondaryConn_.open(n, r),
      Mc(() => {
        this.secondaryConn_ &&
          (this.log_('Timed out trying to upgrade.'), this.secondaryConn_.close())
      }, Math.floor(J5))
  }
  onReset_(e) {
    this.log_('Reset packet received.  New host: ' + e),
      (this.repoInfo_.host = e),
      this.state_ === 1 ? this.close() : (this.closeConnections_(), this.start_())
  }
  onConnectionEstablished_(e, n) {
    this.log_('Realtime connection established.'),
      (this.conn_ = e),
      (this.state_ = 1),
      this.onReady_ && (this.onReady_(n, this.sessionId), (this.onReady_ = null)),
      this.primaryResponsesRequired_ === 0
        ? (this.log_('Primary connection is healthy.'), (this.isHealthy_ = !0))
        : Mc(() => {
            this.sendPingOnPrimaryIfNecessary_()
          }, Math.floor(Q5))
  }
  sendPingOnPrimaryIfNecessary_() {
    !this.isHealthy_ &&
      this.state_ === 1 &&
      (this.log_('sending ping on primary.'), this.sendData_({ t: 'c', d: { t: KE, d: {} } }))
  }
  onSecondaryConnectionLost_() {
    const e = this.secondaryConn_
    ;(this.secondaryConn_ = null), (this.tx_ === e || this.rx_ === e) && this.close()
  }
  onConnectionLost_(e) {
    ;(this.conn_ = null),
      !e && this.state_ === 0
        ? (this.log_('Realtime connection failed.'),
          this.repoInfo_.isCacheableHost() &&
            (Eo.remove('host:' + this.repoInfo_.host),
            (this.repoInfo_.internalHost = this.repoInfo_.host)))
        : this.state_ === 1 && this.log_('Realtime connection lost.'),
      this.close()
  }
  onConnectionShutdown_(e) {
    this.log_('Connection shutdown command received. Shutting down...'),
      this.onKill_ && (this.onKill_(e), (this.onKill_ = null)),
      (this.onDisconnect_ = null),
      this.close()
  }
  sendData_(e) {
    if (this.state_ !== 1) throw 'Connection is not connected'
    this.tx_.send(e)
  }
  close() {
    this.state_ !== 2 &&
      (this.log_('Closing realtime connection.'),
      (this.state_ = 2),
      this.closeConnections_(),
      this.onDisconnect_ && (this.onDisconnect_(), (this.onDisconnect_ = null)))
  }
  closeConnections_() {
    this.log_('Shutting down all connections'),
      this.conn_ && (this.conn_.close(), (this.conn_ = null)),
      this.secondaryConn_ && (this.secondaryConn_.close(), (this.secondaryConn_ = null)),
      this.healthyTimeout_ && (clearTimeout(this.healthyTimeout_), (this.healthyTimeout_ = null))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class iR {
  put(e, n, r, i) {}
  merge(e, n, r, i) {}
  refreshAuthToken(e) {}
  refreshAppCheckToken(e) {}
  onDisconnectPut(e, n, r) {}
  onDisconnectMerge(e, n, r) {}
  onDisconnectCancel(e, n) {}
  reportStats(e) {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let sR = class {
  constructor(e) {
    ;(this.allowedEvents_ = e),
      (this.listeners_ = {}),
      te(Array.isArray(e) && e.length > 0, 'Requires a non-empty array')
  }
  trigger(e, ...n) {
    if (Array.isArray(this.listeners_[e])) {
      const r = [...this.listeners_[e]]
      for (let i = 0; i < r.length; i++) r[i].callback.apply(r[i].context, n)
    }
  }
  on(e, n, r) {
    this.validateEventType_(e),
      (this.listeners_[e] = this.listeners_[e] || []),
      this.listeners_[e].push({ callback: n, context: r })
    const i = this.getInitialEvent(e)
    i && n.apply(r, i)
  }
  off(e, n, r) {
    this.validateEventType_(e)
    const i = this.listeners_[e] || []
    for (let s = 0; s < i.length; s++)
      if (i[s].callback === n && (!r || r === i[s].context)) {
        i.splice(s, 1)
        return
      }
  }
  validateEventType_(e) {
    te(
      this.allowedEvents_.find((n) => n === e),
      'Unknown event: ' + e
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class hf extends sR {
  constructor() {
    super(['online']),
      (this.online_ = !0),
      typeof window < 'u' &&
        typeof window.addEventListener < 'u' &&
        !$v() &&
        (window.addEventListener(
          'online',
          () => {
            this.online_ || ((this.online_ = !0), this.trigger('online', !0))
          },
          !1
        ),
        window.addEventListener(
          'offline',
          () => {
            this.online_ && ((this.online_ = !1), this.trigger('online', !1))
          },
          !1
        ))
  }
  static getInstance() {
    return new hf()
  }
  getInitialEvent(e) {
    return te(e === 'online', 'Unknown event type: ' + e), [this.online_]
  }
  currentlyOnline() {
    return this.online_
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const YE = 32,
  JE = 768
class Tt {
  constructor(e, n) {
    if (n === void 0) {
      this.pieces_ = e.split('/')
      let r = 0
      for (let i = 0; i < this.pieces_.length; i++)
        this.pieces_[i].length > 0 && ((this.pieces_[r] = this.pieces_[i]), r++)
      ;(this.pieces_.length = r), (this.pieceNum_ = 0)
    } else (this.pieces_ = e), (this.pieceNum_ = n)
  }
  toString() {
    let e = ''
    for (let n = this.pieceNum_; n < this.pieces_.length; n++)
      this.pieces_[n] !== '' && (e += '/' + this.pieces_[n])
    return e || '/'
  }
}
function lt() {
  return new Tt('')
}
function qe(t) {
  return t.pieceNum_ >= t.pieces_.length ? null : t.pieces_[t.pieceNum_]
}
function Us(t) {
  return t.pieces_.length - t.pieceNum_
}
function _t(t) {
  let e = t.pieceNum_
  return e < t.pieces_.length && e++, new Tt(t.pieces_, e)
}
function oR(t) {
  return t.pieceNum_ < t.pieces_.length ? t.pieces_[t.pieces_.length - 1] : null
}
function iV(t) {
  let e = ''
  for (let n = t.pieceNum_; n < t.pieces_.length; n++)
    t.pieces_[n] !== '' && (e += '/' + encodeURIComponent(String(t.pieces_[n])))
  return e || '/'
}
function aR(t, e = 0) {
  return t.pieces_.slice(t.pieceNum_ + e)
}
function lR(t) {
  if (t.pieceNum_ >= t.pieces_.length) return null
  const e = []
  for (let n = t.pieceNum_; n < t.pieces_.length - 1; n++) e.push(t.pieces_[n])
  return new Tt(e, 0)
}
function en(t, e) {
  const n = []
  for (let r = t.pieceNum_; r < t.pieces_.length; r++) n.push(t.pieces_[r])
  if (e instanceof Tt) for (let r = e.pieceNum_; r < e.pieces_.length; r++) n.push(e.pieces_[r])
  else {
    const r = e.split('/')
    for (let i = 0; i < r.length; i++) r[i].length > 0 && n.push(r[i])
  }
  return new Tt(n, 0)
}
function je(t) {
  return t.pieceNum_ >= t.pieces_.length
}
function Tr(t, e) {
  const n = qe(t),
    r = qe(e)
  if (n === null) return e
  if (n === r) return Tr(_t(t), _t(e))
  throw new Error('INTERNAL ERROR: innerPath (' + e + ') is not within outerPath (' + t + ')')
}
function cR(t, e) {
  if (Us(t) !== Us(e)) return !1
  for (let n = t.pieceNum_, r = e.pieceNum_; n <= t.pieces_.length; n++, r++)
    if (t.pieces_[n] !== e.pieces_[r]) return !1
  return !0
}
function Dr(t, e) {
  let n = t.pieceNum_,
    r = e.pieceNum_
  if (Us(t) > Us(e)) return !1
  for (; n < t.pieces_.length; ) {
    if (t.pieces_[n] !== e.pieces_[r]) return !1
    ++n, ++r
  }
  return !0
}
class sV {
  constructor(e, n) {
    ;(this.errorPrefix_ = n),
      (this.parts_ = aR(e, 0)),
      (this.byteLength_ = Math.max(1, this.parts_.length))
    for (let r = 0; r < this.parts_.length; r++) this.byteLength_ += Cp(this.parts_[r])
    uR(this)
  }
}
function oV(t, e) {
  t.parts_.length > 0 && (t.byteLength_ += 1), t.parts_.push(e), (t.byteLength_ += Cp(e)), uR(t)
}
function aV(t) {
  const e = t.parts_.pop()
  ;(t.byteLength_ -= Cp(e)), t.parts_.length > 0 && (t.byteLength_ -= 1)
}
function uR(t) {
  if (t.byteLength_ > JE)
    throw new Error(
      t.errorPrefix_ + 'has a key path longer than ' + JE + ' bytes (' + t.byteLength_ + ').'
    )
  if (t.parts_.length > YE)
    throw new Error(
      t.errorPrefix_ +
        'path specified exceeds the maximum depth that can be written (' +
        YE +
        ') or object contains a cycle ' +
        ho(t)
    )
}
function ho(t) {
  return t.parts_.length === 0 ? '' : "in property '" + t.parts_.join('.') + "'"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class a0 extends sR {
  constructor() {
    super(['visible'])
    let e, n
    typeof document < 'u' &&
      typeof document.addEventListener < 'u' &&
      (typeof document.hidden < 'u'
        ? ((n = 'visibilitychange'), (e = 'hidden'))
        : typeof document.mozHidden < 'u'
        ? ((n = 'mozvisibilitychange'), (e = 'mozHidden'))
        : typeof document.msHidden < 'u'
        ? ((n = 'msvisibilitychange'), (e = 'msHidden'))
        : typeof document.webkitHidden < 'u' &&
          ((n = 'webkitvisibilitychange'), (e = 'webkitHidden'))),
      (this.visible_ = !0),
      n &&
        document.addEventListener(
          n,
          () => {
            const r = !document[e]
            r !== this.visible_ && ((this.visible_ = r), this.trigger('visible', r))
          },
          !1
        )
  }
  static getInstance() {
    return new a0()
  }
  getInitialEvent(e) {
    return te(e === 'visible', 'Unknown event type: ' + e), [this.visible_]
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const ec = 1e3,
  lV = 60 * 5 * 1e3,
  QE = 30 * 1e3,
  cV = 1.3,
  uV = 3e4,
  hV = 'server_kill',
  XE = 3
class Ui extends iR {
  constructor(e, n, r, i, s, o, a, l) {
    if (
      (super(),
      (this.repoInfo_ = e),
      (this.applicationId_ = n),
      (this.onDataUpdate_ = r),
      (this.onConnectStatus_ = i),
      (this.onServerInfoUpdate_ = s),
      (this.authTokenProvider_ = o),
      (this.appCheckTokenProvider_ = a),
      (this.authOverride_ = l),
      (this.id = Ui.nextPersistentConnectionId_++),
      (this.log_ = Zu('p:' + this.id + ':')),
      (this.interruptReasons_ = {}),
      (this.listens = new Map()),
      (this.outstandingPuts_ = []),
      (this.outstandingGets_ = []),
      (this.outstandingPutCount_ = 0),
      (this.outstandingGetCount_ = 0),
      (this.onDisconnectRequestQueue_ = []),
      (this.connected_ = !1),
      (this.reconnectDelay_ = ec),
      (this.maxReconnectDelay_ = lV),
      (this.securityDebugCallback_ = null),
      (this.lastSessionId = null),
      (this.establishConnectionTimer_ = null),
      (this.visible_ = !1),
      (this.requestCBHash_ = {}),
      (this.requestNumber_ = 0),
      (this.realtime_ = null),
      (this.authToken_ = null),
      (this.appCheckToken_ = null),
      (this.forceTokenRefresh_ = !1),
      (this.invalidAuthTokenCount_ = 0),
      (this.invalidAppCheckTokenCount_ = 0),
      (this.firstConnection_ = !0),
      (this.lastConnectionAttemptTime_ = null),
      (this.lastConnectionEstablishedTime_ = null),
      l && !qA())
    )
      throw new Error(
        'Auth override specified in options, but not supported on non Node.js platforms'
      )
    a0.getInstance().on('visible', this.onVisible_, this),
      e.host.indexOf('fblocal') === -1 && hf.getInstance().on('online', this.onOnline_, this)
  }
  sendRequest(e, n, r) {
    const i = ++this.requestNumber_,
      s = { r: i, a: e, b: n }
    this.log_(_n(s)),
      te(this.connected_, "sendRequest call when we're not connected not allowed."),
      this.realtime_.sendRequest(s),
      r && (this.requestCBHash_[i] = r)
  }
  get(e) {
    this.initConnection_()
    const n = new ou(),
      i = {
        action: 'g',
        request: { p: e._path.toString(), q: e._queryObject },
        onComplete: (o) => {
          const a = o.d
          o.s === 'ok' ? n.resolve(a) : n.reject(a)
        }
      }
    this.outstandingGets_.push(i), this.outstandingGetCount_++
    const s = this.outstandingGets_.length - 1
    return this.connected_ && this.sendGet_(s), n.promise
  }
  listen(e, n, r, i) {
    this.initConnection_()
    const s = e._queryIdentifier,
      o = e._path.toString()
    this.log_('Listen called for ' + o + ' ' + s),
      this.listens.has(o) || this.listens.set(o, new Map()),
      te(
        e._queryParams.isDefault() || !e._queryParams.loadsAllData(),
        'listen() called for non-default but complete query'
      ),
      te(!this.listens.get(o).has(s), 'listen() called twice for same path/queryId.')
    const a = { onComplete: i, hashFn: n, query: e, tag: r }
    this.listens.get(o).set(s, a), this.connected_ && this.sendListen_(a)
  }
  sendGet_(e) {
    const n = this.outstandingGets_[e]
    this.sendRequest('g', n.request, (r) => {
      delete this.outstandingGets_[e],
        this.outstandingGetCount_--,
        this.outstandingGetCount_ === 0 && (this.outstandingGets_ = []),
        n.onComplete && n.onComplete(r)
    })
  }
  sendListen_(e) {
    const n = e.query,
      r = n._path.toString(),
      i = n._queryIdentifier
    this.log_('Listen on ' + r + ' for ' + i)
    const s = { p: r },
      o = 'q'
    e.tag && ((s.q = n._queryObject), (s.t = e.tag)),
      (s.h = e.hashFn()),
      this.sendRequest(o, s, (a) => {
        const l = a.d,
          c = a.s
        Ui.warnOnListenWarnings_(l, n),
          (this.listens.get(r) && this.listens.get(r).get(i)) === e &&
            (this.log_('listen response', a),
            c !== 'ok' && this.removeListen_(r, i),
            e.onComplete && e.onComplete(c, l))
      })
  }
  static warnOnListenWarnings_(e, n) {
    if (e && typeof e == 'object' && Qi(e, 'w')) {
      const r = al(e, 'w')
      if (Array.isArray(r) && ~r.indexOf('no_index')) {
        const i = '".indexOn": "' + n._queryParams.getIndex().toString() + '"',
          s = n._path.toString()
        lr(
          `Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${i} at ${s} to your security rules for better performance.`
        )
      }
    }
  }
  refreshAuthToken(e) {
    ;(this.authToken_ = e),
      this.log_('Auth token refreshed'),
      this.authToken_
        ? this.tryAuth()
        : this.connected_ && this.sendRequest('unauth', {}, () => {}),
      this.reduceReconnectDelayIfAdminCredential_(e)
  }
  reduceReconnectDelayIfAdminCredential_(e) {
    ;((e && e.length === 40) || b4(e)) &&
      (this.log_('Admin auth credential detected.  Reducing max reconnect time.'),
      (this.maxReconnectDelay_ = QE))
  }
  refreshAppCheckToken(e) {
    ;(this.appCheckToken_ = e),
      this.log_('App check token refreshed'),
      this.appCheckToken_
        ? this.tryAppCheck()
        : this.connected_ && this.sendRequest('unappeck', {}, () => {})
  }
  tryAuth() {
    if (this.connected_ && this.authToken_) {
      const e = this.authToken_,
        n = v4(e) ? 'auth' : 'gauth',
        r = { cred: e }
      this.authOverride_ === null
        ? (r.noauth = !0)
        : typeof this.authOverride_ == 'object' && (r.authvar = this.authOverride_),
        this.sendRequest(n, r, (i) => {
          const s = i.s,
            o = i.d || 'error'
          this.authToken_ === e &&
            (s === 'ok' ? (this.invalidAuthTokenCount_ = 0) : this.onAuthRevoked_(s, o))
        })
    }
  }
  tryAppCheck() {
    this.connected_ &&
      this.appCheckToken_ &&
      this.sendRequest('appcheck', { token: this.appCheckToken_ }, (e) => {
        const n = e.s,
          r = e.d || 'error'
        n === 'ok' ? (this.invalidAppCheckTokenCount_ = 0) : this.onAppCheckRevoked_(n, r)
      })
  }
  unlisten(e, n) {
    const r = e._path.toString(),
      i = e._queryIdentifier
    this.log_('Unlisten called for ' + r + ' ' + i),
      te(
        e._queryParams.isDefault() || !e._queryParams.loadsAllData(),
        'unlisten() called for non-default but complete query'
      ),
      this.removeListen_(r, i) && this.connected_ && this.sendUnlisten_(r, i, e._queryObject, n)
  }
  sendUnlisten_(e, n, r, i) {
    this.log_('Unlisten on ' + e + ' for ' + n)
    const s = { p: e },
      o = 'n'
    i && ((s.q = r), (s.t = i)), this.sendRequest(o, s)
  }
  onDisconnectPut(e, n, r) {
    this.initConnection_(),
      this.connected_
        ? this.sendOnDisconnect_('o', e, n, r)
        : this.onDisconnectRequestQueue_.push({
            pathString: e,
            action: 'o',
            data: n,
            onComplete: r
          })
  }
  onDisconnectMerge(e, n, r) {
    this.initConnection_(),
      this.connected_
        ? this.sendOnDisconnect_('om', e, n, r)
        : this.onDisconnectRequestQueue_.push({
            pathString: e,
            action: 'om',
            data: n,
            onComplete: r
          })
  }
  onDisconnectCancel(e, n) {
    this.initConnection_(),
      this.connected_
        ? this.sendOnDisconnect_('oc', e, null, n)
        : this.onDisconnectRequestQueue_.push({
            pathString: e,
            action: 'oc',
            data: null,
            onComplete: n
          })
  }
  sendOnDisconnect_(e, n, r, i) {
    const s = { p: n, d: r }
    this.log_('onDisconnect ' + e, s),
      this.sendRequest(e, s, (o) => {
        i &&
          setTimeout(() => {
            i(o.s, o.d)
          }, Math.floor(0))
      })
  }
  put(e, n, r, i) {
    this.putInternal('p', e, n, r, i)
  }
  merge(e, n, r, i) {
    this.putInternal('m', e, n, r, i)
  }
  putInternal(e, n, r, i, s) {
    this.initConnection_()
    const o = { p: n, d: r }
    s !== void 0 && (o.h = s),
      this.outstandingPuts_.push({ action: e, request: o, onComplete: i }),
      this.outstandingPutCount_++
    const a = this.outstandingPuts_.length - 1
    this.connected_ ? this.sendPut_(a) : this.log_('Buffering put: ' + n)
  }
  sendPut_(e) {
    const n = this.outstandingPuts_[e].action,
      r = this.outstandingPuts_[e].request,
      i = this.outstandingPuts_[e].onComplete
    ;(this.outstandingPuts_[e].queued = this.connected_),
      this.sendRequest(n, r, (s) => {
        this.log_(n + ' response', s),
          delete this.outstandingPuts_[e],
          this.outstandingPutCount_--,
          this.outstandingPutCount_ === 0 && (this.outstandingPuts_ = []),
          i && i(s.s, s.d)
      })
  }
  reportStats(e) {
    if (this.connected_) {
      const n = { c: e }
      this.log_('reportStats', n),
        this.sendRequest('s', n, (r) => {
          if (r.s !== 'ok') {
            const s = r.d
            this.log_('reportStats', 'Error sending stats: ' + s)
          }
        })
    }
  }
  onDataMessage_(e) {
    if ('r' in e) {
      this.log_('from server: ' + _n(e))
      const n = e.r,
        r = this.requestCBHash_[n]
      r && (delete this.requestCBHash_[n], r(e.b))
    } else {
      if ('error' in e) throw 'A server-side error has occurred: ' + e.error
      'a' in e && this.onDataPush_(e.a, e.b)
    }
  }
  onDataPush_(e, n) {
    this.log_('handleServerMessage', e, n),
      e === 'd'
        ? this.onDataUpdate_(n.p, n.d, !1, n.t)
        : e === 'm'
        ? this.onDataUpdate_(n.p, n.d, !0, n.t)
        : e === 'c'
        ? this.onListenRevoked_(n.p, n.q)
        : e === 'ac'
        ? this.onAuthRevoked_(n.s, n.d)
        : e === 'apc'
        ? this.onAppCheckRevoked_(n.s, n.d)
        : e === 'sd'
        ? this.onSecurityDebugPacket_(n)
        : $y(
            'Unrecognized action received from server: ' +
              _n(e) +
              `
Are you using the latest client?`
          )
  }
  onReady_(e, n) {
    this.log_('connection ready'),
      (this.connected_ = !0),
      (this.lastConnectionEstablishedTime_ = new Date().getTime()),
      this.handleTimestamp_(e),
      (this.lastSessionId = n),
      this.firstConnection_ && this.sendConnectStats_(),
      this.restoreState_(),
      (this.firstConnection_ = !1),
      this.onConnectStatus_(!0)
  }
  scheduleConnect_(e) {
    te(!this.realtime_, "Scheduling a connect when we're already connected/ing?"),
      this.establishConnectionTimer_ && clearTimeout(this.establishConnectionTimer_),
      (this.establishConnectionTimer_ = setTimeout(() => {
        ;(this.establishConnectionTimer_ = null), this.establishConnection_()
      }, Math.floor(e)))
  }
  initConnection_() {
    !this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0)
  }
  onVisible_(e) {
    e &&
      !this.visible_ &&
      this.reconnectDelay_ === this.maxReconnectDelay_ &&
      (this.log_('Window became visible.  Reducing delay.'),
      (this.reconnectDelay_ = ec),
      this.realtime_ || this.scheduleConnect_(0)),
      (this.visible_ = e)
  }
  onOnline_(e) {
    e
      ? (this.log_('Browser went online.'),
        (this.reconnectDelay_ = ec),
        this.realtime_ || this.scheduleConnect_(0))
      : (this.log_('Browser went offline.  Killing connection.'),
        this.realtime_ && this.realtime_.close())
  }
  onRealtimeDisconnect_() {
    if (
      (this.log_('data client disconnected'),
      (this.connected_ = !1),
      (this.realtime_ = null),
      this.cancelSentTransactions_(),
      (this.requestCBHash_ = {}),
      this.shouldReconnect_())
    ) {
      this.visible_
        ? this.lastConnectionEstablishedTime_ &&
          (new Date().getTime() - this.lastConnectionEstablishedTime_ > uV &&
            (this.reconnectDelay_ = ec),
          (this.lastConnectionEstablishedTime_ = null))
        : (this.log_("Window isn't visible.  Delaying reconnect."),
          (this.reconnectDelay_ = this.maxReconnectDelay_),
          (this.lastConnectionAttemptTime_ = new Date().getTime()))
      const e = new Date().getTime() - this.lastConnectionAttemptTime_
      let n = Math.max(0, this.reconnectDelay_ - e)
      ;(n = Math.random() * n),
        this.log_('Trying to reconnect in ' + n + 'ms'),
        this.scheduleConnect_(n),
        (this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * cV))
    }
    this.onConnectStatus_(!1)
  }
  async establishConnection_() {
    if (this.shouldReconnect_()) {
      this.log_('Making a connection attempt'),
        (this.lastConnectionAttemptTime_ = new Date().getTime()),
        (this.lastConnectionEstablishedTime_ = null)
      const e = this.onDataMessage_.bind(this),
        n = this.onReady_.bind(this),
        r = this.onRealtimeDisconnect_.bind(this),
        i = this.id + ':' + Ui.nextConnectionId_++,
        s = this.lastSessionId
      let o = !1,
        a = null
      const l = function () {
          a ? a.close() : ((o = !0), r())
        },
        c = function (h) {
          te(a, "sendRequest call when we're not connected not allowed."), a.sendRequest(h)
        }
      this.realtime_ = { close: l, sendRequest: c }
      const u = this.forceTokenRefresh_
      this.forceTokenRefresh_ = !1
      try {
        const [h, d] = await Promise.all([
          this.authTokenProvider_.getToken(u),
          this.appCheckTokenProvider_.getToken(u)
        ])
        o
          ? Cn('getToken() completed but was canceled')
          : (Cn('getToken() completed. Creating connection.'),
            (this.authToken_ = h && h.accessToken),
            (this.appCheckToken_ = d && d.token),
            (a = new rV(
              i,
              this.repoInfo_,
              this.applicationId_,
              this.appCheckToken_,
              this.authToken_,
              e,
              n,
              r,
              (f) => {
                lr(f + ' (' + this.repoInfo_.toString() + ')'), this.interrupt(hV)
              },
              s
            )))
      } catch (h) {
        this.log_('Failed to get token: ' + h), o || (this.repoInfo_.nodeAdmin && lr(h), l())
      }
    }
  }
  interrupt(e) {
    Cn('Interrupting connection for reason: ' + e),
      (this.interruptReasons_[e] = !0),
      this.realtime_
        ? this.realtime_.close()
        : (this.establishConnectionTimer_ &&
            (clearTimeout(this.establishConnectionTimer_), (this.establishConnectionTimer_ = null)),
          this.connected_ && this.onRealtimeDisconnect_())
  }
  resume(e) {
    Cn('Resuming connection for reason: ' + e),
      delete this.interruptReasons_[e],
      ky(this.interruptReasons_) &&
        ((this.reconnectDelay_ = ec), this.realtime_ || this.scheduleConnect_(0))
  }
  handleTimestamp_(e) {
    const n = e - new Date().getTime()
    this.onServerInfoUpdate_({ serverTimeOffset: n })
  }
  cancelSentTransactions_() {
    for (let e = 0; e < this.outstandingPuts_.length; e++) {
      const n = this.outstandingPuts_[e]
      n &&
        'h' in n.request &&
        n.queued &&
        (n.onComplete && n.onComplete('disconnect'),
        delete this.outstandingPuts_[e],
        this.outstandingPutCount_--)
    }
    this.outstandingPutCount_ === 0 && (this.outstandingPuts_ = [])
  }
  onListenRevoked_(e, n) {
    let r
    n ? (r = n.map((s) => r0(s)).join('$')) : (r = 'default')
    const i = this.removeListen_(e, r)
    i && i.onComplete && i.onComplete('permission_denied')
  }
  removeListen_(e, n) {
    const r = new Tt(e).toString()
    let i
    if (this.listens.has(r)) {
      const s = this.listens.get(r)
      ;(i = s.get(n)), s.delete(n), s.size === 0 && this.listens.delete(r)
    } else i = void 0
    return i
  }
  onAuthRevoked_(e, n) {
    Cn('Auth token revoked: ' + e + '/' + n),
      (this.authToken_ = null),
      (this.forceTokenRefresh_ = !0),
      this.realtime_.close(),
      (e === 'invalid_token' || e === 'permission_denied') &&
        (this.invalidAuthTokenCount_++,
        this.invalidAuthTokenCount_ >= XE &&
          ((this.reconnectDelay_ = QE), this.authTokenProvider_.notifyForInvalidToken()))
  }
  onAppCheckRevoked_(e, n) {
    Cn('App check token revoked: ' + e + '/' + n),
      (this.appCheckToken_ = null),
      (this.forceTokenRefresh_ = !0),
      (e === 'invalid_token' || e === 'permission_denied') &&
        (this.invalidAppCheckTokenCount_++,
        this.invalidAppCheckTokenCount_ >= XE &&
          this.appCheckTokenProvider_.notifyForInvalidToken())
  }
  onSecurityDebugPacket_(e) {
    this.securityDebugCallback_
      ? this.securityDebugCallback_(e)
      : 'msg' in e &&
        console.log(
          'FIREBASE: ' +
            e.msg.replace(
              `
`,
              `
FIREBASE: `
            )
        )
  }
  restoreState_() {
    this.tryAuth(), this.tryAppCheck()
    for (const e of this.listens.values()) for (const n of e.values()) this.sendListen_(n)
    for (let e = 0; e < this.outstandingPuts_.length; e++)
      this.outstandingPuts_[e] && this.sendPut_(e)
    for (; this.onDisconnectRequestQueue_.length; ) {
      const e = this.onDisconnectRequestQueue_.shift()
      this.sendOnDisconnect_(e.action, e.pathString, e.data, e.onComplete)
    }
    for (let e = 0; e < this.outstandingGets_.length; e++)
      this.outstandingGets_[e] && this.sendGet_(e)
  }
  sendConnectStats_() {
    const e = {}
    let n = 'js'
    ;(e['sdk.' + n + '.' + VC.replace(/\./g, '-')] = 1),
      $v() ? (e['framework.cordova'] = 1) : GA() && (e['framework.reactnative'] = 1),
      this.reportStats(e)
  }
  shouldReconnect_() {
    const e = hf.getInstance().currentlyOnline()
    return ky(this.interruptReasons_) && e
  }
}
Ui.nextPersistentConnectionId_ = 0
Ui.nextConnectionId_ = 0
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ke {
  constructor(e, n) {
    ;(this.name = e), (this.node = n)
  }
  static Wrap(e, n) {
    return new Ke(e, n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Mp {
  getCompare() {
    return this.compare.bind(this)
  }
  indexedValueChanged(e, n) {
    const r = new Ke(cl, e),
      i = new Ke(cl, n)
    return this.compare(r, i) !== 0
  }
  minPost() {
    return Ke.MIN
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let jh
class hR extends Mp {
  static get __EMPTY_NODE() {
    return jh
  }
  static set __EMPTY_NODE(e) {
    jh = e
  }
  compare(e, n) {
    return Fl(e.name, n.name)
  }
  isDefinedOn(e) {
    throw xl('KeyIndex.isDefinedOn not expected to be called.')
  }
  indexedValueChanged(e, n) {
    return !1
  }
  minPost() {
    return Ke.MIN
  }
  maxPost() {
    return new Ke(Yo, jh)
  }
  makePost(e, n) {
    return te(typeof e == 'string', 'KeyIndex indexValue must always be a string.'), new Ke(e, jh)
  }
  toString() {
    return '.key'
  }
}
const Ka = new hR()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Wh = class {
    constructor(e, n, r, i, s = null) {
      ;(this.isReverse_ = i), (this.resultGenerator_ = s), (this.nodeStack_ = [])
      let o = 1
      for (; !e.isEmpty(); )
        if (((e = e), (o = n ? r(e.key, n) : 1), i && (o *= -1), o < 0))
          this.isReverse_ ? (e = e.left) : (e = e.right)
        else if (o === 0) {
          this.nodeStack_.push(e)
          break
        } else this.nodeStack_.push(e), this.isReverse_ ? (e = e.right) : (e = e.left)
    }
    getNext() {
      if (this.nodeStack_.length === 0) return null
      let e = this.nodeStack_.pop(),
        n
      if (
        (this.resultGenerator_
          ? (n = this.resultGenerator_(e.key, e.value))
          : (n = { key: e.key, value: e.value }),
        this.isReverse_)
      )
        for (e = e.left; !e.isEmpty(); ) this.nodeStack_.push(e), (e = e.right)
      else for (e = e.right; !e.isEmpty(); ) this.nodeStack_.push(e), (e = e.left)
      return n
    }
    hasNext() {
      return this.nodeStack_.length > 0
    }
    peek() {
      if (this.nodeStack_.length === 0) return null
      const e = this.nodeStack_[this.nodeStack_.length - 1]
      return this.resultGenerator_
        ? this.resultGenerator_(e.key, e.value)
        : { key: e.key, value: e.value }
    }
  },
  nr = class uc {
    constructor(e, n, r, i, s) {
      ;(this.key = e),
        (this.value = n),
        (this.color = r ?? uc.RED),
        (this.left = i ?? ti.EMPTY_NODE),
        (this.right = s ?? ti.EMPTY_NODE)
    }
    copy(e, n, r, i, s) {
      return new uc(
        e ?? this.key,
        n ?? this.value,
        r ?? this.color,
        i ?? this.left,
        s ?? this.right
      )
    }
    count() {
      return this.left.count() + 1 + this.right.count()
    }
    isEmpty() {
      return !1
    }
    inorderTraversal(e) {
      return (
        this.left.inorderTraversal(e) || !!e(this.key, this.value) || this.right.inorderTraversal(e)
      )
    }
    reverseTraversal(e) {
      return (
        this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e)
      )
    }
    min_() {
      return this.left.isEmpty() ? this : this.left.min_()
    }
    minKey() {
      return this.min_().key
    }
    maxKey() {
      return this.right.isEmpty() ? this.key : this.right.maxKey()
    }
    insert(e, n, r) {
      let i = this
      const s = r(e, i.key)
      return (
        s < 0
          ? (i = i.copy(null, null, null, i.left.insert(e, n, r), null))
          : s === 0
          ? (i = i.copy(null, n, null, null, null))
          : (i = i.copy(null, null, null, null, i.right.insert(e, n, r))),
        i.fixUp_()
      )
    }
    removeMin_() {
      if (this.left.isEmpty()) return ti.EMPTY_NODE
      let e = this
      return (
        !e.left.isRed_() && !e.left.left.isRed_() && (e = e.moveRedLeft_()),
        (e = e.copy(null, null, null, e.left.removeMin_(), null)),
        e.fixUp_()
      )
    }
    remove(e, n) {
      let r, i
      if (((r = this), n(e, r.key) < 0))
        !r.left.isEmpty() && !r.left.isRed_() && !r.left.left.isRed_() && (r = r.moveRedLeft_()),
          (r = r.copy(null, null, null, r.left.remove(e, n), null))
      else {
        if (
          (r.left.isRed_() && (r = r.rotateRight_()),
          !r.right.isEmpty() &&
            !r.right.isRed_() &&
            !r.right.left.isRed_() &&
            (r = r.moveRedRight_()),
          n(e, r.key) === 0)
        ) {
          if (r.right.isEmpty()) return ti.EMPTY_NODE
          ;(i = r.right.min_()), (r = r.copy(i.key, i.value, null, null, r.right.removeMin_()))
        }
        r = r.copy(null, null, null, null, r.right.remove(e, n))
      }
      return r.fixUp_()
    }
    isRed_() {
      return this.color
    }
    fixUp_() {
      let e = this
      return (
        e.right.isRed_() && !e.left.isRed_() && (e = e.rotateLeft_()),
        e.left.isRed_() && e.left.left.isRed_() && (e = e.rotateRight_()),
        e.left.isRed_() && e.right.isRed_() && (e = e.colorFlip_()),
        e
      )
    }
    moveRedLeft_() {
      let e = this.colorFlip_()
      return (
        e.right.left.isRed_() &&
          ((e = e.copy(null, null, null, null, e.right.rotateRight_())),
          (e = e.rotateLeft_()),
          (e = e.colorFlip_())),
        e
      )
    }
    moveRedRight_() {
      let e = this.colorFlip_()
      return e.left.left.isRed_() && ((e = e.rotateRight_()), (e = e.colorFlip_())), e
    }
    rotateLeft_() {
      const e = this.copy(null, null, uc.RED, null, this.right.left)
      return this.right.copy(null, null, this.color, e, null)
    }
    rotateRight_() {
      const e = this.copy(null, null, uc.RED, this.left.right, null)
      return this.left.copy(null, null, this.color, null, e)
    }
    colorFlip_() {
      const e = this.left.copy(null, null, !this.left.color, null, null),
        n = this.right.copy(null, null, !this.right.color, null, null)
      return this.copy(null, null, !this.color, e, n)
    }
    checkMaxDepth_() {
      const e = this.check_()
      return Math.pow(2, e) <= this.count() + 1
    }
    check_() {
      if (this.isRed_() && this.left.isRed_())
        throw new Error('Red node has red child(' + this.key + ',' + this.value + ')')
      if (this.right.isRed_())
        throw new Error('Right child of (' + this.key + ',' + this.value + ') is red')
      const e = this.left.check_()
      if (e !== this.right.check_()) throw new Error('Black depths differ')
      return e + (this.isRed_() ? 0 : 1)
    }
  }
nr.RED = !0
nr.BLACK = !1
class dV {
  copy(e, n, r, i, s) {
    return this
  }
  insert(e, n, r) {
    return new nr(e, n, null)
  }
  remove(e, n) {
    return this
  }
  count() {
    return 0
  }
  isEmpty() {
    return !0
  }
  inorderTraversal(e) {
    return !1
  }
  reverseTraversal(e) {
    return !1
  }
  minKey() {
    return null
  }
  maxKey() {
    return null
  }
  check_() {
    return 0
  }
  isRed_() {
    return !1
  }
}
let ti = class Cd {
  constructor(e, n = Cd.EMPTY_NODE) {
    ;(this.comparator_ = e), (this.root_ = n)
  }
  insert(e, n) {
    return new Cd(
      this.comparator_,
      this.root_.insert(e, n, this.comparator_).copy(null, null, nr.BLACK, null, null)
    )
  }
  remove(e) {
    return new Cd(
      this.comparator_,
      this.root_.remove(e, this.comparator_).copy(null, null, nr.BLACK, null, null)
    )
  }
  get(e) {
    let n,
      r = this.root_
    for (; !r.isEmpty(); ) {
      if (((n = this.comparator_(e, r.key)), n === 0)) return r.value
      n < 0 ? (r = r.left) : n > 0 && (r = r.right)
    }
    return null
  }
  getPredecessorKey(e) {
    let n,
      r = this.root_,
      i = null
    for (; !r.isEmpty(); )
      if (((n = this.comparator_(e, r.key)), n === 0)) {
        if (r.left.isEmpty()) return i ? i.key : null
        for (r = r.left; !r.right.isEmpty(); ) r = r.right
        return r.key
      } else n < 0 ? (r = r.left) : n > 0 && ((i = r), (r = r.right))
    throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?')
  }
  isEmpty() {
    return this.root_.isEmpty()
  }
  count() {
    return this.root_.count()
  }
  minKey() {
    return this.root_.minKey()
  }
  maxKey() {
    return this.root_.maxKey()
  }
  inorderTraversal(e) {
    return this.root_.inorderTraversal(e)
  }
  reverseTraversal(e) {
    return this.root_.reverseTraversal(e)
  }
  getIterator(e) {
    return new Wh(this.root_, null, this.comparator_, !1, e)
  }
  getIteratorFrom(e, n) {
    return new Wh(this.root_, e, this.comparator_, !1, n)
  }
  getReverseIteratorFrom(e, n) {
    return new Wh(this.root_, e, this.comparator_, !0, n)
  }
  getReverseIterator(e) {
    return new Wh(this.root_, null, this.comparator_, !0, e)
  }
}
ti.EMPTY_NODE = new dV()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function fV(t, e) {
  return Fl(t.name, e.name)
}
function l0(t, e) {
  return Fl(t, e)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let jy
function pV(t) {
  jy = t
}
const dR = function (t) {
    return typeof t == 'number' ? 'number:' + HC(t) : 'string:' + t
  },
  fR = function (t) {
    if (t.isLeafNode()) {
      const e = t.val()
      te(
        typeof e == 'string' || typeof e == 'number' || (typeof e == 'object' && Qi(e, '.sv')),
        'Priority must be a string or number.'
      )
    } else te(t === jy || t.isEmpty(), 'priority of unexpected type.')
    te(t === jy || t.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.")
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let ZE
class Qt {
  constructor(e, n = Qt.__childrenNodeConstructor.EMPTY_NODE) {
    ;(this.value_ = e),
      (this.priorityNode_ = n),
      (this.lazyHash_ = null),
      te(
        this.value_ !== void 0 && this.value_ !== null,
        "LeafNode shouldn't be created with null/undefined value."
      ),
      fR(this.priorityNode_)
  }
  static set __childrenNodeConstructor(e) {
    ZE = e
  }
  static get __childrenNodeConstructor() {
    return ZE
  }
  isLeafNode() {
    return !0
  }
  getPriority() {
    return this.priorityNode_
  }
  updatePriority(e) {
    return new Qt(this.value_, e)
  }
  getImmediateChild(e) {
    return e === '.priority' ? this.priorityNode_ : Qt.__childrenNodeConstructor.EMPTY_NODE
  }
  getChild(e) {
    return je(e)
      ? this
      : qe(e) === '.priority'
      ? this.priorityNode_
      : Qt.__childrenNodeConstructor.EMPTY_NODE
  }
  hasChild() {
    return !1
  }
  getPredecessorChildName(e, n) {
    return null
  }
  updateImmediateChild(e, n) {
    return e === '.priority'
      ? this.updatePriority(n)
      : n.isEmpty() && e !== '.priority'
      ? this
      : Qt.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(e, n).updatePriority(
          this.priorityNode_
        )
  }
  updateChild(e, n) {
    const r = qe(e)
    return r === null
      ? n
      : n.isEmpty() && r !== '.priority'
      ? this
      : (te(r !== '.priority' || Us(e) === 1, '.priority must be the last token in a path'),
        this.updateImmediateChild(r, Qt.__childrenNodeConstructor.EMPTY_NODE.updateChild(_t(e), n)))
  }
  isEmpty() {
    return !1
  }
  numChildren() {
    return 0
  }
  forEachChild(e, n) {
    return !1
  }
  val(e) {
    return e && !this.getPriority().isEmpty()
      ? { '.value': this.getValue(), '.priority': this.getPriority().val() }
      : this.getValue()
  }
  hash() {
    if (this.lazyHash_ === null) {
      let e = ''
      this.priorityNode_.isEmpty() || (e += 'priority:' + dR(this.priorityNode_.val()) + ':')
      const n = typeof this.value_
      ;(e += n + ':'),
        n === 'number' ? (e += HC(this.value_)) : (e += this.value_),
        (this.lazyHash_ = BC(e))
    }
    return this.lazyHash_
  }
  getValue() {
    return this.value_
  }
  compareTo(e) {
    return e === Qt.__childrenNodeConstructor.EMPTY_NODE
      ? 1
      : e instanceof Qt.__childrenNodeConstructor
      ? -1
      : (te(e.isLeafNode(), 'Unknown node type'), this.compareToLeafNode_(e))
  }
  compareToLeafNode_(e) {
    const n = typeof e.value_,
      r = typeof this.value_,
      i = Qt.VALUE_TYPE_ORDER.indexOf(n),
      s = Qt.VALUE_TYPE_ORDER.indexOf(r)
    return (
      te(i >= 0, 'Unknown leaf type: ' + n),
      te(s >= 0, 'Unknown leaf type: ' + r),
      i === s
        ? r === 'object'
          ? 0
          : this.value_ < e.value_
          ? -1
          : this.value_ === e.value_
          ? 0
          : 1
        : s - i
    )
  }
  withIndex() {
    return this
  }
  isIndexed() {
    return !0
  }
  equals(e) {
    if (e === this) return !0
    if (e.isLeafNode()) {
      const n = e
      return this.value_ === n.value_ && this.priorityNode_.equals(n.priorityNode_)
    } else return !1
  }
}
Qt.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string']
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let pR, mR
function mV(t) {
  pR = t
}
function gV(t) {
  mR = t
}
class yV extends Mp {
  compare(e, n) {
    const r = e.node.getPriority(),
      i = n.node.getPriority(),
      s = r.compareTo(i)
    return s === 0 ? Fl(e.name, n.name) : s
  }
  isDefinedOn(e) {
    return !e.getPriority().isEmpty()
  }
  indexedValueChanged(e, n) {
    return !e.getPriority().equals(n.getPriority())
  }
  minPost() {
    return Ke.MIN
  }
  maxPost() {
    return new Ke(Yo, new Qt('[PRIORITY-POST]', mR))
  }
  makePost(e, n) {
    const r = pR(e)
    return new Ke(n, new Qt('[PRIORITY-POST]', r))
  }
  toString() {
    return '.priority'
  }
}
const Nn = new yV()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const _V = Math.log(2)
class vV {
  constructor(e) {
    const n = (s) => parseInt(Math.log(s) / _V, 10),
      r = (s) => parseInt(Array(s + 1).join('1'), 2)
    ;(this.count = n(e + 1)), (this.current_ = this.count - 1)
    const i = r(this.count)
    this.bits_ = (e + 1) & i
  }
  nextBitIsOne() {
    const e = !(this.bits_ & (1 << this.current_))
    return this.current_--, e
  }
}
const df = function (t, e, n, r) {
  t.sort(e)
  const i = function (l, c) {
      const u = c - l
      let h, d
      if (u === 0) return null
      if (u === 1) return (h = t[l]), (d = n ? n(h) : h), new nr(d, h.node, nr.BLACK, null, null)
      {
        const f = parseInt(u / 2, 10) + l,
          p = i(l, f),
          m = i(f + 1, c)
        return (h = t[f]), (d = n ? n(h) : h), new nr(d, h.node, nr.BLACK, p, m)
      }
    },
    s = function (l) {
      let c = null,
        u = null,
        h = t.length
      const d = function (p, m) {
          const g = h - p,
            _ = h
          h -= p
          const v = i(g + 1, _),
            T = t[g],
            S = n ? n(T) : T
          f(new nr(S, T.node, m, null, v))
        },
        f = function (p) {
          c ? ((c.left = p), (c = p)) : ((u = p), (c = p))
        }
      for (let p = 0; p < l.count; ++p) {
        const m = l.nextBitIsOne(),
          g = Math.pow(2, l.count - (p + 1))
        m ? d(g, nr.BLACK) : (d(g, nr.BLACK), d(g, nr.RED))
      }
      return u
    },
    o = new vV(t.length),
    a = s(o)
  return new ti(r || e, a)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let tg
const _a = {}
class Li {
  constructor(e, n) {
    ;(this.indexes_ = e), (this.indexSet_ = n)
  }
  static get Default() {
    return (
      te(_a && Nn, 'ChildrenNode.ts has not been loaded'),
      (tg = tg || new Li({ '.priority': _a }, { '.priority': Nn })),
      tg
    )
  }
  get(e) {
    const n = al(this.indexes_, e)
    if (!n) throw new Error('No index defined for ' + e)
    return n instanceof ti ? n : null
  }
  hasIndex(e) {
    return Qi(this.indexSet_, e.toString())
  }
  addIndex(e, n) {
    te(e !== Ka, "KeyIndex always exists and isn't meant to be added to the IndexMap.")
    const r = []
    let i = !1
    const s = n.getIterator(Ke.Wrap)
    let o = s.getNext()
    for (; o; ) (i = i || e.isDefinedOn(o.node)), r.push(o), (o = s.getNext())
    let a
    i ? (a = df(r, e.getCompare())) : (a = _a)
    const l = e.toString(),
      c = Object.assign({}, this.indexSet_)
    c[l] = e
    const u = Object.assign({}, this.indexes_)
    return (u[l] = a), new Li(u, c)
  }
  addToIndexes(e, n) {
    const r = tf(this.indexes_, (i, s) => {
      const o = al(this.indexSet_, s)
      if ((te(o, 'Missing index implementation for ' + s), i === _a))
        if (o.isDefinedOn(e.node)) {
          const a = [],
            l = n.getIterator(Ke.Wrap)
          let c = l.getNext()
          for (; c; ) c.name !== e.name && a.push(c), (c = l.getNext())
          return a.push(e), df(a, o.getCompare())
        } else return _a
      else {
        const a = n.get(e.name)
        let l = i
        return a && (l = l.remove(new Ke(e.name, a))), l.insert(e, e.node)
      }
    })
    return new Li(r, this.indexSet_)
  }
  removeFromIndexes(e, n) {
    const r = tf(this.indexes_, (i) => {
      if (i === _a) return i
      {
        const s = n.get(e.name)
        return s ? i.remove(new Ke(e.name, s)) : i
      }
    })
    return new Li(r, this.indexSet_)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let tc
class nt {
  constructor(e, n, r) {
    ;(this.children_ = e),
      (this.priorityNode_ = n),
      (this.indexMap_ = r),
      (this.lazyHash_ = null),
      this.priorityNode_ && fR(this.priorityNode_),
      this.children_.isEmpty() &&
        te(
          !this.priorityNode_ || this.priorityNode_.isEmpty(),
          'An empty node cannot have a priority'
        )
  }
  static get EMPTY_NODE() {
    return tc || (tc = new nt(new ti(l0), null, Li.Default))
  }
  isLeafNode() {
    return !1
  }
  getPriority() {
    return this.priorityNode_ || tc
  }
  updatePriority(e) {
    return this.children_.isEmpty() ? this : new nt(this.children_, e, this.indexMap_)
  }
  getImmediateChild(e) {
    if (e === '.priority') return this.getPriority()
    {
      const n = this.children_.get(e)
      return n === null ? tc : n
    }
  }
  getChild(e) {
    const n = qe(e)
    return n === null ? this : this.getImmediateChild(n).getChild(_t(e))
  }
  hasChild(e) {
    return this.children_.get(e) !== null
  }
  updateImmediateChild(e, n) {
    if ((te(n, 'We should always be passing snapshot nodes'), e === '.priority'))
      return this.updatePriority(n)
    {
      const r = new Ke(e, n)
      let i, s
      n.isEmpty()
        ? ((i = this.children_.remove(e)),
          (s = this.indexMap_.removeFromIndexes(r, this.children_)))
        : ((i = this.children_.insert(e, n)), (s = this.indexMap_.addToIndexes(r, this.children_)))
      const o = i.isEmpty() ? tc : this.priorityNode_
      return new nt(i, o, s)
    }
  }
  updateChild(e, n) {
    const r = qe(e)
    if (r === null) return n
    {
      te(qe(e) !== '.priority' || Us(e) === 1, '.priority must be the last token in a path')
      const i = this.getImmediateChild(r).updateChild(_t(e), n)
      return this.updateImmediateChild(r, i)
    }
  }
  isEmpty() {
    return this.children_.isEmpty()
  }
  numChildren() {
    return this.children_.count()
  }
  val(e) {
    if (this.isEmpty()) return null
    const n = {}
    let r = 0,
      i = 0,
      s = !0
    if (
      (this.forEachChild(Nn, (o, a) => {
        ;(n[o] = a.val(e)),
          r++,
          s && nt.INTEGER_REGEXP_.test(o) ? (i = Math.max(i, Number(o))) : (s = !1)
      }),
      !e && s && i < 2 * r)
    ) {
      const o = []
      for (const a in n) o[a] = n[a]
      return o
    } else
      return e && !this.getPriority().isEmpty() && (n['.priority'] = this.getPriority().val()), n
  }
  hash() {
    if (this.lazyHash_ === null) {
      let e = ''
      this.getPriority().isEmpty() || (e += 'priority:' + dR(this.getPriority().val()) + ':'),
        this.forEachChild(Nn, (n, r) => {
          const i = r.hash()
          i !== '' && (e += ':' + n + ':' + i)
        }),
        (this.lazyHash_ = e === '' ? '' : BC(e))
    }
    return this.lazyHash_
  }
  getPredecessorChildName(e, n, r) {
    const i = this.resolveIndex_(r)
    if (i) {
      const s = i.getPredecessorKey(new Ke(e, n))
      return s ? s.name : null
    } else return this.children_.getPredecessorKey(e)
  }
  getFirstChildName(e) {
    const n = this.resolveIndex_(e)
    if (n) {
      const r = n.minKey()
      return r && r.name
    } else return this.children_.minKey()
  }
  getFirstChild(e) {
    const n = this.getFirstChildName(e)
    return n ? new Ke(n, this.children_.get(n)) : null
  }
  getLastChildName(e) {
    const n = this.resolveIndex_(e)
    if (n) {
      const r = n.maxKey()
      return r && r.name
    } else return this.children_.maxKey()
  }
  getLastChild(e) {
    const n = this.getLastChildName(e)
    return n ? new Ke(n, this.children_.get(n)) : null
  }
  forEachChild(e, n) {
    const r = this.resolveIndex_(e)
    return r ? r.inorderTraversal((i) => n(i.name, i.node)) : this.children_.inorderTraversal(n)
  }
  getIterator(e) {
    return this.getIteratorFrom(e.minPost(), e)
  }
  getIteratorFrom(e, n) {
    const r = this.resolveIndex_(n)
    if (r) return r.getIteratorFrom(e, (i) => i)
    {
      const i = this.children_.getIteratorFrom(e.name, Ke.Wrap)
      let s = i.peek()
      for (; s != null && n.compare(s, e) < 0; ) i.getNext(), (s = i.peek())
      return i
    }
  }
  getReverseIterator(e) {
    return this.getReverseIteratorFrom(e.maxPost(), e)
  }
  getReverseIteratorFrom(e, n) {
    const r = this.resolveIndex_(n)
    if (r) return r.getReverseIteratorFrom(e, (i) => i)
    {
      const i = this.children_.getReverseIteratorFrom(e.name, Ke.Wrap)
      let s = i.peek()
      for (; s != null && n.compare(s, e) > 0; ) i.getNext(), (s = i.peek())
      return i
    }
  }
  compareTo(e) {
    return this.isEmpty()
      ? e.isEmpty()
        ? 0
        : -1
      : e.isLeafNode() || e.isEmpty()
      ? 1
      : e === th
      ? -1
      : 0
  }
  withIndex(e) {
    if (e === Ka || this.indexMap_.hasIndex(e)) return this
    {
      const n = this.indexMap_.addIndex(e, this.children_)
      return new nt(this.children_, this.priorityNode_, n)
    }
  }
  isIndexed(e) {
    return e === Ka || this.indexMap_.hasIndex(e)
  }
  equals(e) {
    if (e === this) return !0
    if (e.isLeafNode()) return !1
    {
      const n = e
      if (this.getPriority().equals(n.getPriority()))
        if (this.children_.count() === n.children_.count()) {
          const r = this.getIterator(Nn),
            i = n.getIterator(Nn)
          let s = r.getNext(),
            o = i.getNext()
          for (; s && o; ) {
            if (s.name !== o.name || !s.node.equals(o.node)) return !1
            ;(s = r.getNext()), (o = i.getNext())
          }
          return s === null && o === null
        } else return !1
      else return !1
    }
  }
  resolveIndex_(e) {
    return e === Ka ? null : this.indexMap_.get(e.toString())
  }
}
nt.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/
class bV extends nt {
  constructor() {
    super(new ti(l0), nt.EMPTY_NODE, Li.Default)
  }
  compareTo(e) {
    return e === this ? 0 : 1
  }
  equals(e) {
    return e === this
  }
  getPriority() {
    return this
  }
  getImmediateChild(e) {
    return nt.EMPTY_NODE
  }
  isEmpty() {
    return !1
  }
}
const th = new bV()
Object.defineProperties(Ke, {
  MIN: { value: new Ke(cl, nt.EMPTY_NODE) },
  MAX: { value: new Ke(Yo, th) }
})
hR.__EMPTY_NODE = nt.EMPTY_NODE
Qt.__childrenNodeConstructor = nt
pV(th)
gV(th)
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const EV = !0
function Rn(t, e = null) {
  if (t === null) return nt.EMPTY_NODE
  if (
    (typeof t == 'object' && '.priority' in t && (e = t['.priority']),
    te(
      e === null ||
        typeof e == 'string' ||
        typeof e == 'number' ||
        (typeof e == 'object' && '.sv' in e),
      'Invalid priority type found: ' + typeof e
    ),
    typeof t == 'object' && '.value' in t && t['.value'] !== null && (t = t['.value']),
    typeof t != 'object' || '.sv' in t)
  ) {
    const n = t
    return new Qt(n, Rn(e))
  }
  if (!(t instanceof Array) && EV) {
    const n = []
    let r = !1
    if (
      (Ar(t, (o, a) => {
        if (o.substring(0, 1) !== '.') {
          const l = Rn(a)
          l.isEmpty() || ((r = r || !l.getPriority().isEmpty()), n.push(new Ke(o, l)))
        }
      }),
      n.length === 0)
    )
      return nt.EMPTY_NODE
    const s = df(n, fV, (o) => o.name, l0)
    if (r) {
      const o = df(n, Nn.getCompare())
      return new nt(s, Rn(e), new Li({ '.priority': o }, { '.priority': Nn }))
    } else return new nt(s, Rn(e), Li.Default)
  } else {
    let n = nt.EMPTY_NODE
    return (
      Ar(t, (r, i) => {
        if (Qi(t, r) && r.substring(0, 1) !== '.') {
          const s = Rn(i)
          ;(s.isLeafNode() || !s.isEmpty()) && (n = n.updateImmediateChild(r, s))
        }
      }),
      n.updatePriority(Rn(e))
    )
  }
}
mV(Rn)
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class TV extends Mp {
  constructor(e) {
    super(),
      (this.indexPath_ = e),
      te(!je(e) && qe(e) !== '.priority', "Can't create PathIndex with empty path or .priority key")
  }
  extractChild(e) {
    return e.getChild(this.indexPath_)
  }
  isDefinedOn(e) {
    return !e.getChild(this.indexPath_).isEmpty()
  }
  compare(e, n) {
    const r = this.extractChild(e.node),
      i = this.extractChild(n.node),
      s = r.compareTo(i)
    return s === 0 ? Fl(e.name, n.name) : s
  }
  makePost(e, n) {
    const r = Rn(e),
      i = nt.EMPTY_NODE.updateChild(this.indexPath_, r)
    return new Ke(n, i)
  }
  maxPost() {
    const e = nt.EMPTY_NODE.updateChild(this.indexPath_, th)
    return new Ke(Yo, e)
  }
  toString() {
    return aR(this.indexPath_, 0).join('/')
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class wV extends Mp {
  compare(e, n) {
    const r = e.node.compareTo(n.node)
    return r === 0 ? Fl(e.name, n.name) : r
  }
  isDefinedOn(e) {
    return !0
  }
  indexedValueChanged(e, n) {
    return !e.equals(n)
  }
  minPost() {
    return Ke.MIN
  }
  maxPost() {
    return Ke.MAX
  }
  makePost(e, n) {
    const r = Rn(e)
    return new Ke(n, r)
  }
  toString() {
    return '.value'
  }
}
const SV = new wV()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function IV(t) {
  return { type: 'value', snapshotNode: t }
}
function AV(t, e) {
  return { type: 'child_added', snapshotNode: e, childName: t }
}
function CV(t, e) {
  return { type: 'child_removed', snapshotNode: e, childName: t }
}
function eT(t, e, n) {
  return { type: 'child_changed', snapshotNode: e, childName: t, oldSnap: n }
}
function RV(t, e) {
  return { type: 'child_moved', snapshotNode: e, childName: t }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class c0 {
  constructor() {
    ;(this.limitSet_ = !1),
      (this.startSet_ = !1),
      (this.startNameSet_ = !1),
      (this.startAfterSet_ = !1),
      (this.endSet_ = !1),
      (this.endNameSet_ = !1),
      (this.endBeforeSet_ = !1),
      (this.limit_ = 0),
      (this.viewFrom_ = ''),
      (this.indexStartValue_ = null),
      (this.indexStartName_ = ''),
      (this.indexEndValue_ = null),
      (this.indexEndName_ = ''),
      (this.index_ = Nn)
  }
  hasStart() {
    return this.startSet_
  }
  isViewFromLeft() {
    return this.viewFrom_ === '' ? this.startSet_ : this.viewFrom_ === 'l'
  }
  getIndexStartValue() {
    return te(this.startSet_, 'Only valid if start has been set'), this.indexStartValue_
  }
  getIndexStartName() {
    return (
      te(this.startSet_, 'Only valid if start has been set'),
      this.startNameSet_ ? this.indexStartName_ : cl
    )
  }
  hasEnd() {
    return this.endSet_
  }
  getIndexEndValue() {
    return te(this.endSet_, 'Only valid if end has been set'), this.indexEndValue_
  }
  getIndexEndName() {
    return (
      te(this.endSet_, 'Only valid if end has been set'), this.endNameSet_ ? this.indexEndName_ : Yo
    )
  }
  hasLimit() {
    return this.limitSet_
  }
  hasAnchoredLimit() {
    return this.limitSet_ && this.viewFrom_ !== ''
  }
  getLimit() {
    return te(this.limitSet_, 'Only valid if limit has been set'), this.limit_
  }
  getIndex() {
    return this.index_
  }
  loadsAllData() {
    return !(this.startSet_ || this.endSet_ || this.limitSet_)
  }
  isDefault() {
    return this.loadsAllData() && this.index_ === Nn
  }
  copy() {
    const e = new c0()
    return (
      (e.limitSet_ = this.limitSet_),
      (e.limit_ = this.limit_),
      (e.startSet_ = this.startSet_),
      (e.startAfterSet_ = this.startAfterSet_),
      (e.indexStartValue_ = this.indexStartValue_),
      (e.startNameSet_ = this.startNameSet_),
      (e.indexStartName_ = this.indexStartName_),
      (e.endSet_ = this.endSet_),
      (e.endBeforeSet_ = this.endBeforeSet_),
      (e.indexEndValue_ = this.indexEndValue_),
      (e.endNameSet_ = this.endNameSet_),
      (e.indexEndName_ = this.indexEndName_),
      (e.index_ = this.index_),
      (e.viewFrom_ = this.viewFrom_),
      e
    )
  }
}
function tT(t) {
  const e = {}
  if (t.isDefault()) return e
  let n
  if (
    (t.index_ === Nn
      ? (n = '$priority')
      : t.index_ === SV
      ? (n = '$value')
      : t.index_ === Ka
      ? (n = '$key')
      : (te(t.index_ instanceof TV, 'Unrecognized index type!'), (n = t.index_.toString())),
    (e.orderBy = _n(n)),
    t.startSet_)
  ) {
    const r = t.startAfterSet_ ? 'startAfter' : 'startAt'
    ;(e[r] = _n(t.indexStartValue_)), t.startNameSet_ && (e[r] += ',' + _n(t.indexStartName_))
  }
  if (t.endSet_) {
    const r = t.endBeforeSet_ ? 'endBefore' : 'endAt'
    ;(e[r] = _n(t.indexEndValue_)), t.endNameSet_ && (e[r] += ',' + _n(t.indexEndName_))
  }
  return (
    t.limitSet_ && (t.isViewFromLeft() ? (e.limitToFirst = t.limit_) : (e.limitToLast = t.limit_)),
    e
  )
}
function nT(t) {
  const e = {}
  if (
    (t.startSet_ &&
      ((e.sp = t.indexStartValue_),
      t.startNameSet_ && (e.sn = t.indexStartName_),
      (e.sin = !t.startAfterSet_)),
    t.endSet_ &&
      ((e.ep = t.indexEndValue_),
      t.endNameSet_ && (e.en = t.indexEndName_),
      (e.ein = !t.endBeforeSet_)),
    t.limitSet_)
  ) {
    e.l = t.limit_
    let n = t.viewFrom_
    n === '' && (t.isViewFromLeft() ? (n = 'l') : (n = 'r')), (e.vf = n)
  }
  return t.index_ !== Nn && (e.i = t.index_.toString()), e
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ff extends iR {
  constructor(e, n, r, i) {
    super(),
      (this.repoInfo_ = e),
      (this.onDataUpdate_ = n),
      (this.authTokenProvider_ = r),
      (this.appCheckTokenProvider_ = i),
      (this.log_ = Zu('p:rest:')),
      (this.listens_ = {})
  }
  reportStats(e) {
    throw new Error('Method not implemented.')
  }
  static getListenId_(e, n) {
    return n !== void 0
      ? 'tag$' + n
      : (te(e._queryParams.isDefault(), "should have a tag if it's not a default query."),
        e._path.toString())
  }
  listen(e, n, r, i) {
    const s = e._path.toString()
    this.log_('Listen called for ' + s + ' ' + e._queryIdentifier)
    const o = ff.getListenId_(e, r),
      a = {}
    this.listens_[o] = a
    const l = tT(e._queryParams)
    this.restRequest_(s + '.json', l, (c, u) => {
      let h = u
      if (
        (c === 404 && ((h = null), (c = null)),
        c === null && this.onDataUpdate_(s, h, !1, r),
        al(this.listens_, o) === a)
      ) {
        let d
        c ? (c === 401 ? (d = 'permission_denied') : (d = 'rest_error:' + c)) : (d = 'ok'),
          i(d, null)
      }
    })
  }
  unlisten(e, n) {
    const r = ff.getListenId_(e, n)
    delete this.listens_[r]
  }
  get(e) {
    const n = tT(e._queryParams),
      r = e._path.toString(),
      i = new ou()
    return (
      this.restRequest_(r + '.json', n, (s, o) => {
        let a = o
        s === 404 && ((a = null), (s = null)),
          s === null ? (this.onDataUpdate_(r, a, !1, null), i.resolve(a)) : i.reject(new Error(a))
      }),
      i.promise
    )
  }
  refreshAuthToken(e) {}
  restRequest_(e, n = {}, r) {
    return (
      (n.format = 'export'),
      Promise.all([
        this.authTokenProvider_.getToken(!1),
        this.appCheckTokenProvider_.getToken(!1)
      ]).then(([i, s]) => {
        i && i.accessToken && (n.auth = i.accessToken), s && s.token && (n.ac = s.token)
        const o =
          (this.repoInfo_.secure ? 'https://' : 'http://') +
          this.repoInfo_.host +
          e +
          '?ns=' +
          this.repoInfo_.namespace +
          Ll(n)
        this.log_('Sending REST request for ' + o)
        const a = new XMLHttpRequest()
        ;(a.onreadystatechange = () => {
          if (r && a.readyState === 4) {
            this.log_(
              'REST Response for ' + o + ' received. status:',
              a.status,
              'response:',
              a.responseText
            )
            let l = null
            if (a.status >= 200 && a.status < 300) {
              try {
                l = au(a.responseText)
              } catch {
                lr('Failed to parse JSON response for ' + o + ': ' + a.responseText)
              }
              r(null, l)
            } else
              a.status !== 401 &&
                a.status !== 404 &&
                lr('Got unsuccessful REST response for ' + o + ' Status: ' + a.status),
                r(a.status)
            r = null
          }
        }),
          a.open('GET', o, !0),
          a.send()
      })
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class kV {
  constructor() {
    this.rootNode_ = nt.EMPTY_NODE
  }
  getNode(e) {
    return this.rootNode_.getChild(e)
  }
  updateSnapshot(e, n) {
    this.rootNode_ = this.rootNode_.updateChild(e, n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function pf() {
  return { value: null, children: new Map() }
}
function gR(t, e, n) {
  if (je(e)) (t.value = n), t.children.clear()
  else if (t.value !== null) t.value = t.value.updateChild(e, n)
  else {
    const r = qe(e)
    t.children.has(r) || t.children.set(r, pf())
    const i = t.children.get(r)
    ;(e = _t(e)), gR(i, e, n)
  }
}
function Wy(t, e, n) {
  t.value !== null
    ? n(e, t.value)
    : OV(t, (r, i) => {
        const s = new Tt(e.toString() + '/' + r)
        Wy(i, s, n)
      })
}
function OV(t, e) {
  t.children.forEach((n, r) => {
    e(r, n)
  })
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class NV {
  constructor(e) {
    ;(this.collection_ = e), (this.last_ = null)
  }
  get() {
    const e = this.collection_.get(),
      n = Object.assign({}, e)
    return (
      this.last_ &&
        Ar(this.last_, (r, i) => {
          n[r] = n[r] - i
        }),
      (this.last_ = e),
      n
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const rT = 10 * 1e3,
  MV = 30 * 1e3,
  PV = 5 * 60 * 1e3
class xV {
  constructor(e, n) {
    ;(this.server_ = n), (this.statsToReport_ = {}), (this.statsListener_ = new NV(e))
    const r = rT + (MV - rT) * Math.random()
    Mc(this.reportStats_.bind(this), Math.floor(r))
  }
  reportStats_() {
    const e = this.statsListener_.get(),
      n = {}
    let r = !1
    Ar(e, (i, s) => {
      s > 0 && Qi(this.statsToReport_, i) && ((n[i] = s), (r = !0))
    }),
      r && this.server_.reportStats(n),
      Mc(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * PV))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var ni
;(function (t) {
  ;(t[(t.OVERWRITE = 0)] = 'OVERWRITE'),
    (t[(t.MERGE = 1)] = 'MERGE'),
    (t[(t.ACK_USER_WRITE = 2)] = 'ACK_USER_WRITE'),
    (t[(t.LISTEN_COMPLETE = 3)] = 'LISTEN_COMPLETE')
})(ni || (ni = {}))
function yR() {
  return { fromUser: !0, fromServer: !1, queryId: null, tagged: !1 }
}
function _R() {
  return { fromUser: !1, fromServer: !0, queryId: null, tagged: !1 }
}
function vR(t) {
  return { fromUser: !1, fromServer: !0, queryId: t, tagged: !0 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class mf {
  constructor(e, n, r) {
    ;(this.path = e),
      (this.affectedTree = n),
      (this.revert = r),
      (this.type = ni.ACK_USER_WRITE),
      (this.source = yR())
  }
  operationForChild(e) {
    if (je(this.path)) {
      if (this.affectedTree.value != null)
        return (
          te(
            this.affectedTree.children.isEmpty(),
            'affectedTree should not have overlapping affected paths.'
          ),
          this
        )
      {
        const n = this.affectedTree.subtree(new Tt(e))
        return new mf(lt(), n, this.revert)
      }
    } else
      return (
        te(qe(this.path) === e, 'operationForChild called for unrelated child.'),
        new mf(_t(this.path), this.affectedTree, this.revert)
      )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Jo {
  constructor(e, n, r) {
    ;(this.source = e), (this.path = n), (this.snap = r), (this.type = ni.OVERWRITE)
  }
  operationForChild(e) {
    return je(this.path)
      ? new Jo(this.source, lt(), this.snap.getImmediateChild(e))
      : new Jo(this.source, _t(this.path), this.snap)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class fu {
  constructor(e, n, r) {
    ;(this.source = e), (this.path = n), (this.children = r), (this.type = ni.MERGE)
  }
  operationForChild(e) {
    if (je(this.path)) {
      const n = this.children.subtree(new Tt(e))
      return n.isEmpty()
        ? null
        : n.value
        ? new Jo(this.source, lt(), n.value)
        : new fu(this.source, lt(), n)
    } else
      return (
        te(qe(this.path) === e, "Can't get a merge for a child not on the path of the operation"),
        new fu(this.source, _t(this.path), this.children)
      )
  }
  toString() {
    return (
      'Operation(' +
      this.path +
      ': ' +
      this.source.toString() +
      ' merge: ' +
      this.children.toString() +
      ')'
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class u0 {
  constructor(e, n, r) {
    ;(this.node_ = e), (this.fullyInitialized_ = n), (this.filtered_ = r)
  }
  isFullyInitialized() {
    return this.fullyInitialized_
  }
  isFiltered() {
    return this.filtered_
  }
  isCompleteForPath(e) {
    if (je(e)) return this.isFullyInitialized() && !this.filtered_
    const n = qe(e)
    return this.isCompleteForChild(n)
  }
  isCompleteForChild(e) {
    return (this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(e)
  }
  getNode() {
    return this.node_
  }
}
function DV(t, e, n, r) {
  const i = [],
    s = []
  return (
    e.forEach((o) => {
      o.type === 'child_changed' &&
        t.index_.indexedValueChanged(o.oldSnap, o.snapshotNode) &&
        s.push(RV(o.childName, o.snapshotNode))
    }),
    nc(t, i, 'child_removed', e, r, n),
    nc(t, i, 'child_added', e, r, n),
    nc(t, i, 'child_moved', s, r, n),
    nc(t, i, 'child_changed', e, r, n),
    nc(t, i, 'value', e, r, n),
    i
  )
}
function nc(t, e, n, r, i, s) {
  const o = r.filter((a) => a.type === n)
  o.sort((a, l) => VV(t, a, l)),
    o.forEach((a) => {
      const l = LV(t, a, s)
      i.forEach((c) => {
        c.respondsTo(a.type) && e.push(c.createEvent(l, t.query_))
      })
    })
}
function LV(t, e, n) {
  return (
    e.type === 'value' ||
      e.type === 'child_removed' ||
      (e.prevName = n.getPredecessorChildName(e.childName, e.snapshotNode, t.index_)),
    e
  )
}
function VV(t, e, n) {
  if (e.childName == null || n.childName == null) throw xl('Should only compare child_ events.')
  const r = new Ke(e.childName, e.snapshotNode),
    i = new Ke(n.childName, n.snapshotNode)
  return t.index_.compare(r, i)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function bR(t, e) {
  return { eventCache: t, serverCache: e }
}
function Pc(t, e, n, r) {
  return bR(new u0(e, n, r), t.serverCache)
}
function ER(t, e, n, r) {
  return bR(t.eventCache, new u0(e, n, r))
}
function Gy(t) {
  return t.eventCache.isFullyInitialized() ? t.eventCache.getNode() : null
}
function Qo(t) {
  return t.serverCache.isFullyInitialized() ? t.serverCache.getNode() : null
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let ng
const FV = () => (ng || (ng = new ti(w5)), ng)
class gt {
  constructor(e, n = FV()) {
    ;(this.value = e), (this.children = n)
  }
  static fromObject(e) {
    let n = new gt(null)
    return (
      Ar(e, (r, i) => {
        n = n.set(new Tt(r), i)
      }),
      n
    )
  }
  isEmpty() {
    return this.value === null && this.children.isEmpty()
  }
  findRootMostMatchingPathAndValue(e, n) {
    if (this.value != null && n(this.value)) return { path: lt(), value: this.value }
    if (je(e)) return null
    {
      const r = qe(e),
        i = this.children.get(r)
      if (i !== null) {
        const s = i.findRootMostMatchingPathAndValue(_t(e), n)
        return s != null ? { path: en(new Tt(r), s.path), value: s.value } : null
      } else return null
    }
  }
  findRootMostValueAndPath(e) {
    return this.findRootMostMatchingPathAndValue(e, () => !0)
  }
  subtree(e) {
    if (je(e)) return this
    {
      const n = qe(e),
        r = this.children.get(n)
      return r !== null ? r.subtree(_t(e)) : new gt(null)
    }
  }
  set(e, n) {
    if (je(e)) return new gt(n, this.children)
    {
      const r = qe(e),
        s = (this.children.get(r) || new gt(null)).set(_t(e), n),
        o = this.children.insert(r, s)
      return new gt(this.value, o)
    }
  }
  remove(e) {
    if (je(e)) return this.children.isEmpty() ? new gt(null) : new gt(null, this.children)
    {
      const n = qe(e),
        r = this.children.get(n)
      if (r) {
        const i = r.remove(_t(e))
        let s
        return (
          i.isEmpty() ? (s = this.children.remove(n)) : (s = this.children.insert(n, i)),
          this.value === null && s.isEmpty() ? new gt(null) : new gt(this.value, s)
        )
      } else return this
    }
  }
  get(e) {
    if (je(e)) return this.value
    {
      const n = qe(e),
        r = this.children.get(n)
      return r ? r.get(_t(e)) : null
    }
  }
  setTree(e, n) {
    if (je(e)) return n
    {
      const r = qe(e),
        s = (this.children.get(r) || new gt(null)).setTree(_t(e), n)
      let o
      return (
        s.isEmpty() ? (o = this.children.remove(r)) : (o = this.children.insert(r, s)),
        new gt(this.value, o)
      )
    }
  }
  fold(e) {
    return this.fold_(lt(), e)
  }
  fold_(e, n) {
    const r = {}
    return (
      this.children.inorderTraversal((i, s) => {
        r[i] = s.fold_(en(e, i), n)
      }),
      n(e, this.value, r)
    )
  }
  findOnPath(e, n) {
    return this.findOnPath_(e, lt(), n)
  }
  findOnPath_(e, n, r) {
    const i = this.value ? r(n, this.value) : !1
    if (i) return i
    if (je(e)) return null
    {
      const s = qe(e),
        o = this.children.get(s)
      return o ? o.findOnPath_(_t(e), en(n, s), r) : null
    }
  }
  foreachOnPath(e, n) {
    return this.foreachOnPath_(e, lt(), n)
  }
  foreachOnPath_(e, n, r) {
    if (je(e)) return this
    {
      this.value && r(n, this.value)
      const i = qe(e),
        s = this.children.get(i)
      return s ? s.foreachOnPath_(_t(e), en(n, i), r) : new gt(null)
    }
  }
  foreach(e) {
    this.foreach_(lt(), e)
  }
  foreach_(e, n) {
    this.children.inorderTraversal((r, i) => {
      i.foreach_(en(e, r), n)
    }),
      this.value && n(e, this.value)
  }
  foreachChild(e) {
    this.children.inorderTraversal((n, r) => {
      r.value && e(n, r.value)
    })
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Fr {
  constructor(e) {
    this.writeTree_ = e
  }
  static empty() {
    return new Fr(new gt(null))
  }
}
function xc(t, e, n) {
  if (je(e)) return new Fr(new gt(n))
  {
    const r = t.writeTree_.findRootMostValueAndPath(e)
    if (r != null) {
      const i = r.path
      let s = r.value
      const o = Tr(i, e)
      return (s = s.updateChild(o, n)), new Fr(t.writeTree_.set(i, s))
    } else {
      const i = new gt(n),
        s = t.writeTree_.setTree(e, i)
      return new Fr(s)
    }
  }
}
function iT(t, e, n) {
  let r = t
  return (
    Ar(n, (i, s) => {
      r = xc(r, en(e, i), s)
    }),
    r
  )
}
function sT(t, e) {
  if (je(e)) return Fr.empty()
  {
    const n = t.writeTree_.setTree(e, new gt(null))
    return new Fr(n)
  }
}
function qy(t, e) {
  return ha(t, e) != null
}
function ha(t, e) {
  const n = t.writeTree_.findRootMostValueAndPath(e)
  return n != null ? t.writeTree_.get(n.path).getChild(Tr(n.path, e)) : null
}
function oT(t) {
  const e = [],
    n = t.writeTree_.value
  return (
    n != null
      ? n.isLeafNode() ||
        n.forEachChild(Nn, (r, i) => {
          e.push(new Ke(r, i))
        })
      : t.writeTree_.children.inorderTraversal((r, i) => {
          i.value != null && e.push(new Ke(r, i.value))
        }),
    e
  )
}
function Ns(t, e) {
  if (je(e)) return t
  {
    const n = ha(t, e)
    return n != null ? new Fr(new gt(n)) : new Fr(t.writeTree_.subtree(e))
  }
}
function Ky(t) {
  return t.writeTree_.isEmpty()
}
function ul(t, e) {
  return TR(lt(), t.writeTree_, e)
}
function TR(t, e, n) {
  if (e.value != null) return n.updateChild(t, e.value)
  {
    let r = null
    return (
      e.children.inorderTraversal((i, s) => {
        i === '.priority'
          ? (te(s.value !== null, 'Priority writes must always be leaf nodes'), (r = s.value))
          : (n = TR(en(t, i), s, n))
      }),
      !n.getChild(t).isEmpty() && r !== null && (n = n.updateChild(en(t, '.priority'), r)),
      n
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function wR(t, e) {
  return RR(e, t)
}
function BV(t, e, n, r, i) {
  te(r > t.lastWriteId, 'Stacking an older write on top of newer ones'),
    i === void 0 && (i = !0),
    t.allWrites.push({ path: e, snap: n, writeId: r, visible: i }),
    i && (t.visibleWrites = xc(t.visibleWrites, e, n)),
    (t.lastWriteId = r)
}
function UV(t, e) {
  for (let n = 0; n < t.allWrites.length; n++) {
    const r = t.allWrites[n]
    if (r.writeId === e) return r
  }
  return null
}
function $V(t, e) {
  const n = t.allWrites.findIndex((a) => a.writeId === e)
  te(n >= 0, 'removeWrite called with nonexistent writeId.')
  const r = t.allWrites[n]
  t.allWrites.splice(n, 1)
  let i = r.visible,
    s = !1,
    o = t.allWrites.length - 1
  for (; i && o >= 0; ) {
    const a = t.allWrites[o]
    a.visible && (o >= n && HV(a, r.path) ? (i = !1) : Dr(r.path, a.path) && (s = !0)), o--
  }
  if (i) {
    if (s) return zV(t), !0
    if (r.snap) t.visibleWrites = sT(t.visibleWrites, r.path)
    else {
      const a = r.children
      Ar(a, (l) => {
        t.visibleWrites = sT(t.visibleWrites, en(r.path, l))
      })
    }
    return !0
  } else return !1
}
function HV(t, e) {
  if (t.snap) return Dr(t.path, e)
  for (const n in t.children) if (t.children.hasOwnProperty(n) && Dr(en(t.path, n), e)) return !0
  return !1
}
function zV(t) {
  ;(t.visibleWrites = SR(t.allWrites, jV, lt())),
    t.allWrites.length > 0
      ? (t.lastWriteId = t.allWrites[t.allWrites.length - 1].writeId)
      : (t.lastWriteId = -1)
}
function jV(t) {
  return t.visible
}
function SR(t, e, n) {
  let r = Fr.empty()
  for (let i = 0; i < t.length; ++i) {
    const s = t[i]
    if (e(s)) {
      const o = s.path
      let a
      if (s.snap)
        Dr(n, o)
          ? ((a = Tr(n, o)), (r = xc(r, a, s.snap)))
          : Dr(o, n) && ((a = Tr(o, n)), (r = xc(r, lt(), s.snap.getChild(a))))
      else if (s.children) {
        if (Dr(n, o)) (a = Tr(n, o)), (r = iT(r, a, s.children))
        else if (Dr(o, n))
          if (((a = Tr(o, n)), je(a))) r = iT(r, lt(), s.children)
          else {
            const l = al(s.children, qe(a))
            if (l) {
              const c = l.getChild(_t(a))
              r = xc(r, lt(), c)
            }
          }
      } else throw xl('WriteRecord should have .snap or .children')
    }
  }
  return r
}
function IR(t, e, n, r, i) {
  if (!r && !i) {
    const s = ha(t.visibleWrites, e)
    if (s != null) return s
    {
      const o = Ns(t.visibleWrites, e)
      if (Ky(o)) return n
      if (n == null && !qy(o, lt())) return null
      {
        const a = n || nt.EMPTY_NODE
        return ul(o, a)
      }
    }
  } else {
    const s = Ns(t.visibleWrites, e)
    if (!i && Ky(s)) return n
    if (!i && n == null && !qy(s, lt())) return null
    {
      const o = function (c) {
          return (
            (c.visible || i) && (!r || !~r.indexOf(c.writeId)) && (Dr(c.path, e) || Dr(e, c.path))
          )
        },
        a = SR(t.allWrites, o, e),
        l = n || nt.EMPTY_NODE
      return ul(a, l)
    }
  }
}
function WV(t, e, n) {
  let r = nt.EMPTY_NODE
  const i = ha(t.visibleWrites, e)
  if (i)
    return (
      i.isLeafNode() ||
        i.forEachChild(Nn, (s, o) => {
          r = r.updateImmediateChild(s, o)
        }),
      r
    )
  if (n) {
    const s = Ns(t.visibleWrites, e)
    return (
      n.forEachChild(Nn, (o, a) => {
        const l = ul(Ns(s, new Tt(o)), a)
        r = r.updateImmediateChild(o, l)
      }),
      oT(s).forEach((o) => {
        r = r.updateImmediateChild(o.name, o.node)
      }),
      r
    )
  } else {
    const s = Ns(t.visibleWrites, e)
    return (
      oT(s).forEach((o) => {
        r = r.updateImmediateChild(o.name, o.node)
      }),
      r
    )
  }
}
function GV(t, e, n, r, i) {
  te(r || i, 'Either existingEventSnap or existingServerSnap must exist')
  const s = en(e, n)
  if (qy(t.visibleWrites, s)) return null
  {
    const o = Ns(t.visibleWrites, s)
    return Ky(o) ? i.getChild(n) : ul(o, i.getChild(n))
  }
}
function qV(t, e, n, r) {
  const i = en(e, n),
    s = ha(t.visibleWrites, i)
  if (s != null) return s
  if (r.isCompleteForChild(n)) {
    const o = Ns(t.visibleWrites, i)
    return ul(o, r.getNode().getImmediateChild(n))
  } else return null
}
function KV(t, e) {
  return ha(t.visibleWrites, e)
}
function YV(t, e, n, r, i, s, o) {
  let a
  const l = Ns(t.visibleWrites, e),
    c = ha(l, lt())
  if (c != null) a = c
  else if (n != null) a = ul(l, n)
  else return []
  if (((a = a.withIndex(o)), !a.isEmpty() && !a.isLeafNode())) {
    const u = [],
      h = o.getCompare(),
      d = s ? a.getReverseIteratorFrom(r, o) : a.getIteratorFrom(r, o)
    let f = d.getNext()
    for (; f && u.length < i; ) h(f, r) !== 0 && u.push(f), (f = d.getNext())
    return u
  } else return []
}
function JV() {
  return { visibleWrites: Fr.empty(), allWrites: [], lastWriteId: -1 }
}
function Yy(t, e, n, r) {
  return IR(t.writeTree, t.treePath, e, n, r)
}
function AR(t, e) {
  return WV(t.writeTree, t.treePath, e)
}
function aT(t, e, n, r) {
  return GV(t.writeTree, t.treePath, e, n, r)
}
function gf(t, e) {
  return KV(t.writeTree, en(t.treePath, e))
}
function QV(t, e, n, r, i, s) {
  return YV(t.writeTree, t.treePath, e, n, r, i, s)
}
function h0(t, e, n) {
  return qV(t.writeTree, t.treePath, e, n)
}
function CR(t, e) {
  return RR(en(t.treePath, e), t.writeTree)
}
function RR(t, e) {
  return { treePath: t, writeTree: e }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class XV {
  constructor() {
    this.changeMap = new Map()
  }
  trackChildChange(e) {
    const n = e.type,
      r = e.childName
    te(
      n === 'child_added' || n === 'child_changed' || n === 'child_removed',
      'Only child changes supported for tracking'
    ),
      te(r !== '.priority', 'Only non-priority child changes can be tracked.')
    const i = this.changeMap.get(r)
    if (i) {
      const s = i.type
      if (n === 'child_added' && s === 'child_removed')
        this.changeMap.set(r, eT(r, e.snapshotNode, i.snapshotNode))
      else if (n === 'child_removed' && s === 'child_added') this.changeMap.delete(r)
      else if (n === 'child_removed' && s === 'child_changed')
        this.changeMap.set(r, CV(r, i.oldSnap))
      else if (n === 'child_changed' && s === 'child_added')
        this.changeMap.set(r, AV(r, e.snapshotNode))
      else if (n === 'child_changed' && s === 'child_changed')
        this.changeMap.set(r, eT(r, e.snapshotNode, i.oldSnap))
      else throw xl('Illegal combination of changes: ' + e + ' occurred after ' + i)
    } else this.changeMap.set(r, e)
  }
  getChanges() {
    return Array.from(this.changeMap.values())
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ZV {
  getCompleteChild(e) {
    return null
  }
  getChildAfterChild(e, n, r) {
    return null
  }
}
const kR = new ZV()
class d0 {
  constructor(e, n, r = null) {
    ;(this.writes_ = e), (this.viewCache_ = n), (this.optCompleteServerCache_ = r)
  }
  getCompleteChild(e) {
    const n = this.viewCache_.eventCache
    if (n.isCompleteForChild(e)) return n.getNode().getImmediateChild(e)
    {
      const r =
        this.optCompleteServerCache_ != null
          ? new u0(this.optCompleteServerCache_, !0, !1)
          : this.viewCache_.serverCache
      return h0(this.writes_, e, r)
    }
  }
  getChildAfterChild(e, n, r) {
    const i =
        this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : Qo(this.viewCache_),
      s = QV(this.writes_, i, n, 1, r, e)
    return s.length === 0 ? null : s[0]
  }
}
function e9(t, e) {
  te(e.eventCache.getNode().isIndexed(t.filter.getIndex()), 'Event snap not indexed'),
    te(e.serverCache.getNode().isIndexed(t.filter.getIndex()), 'Server snap not indexed')
}
function t9(t, e, n, r, i) {
  const s = new XV()
  let o, a
  if (n.type === ni.OVERWRITE) {
    const c = n
    c.source.fromUser
      ? (o = Jy(t, e, c.path, c.snap, r, i, s))
      : (te(c.source.fromServer, 'Unknown source.'),
        (a = c.source.tagged || (e.serverCache.isFiltered() && !je(c.path))),
        (o = yf(t, e, c.path, c.snap, r, i, a, s)))
  } else if (n.type === ni.MERGE) {
    const c = n
    c.source.fromUser
      ? (o = r9(t, e, c.path, c.children, r, i, s))
      : (te(c.source.fromServer, 'Unknown source.'),
        (a = c.source.tagged || e.serverCache.isFiltered()),
        (o = Qy(t, e, c.path, c.children, r, i, a, s)))
  } else if (n.type === ni.ACK_USER_WRITE) {
    const c = n
    c.revert ? (o = o9(t, e, c.path, r, i, s)) : (o = i9(t, e, c.path, c.affectedTree, r, i, s))
  } else if (n.type === ni.LISTEN_COMPLETE) o = s9(t, e, n.path, r, s)
  else throw xl('Unknown operation type: ' + n.type)
  const l = s.getChanges()
  return n9(e, o, l), { viewCache: o, changes: l }
}
function n9(t, e, n) {
  const r = e.eventCache
  if (r.isFullyInitialized()) {
    const i = r.getNode().isLeafNode() || r.getNode().isEmpty(),
      s = Gy(t)
    ;(n.length > 0 ||
      !t.eventCache.isFullyInitialized() ||
      (i && !r.getNode().equals(s)) ||
      !r.getNode().getPriority().equals(s.getPriority())) &&
      n.push(IV(Gy(e)))
  }
}
function OR(t, e, n, r, i, s) {
  const o = e.eventCache
  if (gf(r, n) != null) return e
  {
    let a, l
    if (je(n))
      if (
        (te(
          e.serverCache.isFullyInitialized(),
          'If change path is empty, we must have complete server data'
        ),
        e.serverCache.isFiltered())
      ) {
        const c = Qo(e),
          u = c instanceof nt ? c : nt.EMPTY_NODE,
          h = AR(r, u)
        a = t.filter.updateFullNode(e.eventCache.getNode(), h, s)
      } else {
        const c = Yy(r, Qo(e))
        a = t.filter.updateFullNode(e.eventCache.getNode(), c, s)
      }
    else {
      const c = qe(n)
      if (c === '.priority') {
        te(Us(n) === 1, "Can't have a priority with additional path components")
        const u = o.getNode()
        l = e.serverCache.getNode()
        const h = aT(r, n, u, l)
        h != null ? (a = t.filter.updatePriority(u, h)) : (a = o.getNode())
      } else {
        const u = _t(n)
        let h
        if (o.isCompleteForChild(c)) {
          l = e.serverCache.getNode()
          const d = aT(r, n, o.getNode(), l)
          d != null
            ? (h = o.getNode().getImmediateChild(c).updateChild(u, d))
            : (h = o.getNode().getImmediateChild(c))
        } else h = h0(r, c, e.serverCache)
        h != null ? (a = t.filter.updateChild(o.getNode(), c, h, u, i, s)) : (a = o.getNode())
      }
    }
    return Pc(e, a, o.isFullyInitialized() || je(n), t.filter.filtersNodes())
  }
}
function yf(t, e, n, r, i, s, o, a) {
  const l = e.serverCache
  let c
  const u = o ? t.filter : t.filter.getIndexedFilter()
  if (je(n)) c = u.updateFullNode(l.getNode(), r, null)
  else if (u.filtersNodes() && !l.isFiltered()) {
    const f = l.getNode().updateChild(n, r)
    c = u.updateFullNode(l.getNode(), f, null)
  } else {
    const f = qe(n)
    if (!l.isCompleteForPath(n) && Us(n) > 1) return e
    const p = _t(n),
      g = l.getNode().getImmediateChild(f).updateChild(p, r)
    f === '.priority'
      ? (c = u.updatePriority(l.getNode(), g))
      : (c = u.updateChild(l.getNode(), f, g, p, kR, null))
  }
  const h = ER(e, c, l.isFullyInitialized() || je(n), u.filtersNodes()),
    d = new d0(i, h, s)
  return OR(t, h, n, i, d, a)
}
function Jy(t, e, n, r, i, s, o) {
  const a = e.eventCache
  let l, c
  const u = new d0(i, e, s)
  if (je(n))
    (c = t.filter.updateFullNode(e.eventCache.getNode(), r, o)),
      (l = Pc(e, c, !0, t.filter.filtersNodes()))
  else {
    const h = qe(n)
    if (h === '.priority')
      (c = t.filter.updatePriority(e.eventCache.getNode(), r)),
        (l = Pc(e, c, a.isFullyInitialized(), a.isFiltered()))
    else {
      const d = _t(n),
        f = a.getNode().getImmediateChild(h)
      let p
      if (je(d)) p = r
      else {
        const m = u.getCompleteChild(h)
        m != null
          ? oR(d) === '.priority' && m.getChild(lR(d)).isEmpty()
            ? (p = m)
            : (p = m.updateChild(d, r))
          : (p = nt.EMPTY_NODE)
      }
      if (f.equals(p)) l = e
      else {
        const m = t.filter.updateChild(a.getNode(), h, p, d, u, o)
        l = Pc(e, m, a.isFullyInitialized(), t.filter.filtersNodes())
      }
    }
  }
  return l
}
function lT(t, e) {
  return t.eventCache.isCompleteForChild(e)
}
function r9(t, e, n, r, i, s, o) {
  let a = e
  return (
    r.foreach((l, c) => {
      const u = en(n, l)
      lT(e, qe(u)) && (a = Jy(t, a, u, c, i, s, o))
    }),
    r.foreach((l, c) => {
      const u = en(n, l)
      lT(e, qe(u)) || (a = Jy(t, a, u, c, i, s, o))
    }),
    a
  )
}
function cT(t, e, n) {
  return (
    n.foreach((r, i) => {
      e = e.updateChild(r, i)
    }),
    e
  )
}
function Qy(t, e, n, r, i, s, o, a) {
  if (e.serverCache.getNode().isEmpty() && !e.serverCache.isFullyInitialized()) return e
  let l = e,
    c
  je(n) ? (c = r) : (c = new gt(null).setTree(n, r))
  const u = e.serverCache.getNode()
  return (
    c.children.inorderTraversal((h, d) => {
      if (u.hasChild(h)) {
        const f = e.serverCache.getNode().getImmediateChild(h),
          p = cT(t, f, d)
        l = yf(t, l, new Tt(h), p, i, s, o, a)
      }
    }),
    c.children.inorderTraversal((h, d) => {
      const f = !e.serverCache.isCompleteForChild(h) && d.value === null
      if (!u.hasChild(h) && !f) {
        const p = e.serverCache.getNode().getImmediateChild(h),
          m = cT(t, p, d)
        l = yf(t, l, new Tt(h), m, i, s, o, a)
      }
    }),
    l
  )
}
function i9(t, e, n, r, i, s, o) {
  if (gf(i, n) != null) return e
  const a = e.serverCache.isFiltered(),
    l = e.serverCache
  if (r.value != null) {
    if ((je(n) && l.isFullyInitialized()) || l.isCompleteForPath(n))
      return yf(t, e, n, l.getNode().getChild(n), i, s, a, o)
    if (je(n)) {
      let c = new gt(null)
      return (
        l.getNode().forEachChild(Ka, (u, h) => {
          c = c.set(new Tt(u), h)
        }),
        Qy(t, e, n, c, i, s, a, o)
      )
    } else return e
  } else {
    let c = new gt(null)
    return (
      r.foreach((u, h) => {
        const d = en(n, u)
        l.isCompleteForPath(d) && (c = c.set(u, l.getNode().getChild(d)))
      }),
      Qy(t, e, n, c, i, s, a, o)
    )
  }
}
function s9(t, e, n, r, i) {
  const s = e.serverCache,
    o = ER(e, s.getNode(), s.isFullyInitialized() || je(n), s.isFiltered())
  return OR(t, o, n, r, kR, i)
}
function o9(t, e, n, r, i, s) {
  let o
  if (gf(r, n) != null) return e
  {
    const a = new d0(r, e, i),
      l = e.eventCache.getNode()
    let c
    if (je(n) || qe(n) === '.priority') {
      let u
      if (e.serverCache.isFullyInitialized()) u = Yy(r, Qo(e))
      else {
        const h = e.serverCache.getNode()
        te(h instanceof nt, 'serverChildren would be complete if leaf node'), (u = AR(r, h))
      }
      ;(u = u), (c = t.filter.updateFullNode(l, u, s))
    } else {
      const u = qe(n)
      let h = h0(r, u, e.serverCache)
      h == null && e.serverCache.isCompleteForChild(u) && (h = l.getImmediateChild(u)),
        h != null
          ? (c = t.filter.updateChild(l, u, h, _t(n), a, s))
          : e.eventCache.getNode().hasChild(u)
          ? (c = t.filter.updateChild(l, u, nt.EMPTY_NODE, _t(n), a, s))
          : (c = l),
        c.isEmpty() &&
          e.serverCache.isFullyInitialized() &&
          ((o = Yy(r, Qo(e))), o.isLeafNode() && (c = t.filter.updateFullNode(c, o, s)))
    }
    return (
      (o = e.serverCache.isFullyInitialized() || gf(r, lt()) != null),
      Pc(e, c, o, t.filter.filtersNodes())
    )
  }
}
function a9(t, e) {
  const n = Qo(t.viewCache_)
  return n &&
    (t.query._queryParams.loadsAllData() || (!je(e) && !n.getImmediateChild(qe(e)).isEmpty()))
    ? n.getChild(e)
    : null
}
function uT(t, e, n, r) {
  e.type === ni.MERGE &&
    e.source.queryId !== null &&
    (te(Qo(t.viewCache_), 'We should always have a full cache before handling merges'),
    te(Gy(t.viewCache_), 'Missing event cache, even though we have a server cache'))
  const i = t.viewCache_,
    s = t9(t.processor_, i, e, n, r)
  return (
    e9(t.processor_, s.viewCache),
    te(
      s.viewCache.serverCache.isFullyInitialized() || !i.serverCache.isFullyInitialized(),
      'Once a server snap is complete, it should never go back'
    ),
    (t.viewCache_ = s.viewCache),
    l9(t, s.changes, s.viewCache.eventCache.getNode(), null)
  )
}
function l9(t, e, n, r) {
  const i = r ? [r] : t.eventRegistrations_
  return DV(t.eventGenerator_, e, n, i)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let hT
function c9(t) {
  te(!hT, '__referenceConstructor has already been defined'), (hT = t)
}
function f0(t, e, n, r) {
  const i = e.source.queryId
  if (i !== null) {
    const s = t.views.get(i)
    return te(s != null, 'SyncTree gave us an op for an invalid query.'), uT(s, e, n, r)
  } else {
    let s = []
    for (const o of t.views.values()) s = s.concat(uT(o, e, n, r))
    return s
  }
}
function p0(t, e) {
  let n = null
  for (const r of t.views.values()) n = n || a9(r, e)
  return n
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let dT
function u9(t) {
  te(!dT, '__referenceConstructor has already been defined'), (dT = t)
}
class fT {
  constructor(e) {
    ;(this.listenProvider_ = e),
      (this.syncPointTree_ = new gt(null)),
      (this.pendingWriteTree_ = JV()),
      (this.tagToQueryMap = new Map()),
      (this.queryToTagMap = new Map())
  }
}
function h9(t, e, n, r, i) {
  return BV(t.pendingWriteTree_, e, n, r, i), i ? xp(t, new Jo(yR(), e, n)) : []
}
function Ma(t, e, n = !1) {
  const r = UV(t.pendingWriteTree_, e)
  if ($V(t.pendingWriteTree_, e)) {
    let s = new gt(null)
    return (
      r.snap != null
        ? (s = s.set(lt(), !0))
        : Ar(r.children, (o) => {
            s = s.set(new Tt(o), !0)
          }),
      xp(t, new mf(r.path, s, n))
    )
  } else return []
}
function Pp(t, e, n) {
  return xp(t, new Jo(_R(), e, n))
}
function d9(t, e, n) {
  const r = gt.fromObject(n)
  return xp(t, new fu(_R(), e, r))
}
function f9(t, e, n, r) {
  const i = xR(t, r)
  if (i != null) {
    const s = DR(i),
      o = s.path,
      a = s.queryId,
      l = Tr(o, e),
      c = new Jo(vR(a), l, n)
    return LR(t, o, c)
  } else return []
}
function p9(t, e, n, r) {
  const i = xR(t, r)
  if (i) {
    const s = DR(i),
      o = s.path,
      a = s.queryId,
      l = Tr(o, e),
      c = gt.fromObject(n),
      u = new fu(vR(a), l, c)
    return LR(t, o, u)
  } else return []
}
function NR(t, e, n) {
  const i = t.pendingWriteTree_,
    s = t.syncPointTree_.findOnPath(e, (o, a) => {
      const l = Tr(o, e),
        c = p0(a, l)
      if (c) return c
    })
  return IR(i, e, s, n, !0)
}
function xp(t, e) {
  return MR(e, t.syncPointTree_, null, wR(t.pendingWriteTree_, lt()))
}
function MR(t, e, n, r) {
  if (je(t.path)) return PR(t, e, n, r)
  {
    const i = e.get(lt())
    n == null && i != null && (n = p0(i, lt()))
    let s = []
    const o = qe(t.path),
      a = t.operationForChild(o),
      l = e.children.get(o)
    if (l && a) {
      const c = n ? n.getImmediateChild(o) : null,
        u = CR(r, o)
      s = s.concat(MR(a, l, c, u))
    }
    return i && (s = s.concat(f0(i, t, r, n))), s
  }
}
function PR(t, e, n, r) {
  const i = e.get(lt())
  n == null && i != null && (n = p0(i, lt()))
  let s = []
  return (
    e.children.inorderTraversal((o, a) => {
      const l = n ? n.getImmediateChild(o) : null,
        c = CR(r, o),
        u = t.operationForChild(o)
      u && (s = s.concat(PR(u, a, l, c)))
    }),
    i && (s = s.concat(f0(i, t, r, n))),
    s
  )
}
function xR(t, e) {
  return t.tagToQueryMap.get(e)
}
function DR(t) {
  const e = t.indexOf('$')
  return (
    te(e !== -1 && e < t.length - 1, 'Bad queryKey.'),
    { queryId: t.substr(e + 1), path: new Tt(t.substr(0, e)) }
  )
}
function LR(t, e, n) {
  const r = t.syncPointTree_.get(e)
  te(r, "Missing sync point for query tag that we're tracking")
  const i = wR(t.pendingWriteTree_, e)
  return f0(r, n, i, null)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class m0 {
  constructor(e) {
    this.node_ = e
  }
  getImmediateChild(e) {
    const n = this.node_.getImmediateChild(e)
    return new m0(n)
  }
  node() {
    return this.node_
  }
}
class g0 {
  constructor(e, n) {
    ;(this.syncTree_ = e), (this.path_ = n)
  }
  getImmediateChild(e) {
    const n = en(this.path_, e)
    return new g0(this.syncTree_, n)
  }
  node() {
    return NR(this.syncTree_, this.path_)
  }
}
const m9 = function (t) {
    return (t = t || {}), (t.timestamp = t.timestamp || new Date().getTime()), t
  },
  pT = function (t, e, n) {
    if (!t || typeof t != 'object') return t
    if ((te('.sv' in t, 'Unexpected leaf node or priority contents'), typeof t['.sv'] == 'string'))
      return g9(t['.sv'], e, n)
    if (typeof t['.sv'] == 'object') return y9(t['.sv'], e)
    te(!1, 'Unexpected server value: ' + JSON.stringify(t, null, 2))
  },
  g9 = function (t, e, n) {
    switch (t) {
      case 'timestamp':
        return n.timestamp
      default:
        te(!1, 'Unexpected server value: ' + t)
    }
  },
  y9 = function (t, e, n) {
    t.hasOwnProperty('increment') ||
      te(!1, 'Unexpected server value: ' + JSON.stringify(t, null, 2))
    const r = t.increment
    typeof r != 'number' && te(!1, 'Unexpected increment value: ' + r)
    const i = e.node()
    if (
      (te(i !== null && typeof i < 'u', 'Expected ChildrenNode.EMPTY_NODE for nulls'),
      !i.isLeafNode())
    )
      return r
    const o = i.getValue()
    return typeof o != 'number' ? r : o + r
  },
  _9 = function (t, e, n, r) {
    return y0(e, new g0(n, t), r)
  },
  v9 = function (t, e, n) {
    return y0(t, new m0(e), n)
  }
function y0(t, e, n) {
  const r = t.getPriority().val(),
    i = pT(r, e.getImmediateChild('.priority'), n)
  let s
  if (t.isLeafNode()) {
    const o = t,
      a = pT(o.getValue(), e, n)
    return a !== o.getValue() || i !== o.getPriority().val() ? new Qt(a, Rn(i)) : t
  } else {
    const o = t
    return (
      (s = o),
      i !== o.getPriority().val() && (s = s.updatePriority(new Qt(i))),
      o.forEachChild(Nn, (a, l) => {
        const c = y0(l, e.getImmediateChild(a), n)
        c !== l && (s = s.updateImmediateChild(a, c))
      }),
      s
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _0 {
  constructor(e = '', n = null, r = { children: {}, childCount: 0 }) {
    ;(this.name = e), (this.parent = n), (this.node = r)
  }
}
function v0(t, e) {
  let n = e instanceof Tt ? e : new Tt(e),
    r = t,
    i = qe(n)
  for (; i !== null; ) {
    const s = al(r.node.children, i) || { children: {}, childCount: 0 }
    ;(r = new _0(i, r, s)), (n = _t(n)), (i = qe(n))
  }
  return r
}
function Bl(t) {
  return t.node.value
}
function VR(t, e) {
  ;(t.node.value = e), Xy(t)
}
function FR(t) {
  return t.node.childCount > 0
}
function b9(t) {
  return Bl(t) === void 0 && !FR(t)
}
function Dp(t, e) {
  Ar(t.node.children, (n, r) => {
    e(new _0(n, t, r))
  })
}
function BR(t, e, n, r) {
  n && !r && e(t),
    Dp(t, (i) => {
      BR(i, e, !0, r)
    }),
    n && r && e(t)
}
function E9(t, e, n) {
  let r = n ? t : t.parent
  for (; r !== null; ) {
    if (e(r)) return !0
    r = r.parent
  }
  return !1
}
function nh(t) {
  return new Tt(t.parent === null ? t.name : nh(t.parent) + '/' + t.name)
}
function Xy(t) {
  t.parent !== null && T9(t.parent, t.name, t)
}
function T9(t, e, n) {
  const r = b9(n),
    i = Qi(t.node.children, e)
  r && i
    ? (delete t.node.children[e], t.node.childCount--, Xy(t))
    : !r && !i && ((t.node.children[e] = n.node), t.node.childCount++, Xy(t))
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const w9 = /[\[\].#$\/\u0000-\u001F\u007F]/,
  S9 = /[\[\].#$\u0000-\u001F\u007F]/,
  rg = 10 * 1024 * 1024,
  UR = function (t) {
    return typeof t == 'string' && t.length !== 0 && !w9.test(t)
  },
  I9 = function (t) {
    return typeof t == 'string' && t.length !== 0 && !S9.test(t)
  },
  A9 = function (t) {
    return t && (t = t.replace(/^\/*\.info(\/|$)/, '/')), I9(t)
  },
  $R = function (t, e, n) {
    const r = n instanceof Tt ? new sV(n, t) : n
    if (e === void 0) throw new Error(t + 'contains undefined ' + ho(r))
    if (typeof e == 'function')
      throw new Error(t + 'contains a function ' + ho(r) + ' with contents = ' + e.toString())
    if (UC(e)) throw new Error(t + 'contains ' + e.toString() + ' ' + ho(r))
    if (typeof e == 'string' && e.length > rg / 3 && Cp(e) > rg)
      throw new Error(
        t +
          'contains a string greater than ' +
          rg +
          ' utf8 bytes ' +
          ho(r) +
          " ('" +
          e.substring(0, 50) +
          "...')"
      )
    if (e && typeof e == 'object') {
      let i = !1,
        s = !1
      if (
        (Ar(e, (o, a) => {
          if (o === '.value') i = !0
          else if (o !== '.priority' && o !== '.sv' && ((s = !0), !UR(o)))
            throw new Error(
              t +
                ' contains an invalid key (' +
                o +
                ') ' +
                ho(r) +
                `.  Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`
            )
          oV(r, o), $R(t, a, r), aV(r)
        }),
        i && s)
      )
        throw new Error(
          t + ' contains ".value" child ' + ho(r) + ' in addition to actual children.'
        )
    }
  },
  C9 = function (t, e) {
    const n = e.path.toString()
    if (
      typeof e.repoInfo.host != 'string' ||
      e.repoInfo.host.length === 0 ||
      (!UR(e.repoInfo.namespace) && e.repoInfo.host.split(':')[0] !== 'localhost') ||
      (n.length !== 0 && !A9(n))
    )
      throw new Error(
        I4(t, 'url') +
          `must be a valid firebase URL and the path can't contain ".", "#", "$", "[", or "]".`
      )
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class R9 {
  constructor() {
    ;(this.eventLists_ = []), (this.recursionDepth_ = 0)
  }
}
function k9(t, e) {
  let n = null
  for (let r = 0; r < e.length; r++) {
    const i = e[r],
      s = i.getPath()
    n !== null && !cR(s, n.path) && (t.eventLists_.push(n), (n = null)),
      n === null && (n = { events: [], path: s }),
      n.events.push(i)
  }
  n && t.eventLists_.push(n)
}
function da(t, e, n) {
  k9(t, n), O9(t, (r) => Dr(r, e) || Dr(e, r))
}
function O9(t, e) {
  t.recursionDepth_++
  let n = !0
  for (let r = 0; r < t.eventLists_.length; r++) {
    const i = t.eventLists_[r]
    if (i) {
      const s = i.path
      e(s) ? (N9(t.eventLists_[r]), (t.eventLists_[r] = null)) : (n = !1)
    }
  }
  n && (t.eventLists_ = []), t.recursionDepth_--
}
function N9(t) {
  for (let e = 0; e < t.events.length; e++) {
    const n = t.events[e]
    if (n !== null) {
      t.events[e] = null
      const r = n.getEventRunner()
      Vo && Cn('event: ' + n.toString()), eh(r)
    }
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const M9 = 'repo_interrupt',
  P9 = 25
class x9 {
  constructor(e, n, r, i) {
    ;(this.repoInfo_ = e),
      (this.forceRestClient_ = n),
      (this.authTokenProvider_ = r),
      (this.appCheckProvider_ = i),
      (this.dataUpdateCount = 0),
      (this.statsListener_ = null),
      (this.eventQueue_ = new R9()),
      (this.nextWriteId_ = 1),
      (this.interceptServerDataCallback_ = null),
      (this.onDisconnect_ = pf()),
      (this.transactionQueueTree_ = new _0()),
      (this.persistentConnection_ = null),
      (this.key = this.repoInfo_.toURLString())
  }
  toString() {
    return (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host
  }
}
function D9(t, e, n) {
  if (((t.stats_ = s0(t.repoInfo_)), t.forceRestClient_ || k5()))
    (t.server_ = new ff(
      t.repoInfo_,
      (r, i, s, o) => {
        mT(t, r, i, s, o)
      },
      t.authTokenProvider_,
      t.appCheckProvider_
    )),
      setTimeout(() => gT(t, !0), 0)
  else {
    if (typeof n < 'u' && n !== null) {
      if (typeof n != 'object')
        throw new Error('Only objects are supported for option databaseAuthVariableOverride')
      try {
        _n(n)
      } catch (r) {
        throw new Error('Invalid authOverride provided: ' + r)
      }
    }
    ;(t.persistentConnection_ = new Ui(
      t.repoInfo_,
      e,
      (r, i, s, o) => {
        mT(t, r, i, s, o)
      },
      (r) => {
        gT(t, r)
      },
      (r) => {
        V9(t, r)
      },
      t.authTokenProvider_,
      t.appCheckProvider_,
      n
    )),
      (t.server_ = t.persistentConnection_)
  }
  t.authTokenProvider_.addTokenChangeListener((r) => {
    t.server_.refreshAuthToken(r)
  }),
    t.appCheckProvider_.addTokenChangeListener((r) => {
      t.server_.refreshAppCheckToken(r.token)
    }),
    (t.statsReporter_ = D5(t.repoInfo_, () => new xV(t.stats_, t.server_))),
    (t.infoData_ = new kV()),
    (t.infoSyncTree_ = new fT({
      startListening: (r, i, s, o) => {
        let a = []
        const l = t.infoData_.getNode(r._path)
        return (
          l.isEmpty() ||
            ((a = Pp(t.infoSyncTree_, r._path, l)),
            setTimeout(() => {
              o('ok')
            }, 0)),
          a
        )
      },
      stopListening: () => {}
    })),
    b0(t, 'connected', !1),
    (t.serverSyncTree_ = new fT({
      startListening: (r, i, s, o) => (
        t.server_.listen(r, s, i, (a, l) => {
          const c = o(a, l)
          da(t.eventQueue_, r._path, c)
        }),
        []
      ),
      stopListening: (r, i) => {
        t.server_.unlisten(r, i)
      }
    }))
}
function L9(t) {
  const n = t.infoData_.getNode(new Tt('.info/serverTimeOffset')).val() || 0
  return new Date().getTime() + n
}
function HR(t) {
  return m9({ timestamp: L9(t) })
}
function mT(t, e, n, r, i) {
  t.dataUpdateCount++
  const s = new Tt(e)
  n = t.interceptServerDataCallback_ ? t.interceptServerDataCallback_(e, n) : n
  let o = []
  if (i)
    if (r) {
      const l = tf(n, (c) => Rn(c))
      o = p9(t.serverSyncTree_, s, l, i)
    } else {
      const l = Rn(n)
      o = f9(t.serverSyncTree_, s, l, i)
    }
  else if (r) {
    const l = tf(n, (c) => Rn(c))
    o = d9(t.serverSyncTree_, s, l)
  } else {
    const l = Rn(n)
    o = Pp(t.serverSyncTree_, s, l)
  }
  let a = s
  o.length > 0 && (a = T0(t, s)), da(t.eventQueue_, a, o)
}
function gT(t, e) {
  b0(t, 'connected', e), e === !1 && B9(t)
}
function V9(t, e) {
  Ar(e, (n, r) => {
    b0(t, n, r)
  })
}
function b0(t, e, n) {
  const r = new Tt('/.info/' + e),
    i = Rn(n)
  t.infoData_.updateSnapshot(r, i)
  const s = Pp(t.infoSyncTree_, r, i)
  da(t.eventQueue_, r, s)
}
function F9(t) {
  return t.nextWriteId_++
}
function B9(t) {
  zR(t, 'onDisconnectEvents')
  const e = HR(t),
    n = pf()
  Wy(t.onDisconnect_, lt(), (i, s) => {
    const o = _9(i, s, t.serverSyncTree_, e)
    gR(n, i, o)
  })
  let r = []
  Wy(n, lt(), (i, s) => {
    r = r.concat(Pp(t.serverSyncTree_, i, s))
    const o = z9(t, i)
    T0(t, o)
  }),
    (t.onDisconnect_ = pf()),
    da(t.eventQueue_, lt(), r)
}
function U9(t) {
  t.persistentConnection_ && t.persistentConnection_.interrupt(M9)
}
function zR(t, ...e) {
  let n = ''
  t.persistentConnection_ && (n = t.persistentConnection_.id + ':'), Cn(n, ...e)
}
function jR(t, e, n) {
  return NR(t.serverSyncTree_, e, n) || nt.EMPTY_NODE
}
function E0(t, e = t.transactionQueueTree_) {
  if ((e || Lp(t, e), Bl(e))) {
    const n = GR(t, e)
    te(n.length > 0, 'Sending zero length transaction queue'),
      n.every((i) => i.status === 0) && $9(t, nh(e), n)
  } else
    FR(e) &&
      Dp(e, (n) => {
        E0(t, n)
      })
}
function $9(t, e, n) {
  const r = n.map((c) => c.currentWriteId),
    i = jR(t, e, r)
  let s = i
  const o = i.hash()
  for (let c = 0; c < n.length; c++) {
    const u = n[c]
    te(u.status === 0, 'tryToSendTransactionQueue_: items in queue should all be run.'),
      (u.status = 1),
      u.retryCount++
    const h = Tr(e, u.path)
    s = s.updateChild(h, u.currentOutputSnapshotRaw)
  }
  const a = s.val(!0),
    l = e
  t.server_.put(
    l.toString(),
    a,
    (c) => {
      zR(t, 'transaction put response', { path: l.toString(), status: c })
      let u = []
      if (c === 'ok') {
        const h = []
        for (let d = 0; d < n.length; d++)
          (n[d].status = 2),
            (u = u.concat(Ma(t.serverSyncTree_, n[d].currentWriteId))),
            n[d].onComplete &&
              h.push(() => n[d].onComplete(null, !0, n[d].currentOutputSnapshotResolved)),
            n[d].unwatcher()
        Lp(t, v0(t.transactionQueueTree_, e)),
          E0(t, t.transactionQueueTree_),
          da(t.eventQueue_, e, u)
        for (let d = 0; d < h.length; d++) eh(h[d])
      } else {
        if (c === 'datastale')
          for (let h = 0; h < n.length; h++)
            n[h].status === 3 ? (n[h].status = 4) : (n[h].status = 0)
        else {
          lr('transaction at ' + l.toString() + ' failed: ' + c)
          for (let h = 0; h < n.length; h++) (n[h].status = 4), (n[h].abortReason = c)
        }
        T0(t, e)
      }
    },
    o
  )
}
function T0(t, e) {
  const n = WR(t, e),
    r = nh(n),
    i = GR(t, n)
  return H9(t, i, r), r
}
function H9(t, e, n) {
  if (e.length === 0) return
  const r = []
  let i = []
  const o = e.filter((a) => a.status === 0).map((a) => a.currentWriteId)
  for (let a = 0; a < e.length; a++) {
    const l = e[a],
      c = Tr(n, l.path)
    let u = !1,
      h
    if (
      (te(c !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.'),
      l.status === 4)
    )
      (u = !0), (h = l.abortReason), (i = i.concat(Ma(t.serverSyncTree_, l.currentWriteId, !0)))
    else if (l.status === 0)
      if (l.retryCount >= P9)
        (u = !0), (h = 'maxretry'), (i = i.concat(Ma(t.serverSyncTree_, l.currentWriteId, !0)))
      else {
        const d = jR(t, l.path, o)
        l.currentInputSnapshot = d
        const f = e[a].update(d.val())
        if (f !== void 0) {
          $R('transaction failed: Data returned ', f, l.path)
          let p = Rn(f)
          ;(typeof f == 'object' && f != null && Qi(f, '.priority')) ||
            (p = p.updatePriority(d.getPriority()))
          const g = l.currentWriteId,
            _ = HR(t),
            v = v9(p, d, _)
          ;(l.currentOutputSnapshotRaw = p),
            (l.currentOutputSnapshotResolved = v),
            (l.currentWriteId = F9(t)),
            o.splice(o.indexOf(g), 1),
            (i = i.concat(h9(t.serverSyncTree_, l.path, v, l.currentWriteId, l.applyLocally))),
            (i = i.concat(Ma(t.serverSyncTree_, g, !0)))
        } else (u = !0), (h = 'nodata'), (i = i.concat(Ma(t.serverSyncTree_, l.currentWriteId, !0)))
      }
    da(t.eventQueue_, n, i),
      (i = []),
      u &&
        ((e[a].status = 2),
        (function (d) {
          setTimeout(d, Math.floor(0))
        })(e[a].unwatcher),
        e[a].onComplete &&
          (h === 'nodata'
            ? r.push(() => e[a].onComplete(null, !1, e[a].currentInputSnapshot))
            : r.push(() => e[a].onComplete(new Error(h), !1, null))))
  }
  Lp(t, t.transactionQueueTree_)
  for (let a = 0; a < r.length; a++) eh(r[a])
  E0(t, t.transactionQueueTree_)
}
function WR(t, e) {
  let n,
    r = t.transactionQueueTree_
  for (n = qe(e); n !== null && Bl(r) === void 0; ) (r = v0(r, n)), (e = _t(e)), (n = qe(e))
  return r
}
function GR(t, e) {
  const n = []
  return qR(t, e, n), n.sort((r, i) => r.order - i.order), n
}
function qR(t, e, n) {
  const r = Bl(e)
  if (r) for (let i = 0; i < r.length; i++) n.push(r[i])
  Dp(e, (i) => {
    qR(t, i, n)
  })
}
function Lp(t, e) {
  const n = Bl(e)
  if (n) {
    let r = 0
    for (let i = 0; i < n.length; i++) n[i].status !== 2 && ((n[r] = n[i]), r++)
    ;(n.length = r), VR(e, n.length > 0 ? n : void 0)
  }
  Dp(e, (r) => {
    Lp(t, r)
  })
}
function z9(t, e) {
  const n = nh(WR(t, e)),
    r = v0(t.transactionQueueTree_, e)
  return (
    E9(r, (i) => {
      ig(t, i)
    }),
    ig(t, r),
    BR(r, (i) => {
      ig(t, i)
    }),
    n
  )
}
function ig(t, e) {
  const n = Bl(e)
  if (n) {
    const r = []
    let i = [],
      s = -1
    for (let o = 0; o < n.length; o++)
      n[o].status === 3 ||
        (n[o].status === 1
          ? (te(s === o - 1, 'All SENT items should be at beginning of queue.'),
            (s = o),
            (n[o].status = 3),
            (n[o].abortReason = 'set'))
          : (te(n[o].status === 0, 'Unexpected transaction status in abort'),
            n[o].unwatcher(),
            (i = i.concat(Ma(t.serverSyncTree_, n[o].currentWriteId, !0))),
            n[o].onComplete && r.push(n[o].onComplete.bind(null, new Error('set'), !1, null))))
    s === -1 ? VR(e, void 0) : (n.length = s + 1), da(t.eventQueue_, nh(e), i)
    for (let o = 0; o < r.length; o++) eh(r[o])
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function j9(t) {
  let e = ''
  const n = t.split('/')
  for (let r = 0; r < n.length; r++)
    if (n[r].length > 0) {
      let i = n[r]
      try {
        i = decodeURIComponent(i.replace(/\+/g, ' '))
      } catch {}
      e += '/' + i
    }
  return e
}
function W9(t) {
  const e = {}
  t.charAt(0) === '?' && (t = t.substring(1))
  for (const n of t.split('&')) {
    if (n.length === 0) continue
    const r = n.split('=')
    r.length === 2
      ? (e[decodeURIComponent(r[0])] = decodeURIComponent(r[1]))
      : lr(`Invalid query segment '${n}' in query '${t}'`)
  }
  return e
}
const yT = function (t, e) {
    const n = G9(t),
      r = n.namespace
    n.domain === 'firebase.com' &&
      Ko(n.host + ' is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead'),
      (!r || r === 'undefined') &&
        n.domain !== 'localhost' &&
        Ko('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com'),
      n.secure || E5()
    const i = n.scheme === 'ws' || n.scheme === 'wss'
    return {
      repoInfo: new M5(n.host, n.secure, r, i, e, '', r !== n.subdomain),
      path: new Tt(n.pathString)
    }
  },
  G9 = function (t) {
    let e = '',
      n = '',
      r = '',
      i = '',
      s = '',
      o = !0,
      a = 'https',
      l = 443
    if (typeof t == 'string') {
      let c = t.indexOf('//')
      c >= 0 && ((a = t.substring(0, c - 1)), (t = t.substring(c + 2)))
      let u = t.indexOf('/')
      u === -1 && (u = t.length)
      let h = t.indexOf('?')
      h === -1 && (h = t.length),
        (e = t.substring(0, Math.min(u, h))),
        u < h && (i = j9(t.substring(u, h)))
      const d = W9(t.substring(Math.min(t.length, h)))
      ;(c = e.indexOf(':')),
        c >= 0
          ? ((o = a === 'https' || a === 'wss'), (l = parseInt(e.substring(c + 1), 10)))
          : (c = e.length)
      const f = e.slice(0, c)
      if (f.toLowerCase() === 'localhost') n = 'localhost'
      else if (f.split('.').length <= 2) n = f
      else {
        const p = e.indexOf('.')
        ;(r = e.substring(0, p).toLowerCase()), (n = e.substring(p + 1)), (s = r)
      }
      'ns' in d && (s = d.ns)
    }
    return {
      host: e,
      port: l,
      domain: n,
      subdomain: r,
      secure: o,
      scheme: a,
      pathString: i,
      namespace: s
    }
  }
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class w0 {
  constructor(e, n, r, i) {
    ;(this._repo = e), (this._path = n), (this._queryParams = r), (this._orderByCalled = i)
  }
  get key() {
    return je(this._path) ? null : oR(this._path)
  }
  get ref() {
    return new Ul(this._repo, this._path)
  }
  get _queryIdentifier() {
    const e = nT(this._queryParams),
      n = r0(e)
    return n === '{}' ? 'default' : n
  }
  get _queryObject() {
    return nT(this._queryParams)
  }
  isEqual(e) {
    if (((e = sn(e)), !(e instanceof w0))) return !1
    const n = this._repo === e._repo,
      r = cR(this._path, e._path),
      i = this._queryIdentifier === e._queryIdentifier
    return n && r && i
  }
  toJSON() {
    return this.toString()
  }
  toString() {
    return this._repo.toString() + iV(this._path)
  }
}
class Ul extends w0 {
  constructor(e, n) {
    super(e, n, new c0(), !1)
  }
  get parent() {
    const e = lR(this._path)
    return e === null ? null : new Ul(this._repo, e)
  }
  get root() {
    let e = this
    for (; e.parent !== null; ) e = e.parent
    return e
  }
}
c9(Ul)
u9(Ul)
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const q9 = 'FIREBASE_DATABASE_EMULATOR_HOST',
  Zy = {}
let K9 = !1
function Y9(t, e, n, r, i) {
  let s = r || t.options.databaseURL
  s === void 0 &&
    (t.options.projectId ||
      Ko(
        "Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."
      ),
    Cn('Using default host for project ', t.options.projectId),
    (s = `${t.options.projectId}-default-rtdb.firebaseio.com`))
  let o = yT(s, i),
    a = o.repoInfo,
    l,
    c
  typeof process < 'u' && VE && (c = VE[q9]),
    c
      ? ((l = !0), (s = `http://${c}?ns=${a.namespace}`), (o = yT(s, i)), (a = o.repoInfo))
      : (l = !o.repoInfo.secure)
  const u = i && l ? new Hy(Hy.OWNER) : new N5(t.name, t.options, e)
  C9('Invalid Firebase Database URL', o),
    je(o.path) ||
      Ko('Database URL must point to the root of a Firebase Database (not including a child path).')
  const h = Q9(a, t, u, new O5(t.name, n))
  return new X9(h, t)
}
function J9(t, e) {
  const n = Zy[e]
  ;(!n || n[t.key] !== t) && Ko(`Database ${e}(${t.repoInfo_}) has already been deleted.`),
    U9(t),
    delete n[t.key]
}
function Q9(t, e, n, r) {
  let i = Zy[e.name]
  i || ((i = {}), (Zy[e.name] = i))
  let s = i[t.toURLString()]
  return (
    s &&
      Ko(
        'Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.'
      ),
    (s = new x9(t, K9, n, r)),
    (i[t.toURLString()] = s),
    s
  )
}
class X9 {
  constructor(e, n) {
    ;(this._repoInternal = e),
      (this.app = n),
      (this.type = 'database'),
      (this._instanceStarted = !1)
  }
  get _repo() {
    return (
      this._instanceStarted ||
        (D9(
          this._repoInternal,
          this.app.options.appId,
          this.app.options.databaseAuthVariableOverride
        ),
        (this._instanceStarted = !0)),
      this._repoInternal
    )
  }
  get _root() {
    return this._rootInternal || (this._rootInternal = new Ul(this._repo, lt())), this._rootInternal
  }
  _delete() {
    return (
      this._rootInternal !== null &&
        (J9(this._repo, this.app.name), (this._repoInternal = null), (this._rootInternal = null)),
      Promise.resolve()
    )
  }
  _checkNotDeleted(e) {
    this._rootInternal === null && Ko('Cannot call ' + e + ' on a deleted database.')
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Z9(t) {
  g5(Ys),
    mi(
      new Ur(
        'database',
        (e, { instanceIdentifier: n }) => {
          const r = e.getProvider('app').getImmediate(),
            i = e.getProvider('auth-internal'),
            s = e.getProvider('app-check-internal')
          return Y9(r, i, s, n)
        },
        'PUBLIC'
      ).setMultipleInstances(!0)
    ),
    ar(FE, BE, t),
    ar(FE, BE, 'esm2017')
}
Ui.prototype.simpleListen = function (t, e) {
  this.sendRequest('q', { p: t }, e)
}
Ui.prototype.echo = function (t, e) {
  this.sendRequest('echo', { d: t }, e)
}
Z9()
var eF =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : typeof self < 'u'
      ? self
      : {},
  ne,
  S0 = S0 || {},
  Re = eF || self
function Vp(t) {
  var e = typeof t
  return (
    (e = e != 'object' ? e : t ? (Array.isArray(t) ? 'array' : e) : 'null'),
    e == 'array' || (e == 'object' && typeof t.length == 'number')
  )
}
function rh(t) {
  var e = typeof t
  return (e == 'object' && t != null) || e == 'function'
}
function tF(t) {
  return (Object.prototype.hasOwnProperty.call(t, sg) && t[sg]) || (t[sg] = ++nF)
}
var sg = 'closure_uid_' + ((1e9 * Math.random()) >>> 0),
  nF = 0
function rF(t, e, n) {
  return t.call.apply(t.bind, arguments)
}
function iF(t, e, n) {
  if (!t) throw Error()
  if (2 < arguments.length) {
    var r = Array.prototype.slice.call(arguments, 2)
    return function () {
      var i = Array.prototype.slice.call(arguments)
      return Array.prototype.unshift.apply(i, r), t.apply(e, i)
    }
  }
  return function () {
    return t.apply(e, arguments)
  }
}
function Mn(t, e, n) {
  return (
    Function.prototype.bind && Function.prototype.bind.toString().indexOf('native code') != -1
      ? (Mn = rF)
      : (Mn = iF),
    Mn.apply(null, arguments)
  )
}
function Gh(t, e) {
  var n = Array.prototype.slice.call(arguments, 1)
  return function () {
    var r = n.slice()
    return r.push.apply(r, arguments), t.apply(this, r)
  }
}
function ln(t, e) {
  function n() {}
  ;(n.prototype = e.prototype),
    (t.$ = e.prototype),
    (t.prototype = new n()),
    (t.prototype.constructor = t),
    (t.ac = function (r, i, s) {
      for (var o = Array(arguments.length - 2), a = 2; a < arguments.length; a++)
        o[a - 2] = arguments[a]
      return e.prototype[i].apply(r, o)
    })
}
function Js() {
  ;(this.s = this.s), (this.o = this.o)
}
var sF = 0
Js.prototype.s = !1
Js.prototype.sa = function () {
  !this.s && ((this.s = !0), this.N(), sF != 0) && tF(this)
}
Js.prototype.N = function () {
  if (this.o) for (; this.o.length; ) this.o.shift()()
}
const KR = Array.prototype.indexOf
  ? function (t, e) {
      return Array.prototype.indexOf.call(t, e, void 0)
    }
  : function (t, e) {
      if (typeof t == 'string') return typeof e != 'string' || e.length != 1 ? -1 : t.indexOf(e, 0)
      for (let n = 0; n < t.length; n++) if (n in t && t[n] === e) return n
      return -1
    }
function I0(t) {
  const e = t.length
  if (0 < e) {
    const n = Array(e)
    for (let r = 0; r < e; r++) n[r] = t[r]
    return n
  }
  return []
}
function _T(t, e) {
  for (let n = 1; n < arguments.length; n++) {
    const r = arguments[n]
    if (Vp(r)) {
      const i = t.length || 0,
        s = r.length || 0
      t.length = i + s
      for (let o = 0; o < s; o++) t[i + o] = r[o]
    } else t.push(r)
  }
}
function Pn(t, e) {
  ;(this.type = t), (this.g = this.target = e), (this.defaultPrevented = !1)
}
Pn.prototype.h = function () {
  this.defaultPrevented = !0
}
var oF = (function () {
  if (!Re.addEventListener || !Object.defineProperty) return !1
  var t = !1,
    e = Object.defineProperty({}, 'passive', {
      get: function () {
        t = !0
      }
    })
  try {
    const n = () => {}
    Re.addEventListener('test', n, e), Re.removeEventListener('test', n, e)
  } catch {}
  return t
})()
function pu(t) {
  return /^[\s\xa0]*$/.test(t)
}
function Fp() {
  var t = Re.navigator
  return t && (t = t.userAgent) ? t : ''
}
function Xr(t) {
  return Fp().indexOf(t) != -1
}
function A0(t) {
  return A0[' '](t), t
}
A0[' '] = function () {}
function aF(t, e) {
  var n = ZF
  return Object.prototype.hasOwnProperty.call(n, t) ? n[t] : (n[t] = e(t))
}
var lF = Xr('Opera'),
  hl = Xr('Trident') || Xr('MSIE'),
  YR = Xr('Edge'),
  e_ = YR || hl,
  JR =
    Xr('Gecko') &&
    !(Fp().toLowerCase().indexOf('webkit') != -1 && !Xr('Edge')) &&
    !(Xr('Trident') || Xr('MSIE')) &&
    !Xr('Edge'),
  cF = Fp().toLowerCase().indexOf('webkit') != -1 && !Xr('Edge')
function QR() {
  var t = Re.document
  return t ? t.documentMode : void 0
}
var t_
e: {
  var og = '',
    ag = (function () {
      var t = Fp()
      if (JR) return /rv:([^\);]+)(\)|;)/.exec(t)
      if (YR) return /Edge\/([\d\.]+)/.exec(t)
      if (hl) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(t)
      if (cF) return /WebKit\/(\S+)/.exec(t)
      if (lF) return /(?:Version)[ \/]?(\S+)/.exec(t)
    })()
  if ((ag && (og = ag ? ag[1] : ''), hl)) {
    var lg = QR()
    if (lg != null && lg > parseFloat(og)) {
      t_ = String(lg)
      break e
    }
  }
  t_ = og
}
var n_
if (Re.document && hl) {
  var vT = QR()
  n_ = vT || parseInt(t_, 10) || void 0
} else n_ = void 0
var uF = n_
function mu(t, e) {
  if (
    (Pn.call(this, t ? t.type : ''),
    (this.relatedTarget = this.g = this.target = null),
    (this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0),
    (this.key = ''),
    (this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1),
    (this.state = null),
    (this.pointerId = 0),
    (this.pointerType = ''),
    (this.i = null),
    t)
  ) {
    var n = (this.type = t.type),
      r = t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : null
    if (((this.target = t.target || t.srcElement), (this.g = e), (e = t.relatedTarget))) {
      if (JR) {
        e: {
          try {
            A0(e.nodeName)
            var i = !0
            break e
          } catch {}
          i = !1
        }
        i || (e = null)
      }
    } else n == 'mouseover' ? (e = t.fromElement) : n == 'mouseout' && (e = t.toElement)
    ;(this.relatedTarget = e),
      r
        ? ((this.clientX = r.clientX !== void 0 ? r.clientX : r.pageX),
          (this.clientY = r.clientY !== void 0 ? r.clientY : r.pageY),
          (this.screenX = r.screenX || 0),
          (this.screenY = r.screenY || 0))
        : ((this.clientX = t.clientX !== void 0 ? t.clientX : t.pageX),
          (this.clientY = t.clientY !== void 0 ? t.clientY : t.pageY),
          (this.screenX = t.screenX || 0),
          (this.screenY = t.screenY || 0)),
      (this.button = t.button),
      (this.key = t.key || ''),
      (this.ctrlKey = t.ctrlKey),
      (this.altKey = t.altKey),
      (this.shiftKey = t.shiftKey),
      (this.metaKey = t.metaKey),
      (this.pointerId = t.pointerId || 0),
      (this.pointerType =
        typeof t.pointerType == 'string' ? t.pointerType : hF[t.pointerType] || ''),
      (this.state = t.state),
      (this.i = t),
      t.defaultPrevented && mu.$.h.call(this)
  }
}
ln(mu, Pn)
var hF = { 2: 'touch', 3: 'pen', 4: 'mouse' }
mu.prototype.h = function () {
  mu.$.h.call(this)
  var t = this.i
  t.preventDefault ? t.preventDefault() : (t.returnValue = !1)
}
var ih = 'closure_listenable_' + ((1e6 * Math.random()) | 0),
  dF = 0
function fF(t, e, n, r, i) {
  ;(this.listener = t),
    (this.proxy = null),
    (this.src = e),
    (this.type = n),
    (this.capture = !!r),
    (this.la = i),
    (this.key = ++dF),
    (this.fa = this.ia = !1)
}
function Bp(t) {
  ;(t.fa = !0), (t.listener = null), (t.proxy = null), (t.src = null), (t.la = null)
}
function C0(t, e, n) {
  for (const r in t) e.call(n, t[r], r, t)
}
function pF(t, e) {
  for (const n in t) e.call(void 0, t[n], n, t)
}
function XR(t) {
  const e = {}
  for (const n in t) e[n] = t[n]
  return e
}
const bT =
  'constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf'.split(
    ' '
  )
function ZR(t, e) {
  let n, r
  for (let i = 1; i < arguments.length; i++) {
    r = arguments[i]
    for (n in r) t[n] = r[n]
    for (let s = 0; s < bT.length; s++)
      (n = bT[s]), Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
  }
}
function Up(t) {
  ;(this.src = t), (this.g = {}), (this.h = 0)
}
Up.prototype.add = function (t, e, n, r, i) {
  var s = t.toString()
  ;(t = this.g[s]), t || ((t = this.g[s] = []), this.h++)
  var o = i_(t, e, r, i)
  return (
    -1 < o
      ? ((e = t[o]), n || (e.ia = !1))
      : ((e = new fF(e, this.src, s, !!r, i)), (e.ia = n), t.push(e)),
    e
  )
}
function r_(t, e) {
  var n = e.type
  if (n in t.g) {
    var r = t.g[n],
      i = KR(r, e),
      s
    ;(s = 0 <= i) && Array.prototype.splice.call(r, i, 1),
      s && (Bp(e), t.g[n].length == 0 && (delete t.g[n], t.h--))
  }
}
function i_(t, e, n, r) {
  for (var i = 0; i < t.length; ++i) {
    var s = t[i]
    if (!s.fa && s.listener == e && s.capture == !!n && s.la == r) return i
  }
  return -1
}
var R0 = 'closure_lm_' + ((1e6 * Math.random()) | 0),
  cg = {}
function ek(t, e, n, r, i) {
  if (r && r.once) return nk(t, e, n, r, i)
  if (Array.isArray(e)) {
    for (var s = 0; s < e.length; s++) ek(t, e[s], n, r, i)
    return null
  }
  return (n = N0(n)), t && t[ih] ? t.O(e, n, rh(r) ? !!r.capture : !!r, i) : tk(t, e, n, !1, r, i)
}
function tk(t, e, n, r, i, s) {
  if (!e) throw Error('Invalid event type')
  var o = rh(i) ? !!i.capture : !!i,
    a = O0(t)
  if ((a || (t[R0] = a = new Up(t)), (n = a.add(e, n, r, o, s)), n.proxy)) return n
  if (((r = mF()), (n.proxy = r), (r.src = t), (r.listener = n), t.addEventListener))
    oF || (i = o), i === void 0 && (i = !1), t.addEventListener(e.toString(), r, i)
  else if (t.attachEvent) t.attachEvent(ik(e.toString()), r)
  else if (t.addListener && t.removeListener) t.addListener(r)
  else throw Error('addEventListener and attachEvent are unavailable.')
  return n
}
function mF() {
  function t(n) {
    return e.call(t.src, t.listener, n)
  }
  const e = gF
  return t
}
function nk(t, e, n, r, i) {
  if (Array.isArray(e)) {
    for (var s = 0; s < e.length; s++) nk(t, e[s], n, r, i)
    return null
  }
  return (n = N0(n)), t && t[ih] ? t.P(e, n, rh(r) ? !!r.capture : !!r, i) : tk(t, e, n, !0, r, i)
}
function rk(t, e, n, r, i) {
  if (Array.isArray(e)) for (var s = 0; s < e.length; s++) rk(t, e[s], n, r, i)
  else
    (r = rh(r) ? !!r.capture : !!r),
      (n = N0(n)),
      t && t[ih]
        ? ((t = t.i),
          (e = String(e).toString()),
          e in t.g &&
            ((s = t.g[e]),
            (n = i_(s, n, r, i)),
            -1 < n &&
              (Bp(s[n]),
              Array.prototype.splice.call(s, n, 1),
              s.length == 0 && (delete t.g[e], t.h--))))
        : t &&
          (t = O0(t)) &&
          ((e = t.g[e.toString()]),
          (t = -1),
          e && (t = i_(e, n, r, i)),
          (n = -1 < t ? e[t] : null) && k0(n))
}
function k0(t) {
  if (typeof t != 'number' && t && !t.fa) {
    var e = t.src
    if (e && e[ih]) r_(e.i, t)
    else {
      var n = t.type,
        r = t.proxy
      e.removeEventListener
        ? e.removeEventListener(n, r, t.capture)
        : e.detachEvent
        ? e.detachEvent(ik(n), r)
        : e.addListener && e.removeListener && e.removeListener(r),
        (n = O0(e)) ? (r_(n, t), n.h == 0 && ((n.src = null), (e[R0] = null))) : Bp(t)
    }
  }
}
function ik(t) {
  return t in cg ? cg[t] : (cg[t] = 'on' + t)
}
function gF(t, e) {
  if (t.fa) t = !0
  else {
    e = new mu(e, this)
    var n = t.listener,
      r = t.la || t.src
    t.ia && k0(t), (t = n.call(r, e))
  }
  return t
}
function O0(t) {
  return (t = t[R0]), t instanceof Up ? t : null
}
var ug = '__closure_events_fn_' + ((1e9 * Math.random()) >>> 0)
function N0(t) {
  return typeof t == 'function'
    ? t
    : (t[ug] ||
        (t[ug] = function (e) {
          return t.handleEvent(e)
        }),
      t[ug])
}
function on() {
  Js.call(this), (this.i = new Up(this)), (this.S = this), (this.J = null)
}
ln(on, Js)
on.prototype[ih] = !0
on.prototype.removeEventListener = function (t, e, n, r) {
  rk(this, t, e, n, r)
}
function bn(t, e) {
  var n,
    r = t.J
  if (r) for (n = []; r; r = r.J) n.push(r)
  if (((t = t.S), (r = e.type || e), typeof e == 'string')) e = new Pn(e, t)
  else if (e instanceof Pn) e.target = e.target || t
  else {
    var i = e
    ;(e = new Pn(r, t)), ZR(e, i)
  }
  if (((i = !0), n))
    for (var s = n.length - 1; 0 <= s; s--) {
      var o = (e.g = n[s])
      i = qh(o, r, !0, e) && i
    }
  if (((o = e.g = t), (i = qh(o, r, !0, e) && i), (i = qh(o, r, !1, e) && i), n))
    for (s = 0; s < n.length; s++) (o = e.g = n[s]), (i = qh(o, r, !1, e) && i)
}
on.prototype.N = function () {
  if ((on.$.N.call(this), this.i)) {
    var t = this.i,
      e
    for (e in t.g) {
      for (var n = t.g[e], r = 0; r < n.length; r++) Bp(n[r])
      delete t.g[e], t.h--
    }
  }
  this.J = null
}
on.prototype.O = function (t, e, n, r) {
  return this.i.add(String(t), e, !1, n, r)
}
on.prototype.P = function (t, e, n, r) {
  return this.i.add(String(t), e, !0, n, r)
}
function qh(t, e, n, r) {
  if (((e = t.i.g[String(e)]), !e)) return !0
  e = e.concat()
  for (var i = !0, s = 0; s < e.length; ++s) {
    var o = e[s]
    if (o && !o.fa && o.capture == n) {
      var a = o.listener,
        l = o.la || o.src
      o.ia && r_(t.i, o), (i = a.call(l, r) !== !1 && i)
    }
  }
  return i && !r.defaultPrevented
}
var M0 = Re.JSON.stringify
class yF {
  constructor(e, n) {
    ;(this.i = e), (this.j = n), (this.h = 0), (this.g = null)
  }
  get() {
    let e
    return (
      0 < this.h ? (this.h--, (e = this.g), (this.g = e.next), (e.next = null)) : (e = this.i()), e
    )
  }
}
function _F() {
  var t = P0
  let e = null
  return t.g && ((e = t.g), (t.g = t.g.next), t.g || (t.h = null), (e.next = null)), e
}
class vF {
  constructor() {
    this.h = this.g = null
  }
  add(e, n) {
    const r = sk.get()
    r.set(e, n), this.h ? (this.h.next = r) : (this.g = r), (this.h = r)
  }
}
var sk = new yF(
  () => new bF(),
  (t) => t.reset()
)
class bF {
  constructor() {
    this.next = this.g = this.h = null
  }
  set(e, n) {
    ;(this.h = e), (this.g = n), (this.next = null)
  }
  reset() {
    this.next = this.g = this.h = null
  }
}
function EF(t) {
  var e = 1
  t = t.split(':')
  const n = []
  for (; 0 < e && t.length; ) n.push(t.shift()), e--
  return t.length && n.push(t.join(':')), n
}
function TF(t) {
  Re.setTimeout(() => {
    throw t
  }, 0)
}
let gu,
  yu = !1,
  P0 = new vF(),
  ok = () => {
    const t = Re.Promise.resolve(void 0)
    gu = () => {
      t.then(wF)
    }
  }
var wF = () => {
  for (var t; (t = _F()); ) {
    try {
      t.h.call(t.g)
    } catch (n) {
      TF(n)
    }
    var e = sk
    e.j(t), 100 > e.h && (e.h++, (t.next = e.g), (e.g = t))
  }
  yu = !1
}
function $p(t, e) {
  on.call(this),
    (this.h = t || 1),
    (this.g = e || Re),
    (this.j = Mn(this.qb, this)),
    (this.l = Date.now())
}
ln($p, on)
ne = $p.prototype
ne.ga = !1
ne.T = null
ne.qb = function () {
  if (this.ga) {
    var t = Date.now() - this.l
    0 < t && t < 0.8 * this.h
      ? (this.T = this.g.setTimeout(this.j, this.h - t))
      : (this.T && (this.g.clearTimeout(this.T), (this.T = null)),
        bn(this, 'tick'),
        this.ga && (x0(this), this.start()))
  }
}
ne.start = function () {
  ;(this.ga = !0), this.T || ((this.T = this.g.setTimeout(this.j, this.h)), (this.l = Date.now()))
}
function x0(t) {
  ;(t.ga = !1), t.T && (t.g.clearTimeout(t.T), (t.T = null))
}
ne.N = function () {
  $p.$.N.call(this), x0(this), delete this.g
}
function D0(t, e, n) {
  if (typeof t == 'function') n && (t = Mn(t, n))
  else if (t && typeof t.handleEvent == 'function') t = Mn(t.handleEvent, t)
  else throw Error('Invalid listener argument')
  return 2147483647 < Number(e) ? -1 : Re.setTimeout(t, e || 0)
}
function ak(t) {
  t.g = D0(() => {
    ;(t.g = null), t.i && ((t.i = !1), ak(t))
  }, t.j)
  const e = t.h
  ;(t.h = null), t.m.apply(null, e)
}
class SF extends Js {
  constructor(e, n) {
    super(), (this.m = e), (this.j = n), (this.h = null), (this.i = !1), (this.g = null)
  }
  l(e) {
    ;(this.h = arguments), this.g ? (this.i = !0) : ak(this)
  }
  N() {
    super.N(), this.g && (Re.clearTimeout(this.g), (this.g = null), (this.i = !1), (this.h = null))
  }
}
function _u(t) {
  Js.call(this), (this.h = t), (this.g = {})
}
ln(_u, Js)
var ET = []
function lk(t, e, n, r) {
  Array.isArray(n) || (n && (ET[0] = n.toString()), (n = ET))
  for (var i = 0; i < n.length; i++) {
    var s = ek(e, n[i], r || t.handleEvent, !1, t.h || t)
    if (!s) break
    t.g[s.key] = s
  }
}
function ck(t) {
  C0(
    t.g,
    function (e, n) {
      this.g.hasOwnProperty(n) && k0(e)
    },
    t
  ),
    (t.g = {})
}
_u.prototype.N = function () {
  _u.$.N.call(this), ck(this)
}
_u.prototype.handleEvent = function () {
  throw Error('EventHandler.handleEvent not implemented')
}
function Hp() {
  this.g = !0
}
Hp.prototype.Ea = function () {
  this.g = !1
}
function IF(t, e, n, r, i, s) {
  t.info(function () {
    if (t.g)
      if (s)
        for (var o = '', a = s.split('&'), l = 0; l < a.length; l++) {
          var c = a[l].split('=')
          if (1 < c.length) {
            var u = c[0]
            c = c[1]
            var h = u.split('_')
            o = 2 <= h.length && h[1] == 'type' ? o + (u + '=' + c + '&') : o + (u + '=redacted&')
          }
        }
      else o = null
    else o = s
    return (
      'XMLHTTP REQ (' +
      r +
      ') [attempt ' +
      i +
      ']: ' +
      e +
      `
` +
      n +
      `
` +
      o
    )
  })
}
function AF(t, e, n, r, i, s, o) {
  t.info(function () {
    return (
      'XMLHTTP RESP (' +
      r +
      ') [ attempt ' +
      i +
      ']: ' +
      e +
      `
` +
      n +
      `
` +
      s +
      ' ' +
      o
    )
  })
}
function Pa(t, e, n, r) {
  t.info(function () {
    return 'XMLHTTP TEXT (' + e + '): ' + RF(t, n) + (r ? ' ' + r : '')
  })
}
function CF(t, e) {
  t.info(function () {
    return 'TIMEOUT: ' + e
  })
}
Hp.prototype.info = function () {}
function RF(t, e) {
  if (!t.g) return e
  if (!e) return null
  try {
    var n = JSON.parse(e)
    if (n) {
      for (t = 0; t < n.length; t++)
        if (Array.isArray(n[t])) {
          var r = n[t]
          if (!(2 > r.length)) {
            var i = r[1]
            if (Array.isArray(i) && !(1 > i.length)) {
              var s = i[0]
              if (s != 'noop' && s != 'stop' && s != 'close')
                for (var o = 1; o < i.length; o++) i[o] = ''
            }
          }
        }
    }
    return M0(n)
  } catch {
    return e
  }
}
var fa = {},
  TT = null
function zp() {
  return (TT = TT || new on())
}
fa.Ta = 'serverreachability'
function uk(t) {
  Pn.call(this, fa.Ta, t)
}
ln(uk, Pn)
function vu(t) {
  const e = zp()
  bn(e, new uk(e))
}
fa.STAT_EVENT = 'statevent'
function hk(t, e) {
  Pn.call(this, fa.STAT_EVENT, t), (this.stat = e)
}
ln(hk, Pn)
function Fn(t) {
  const e = zp()
  bn(e, new hk(e, t))
}
fa.Ua = 'timingevent'
function dk(t, e) {
  Pn.call(this, fa.Ua, t), (this.size = e)
}
ln(dk, Pn)
function sh(t, e) {
  if (typeof t != 'function') throw Error('Fn must not be null and must be a function')
  return Re.setTimeout(function () {
    t()
  }, e)
}
var jp = { NO_ERROR: 0, rb: 1, Eb: 2, Db: 3, yb: 4, Cb: 5, Fb: 6, Qa: 7, TIMEOUT: 8, Ib: 9 },
  fk = {
    wb: 'complete',
    Sb: 'success',
    Ra: 'error',
    Qa: 'abort',
    Kb: 'ready',
    Lb: 'readystatechange',
    TIMEOUT: 'timeout',
    Gb: 'incrementaldata',
    Jb: 'progress',
    zb: 'downloadprogress',
    $b: 'uploadprogress'
  }
function L0() {}
L0.prototype.h = null
function wT(t) {
  return t.h || (t.h = t.i())
}
function pk() {}
var oh = { OPEN: 'a', vb: 'b', Ra: 'c', Hb: 'd' }
function V0() {
  Pn.call(this, 'd')
}
ln(V0, Pn)
function F0() {
  Pn.call(this, 'c')
}
ln(F0, Pn)
var s_
function Wp() {}
ln(Wp, L0)
Wp.prototype.g = function () {
  return new XMLHttpRequest()
}
Wp.prototype.i = function () {
  return {}
}
s_ = new Wp()
function ah(t, e, n, r) {
  ;(this.l = t),
    (this.j = e),
    (this.m = n),
    (this.W = r || 1),
    (this.U = new _u(this)),
    (this.P = kF),
    (t = e_ ? 125 : void 0),
    (this.V = new $p(t)),
    (this.I = null),
    (this.i = !1),
    (this.u = this.B = this.A = this.L = this.G = this.Y = this.C = null),
    (this.F = []),
    (this.g = null),
    (this.o = 0),
    (this.s = this.v = null),
    (this.ca = -1),
    (this.J = !1),
    (this.O = 0),
    (this.M = null),
    (this.ba = this.K = this.aa = this.S = !1),
    (this.h = new mk())
}
function mk() {
  ;(this.i = null), (this.g = ''), (this.h = !1)
}
var kF = 45e3,
  gk = {},
  o_ = {}
ne = ah.prototype
ne.setTimeout = function (t) {
  this.P = t
}
function a_(t, e, n) {
  ;(t.L = 1), (t.A = qp(ji(e))), (t.u = n), (t.S = !0), yk(t, null)
}
function yk(t, e) {
  ;(t.G = Date.now()), lh(t), (t.B = ji(t.A))
  var n = t.B,
    r = t.W
  Array.isArray(r) || (r = [String(r)]),
    Ik(n.i, 't', r),
    (t.o = 0),
    (n = t.l.J),
    (t.h = new mk()),
    (t.g = Gk(t.l, n ? e : null, !t.u)),
    0 < t.O && (t.M = new SF(Mn(t.Pa, t, t.g), t.O)),
    lk(t.U, t.g, 'readystatechange', t.nb),
    (e = t.I ? XR(t.I) : {}),
    t.u
      ? (t.v || (t.v = 'POST'),
        (e['Content-Type'] = 'application/x-www-form-urlencoded'),
        t.g.ha(t.B, t.v, t.u, e))
      : ((t.v = 'GET'), t.g.ha(t.B, t.v, null, e)),
    vu(),
    IF(t.j, t.v, t.B, t.m, t.W, t.u)
}
ne.nb = function (t) {
  t = t.target
  const e = this.M
  e && ri(t) == 3 ? e.l() : this.Pa(t)
}
ne.Pa = function (t) {
  try {
    if (t == this.g)
      e: {
        const u = ri(this.g)
        var e = this.g.Ia()
        const h = this.g.da()
        if (!(3 > u) && (u != 3 || e_ || (this.g && (this.h.h || this.g.ja() || CT(this.g))))) {
          this.J || u != 4 || e == 7 || (e == 8 || 0 >= h ? vu(3) : vu(2)), Gp(this)
          var n = this.g.da()
          this.ca = n
          t: if (_k(this)) {
            var r = CT(this.g)
            t = ''
            var i = r.length,
              s = ri(this.g) == 4
            if (!this.h.i) {
              if (typeof TextDecoder > 'u') {
                To(this), Dc(this)
                var o = ''
                break t
              }
              this.h.i = new Re.TextDecoder()
            }
            for (e = 0; e < i; e++)
              (this.h.h = !0), (t += this.h.i.decode(r[e], { stream: s && e == i - 1 }))
            ;(r.length = 0), (this.h.g += t), (this.o = 0), (o = this.h.g)
          } else o = this.g.ja()
          if (((this.i = n == 200), AF(this.j, this.v, this.B, this.m, this.W, u, n), this.i)) {
            if (this.aa && !this.K) {
              t: {
                if (this.g) {
                  var a,
                    l = this.g
                  if (
                    (a = l.g ? l.g.getResponseHeader('X-HTTP-Initial-Response') : null) &&
                    !pu(a)
                  ) {
                    var c = a
                    break t
                  }
                }
                c = null
              }
              if ((n = c))
                Pa(this.j, this.m, n, 'Initial handshake response via X-HTTP-Initial-Response'),
                  (this.K = !0),
                  l_(this, n)
              else {
                ;(this.i = !1), (this.s = 3), Fn(12), To(this), Dc(this)
                break e
              }
            }
            this.S
              ? (vk(this, u, o),
                e_ && this.i && u == 3 && (lk(this.U, this.V, 'tick', this.mb), this.V.start()))
              : (Pa(this.j, this.m, o, null), l_(this, o)),
              u == 4 && To(this),
              this.i && !this.J && (u == 4 ? Hk(this.l, this) : ((this.i = !1), lh(this)))
          } else
            JF(this.g),
              n == 400 && 0 < o.indexOf('Unknown SID')
                ? ((this.s = 3), Fn(12))
                : ((this.s = 0), Fn(13)),
              To(this),
              Dc(this)
        }
      }
  } catch {
  } finally {
  }
}
function _k(t) {
  return t.g ? t.v == 'GET' && t.L != 2 && t.l.Ha : !1
}
function vk(t, e, n) {
  let r = !0,
    i
  for (; !t.J && t.o < n.length; )
    if (((i = OF(t, n)), i == o_)) {
      e == 4 && ((t.s = 4), Fn(14), (r = !1)), Pa(t.j, t.m, null, '[Incomplete Response]')
      break
    } else if (i == gk) {
      ;(t.s = 4), Fn(15), Pa(t.j, t.m, n, '[Invalid Chunk]'), (r = !1)
      break
    } else Pa(t.j, t.m, i, null), l_(t, i)
  _k(t) && t.o != 0 && ((t.h.g = t.h.g.slice(t.o)), (t.o = 0)),
    e != 4 || n.length != 0 || t.h.h || ((t.s = 1), Fn(16), (r = !1)),
    (t.i = t.i && r),
    r
      ? 0 < n.length &&
        !t.ba &&
        ((t.ba = !0),
        (e = t.l),
        e.g == t &&
          e.ca &&
          !e.M &&
          (e.l.info('Great, no buffering proxy detected. Bytes received: ' + n.length),
          j0(e),
          (e.M = !0),
          Fn(11)))
      : (Pa(t.j, t.m, n, '[Invalid Chunked Response]'), To(t), Dc(t))
}
ne.mb = function () {
  if (this.g) {
    var t = ri(this.g),
      e = this.g.ja()
    this.o < e.length && (Gp(this), vk(this, t, e), this.i && t != 4 && lh(this))
  }
}
function OF(t, e) {
  var n = t.o,
    r = e.indexOf(
      `
`,
      n
    )
  return r == -1
    ? o_
    : ((n = Number(e.substring(n, r))),
      isNaN(n)
        ? gk
        : ((r += 1), r + n > e.length ? o_ : ((e = e.slice(r, r + n)), (t.o = r + n), e)))
}
ne.cancel = function () {
  ;(this.J = !0), To(this)
}
function lh(t) {
  ;(t.Y = Date.now() + t.P), bk(t, t.P)
}
function bk(t, e) {
  if (t.C != null) throw Error('WatchDog timer not null')
  t.C = sh(Mn(t.lb, t), e)
}
function Gp(t) {
  t.C && (Re.clearTimeout(t.C), (t.C = null))
}
ne.lb = function () {
  this.C = null
  const t = Date.now()
  0 <= t - this.Y
    ? (CF(this.j, this.B), this.L != 2 && (vu(), Fn(17)), To(this), (this.s = 2), Dc(this))
    : bk(this, this.Y - t)
}
function Dc(t) {
  t.l.H == 0 || t.J || Hk(t.l, t)
}
function To(t) {
  Gp(t)
  var e = t.M
  e && typeof e.sa == 'function' && e.sa(),
    (t.M = null),
    x0(t.V),
    ck(t.U),
    t.g && ((e = t.g), (t.g = null), e.abort(), e.sa())
}
function l_(t, e) {
  try {
    var n = t.l
    if (n.H != 0 && (n.g == t || c_(n.i, t))) {
      if (!t.K && c_(n.i, t) && n.H == 3) {
        try {
          var r = n.Ja.g.parse(e)
        } catch {
          r = null
        }
        if (Array.isArray(r) && r.length == 3) {
          var i = r
          if (i[0] == 0) {
            e: if (!n.u) {
              if (n.g)
                if (n.g.G + 3e3 < t.G) bf(n), Qp(n)
                else break e
              z0(n), Fn(18)
            }
          } else
            (n.Fa = i[1]),
              0 < n.Fa - n.V &&
                37500 > i[2] &&
                n.G &&
                n.A == 0 &&
                !n.v &&
                (n.v = sh(Mn(n.ib, n), 6e3))
          if (1 >= Rk(n.i) && n.oa) {
            try {
              n.oa()
            } catch {}
            n.oa = void 0
          }
        } else wo(n, 11)
      } else if (((t.K || n.g == t) && bf(n), !pu(e)))
        for (i = n.Ja.g.parse(e), e = 0; e < i.length; e++) {
          let c = i[e]
          if (((n.V = c[0]), (c = c[1]), n.H == 2))
            if (c[0] == 'c') {
              ;(n.K = c[1]), (n.pa = c[2])
              const u = c[3]
              u != null && ((n.ra = u), n.l.info('VER=' + n.ra))
              const h = c[4]
              h != null && ((n.Ga = h), n.l.info('SVER=' + n.Ga))
              const d = c[5]
              d != null &&
                typeof d == 'number' &&
                0 < d &&
                ((r = 1.5 * d), (n.L = r), n.l.info('backChannelRequestTimeoutMs_=' + r)),
                (r = n)
              const f = t.g
              if (f) {
                const p = f.g ? f.g.getResponseHeader('X-Client-Wire-Protocol') : null
                if (p) {
                  var s = r.i
                  s.g ||
                    (p.indexOf('spdy') == -1 && p.indexOf('quic') == -1 && p.indexOf('h2') == -1) ||
                    ((s.j = s.l), (s.g = new Set()), s.h && (B0(s, s.h), (s.h = null)))
                }
                if (r.F) {
                  const m = f.g ? f.g.getResponseHeader('X-HTTP-Session-Id') : null
                  m && ((r.Da = m), bt(r.I, r.F, m))
                }
              }
              ;(n.H = 3),
                n.h && n.h.Ba(),
                n.ca && ((n.S = Date.now() - t.G), n.l.info('Handshake RTT: ' + n.S + 'ms')),
                (r = n)
              var o = t
              if (((r.wa = Wk(r, r.J ? r.pa : null, r.Y)), o.K)) {
                kk(r.i, o)
                var a = o,
                  l = r.L
                l && a.setTimeout(l), a.C && (Gp(a), lh(a)), (r.g = o)
              } else Uk(r)
              0 < n.j.length && Xp(n)
            } else (c[0] != 'stop' && c[0] != 'close') || wo(n, 7)
          else
            n.H == 3 &&
              (c[0] == 'stop' || c[0] == 'close'
                ? c[0] == 'stop'
                  ? wo(n, 7)
                  : H0(n)
                : c[0] != 'noop' && n.h && n.h.Aa(c),
              (n.A = 0))
        }
    }
    vu(4)
  } catch {}
}
function NF(t) {
  if (t.Z && typeof t.Z == 'function') return t.Z()
  if ((typeof Map < 'u' && t instanceof Map) || (typeof Set < 'u' && t instanceof Set))
    return Array.from(t.values())
  if (typeof t == 'string') return t.split('')
  if (Vp(t)) {
    for (var e = [], n = t.length, r = 0; r < n; r++) e.push(t[r])
    return e
  }
  ;(e = []), (n = 0)
  for (r in t) e[n++] = t[r]
  return e
}
function MF(t) {
  if (t.ta && typeof t.ta == 'function') return t.ta()
  if (!t.Z || typeof t.Z != 'function') {
    if (typeof Map < 'u' && t instanceof Map) return Array.from(t.keys())
    if (!(typeof Set < 'u' && t instanceof Set)) {
      if (Vp(t) || typeof t == 'string') {
        var e = []
        t = t.length
        for (var n = 0; n < t; n++) e.push(n)
        return e
      }
      ;(e = []), (n = 0)
      for (const r in t) e[n++] = r
      return e
    }
  }
}
function Ek(t, e) {
  if (t.forEach && typeof t.forEach == 'function') t.forEach(e, void 0)
  else if (Vp(t) || typeof t == 'string') Array.prototype.forEach.call(t, e, void 0)
  else
    for (var n = MF(t), r = NF(t), i = r.length, s = 0; s < i; s++)
      e.call(void 0, r[s], n && n[s], t)
}
var Tk = RegExp(
  '^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$'
)
function PF(t, e) {
  if (t) {
    t = t.split('&')
    for (var n = 0; n < t.length; n++) {
      var r = t[n].indexOf('='),
        i = null
      if (0 <= r) {
        var s = t[n].substring(0, r)
        i = t[n].substring(r + 1)
      } else s = t[n]
      e(s, i ? decodeURIComponent(i.replace(/\+/g, ' ')) : '')
    }
  }
}
function Fo(t) {
  if (
    ((this.g = this.s = this.j = ''),
    (this.m = null),
    (this.o = this.l = ''),
    (this.h = !1),
    t instanceof Fo)
  ) {
    ;(this.h = t.h), _f(this, t.j), (this.s = t.s), (this.g = t.g), vf(this, t.m), (this.l = t.l)
    var e = t.i,
      n = new bu()
    ;(n.i = e.i), e.g && ((n.g = new Map(e.g)), (n.h = e.h)), ST(this, n), (this.o = t.o)
  } else
    t && (e = String(t).match(Tk))
      ? ((this.h = !1),
        _f(this, e[1] || '', !0),
        (this.s = hc(e[2] || '')),
        (this.g = hc(e[3] || '', !0)),
        vf(this, e[4]),
        (this.l = hc(e[5] || '', !0)),
        ST(this, e[6] || '', !0),
        (this.o = hc(e[7] || '')))
      : ((this.h = !1), (this.i = new bu(null, this.h)))
}
Fo.prototype.toString = function () {
  var t = [],
    e = this.j
  e && t.push(dc(e, IT, !0), ':')
  var n = this.g
  return (
    (n || e == 'file') &&
      (t.push('//'),
      (e = this.s) && t.push(dc(e, IT, !0), '@'),
      t.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g, '%$1')),
      (n = this.m),
      n != null && t.push(':', String(n))),
    (n = this.l) &&
      (this.g && n.charAt(0) != '/' && t.push('/'),
      t.push(dc(n, n.charAt(0) == '/' ? LF : DF, !0))),
    (n = this.i.toString()) && t.push('?', n),
    (n = this.o) && t.push('#', dc(n, FF)),
    t.join('')
  )
}
function ji(t) {
  return new Fo(t)
}
function _f(t, e, n) {
  ;(t.j = n ? hc(e, !0) : e), t.j && (t.j = t.j.replace(/:$/, ''))
}
function vf(t, e) {
  if (e) {
    if (((e = Number(e)), isNaN(e) || 0 > e)) throw Error('Bad port number ' + e)
    t.m = e
  } else t.m = null
}
function ST(t, e, n) {
  e instanceof bu ? ((t.i = e), BF(t.i, t.h)) : (n || (e = dc(e, VF)), (t.i = new bu(e, t.h)))
}
function bt(t, e, n) {
  t.i.set(e, n)
}
function qp(t) {
  return (
    bt(
      t,
      'zx',
      Math.floor(2147483648 * Math.random()).toString(36) +
        Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)
    ),
    t
  )
}
function hc(t, e) {
  return t ? (e ? decodeURI(t.replace(/%25/g, '%2525')) : decodeURIComponent(t)) : ''
}
function dc(t, e, n) {
  return typeof t == 'string'
    ? ((t = encodeURI(t).replace(e, xF)), n && (t = t.replace(/%25([0-9a-fA-F]{2})/g, '%$1')), t)
    : null
}
function xF(t) {
  return (t = t.charCodeAt(0)), '%' + ((t >> 4) & 15).toString(16) + (t & 15).toString(16)
}
var IT = /[#\/\?@]/g,
  DF = /[#\?:]/g,
  LF = /[#\?]/g,
  VF = /[#\?@]/g,
  FF = /#/g
function bu(t, e) {
  ;(this.h = this.g = null), (this.i = t || null), (this.j = !!e)
}
function Qs(t) {
  t.g ||
    ((t.g = new Map()),
    (t.h = 0),
    t.i &&
      PF(t.i, function (e, n) {
        t.add(decodeURIComponent(e.replace(/\+/g, ' ')), n)
      }))
}
ne = bu.prototype
ne.add = function (t, e) {
  Qs(this), (this.i = null), (t = $l(this, t))
  var n = this.g.get(t)
  return n || this.g.set(t, (n = [])), n.push(e), (this.h += 1), this
}
function wk(t, e) {
  Qs(t), (e = $l(t, e)), t.g.has(e) && ((t.i = null), (t.h -= t.g.get(e).length), t.g.delete(e))
}
function Sk(t, e) {
  return Qs(t), (e = $l(t, e)), t.g.has(e)
}
ne.forEach = function (t, e) {
  Qs(this),
    this.g.forEach(function (n, r) {
      n.forEach(function (i) {
        t.call(e, i, r, this)
      }, this)
    }, this)
}
ne.ta = function () {
  Qs(this)
  const t = Array.from(this.g.values()),
    e = Array.from(this.g.keys()),
    n = []
  for (let r = 0; r < e.length; r++) {
    const i = t[r]
    for (let s = 0; s < i.length; s++) n.push(e[r])
  }
  return n
}
ne.Z = function (t) {
  Qs(this)
  let e = []
  if (typeof t == 'string') Sk(this, t) && (e = e.concat(this.g.get($l(this, t))))
  else {
    t = Array.from(this.g.values())
    for (let n = 0; n < t.length; n++) e = e.concat(t[n])
  }
  return e
}
ne.set = function (t, e) {
  return (
    Qs(this),
    (this.i = null),
    (t = $l(this, t)),
    Sk(this, t) && (this.h -= this.g.get(t).length),
    this.g.set(t, [e]),
    (this.h += 1),
    this
  )
}
ne.get = function (t, e) {
  return t ? ((t = this.Z(t)), 0 < t.length ? String(t[0]) : e) : e
}
function Ik(t, e, n) {
  wk(t, e), 0 < n.length && ((t.i = null), t.g.set($l(t, e), I0(n)), (t.h += n.length))
}
ne.toString = function () {
  if (this.i) return this.i
  if (!this.g) return ''
  const t = [],
    e = Array.from(this.g.keys())
  for (var n = 0; n < e.length; n++) {
    var r = e[n]
    const s = encodeURIComponent(String(r)),
      o = this.Z(r)
    for (r = 0; r < o.length; r++) {
      var i = s
      o[r] !== '' && (i += '=' + encodeURIComponent(String(o[r]))), t.push(i)
    }
  }
  return (this.i = t.join('&'))
}
function $l(t, e) {
  return (e = String(e)), t.j && (e = e.toLowerCase()), e
}
function BF(t, e) {
  e &&
    !t.j &&
    (Qs(t),
    (t.i = null),
    t.g.forEach(function (n, r) {
      var i = r.toLowerCase()
      r != i && (wk(this, r), Ik(this, i, n))
    }, t)),
    (t.j = e)
}
var UF = class {
  constructor(t, e) {
    ;(this.g = t), (this.map = e)
  }
}
function Ak(t) {
  ;(this.l = t || $F),
    Re.PerformanceNavigationTiming
      ? ((t = Re.performance.getEntriesByType('navigation')),
        (t = 0 < t.length && (t[0].nextHopProtocol == 'hq' || t[0].nextHopProtocol == 'h2')))
      : (t = !!(Re.g && Re.g.Ka && Re.g.Ka() && Re.g.Ka().dc)),
    (this.j = t ? this.l : 1),
    (this.g = null),
    1 < this.j && (this.g = new Set()),
    (this.h = null),
    (this.i = [])
}
var $F = 10
function Ck(t) {
  return t.h ? !0 : t.g ? t.g.size >= t.j : !1
}
function Rk(t) {
  return t.h ? 1 : t.g ? t.g.size : 0
}
function c_(t, e) {
  return t.h ? t.h == e : t.g ? t.g.has(e) : !1
}
function B0(t, e) {
  t.g ? t.g.add(e) : (t.h = e)
}
function kk(t, e) {
  t.h && t.h == e ? (t.h = null) : t.g && t.g.has(e) && t.g.delete(e)
}
Ak.prototype.cancel = function () {
  if (((this.i = Ok(this)), this.h)) this.h.cancel(), (this.h = null)
  else if (this.g && this.g.size !== 0) {
    for (const t of this.g.values()) t.cancel()
    this.g.clear()
  }
}
function Ok(t) {
  if (t.h != null) return t.i.concat(t.h.F)
  if (t.g != null && t.g.size !== 0) {
    let e = t.i
    for (const n of t.g.values()) e = e.concat(n.F)
    return e
  }
  return I0(t.i)
}
var HF = class {
  stringify(t) {
    return Re.JSON.stringify(t, void 0)
  }
  parse(t) {
    return Re.JSON.parse(t, void 0)
  }
}
function zF() {
  this.g = new HF()
}
function jF(t, e, n) {
  const r = n || ''
  try {
    Ek(t, function (i, s) {
      let o = i
      rh(i) && (o = M0(i)), e.push(r + s + '=' + encodeURIComponent(o))
    })
  } catch (i) {
    throw (e.push(r + 'type=' + encodeURIComponent('_badmap')), i)
  }
}
function WF(t, e) {
  const n = new Hp()
  if (Re.Image) {
    const r = new Image()
    ;(r.onload = Gh(Kh, n, r, 'TestLoadImage: loaded', !0, e)),
      (r.onerror = Gh(Kh, n, r, 'TestLoadImage: error', !1, e)),
      (r.onabort = Gh(Kh, n, r, 'TestLoadImage: abort', !1, e)),
      (r.ontimeout = Gh(Kh, n, r, 'TestLoadImage: timeout', !1, e)),
      Re.setTimeout(function () {
        r.ontimeout && r.ontimeout()
      }, 1e4),
      (r.src = t)
  } else e(!1)
}
function Kh(t, e, n, r, i) {
  try {
    ;(e.onload = null), (e.onerror = null), (e.onabort = null), (e.ontimeout = null), i(r)
  } catch {}
}
function Kp(t) {
  ;(this.l = t.ec || null), (this.j = t.ob || !1)
}
ln(Kp, L0)
Kp.prototype.g = function () {
  return new Yp(this.l, this.j)
}
Kp.prototype.i = (function (t) {
  return function () {
    return t
  }
})({})
function Yp(t, e) {
  on.call(this),
    (this.F = t),
    (this.u = e),
    (this.m = void 0),
    (this.readyState = U0),
    (this.status = 0),
    (this.responseType = this.responseText = this.response = this.statusText = ''),
    (this.onreadystatechange = null),
    (this.v = new Headers()),
    (this.h = null),
    (this.C = 'GET'),
    (this.B = ''),
    (this.g = !1),
    (this.A = this.j = this.l = null)
}
ln(Yp, on)
var U0 = 0
ne = Yp.prototype
ne.open = function (t, e) {
  if (this.readyState != U0) throw (this.abort(), Error('Error reopening a connection'))
  ;(this.C = t), (this.B = e), (this.readyState = 1), Eu(this)
}
ne.send = function (t) {
  if (this.readyState != 1) throw (this.abort(), Error('need to call open() first. '))
  this.g = !0
  const e = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 }
  t && (e.body = t),
    (this.F || Re).fetch(new Request(this.B, e)).then(this.$a.bind(this), this.ka.bind(this))
}
ne.abort = function () {
  ;(this.response = this.responseText = ''),
    (this.v = new Headers()),
    (this.status = 0),
    this.j && this.j.cancel('Request was aborted.').catch(() => {}),
    1 <= this.readyState && this.g && this.readyState != 4 && ((this.g = !1), ch(this)),
    (this.readyState = U0)
}
ne.$a = function (t) {
  if (
    this.g &&
    ((this.l = t),
    this.h ||
      ((this.status = this.l.status),
      (this.statusText = this.l.statusText),
      (this.h = t.headers),
      (this.readyState = 2),
      Eu(this)),
    this.g && ((this.readyState = 3), Eu(this), this.g))
  )
    if (this.responseType === 'arraybuffer')
      t.arrayBuffer().then(this.Ya.bind(this), this.ka.bind(this))
    else if (typeof Re.ReadableStream < 'u' && 'body' in t) {
      if (((this.j = t.body.getReader()), this.u)) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.')
        this.response = []
      } else (this.response = this.responseText = ''), (this.A = new TextDecoder())
      Nk(this)
    } else t.text().then(this.Za.bind(this), this.ka.bind(this))
}
function Nk(t) {
  t.j.read().then(t.Xa.bind(t)).catch(t.ka.bind(t))
}
ne.Xa = function (t) {
  if (this.g) {
    if (this.u && t.value) this.response.push(t.value)
    else if (!this.u) {
      var e = t.value ? t.value : new Uint8Array(0)
      ;(e = this.A.decode(e, { stream: !t.done })) && (this.response = this.responseText += e)
    }
    t.done ? ch(this) : Eu(this), this.readyState == 3 && Nk(this)
  }
}
ne.Za = function (t) {
  this.g && ((this.response = this.responseText = t), ch(this))
}
ne.Ya = function (t) {
  this.g && ((this.response = t), ch(this))
}
ne.ka = function () {
  this.g && ch(this)
}
function ch(t) {
  ;(t.readyState = 4), (t.l = null), (t.j = null), (t.A = null), Eu(t)
}
ne.setRequestHeader = function (t, e) {
  this.v.append(t, e)
}
ne.getResponseHeader = function (t) {
  return (this.h && this.h.get(t.toLowerCase())) || ''
}
ne.getAllResponseHeaders = function () {
  if (!this.h) return ''
  const t = [],
    e = this.h.entries()
  for (var n = e.next(); !n.done; ) (n = n.value), t.push(n[0] + ': ' + n[1]), (n = e.next())
  return t.join(`\r
`)
}
function Eu(t) {
  t.onreadystatechange && t.onreadystatechange.call(t)
}
Object.defineProperty(Yp.prototype, 'withCredentials', {
  get: function () {
    return this.m === 'include'
  },
  set: function (t) {
    this.m = t ? 'include' : 'same-origin'
  }
})
var GF = Re.JSON.parse
function Mt(t) {
  on.call(this),
    (this.headers = new Map()),
    (this.u = t || null),
    (this.h = !1),
    (this.C = this.g = null),
    (this.I = ''),
    (this.m = 0),
    (this.j = ''),
    (this.l = this.G = this.v = this.F = !1),
    (this.B = 0),
    (this.A = null),
    (this.K = Mk),
    (this.L = this.M = !1)
}
ln(Mt, on)
var Mk = '',
  qF = /^https?$/i,
  KF = ['POST', 'PUT']
ne = Mt.prototype
ne.Oa = function (t) {
  this.M = t
}
ne.ha = function (t, e, n, r) {
  if (this.g)
    throw Error(
      '[goog.net.XhrIo] Object is active with another request=' + this.I + '; newUri=' + t
    )
  ;(e = e ? e.toUpperCase() : 'GET'),
    (this.I = t),
    (this.j = ''),
    (this.m = 0),
    (this.F = !1),
    (this.h = !0),
    (this.g = this.u ? this.u.g() : s_.g()),
    (this.C = this.u ? wT(this.u) : wT(s_)),
    (this.g.onreadystatechange = Mn(this.La, this))
  try {
    ;(this.G = !0), this.g.open(e, String(t), !0), (this.G = !1)
  } catch (s) {
    AT(this, s)
    return
  }
  if (((t = n || ''), (n = new Map(this.headers)), r))
    if (Object.getPrototypeOf(r) === Object.prototype) for (var i in r) n.set(i, r[i])
    else if (typeof r.keys == 'function' && typeof r.get == 'function')
      for (const s of r.keys()) n.set(s, r.get(s))
    else throw Error('Unknown input type for opt_headers: ' + String(r))
  ;(r = Array.from(n.keys()).find((s) => s.toLowerCase() == 'content-type')),
    (i = Re.FormData && t instanceof Re.FormData),
    !(0 <= KR(KF, e)) ||
      r ||
      i ||
      n.set('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8')
  for (const [s, o] of n) this.g.setRequestHeader(s, o)
  this.K && (this.g.responseType = this.K),
    'withCredentials' in this.g &&
      this.g.withCredentials !== this.M &&
      (this.g.withCredentials = this.M)
  try {
    Dk(this),
      0 < this.B &&
        ((this.L = YF(this.g))
          ? ((this.g.timeout = this.B), (this.g.ontimeout = Mn(this.ua, this)))
          : (this.A = D0(this.ua, this.B, this))),
      (this.v = !0),
      this.g.send(t),
      (this.v = !1)
  } catch (s) {
    AT(this, s)
  }
}
function YF(t) {
  return hl && typeof t.timeout == 'number' && t.ontimeout !== void 0
}
ne.ua = function () {
  typeof S0 < 'u' &&
    this.g &&
    ((this.j = 'Timed out after ' + this.B + 'ms, aborting'),
    (this.m = 8),
    bn(this, 'timeout'),
    this.abort(8))
}
function AT(t, e) {
  ;(t.h = !1), t.g && ((t.l = !0), t.g.abort(), (t.l = !1)), (t.j = e), (t.m = 5), Pk(t), Jp(t)
}
function Pk(t) {
  t.F || ((t.F = !0), bn(t, 'complete'), bn(t, 'error'))
}
ne.abort = function (t) {
  this.g &&
    this.h &&
    ((this.h = !1),
    (this.l = !0),
    this.g.abort(),
    (this.l = !1),
    (this.m = t || 7),
    bn(this, 'complete'),
    bn(this, 'abort'),
    Jp(this))
}
ne.N = function () {
  this.g && (this.h && ((this.h = !1), (this.l = !0), this.g.abort(), (this.l = !1)), Jp(this, !0)),
    Mt.$.N.call(this)
}
ne.La = function () {
  this.s || (this.G || this.v || this.l ? xk(this) : this.kb())
}
ne.kb = function () {
  xk(this)
}
function xk(t) {
  if (t.h && typeof S0 < 'u' && (!t.C[1] || ri(t) != 4 || t.da() != 2)) {
    if (t.v && ri(t) == 4) D0(t.La, 0, t)
    else if ((bn(t, 'readystatechange'), ri(t) == 4)) {
      t.h = !1
      try {
        const o = t.da()
        e: switch (o) {
          case 200:
          case 201:
          case 202:
          case 204:
          case 206:
          case 304:
          case 1223:
            var e = !0
            break e
          default:
            e = !1
        }
        var n
        if (!(n = e)) {
          var r
          if ((r = o === 0)) {
            var i = String(t.I).match(Tk)[1] || null
            !i && Re.self && Re.self.location && (i = Re.self.location.protocol.slice(0, -1)),
              (r = !qF.test(i ? i.toLowerCase() : ''))
          }
          n = r
        }
        if (n) bn(t, 'complete'), bn(t, 'success')
        else {
          t.m = 6
          try {
            var s = 2 < ri(t) ? t.g.statusText : ''
          } catch {
            s = ''
          }
          ;(t.j = s + ' [' + t.da() + ']'), Pk(t)
        }
      } finally {
        Jp(t)
      }
    }
  }
}
function Jp(t, e) {
  if (t.g) {
    Dk(t)
    const n = t.g,
      r = t.C[0] ? () => {} : null
    ;(t.g = null), (t.C = null), e || bn(t, 'ready')
    try {
      n.onreadystatechange = r
    } catch {}
  }
}
function Dk(t) {
  t.g && t.L && (t.g.ontimeout = null), t.A && (Re.clearTimeout(t.A), (t.A = null))
}
ne.isActive = function () {
  return !!this.g
}
function ri(t) {
  return t.g ? t.g.readyState : 0
}
ne.da = function () {
  try {
    return 2 < ri(this) ? this.g.status : -1
  } catch {
    return -1
  }
}
ne.ja = function () {
  try {
    return this.g ? this.g.responseText : ''
  } catch {
    return ''
  }
}
ne.Wa = function (t) {
  if (this.g) {
    var e = this.g.responseText
    return t && e.indexOf(t) == 0 && (e = e.substring(t.length)), GF(e)
  }
}
function CT(t) {
  try {
    if (!t.g) return null
    if ('response' in t.g) return t.g.response
    switch (t.K) {
      case Mk:
      case 'text':
        return t.g.responseText
      case 'arraybuffer':
        if ('mozResponseArrayBuffer' in t.g) return t.g.mozResponseArrayBuffer
    }
    return null
  } catch {
    return null
  }
}
function JF(t) {
  const e = {}
  t = ((t.g && 2 <= ri(t) && t.g.getAllResponseHeaders()) || '').split(`\r
`)
  for (let r = 0; r < t.length; r++) {
    if (pu(t[r])) continue
    var n = EF(t[r])
    const i = n[0]
    if (((n = n[1]), typeof n != 'string')) continue
    n = n.trim()
    const s = e[i] || []
    ;(e[i] = s), s.push(n)
  }
  pF(e, function (r) {
    return r.join(', ')
  })
}
ne.Ia = function () {
  return this.m
}
ne.Sa = function () {
  return typeof this.j == 'string' ? this.j : String(this.j)
}
function Lk(t) {
  let e = ''
  return (
    C0(t, function (n, r) {
      ;(e += r),
        (e += ':'),
        (e += n),
        (e += `\r
`)
    }),
    e
  )
}
function $0(t, e, n) {
  e: {
    for (r in n) {
      var r = !1
      break e
    }
    r = !0
  }
  r ||
    ((n = Lk(n)), typeof t == 'string' ? n != null && encodeURIComponent(String(n)) : bt(t, e, n))
}
function rc(t, e, n) {
  return (n && n.internalChannelParams && n.internalChannelParams[t]) || e
}
function Vk(t) {
  ;(this.Ga = 0),
    (this.j = []),
    (this.l = new Hp()),
    (this.pa =
      this.wa =
      this.I =
      this.Y =
      this.g =
      this.Da =
      this.F =
      this.na =
      this.o =
      this.U =
      this.s =
        null),
    (this.fb = this.W = 0),
    (this.cb = rc('failFast', !1, t)),
    (this.G = this.v = this.u = this.m = this.h = null),
    (this.aa = !0),
    (this.Fa = this.V = -1),
    (this.ba = this.A = this.C = 0),
    (this.ab = rc('baseRetryDelayMs', 5e3, t)),
    (this.hb = rc('retryDelaySeedMs', 1e4, t)),
    (this.eb = rc('forwardChannelMaxRetries', 2, t)),
    (this.xa = rc('forwardChannelRequestTimeoutMs', 2e4, t)),
    (this.va = (t && t.xmlHttpFactory) || void 0),
    (this.Ha = (t && t.useFetchStreams) || !1),
    (this.L = void 0),
    (this.J = (t && t.supportsCrossDomainXhr) || !1),
    (this.K = ''),
    (this.i = new Ak(t && t.concurrentRequestLimit)),
    (this.Ja = new zF()),
    (this.P = (t && t.fastHandshake) || !1),
    (this.O = (t && t.encodeInitMessageHeaders) || !1),
    this.P && this.O && (this.O = !1),
    (this.bb = (t && t.bc) || !1),
    t && t.Ea && this.l.Ea(),
    t && t.forceLongPolling && (this.aa = !1),
    (this.ca = (!this.P && this.aa && t && t.detectBufferingProxy) || !1),
    (this.qa = void 0),
    t && t.longPollingTimeout && 0 < t.longPollingTimeout && (this.qa = t.longPollingTimeout),
    (this.oa = void 0),
    (this.S = 0),
    (this.M = !1),
    (this.ma = this.B = null)
}
ne = Vk.prototype
ne.ra = 8
ne.H = 1
function H0(t) {
  if ((Fk(t), t.H == 3)) {
    var e = t.W++,
      n = ji(t.I)
    if (
      (bt(n, 'SID', t.K),
      bt(n, 'RID', e),
      bt(n, 'TYPE', 'terminate'),
      uh(t, n),
      (e = new ah(t, t.l, e)),
      (e.L = 2),
      (e.A = qp(ji(n))),
      (n = !1),
      Re.navigator && Re.navigator.sendBeacon)
    )
      try {
        n = Re.navigator.sendBeacon(e.A.toString(), '')
      } catch {}
    !n && Re.Image && ((new Image().src = e.A), (n = !0)),
      n || ((e.g = Gk(e.l, null)), e.g.ha(e.A)),
      (e.G = Date.now()),
      lh(e)
  }
  jk(t)
}
function Qp(t) {
  t.g && (j0(t), t.g.cancel(), (t.g = null))
}
function Fk(t) {
  Qp(t),
    t.u && (Re.clearTimeout(t.u), (t.u = null)),
    bf(t),
    t.i.cancel(),
    t.m && (typeof t.m == 'number' && Re.clearTimeout(t.m), (t.m = null))
}
function Xp(t) {
  if (!Ck(t.i) && !t.m) {
    t.m = !0
    var e = t.Na
    gu || ok(), yu || (gu(), (yu = !0)), P0.add(e, t), (t.C = 0)
  }
}
function QF(t, e) {
  return Rk(t.i) >= t.i.j - (t.m ? 1 : 0)
    ? !1
    : t.m
    ? ((t.j = e.F.concat(t.j)), !0)
    : t.H == 1 || t.H == 2 || t.C >= (t.cb ? 0 : t.eb)
    ? !1
    : ((t.m = sh(Mn(t.Na, t, e), zk(t, t.C))), t.C++, !0)
}
ne.Na = function (t) {
  if (this.m)
    if (((this.m = null), this.H == 1)) {
      if (!t) {
        ;(this.W = Math.floor(1e5 * Math.random())), (t = this.W++)
        const i = new ah(this, this.l, t)
        let s = this.s
        if (
          (this.U && (s ? ((s = XR(s)), ZR(s, this.U)) : (s = this.U)),
          this.o !== null || this.O || ((i.I = s), (s = null)),
          this.P)
        )
          e: {
            for (var e = 0, n = 0; n < this.j.length; n++) {
              t: {
                var r = this.j[n]
                if ('__data__' in r.map && ((r = r.map.__data__), typeof r == 'string')) {
                  r = r.length
                  break t
                }
                r = void 0
              }
              if (r === void 0) break
              if (((e += r), 4096 < e)) {
                e = n
                break e
              }
              if (e === 4096 || n === this.j.length - 1) {
                e = n + 1
                break e
              }
            }
            e = 1e3
          }
        else e = 1e3
        ;(e = Bk(this, i, e)),
          (n = ji(this.I)),
          bt(n, 'RID', t),
          bt(n, 'CVER', 22),
          this.F && bt(n, 'X-HTTP-Session-Id', this.F),
          uh(this, n),
          s &&
            (this.O
              ? (e = 'headers=' + encodeURIComponent(String(Lk(s))) + '&' + e)
              : this.o && $0(n, this.o, s)),
          B0(this.i, i),
          this.bb && bt(n, 'TYPE', 'init'),
          this.P
            ? (bt(n, '$req', e), bt(n, 'SID', 'null'), (i.aa = !0), a_(i, n, null))
            : a_(i, n, e),
          (this.H = 2)
      }
    } else this.H == 3 && (t ? RT(this, t) : this.j.length == 0 || Ck(this.i) || RT(this))
}
function RT(t, e) {
  var n
  e ? (n = e.m) : (n = t.W++)
  const r = ji(t.I)
  bt(r, 'SID', t.K),
    bt(r, 'RID', n),
    bt(r, 'AID', t.V),
    uh(t, r),
    t.o && t.s && $0(r, t.o, t.s),
    (n = new ah(t, t.l, n, t.C + 1)),
    t.o === null && (n.I = t.s),
    e && (t.j = e.F.concat(t.j)),
    (e = Bk(t, n, 1e3)),
    n.setTimeout(Math.round(0.5 * t.xa) + Math.round(0.5 * t.xa * Math.random())),
    B0(t.i, n),
    a_(n, r, e)
}
function uh(t, e) {
  t.na &&
    C0(t.na, function (n, r) {
      bt(e, r, n)
    }),
    t.h &&
      Ek({}, function (n, r) {
        bt(e, r, n)
      })
}
function Bk(t, e, n) {
  n = Math.min(t.j.length, n)
  var r = t.h ? Mn(t.h.Va, t.h, t) : null
  e: {
    var i = t.j
    let s = -1
    for (;;) {
      const o = ['count=' + n]
      s == -1 ? (0 < n ? ((s = i[0].g), o.push('ofs=' + s)) : (s = 0)) : o.push('ofs=' + s)
      let a = !0
      for (let l = 0; l < n; l++) {
        let c = i[l].g
        const u = i[l].map
        if (((c -= s), 0 > c)) (s = Math.max(0, i[l].g - 100)), (a = !1)
        else
          try {
            jF(u, o, 'req' + c + '_')
          } catch {
            r && r(u)
          }
      }
      if (a) {
        r = o.join('&')
        break e
      }
    }
  }
  return (t = t.j.splice(0, n)), (e.F = t), r
}
function Uk(t) {
  if (!t.g && !t.u) {
    t.ba = 1
    var e = t.Ma
    gu || ok(), yu || (gu(), (yu = !0)), P0.add(e, t), (t.A = 0)
  }
}
function z0(t) {
  return t.g || t.u || 3 <= t.A ? !1 : (t.ba++, (t.u = sh(Mn(t.Ma, t), zk(t, t.A))), t.A++, !0)
}
ne.Ma = function () {
  if (((this.u = null), $k(this), this.ca && !(this.M || this.g == null || 0 >= this.S))) {
    var t = 2 * this.S
    this.l.info('BP detection timer enabled: ' + t), (this.B = sh(Mn(this.jb, this), t))
  }
}
ne.jb = function () {
  this.B &&
    ((this.B = null),
    this.l.info('BP detection timeout reached.'),
    this.l.info('Buffering proxy detected and switch to long-polling!'),
    (this.G = !1),
    (this.M = !0),
    Fn(10),
    Qp(this),
    $k(this))
}
function j0(t) {
  t.B != null && (Re.clearTimeout(t.B), (t.B = null))
}
function $k(t) {
  ;(t.g = new ah(t, t.l, 'rpc', t.ba)), t.o === null && (t.g.I = t.s), (t.g.O = 0)
  var e = ji(t.wa)
  bt(e, 'RID', 'rpc'),
    bt(e, 'SID', t.K),
    bt(e, 'AID', t.V),
    bt(e, 'CI', t.G ? '0' : '1'),
    !t.G && t.qa && bt(e, 'TO', t.qa),
    bt(e, 'TYPE', 'xmlhttp'),
    uh(t, e),
    t.o && t.s && $0(e, t.o, t.s),
    t.L && t.g.setTimeout(t.L)
  var n = t.g
  ;(t = t.pa), (n.L = 1), (n.A = qp(ji(e))), (n.u = null), (n.S = !0), yk(n, t)
}
ne.ib = function () {
  this.v != null && ((this.v = null), Qp(this), z0(this), Fn(19))
}
function bf(t) {
  t.v != null && (Re.clearTimeout(t.v), (t.v = null))
}
function Hk(t, e) {
  var n = null
  if (t.g == e) {
    bf(t), j0(t), (t.g = null)
    var r = 2
  } else if (c_(t.i, e)) (n = e.F), kk(t.i, e), (r = 1)
  else return
  if (t.H != 0) {
    if (e.i)
      if (r == 1) {
        ;(n = e.u ? e.u.length : 0), (e = Date.now() - e.G)
        var i = t.C
        ;(r = zp()), bn(r, new dk(r, n)), Xp(t)
      } else Uk(t)
    else if (
      ((i = e.s), i == 3 || (i == 0 && 0 < e.ca) || !((r == 1 && QF(t, e)) || (r == 2 && z0(t))))
    )
      switch ((n && 0 < n.length && ((e = t.i), (e.i = e.i.concat(n))), i)) {
        case 1:
          wo(t, 5)
          break
        case 4:
          wo(t, 10)
          break
        case 3:
          wo(t, 6)
          break
        default:
          wo(t, 2)
      }
  }
}
function zk(t, e) {
  let n = t.ab + Math.floor(Math.random() * t.hb)
  return t.isActive() || (n *= 2), n * e
}
function wo(t, e) {
  if ((t.l.info('Error code ' + e), e == 2)) {
    var n = null
    t.h && (n = null)
    var r = Mn(t.pb, t)
    n ||
      ((n = new Fo('//www.google.com/images/cleardot.gif')),
      (Re.location && Re.location.protocol == 'http') || _f(n, 'https'),
      qp(n)),
      WF(n.toString(), r)
  } else Fn(2)
  ;(t.H = 0), t.h && t.h.za(e), jk(t), Fk(t)
}
ne.pb = function (t) {
  t
    ? (this.l.info('Successfully pinged google.com'), Fn(2))
    : (this.l.info('Failed to ping google.com'), Fn(1))
}
function jk(t) {
  if (((t.H = 0), (t.ma = []), t.h)) {
    const e = Ok(t.i)
    ;(e.length != 0 || t.j.length != 0) &&
      (_T(t.ma, e), _T(t.ma, t.j), (t.i.i.length = 0), I0(t.j), (t.j.length = 0)),
      t.h.ya()
  }
}
function Wk(t, e, n) {
  var r = n instanceof Fo ? ji(n) : new Fo(n)
  if (r.g != '') e && (r.g = e + '.' + r.g), vf(r, r.m)
  else {
    var i = Re.location
    ;(r = i.protocol), (e = e ? e + '.' + i.hostname : i.hostname), (i = +i.port)
    var s = new Fo(null)
    r && _f(s, r), e && (s.g = e), i && vf(s, i), n && (s.l = n), (r = s)
  }
  return (n = t.F), (e = t.Da), n && e && bt(r, n, e), bt(r, 'VER', t.ra), uh(t, r), r
}
function Gk(t, e, n) {
  if (e && !t.J) throw Error("Can't create secondary domain capable XhrIo object.")
  return (e = t.Ha && !t.va ? new Mt(new Kp({ ob: n })) : new Mt(t.va)), e.Oa(t.J), e
}
ne.isActive = function () {
  return !!this.h && this.h.isActive(this)
}
function qk() {}
ne = qk.prototype
ne.Ba = function () {}
ne.Aa = function () {}
ne.za = function () {}
ne.ya = function () {}
ne.isActive = function () {
  return !0
}
ne.Va = function () {}
function Ef() {
  if (hl && !(10 <= Number(uF))) throw Error('Environmental error: no available transport.')
}
Ef.prototype.g = function (t, e) {
  return new hr(t, e)
}
function hr(t, e) {
  on.call(this),
    (this.g = new Vk(e)),
    (this.l = t),
    (this.h = (e && e.messageUrlParams) || null),
    (t = (e && e.messageHeaders) || null),
    e &&
      e.clientProtocolHeaderRequired &&
      (t ? (t['X-Client-Protocol'] = 'webchannel') : (t = { 'X-Client-Protocol': 'webchannel' })),
    (this.g.s = t),
    (t = (e && e.initMessageHeaders) || null),
    e &&
      e.messageContentType &&
      (t
        ? (t['X-WebChannel-Content-Type'] = e.messageContentType)
        : (t = { 'X-WebChannel-Content-Type': e.messageContentType })),
    e &&
      e.Ca &&
      (t
        ? (t['X-WebChannel-Client-Profile'] = e.Ca)
        : (t = { 'X-WebChannel-Client-Profile': e.Ca })),
    (this.g.U = t),
    (t = e && e.cc) && !pu(t) && (this.g.o = t),
    (this.A = (e && e.supportsCrossDomainXhr) || !1),
    (this.v = (e && e.sendRawJson) || !1),
    (e = e && e.httpSessionIdParam) &&
      !pu(e) &&
      ((this.g.F = e), (t = this.h), t !== null && e in t && ((t = this.h), e in t && delete t[e])),
    (this.j = new Hl(this))
}
ln(hr, on)
hr.prototype.m = function () {
  ;(this.g.h = this.j), this.A && (this.g.J = !0)
  var t = this.g,
    e = this.l,
    n = this.h || void 0
  Fn(0), (t.Y = e), (t.na = n || {}), (t.G = t.aa), (t.I = Wk(t, null, t.Y)), Xp(t)
}
hr.prototype.close = function () {
  H0(this.g)
}
hr.prototype.u = function (t) {
  var e = this.g
  if (typeof t == 'string') {
    var n = {}
    ;(n.__data__ = t), (t = n)
  } else this.v && ((n = {}), (n.__data__ = M0(t)), (t = n))
  e.j.push(new UF(e.fb++, t)), e.H == 3 && Xp(e)
}
hr.prototype.N = function () {
  ;(this.g.h = null), delete this.j, H0(this.g), delete this.g, hr.$.N.call(this)
}
function Kk(t) {
  V0.call(this),
    t.__headers__ &&
      ((this.headers = t.__headers__),
      (this.statusCode = t.__status__),
      delete t.__headers__,
      delete t.__status__)
  var e = t.__sm__
  if (e) {
    e: {
      for (const n in e) {
        t = n
        break e
      }
      t = void 0
    }
    ;(this.i = t) && ((t = this.i), (e = e !== null && t in e ? e[t] : void 0)), (this.data = e)
  } else this.data = t
}
ln(Kk, V0)
function Yk() {
  F0.call(this), (this.status = 1)
}
ln(Yk, F0)
function Hl(t) {
  this.g = t
}
ln(Hl, qk)
Hl.prototype.Ba = function () {
  bn(this.g, 'a')
}
Hl.prototype.Aa = function (t) {
  bn(this.g, new Kk(t))
}
Hl.prototype.za = function (t) {
  bn(this.g, new Yk())
}
Hl.prototype.ya = function () {
  bn(this.g, 'b')
}
function XF() {
  this.blockSize = -1
}
function Hr() {
  ;(this.blockSize = -1),
    (this.blockSize = 64),
    (this.g = Array(4)),
    (this.m = Array(this.blockSize)),
    (this.i = this.h = 0),
    this.reset()
}
ln(Hr, XF)
Hr.prototype.reset = function () {
  ;(this.g[0] = 1732584193),
    (this.g[1] = 4023233417),
    (this.g[2] = 2562383102),
    (this.g[3] = 271733878),
    (this.i = this.h = 0)
}
function hg(t, e, n) {
  n || (n = 0)
  var r = Array(16)
  if (typeof e == 'string')
    for (var i = 0; 16 > i; ++i)
      r[i] =
        e.charCodeAt(n++) |
        (e.charCodeAt(n++) << 8) |
        (e.charCodeAt(n++) << 16) |
        (e.charCodeAt(n++) << 24)
  else for (i = 0; 16 > i; ++i) r[i] = e[n++] | (e[n++] << 8) | (e[n++] << 16) | (e[n++] << 24)
  ;(e = t.g[0]), (n = t.g[1]), (i = t.g[2])
  var s = t.g[3],
    o = (e + (s ^ (n & (i ^ s))) + r[0] + 3614090360) & 4294967295
  ;(e = n + (((o << 7) & 4294967295) | (o >>> 25))),
    (o = (s + (i ^ (e & (n ^ i))) + r[1] + 3905402710) & 4294967295),
    (s = e + (((o << 12) & 4294967295) | (o >>> 20))),
    (o = (i + (n ^ (s & (e ^ n))) + r[2] + 606105819) & 4294967295),
    (i = s + (((o << 17) & 4294967295) | (o >>> 15))),
    (o = (n + (e ^ (i & (s ^ e))) + r[3] + 3250441966) & 4294967295),
    (n = i + (((o << 22) & 4294967295) | (o >>> 10))),
    (o = (e + (s ^ (n & (i ^ s))) + r[4] + 4118548399) & 4294967295),
    (e = n + (((o << 7) & 4294967295) | (o >>> 25))),
    (o = (s + (i ^ (e & (n ^ i))) + r[5] + 1200080426) & 4294967295),
    (s = e + (((o << 12) & 4294967295) | (o >>> 20))),
    (o = (i + (n ^ (s & (e ^ n))) + r[6] + 2821735955) & 4294967295),
    (i = s + (((o << 17) & 4294967295) | (o >>> 15))),
    (o = (n + (e ^ (i & (s ^ e))) + r[7] + 4249261313) & 4294967295),
    (n = i + (((o << 22) & 4294967295) | (o >>> 10))),
    (o = (e + (s ^ (n & (i ^ s))) + r[8] + 1770035416) & 4294967295),
    (e = n + (((o << 7) & 4294967295) | (o >>> 25))),
    (o = (s + (i ^ (e & (n ^ i))) + r[9] + 2336552879) & 4294967295),
    (s = e + (((o << 12) & 4294967295) | (o >>> 20))),
    (o = (i + (n ^ (s & (e ^ n))) + r[10] + 4294925233) & 4294967295),
    (i = s + (((o << 17) & 4294967295) | (o >>> 15))),
    (o = (n + (e ^ (i & (s ^ e))) + r[11] + 2304563134) & 4294967295),
    (n = i + (((o << 22) & 4294967295) | (o >>> 10))),
    (o = (e + (s ^ (n & (i ^ s))) + r[12] + 1804603682) & 4294967295),
    (e = n + (((o << 7) & 4294967295) | (o >>> 25))),
    (o = (s + (i ^ (e & (n ^ i))) + r[13] + 4254626195) & 4294967295),
    (s = e + (((o << 12) & 4294967295) | (o >>> 20))),
    (o = (i + (n ^ (s & (e ^ n))) + r[14] + 2792965006) & 4294967295),
    (i = s + (((o << 17) & 4294967295) | (o >>> 15))),
    (o = (n + (e ^ (i & (s ^ e))) + r[15] + 1236535329) & 4294967295),
    (n = i + (((o << 22) & 4294967295) | (o >>> 10))),
    (o = (e + (i ^ (s & (n ^ i))) + r[1] + 4129170786) & 4294967295),
    (e = n + (((o << 5) & 4294967295) | (o >>> 27))),
    (o = (s + (n ^ (i & (e ^ n))) + r[6] + 3225465664) & 4294967295),
    (s = e + (((o << 9) & 4294967295) | (o >>> 23))),
    (o = (i + (e ^ (n & (s ^ e))) + r[11] + 643717713) & 4294967295),
    (i = s + (((o << 14) & 4294967295) | (o >>> 18))),
    (o = (n + (s ^ (e & (i ^ s))) + r[0] + 3921069994) & 4294967295),
    (n = i + (((o << 20) & 4294967295) | (o >>> 12))),
    (o = (e + (i ^ (s & (n ^ i))) + r[5] + 3593408605) & 4294967295),
    (e = n + (((o << 5) & 4294967295) | (o >>> 27))),
    (o = (s + (n ^ (i & (e ^ n))) + r[10] + 38016083) & 4294967295),
    (s = e + (((o << 9) & 4294967295) | (o >>> 23))),
    (o = (i + (e ^ (n & (s ^ e))) + r[15] + 3634488961) & 4294967295),
    (i = s + (((o << 14) & 4294967295) | (o >>> 18))),
    (o = (n + (s ^ (e & (i ^ s))) + r[4] + 3889429448) & 4294967295),
    (n = i + (((o << 20) & 4294967295) | (o >>> 12))),
    (o = (e + (i ^ (s & (n ^ i))) + r[9] + 568446438) & 4294967295),
    (e = n + (((o << 5) & 4294967295) | (o >>> 27))),
    (o = (s + (n ^ (i & (e ^ n))) + r[14] + 3275163606) & 4294967295),
    (s = e + (((o << 9) & 4294967295) | (o >>> 23))),
    (o = (i + (e ^ (n & (s ^ e))) + r[3] + 4107603335) & 4294967295),
    (i = s + (((o << 14) & 4294967295) | (o >>> 18))),
    (o = (n + (s ^ (e & (i ^ s))) + r[8] + 1163531501) & 4294967295),
    (n = i + (((o << 20) & 4294967295) | (o >>> 12))),
    (o = (e + (i ^ (s & (n ^ i))) + r[13] + 2850285829) & 4294967295),
    (e = n + (((o << 5) & 4294967295) | (o >>> 27))),
    (o = (s + (n ^ (i & (e ^ n))) + r[2] + 4243563512) & 4294967295),
    (s = e + (((o << 9) & 4294967295) | (o >>> 23))),
    (o = (i + (e ^ (n & (s ^ e))) + r[7] + 1735328473) & 4294967295),
    (i = s + (((o << 14) & 4294967295) | (o >>> 18))),
    (o = (n + (s ^ (e & (i ^ s))) + r[12] + 2368359562) & 4294967295),
    (n = i + (((o << 20) & 4294967295) | (o >>> 12))),
    (o = (e + (n ^ i ^ s) + r[5] + 4294588738) & 4294967295),
    (e = n + (((o << 4) & 4294967295) | (o >>> 28))),
    (o = (s + (e ^ n ^ i) + r[8] + 2272392833) & 4294967295),
    (s = e + (((o << 11) & 4294967295) | (o >>> 21))),
    (o = (i + (s ^ e ^ n) + r[11] + 1839030562) & 4294967295),
    (i = s + (((o << 16) & 4294967295) | (o >>> 16))),
    (o = (n + (i ^ s ^ e) + r[14] + 4259657740) & 4294967295),
    (n = i + (((o << 23) & 4294967295) | (o >>> 9))),
    (o = (e + (n ^ i ^ s) + r[1] + 2763975236) & 4294967295),
    (e = n + (((o << 4) & 4294967295) | (o >>> 28))),
    (o = (s + (e ^ n ^ i) + r[4] + 1272893353) & 4294967295),
    (s = e + (((o << 11) & 4294967295) | (o >>> 21))),
    (o = (i + (s ^ e ^ n) + r[7] + 4139469664) & 4294967295),
    (i = s + (((o << 16) & 4294967295) | (o >>> 16))),
    (o = (n + (i ^ s ^ e) + r[10] + 3200236656) & 4294967295),
    (n = i + (((o << 23) & 4294967295) | (o >>> 9))),
    (o = (e + (n ^ i ^ s) + r[13] + 681279174) & 4294967295),
    (e = n + (((o << 4) & 4294967295) | (o >>> 28))),
    (o = (s + (e ^ n ^ i) + r[0] + 3936430074) & 4294967295),
    (s = e + (((o << 11) & 4294967295) | (o >>> 21))),
    (o = (i + (s ^ e ^ n) + r[3] + 3572445317) & 4294967295),
    (i = s + (((o << 16) & 4294967295) | (o >>> 16))),
    (o = (n + (i ^ s ^ e) + r[6] + 76029189) & 4294967295),
    (n = i + (((o << 23) & 4294967295) | (o >>> 9))),
    (o = (e + (n ^ i ^ s) + r[9] + 3654602809) & 4294967295),
    (e = n + (((o << 4) & 4294967295) | (o >>> 28))),
    (o = (s + (e ^ n ^ i) + r[12] + 3873151461) & 4294967295),
    (s = e + (((o << 11) & 4294967295) | (o >>> 21))),
    (o = (i + (s ^ e ^ n) + r[15] + 530742520) & 4294967295),
    (i = s + (((o << 16) & 4294967295) | (o >>> 16))),
    (o = (n + (i ^ s ^ e) + r[2] + 3299628645) & 4294967295),
    (n = i + (((o << 23) & 4294967295) | (o >>> 9))),
    (o = (e + (i ^ (n | ~s)) + r[0] + 4096336452) & 4294967295),
    (e = n + (((o << 6) & 4294967295) | (o >>> 26))),
    (o = (s + (n ^ (e | ~i)) + r[7] + 1126891415) & 4294967295),
    (s = e + (((o << 10) & 4294967295) | (o >>> 22))),
    (o = (i + (e ^ (s | ~n)) + r[14] + 2878612391) & 4294967295),
    (i = s + (((o << 15) & 4294967295) | (o >>> 17))),
    (o = (n + (s ^ (i | ~e)) + r[5] + 4237533241) & 4294967295),
    (n = i + (((o << 21) & 4294967295) | (o >>> 11))),
    (o = (e + (i ^ (n | ~s)) + r[12] + 1700485571) & 4294967295),
    (e = n + (((o << 6) & 4294967295) | (o >>> 26))),
    (o = (s + (n ^ (e | ~i)) + r[3] + 2399980690) & 4294967295),
    (s = e + (((o << 10) & 4294967295) | (o >>> 22))),
    (o = (i + (e ^ (s | ~n)) + r[10] + 4293915773) & 4294967295),
    (i = s + (((o << 15) & 4294967295) | (o >>> 17))),
    (o = (n + (s ^ (i | ~e)) + r[1] + 2240044497) & 4294967295),
    (n = i + (((o << 21) & 4294967295) | (o >>> 11))),
    (o = (e + (i ^ (n | ~s)) + r[8] + 1873313359) & 4294967295),
    (e = n + (((o << 6) & 4294967295) | (o >>> 26))),
    (o = (s + (n ^ (e | ~i)) + r[15] + 4264355552) & 4294967295),
    (s = e + (((o << 10) & 4294967295) | (o >>> 22))),
    (o = (i + (e ^ (s | ~n)) + r[6] + 2734768916) & 4294967295),
    (i = s + (((o << 15) & 4294967295) | (o >>> 17))),
    (o = (n + (s ^ (i | ~e)) + r[13] + 1309151649) & 4294967295),
    (n = i + (((o << 21) & 4294967295) | (o >>> 11))),
    (o = (e + (i ^ (n | ~s)) + r[4] + 4149444226) & 4294967295),
    (e = n + (((o << 6) & 4294967295) | (o >>> 26))),
    (o = (s + (n ^ (e | ~i)) + r[11] + 3174756917) & 4294967295),
    (s = e + (((o << 10) & 4294967295) | (o >>> 22))),
    (o = (i + (e ^ (s | ~n)) + r[2] + 718787259) & 4294967295),
    (i = s + (((o << 15) & 4294967295) | (o >>> 17))),
    (o = (n + (s ^ (i | ~e)) + r[9] + 3951481745) & 4294967295),
    (t.g[0] = (t.g[0] + e) & 4294967295),
    (t.g[1] = (t.g[1] + (i + (((o << 21) & 4294967295) | (o >>> 11)))) & 4294967295),
    (t.g[2] = (t.g[2] + i) & 4294967295),
    (t.g[3] = (t.g[3] + s) & 4294967295)
}
Hr.prototype.j = function (t, e) {
  e === void 0 && (e = t.length)
  for (var n = e - this.blockSize, r = this.m, i = this.h, s = 0; s < e; ) {
    if (i == 0) for (; s <= n; ) hg(this, t, s), (s += this.blockSize)
    if (typeof t == 'string') {
      for (; s < e; )
        if (((r[i++] = t.charCodeAt(s++)), i == this.blockSize)) {
          hg(this, r), (i = 0)
          break
        }
    } else
      for (; s < e; )
        if (((r[i++] = t[s++]), i == this.blockSize)) {
          hg(this, r), (i = 0)
          break
        }
  }
  ;(this.h = i), (this.i += e)
}
Hr.prototype.l = function () {
  var t = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h)
  t[0] = 128
  for (var e = 1; e < t.length - 8; ++e) t[e] = 0
  var n = 8 * this.i
  for (e = t.length - 8; e < t.length; ++e) (t[e] = n & 255), (n /= 256)
  for (this.j(t), t = Array(16), e = n = 0; 4 > e; ++e)
    for (var r = 0; 32 > r; r += 8) t[n++] = (this.g[e] >>> r) & 255
  return t
}
function it(t, e) {
  this.h = e
  for (var n = [], r = !0, i = t.length - 1; 0 <= i; i--) {
    var s = t[i] | 0
    ;(r && s == e) || ((n[i] = s), (r = !1))
  }
  this.g = n
}
var ZF = {}
function W0(t) {
  return -128 <= t && 128 > t
    ? aF(t, function (e) {
        return new it([e | 0], 0 > e ? -1 : 0)
      })
    : new it([t | 0], 0 > t ? -1 : 0)
}
function ii(t) {
  if (isNaN(t) || !isFinite(t)) return Ya
  if (0 > t) return pn(ii(-t))
  for (var e = [], n = 1, r = 0; t >= n; r++) (e[r] = (t / n) | 0), (n *= u_)
  return new it(e, 0)
}
function Jk(t, e) {
  if (t.length == 0) throw Error('number format error: empty string')
  if (((e = e || 10), 2 > e || 36 < e)) throw Error('radix out of range: ' + e)
  if (t.charAt(0) == '-') return pn(Jk(t.substring(1), e))
  if (0 <= t.indexOf('-')) throw Error('number format error: interior "-" character')
  for (var n = ii(Math.pow(e, 8)), r = Ya, i = 0; i < t.length; i += 8) {
    var s = Math.min(8, t.length - i),
      o = parseInt(t.substring(i, i + s), e)
    8 > s ? ((s = ii(Math.pow(e, s))), (r = r.R(s).add(ii(o)))) : ((r = r.R(n)), (r = r.add(ii(o))))
  }
  return r
}
var u_ = 4294967296,
  Ya = W0(0),
  h_ = W0(1),
  kT = W0(16777216)
ne = it.prototype
ne.ea = function () {
  if (vr(this)) return -pn(this).ea()
  for (var t = 0, e = 1, n = 0; n < this.g.length; n++) {
    var r = this.D(n)
    ;(t += (0 <= r ? r : u_ + r) * e), (e *= u_)
  }
  return t
}
ne.toString = function (t) {
  if (((t = t || 10), 2 > t || 36 < t)) throw Error('radix out of range: ' + t)
  if (Vi(this)) return '0'
  if (vr(this)) return '-' + pn(this).toString(t)
  for (var e = ii(Math.pow(t, 6)), n = this, r = ''; ; ) {
    var i = wf(n, e).g
    n = Tf(n, i.R(e))
    var s = ((0 < n.g.length ? n.g[0] : n.h) >>> 0).toString(t)
    if (((n = i), Vi(n))) return s + r
    for (; 6 > s.length; ) s = '0' + s
    r = s + r
  }
}
ne.D = function (t) {
  return 0 > t ? 0 : t < this.g.length ? this.g[t] : this.h
}
function Vi(t) {
  if (t.h != 0) return !1
  for (var e = 0; e < t.g.length; e++) if (t.g[e] != 0) return !1
  return !0
}
function vr(t) {
  return t.h == -1
}
ne.X = function (t) {
  return (t = Tf(this, t)), vr(t) ? -1 : Vi(t) ? 0 : 1
}
function pn(t) {
  for (var e = t.g.length, n = [], r = 0; r < e; r++) n[r] = ~t.g[r]
  return new it(n, ~t.h).add(h_)
}
ne.abs = function () {
  return vr(this) ? pn(this) : this
}
ne.add = function (t) {
  for (var e = Math.max(this.g.length, t.g.length), n = [], r = 0, i = 0; i <= e; i++) {
    var s = r + (this.D(i) & 65535) + (t.D(i) & 65535),
      o = (s >>> 16) + (this.D(i) >>> 16) + (t.D(i) >>> 16)
    ;(r = o >>> 16), (s &= 65535), (o &= 65535), (n[i] = (o << 16) | s)
  }
  return new it(n, n[n.length - 1] & -2147483648 ? -1 : 0)
}
function Tf(t, e) {
  return t.add(pn(e))
}
ne.R = function (t) {
  if (Vi(this) || Vi(t)) return Ya
  if (vr(this)) return vr(t) ? pn(this).R(pn(t)) : pn(pn(this).R(t))
  if (vr(t)) return pn(this.R(pn(t)))
  if (0 > this.X(kT) && 0 > t.X(kT)) return ii(this.ea() * t.ea())
  for (var e = this.g.length + t.g.length, n = [], r = 0; r < 2 * e; r++) n[r] = 0
  for (r = 0; r < this.g.length; r++)
    for (var i = 0; i < t.g.length; i++) {
      var s = this.D(r) >>> 16,
        o = this.D(r) & 65535,
        a = t.D(i) >>> 16,
        l = t.D(i) & 65535
      ;(n[2 * r + 2 * i] += o * l),
        Yh(n, 2 * r + 2 * i),
        (n[2 * r + 2 * i + 1] += s * l),
        Yh(n, 2 * r + 2 * i + 1),
        (n[2 * r + 2 * i + 1] += o * a),
        Yh(n, 2 * r + 2 * i + 1),
        (n[2 * r + 2 * i + 2] += s * a),
        Yh(n, 2 * r + 2 * i + 2)
    }
  for (r = 0; r < e; r++) n[r] = (n[2 * r + 1] << 16) | n[2 * r]
  for (r = e; r < 2 * e; r++) n[r] = 0
  return new it(n, 0)
}
function Yh(t, e) {
  for (; (t[e] & 65535) != t[e]; ) (t[e + 1] += t[e] >>> 16), (t[e] &= 65535), e++
}
function ic(t, e) {
  ;(this.g = t), (this.h = e)
}
function wf(t, e) {
  if (Vi(e)) throw Error('division by zero')
  if (Vi(t)) return new ic(Ya, Ya)
  if (vr(t)) return (e = wf(pn(t), e)), new ic(pn(e.g), pn(e.h))
  if (vr(e)) return (e = wf(t, pn(e))), new ic(pn(e.g), e.h)
  if (30 < t.g.length) {
    if (vr(t) || vr(e)) throw Error('slowDivide_ only works with positive integers.')
    for (var n = h_, r = e; 0 >= r.X(t); ) (n = OT(n)), (r = OT(r))
    var i = va(n, 1),
      s = va(r, 1)
    for (r = va(r, 2), n = va(n, 2); !Vi(r); ) {
      var o = s.add(r)
      0 >= o.X(t) && ((i = i.add(n)), (s = o)), (r = va(r, 1)), (n = va(n, 1))
    }
    return (e = Tf(t, i.R(e))), new ic(i, e)
  }
  for (i = Ya; 0 <= t.X(e); ) {
    for (
      n = Math.max(1, Math.floor(t.ea() / e.ea())),
        r = Math.ceil(Math.log(n) / Math.LN2),
        r = 48 >= r ? 1 : Math.pow(2, r - 48),
        s = ii(n),
        o = s.R(e);
      vr(o) || 0 < o.X(t);

    )
      (n -= r), (s = ii(n)), (o = s.R(e))
    Vi(s) && (s = h_), (i = i.add(s)), (t = Tf(t, o))
  }
  return new ic(i, t)
}
ne.gb = function (t) {
  return wf(this, t).h
}
ne.and = function (t) {
  for (var e = Math.max(this.g.length, t.g.length), n = [], r = 0; r < e; r++)
    n[r] = this.D(r) & t.D(r)
  return new it(n, this.h & t.h)
}
ne.or = function (t) {
  for (var e = Math.max(this.g.length, t.g.length), n = [], r = 0; r < e; r++)
    n[r] = this.D(r) | t.D(r)
  return new it(n, this.h | t.h)
}
ne.xor = function (t) {
  for (var e = Math.max(this.g.length, t.g.length), n = [], r = 0; r < e; r++)
    n[r] = this.D(r) ^ t.D(r)
  return new it(n, this.h ^ t.h)
}
function OT(t) {
  for (var e = t.g.length + 1, n = [], r = 0; r < e; r++) n[r] = (t.D(r) << 1) | (t.D(r - 1) >>> 31)
  return new it(n, t.h)
}
function va(t, e) {
  var n = e >> 5
  e %= 32
  for (var r = t.g.length - n, i = [], s = 0; s < r; s++)
    i[s] = 0 < e ? (t.D(s + n) >>> e) | (t.D(s + n + 1) << (32 - e)) : t.D(s + n)
  return new it(i, t.h)
}
Ef.prototype.createWebChannel = Ef.prototype.g
hr.prototype.send = hr.prototype.u
hr.prototype.open = hr.prototype.m
hr.prototype.close = hr.prototype.close
jp.NO_ERROR = 0
jp.TIMEOUT = 8
jp.HTTP_ERROR = 6
fk.COMPLETE = 'complete'
pk.EventType = oh
oh.OPEN = 'a'
oh.CLOSE = 'b'
oh.ERROR = 'c'
oh.MESSAGE = 'd'
on.prototype.listen = on.prototype.O
Mt.prototype.listenOnce = Mt.prototype.P
Mt.prototype.getLastError = Mt.prototype.Sa
Mt.prototype.getLastErrorCode = Mt.prototype.Ia
Mt.prototype.getStatus = Mt.prototype.da
Mt.prototype.getResponseJson = Mt.prototype.Wa
Mt.prototype.getResponseText = Mt.prototype.ja
Mt.prototype.send = Mt.prototype.ha
Mt.prototype.setWithCredentials = Mt.prototype.Oa
Hr.prototype.digest = Hr.prototype.l
Hr.prototype.reset = Hr.prototype.reset
Hr.prototype.update = Hr.prototype.j
it.prototype.add = it.prototype.add
it.prototype.multiply = it.prototype.R
it.prototype.modulo = it.prototype.gb
it.prototype.compare = it.prototype.X
it.prototype.toNumber = it.prototype.ea
it.prototype.toString = it.prototype.toString
it.prototype.getBits = it.prototype.D
it.fromNumber = ii
it.fromString = Jk
var e7 = function () {
    return new Ef()
  },
  t7 = function () {
    return zp()
  },
  dg = jp,
  n7 = fk,
  r7 = fa,
  NT = {
    xb: 0,
    Ab: 1,
    Bb: 2,
    Ub: 3,
    Zb: 4,
    Wb: 5,
    Xb: 6,
    Vb: 7,
    Tb: 8,
    Yb: 9,
    PROXY: 10,
    NOPROXY: 11,
    Rb: 12,
    Nb: 13,
    Ob: 14,
    Mb: 15,
    Pb: 16,
    Qb: 17,
    tb: 18,
    sb: 19,
    ub: 20
  },
  Jh = pk,
  i7 = Mt,
  s7 = Hr,
  Ja = it
const MT = '@firebase/firestore'
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class An {
  constructor(e) {
    this.uid = e
  }
  isAuthenticated() {
    return this.uid != null
  }
  toKey() {
    return this.isAuthenticated() ? 'uid:' + this.uid : 'anonymous-user'
  }
  isEqual(e) {
    return e.uid === this.uid
  }
}
;(An.UNAUTHENTICATED = new An(null)),
  (An.GOOGLE_CREDENTIALS = new An('google-credentials-uid')),
  (An.FIRST_PARTY = new An('first-party-uid')),
  (An.MOCK_USER = new An('mock-user'))
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let zl = '10.9.0'
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Xo = new Ku('@firebase/firestore')
function sc() {
  return Xo.logLevel
}
function ee(t, ...e) {
  if (Xo.logLevel <= He.DEBUG) {
    const n = e.map(G0)
    Xo.debug(`Firestore (${zl}): ${t}`, ...n)
  }
}
function yi(t, ...e) {
  if (Xo.logLevel <= He.ERROR) {
    const n = e.map(G0)
    Xo.error(`Firestore (${zl}): ${t}`, ...n)
  }
}
function dl(t, ...e) {
  if (Xo.logLevel <= He.WARN) {
    const n = e.map(G0)
    Xo.warn(`Firestore (${zl}): ${t}`, ...n)
  }
}
function G0(t) {
  if (typeof t == 'string') return t
  try {
    /**
     * @license
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */ return (function (n) {
      return JSON.stringify(n)
    })(t)
  } catch {
    return t
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Ce(t = 'Unexpected state') {
  const e = `FIRESTORE (${zl}) INTERNAL ASSERTION FAILED: ` + t
  throw (yi(e), new Error(e))
}
function mt(t, e) {
  t || Ce()
}
function Pe(t, e) {
  return t
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const V = {
  OK: 'ok',
  CANCELLED: 'cancelled',
  UNKNOWN: 'unknown',
  INVALID_ARGUMENT: 'invalid-argument',
  DEADLINE_EXCEEDED: 'deadline-exceeded',
  NOT_FOUND: 'not-found',
  ALREADY_EXISTS: 'already-exists',
  PERMISSION_DENIED: 'permission-denied',
  UNAUTHENTICATED: 'unauthenticated',
  RESOURCE_EXHAUSTED: 'resource-exhausted',
  FAILED_PRECONDITION: 'failed-precondition',
  ABORTED: 'aborted',
  OUT_OF_RANGE: 'out-of-range',
  UNIMPLEMENTED: 'unimplemented',
  INTERNAL: 'internal',
  UNAVAILABLE: 'unavailable',
  DATA_LOSS: 'data-loss'
}
class ue extends Ii {
  constructor(e, n) {
    super(e, n),
      (this.code = e),
      (this.message = n),
      (this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ui {
  constructor() {
    this.promise = new Promise((e, n) => {
      ;(this.resolve = e), (this.reject = n)
    })
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Qk {
  constructor(e, n) {
    ;(this.user = n),
      (this.type = 'OAuth'),
      (this.headers = new Map()),
      this.headers.set('Authorization', `Bearer ${e}`)
  }
}
class o7 {
  getToken() {
    return Promise.resolve(null)
  }
  invalidateToken() {}
  start(e, n) {
    e.enqueueRetryable(() => n(An.UNAUTHENTICATED))
  }
  shutdown() {}
}
class a7 {
  constructor(e) {
    ;(this.token = e), (this.changeListener = null)
  }
  getToken() {
    return Promise.resolve(this.token)
  }
  invalidateToken() {}
  start(e, n) {
    ;(this.changeListener = n), e.enqueueRetryable(() => n(this.token.user))
  }
  shutdown() {
    this.changeListener = null
  }
}
class l7 {
  constructor(e) {
    ;(this.t = e),
      (this.currentUser = An.UNAUTHENTICATED),
      (this.i = 0),
      (this.forceRefresh = !1),
      (this.auth = null)
  }
  start(e, n) {
    let r = this.i
    const i = (l) => (this.i !== r ? ((r = this.i), n(l)) : Promise.resolve())
    let s = new ui()
    this.o = () => {
      this.i++,
        (this.currentUser = this.u()),
        s.resolve(),
        (s = new ui()),
        e.enqueueRetryable(() => i(this.currentUser))
    }
    const o = () => {
        const l = s
        e.enqueueRetryable(async () => {
          await l.promise, await i(this.currentUser)
        })
      },
      a = (l) => {
        ee('FirebaseAuthCredentialsProvider', 'Auth detected'),
          (this.auth = l),
          this.auth.addAuthTokenListener(this.o),
          o()
      }
    this.t.onInit((l) => a(l)),
      setTimeout(() => {
        if (!this.auth) {
          const l = this.t.getImmediate({ optional: !0 })
          l
            ? a(l)
            : (ee('FirebaseAuthCredentialsProvider', 'Auth not yet detected'),
              s.resolve(),
              (s = new ui()))
        }
      }, 0),
      o()
  }
  getToken() {
    const e = this.i,
      n = this.forceRefresh
    return (
      (this.forceRefresh = !1),
      this.auth
        ? this.auth
            .getToken(n)
            .then((r) =>
              this.i !== e
                ? (ee('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.'),
                  this.getToken())
                : r
                ? (mt(typeof r.accessToken == 'string'), new Qk(r.accessToken, this.currentUser))
                : null
            )
        : Promise.resolve(null)
    )
  }
  invalidateToken() {
    this.forceRefresh = !0
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o)
  }
  u() {
    const e = this.auth && this.auth.getUid()
    return mt(e === null || typeof e == 'string'), new An(e)
  }
}
class c7 {
  constructor(e, n, r) {
    ;(this.l = e),
      (this.h = n),
      (this.P = r),
      (this.type = 'FirstParty'),
      (this.user = An.FIRST_PARTY),
      (this.I = new Map())
  }
  T() {
    return this.P ? this.P() : null
  }
  get headers() {
    this.I.set('X-Goog-AuthUser', this.l)
    const e = this.T()
    return (
      e && this.I.set('Authorization', e),
      this.h && this.I.set('X-Goog-Iam-Authorization-Token', this.h),
      this.I
    )
  }
}
class u7 {
  constructor(e, n, r) {
    ;(this.l = e), (this.h = n), (this.P = r)
  }
  getToken() {
    return Promise.resolve(new c7(this.l, this.h, this.P))
  }
  start(e, n) {
    e.enqueueRetryable(() => n(An.FIRST_PARTY))
  }
  shutdown() {}
  invalidateToken() {}
}
class h7 {
  constructor(e) {
    ;(this.value = e),
      (this.type = 'AppCheck'),
      (this.headers = new Map()),
      e && e.length > 0 && this.headers.set('x-firebase-appcheck', this.value)
  }
}
class d7 {
  constructor(e) {
    ;(this.A = e), (this.forceRefresh = !1), (this.appCheck = null), (this.R = null)
  }
  start(e, n) {
    const r = (s) => {
      s.error != null &&
        ee(
          'FirebaseAppCheckTokenProvider',
          `Error getting App Check token; using placeholder token instead. Error: ${s.error.message}`
        )
      const o = s.token !== this.R
      return (
        (this.R = s.token),
        ee('FirebaseAppCheckTokenProvider', `Received ${o ? 'new' : 'existing'} token.`),
        o ? n(s.token) : Promise.resolve()
      )
    }
    this.o = (s) => {
      e.enqueueRetryable(() => r(s))
    }
    const i = (s) => {
      ee('FirebaseAppCheckTokenProvider', 'AppCheck detected'),
        (this.appCheck = s),
        this.appCheck.addTokenListener(this.o)
    }
    this.A.onInit((s) => i(s)),
      setTimeout(() => {
        if (!this.appCheck) {
          const s = this.A.getImmediate({ optional: !0 })
          s ? i(s) : ee('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected')
        }
      }, 0)
  }
  getToken() {
    const e = this.forceRefresh
    return (
      (this.forceRefresh = !1),
      this.appCheck
        ? this.appCheck
            .getToken(e)
            .then((n) =>
              n ? (mt(typeof n.token == 'string'), (this.R = n.token), new h7(n.token)) : null
            )
        : Promise.resolve(null)
    )
  }
  invalidateToken() {
    this.forceRefresh = !0
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function f7(t) {
  const e = typeof self < 'u' && (self.crypto || self.msCrypto),
    n = new Uint8Array(t)
  if (e && typeof e.getRandomValues == 'function') e.getRandomValues(n)
  else for (let r = 0; r < t; r++) n[r] = Math.floor(256 * Math.random())
  return n
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Xk {
  static newId() {
    const e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
      n = Math.floor(256 / e.length) * e.length
    let r = ''
    for (; r.length < 20; ) {
      const i = f7(40)
      for (let s = 0; s < i.length; ++s)
        r.length < 20 && i[s] < n && (r += e.charAt(i[s] % e.length))
    }
    return r
  }
}
function et(t, e) {
  return t < e ? -1 : t > e ? 1 : 0
}
function fl(t, e, n) {
  return t.length === e.length && t.every((r, i) => n(r, e[i]))
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class $t {
  constructor(e, n) {
    if (((this.seconds = e), (this.nanoseconds = n), n < 0))
      throw new ue(V.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + n)
    if (n >= 1e9) throw new ue(V.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + n)
    if (e < -62135596800) throw new ue(V.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + e)
    if (e >= 253402300800) throw new ue(V.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + e)
  }
  static now() {
    return $t.fromMillis(Date.now())
  }
  static fromDate(e) {
    return $t.fromMillis(e.getTime())
  }
  static fromMillis(e) {
    const n = Math.floor(e / 1e3),
      r = Math.floor(1e6 * (e - 1e3 * n))
    return new $t(n, r)
  }
  toDate() {
    return new Date(this.toMillis())
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6
  }
  _compareTo(e) {
    return this.seconds === e.seconds
      ? et(this.nanoseconds, e.nanoseconds)
      : et(this.seconds, e.seconds)
  }
  isEqual(e) {
    return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds
  }
  toString() {
    return 'Timestamp(seconds=' + this.seconds + ', nanoseconds=' + this.nanoseconds + ')'
  }
  toJSON() {
    return { seconds: this.seconds, nanoseconds: this.nanoseconds }
  }
  valueOf() {
    const e = this.seconds - -62135596800
    return String(e).padStart(12, '0') + '.' + String(this.nanoseconds).padStart(9, '0')
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ne {
  constructor(e) {
    this.timestamp = e
  }
  static fromTimestamp(e) {
    return new Ne(e)
  }
  static min() {
    return new Ne(new $t(0, 0))
  }
  static max() {
    return new Ne(new $t(253402300799, 999999999))
  }
  compareTo(e) {
    return this.timestamp._compareTo(e.timestamp)
  }
  isEqual(e) {
    return this.timestamp.isEqual(e.timestamp)
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3
  }
  toString() {
    return 'SnapshotVersion(' + this.timestamp.toString() + ')'
  }
  toTimestamp() {
    return this.timestamp
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Tu {
  constructor(e, n, r) {
    n === void 0 ? (n = 0) : n > e.length && Ce(),
      r === void 0 ? (r = e.length - n) : r > e.length - n && Ce(),
      (this.segments = e),
      (this.offset = n),
      (this.len = r)
  }
  get length() {
    return this.len
  }
  isEqual(e) {
    return Tu.comparator(this, e) === 0
  }
  child(e) {
    const n = this.segments.slice(this.offset, this.limit())
    return (
      e instanceof Tu
        ? e.forEach((r) => {
            n.push(r)
          })
        : n.push(e),
      this.construct(n)
    )
  }
  limit() {
    return this.offset + this.length
  }
  popFirst(e) {
    return (
      (e = e === void 0 ? 1 : e), this.construct(this.segments, this.offset + e, this.length - e)
    )
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1)
  }
  firstSegment() {
    return this.segments[this.offset]
  }
  lastSegment() {
    return this.get(this.length - 1)
  }
  get(e) {
    return this.segments[this.offset + e]
  }
  isEmpty() {
    return this.length === 0
  }
  isPrefixOf(e) {
    if (e.length < this.length) return !1
    for (let n = 0; n < this.length; n++) if (this.get(n) !== e.get(n)) return !1
    return !0
  }
  isImmediateParentOf(e) {
    if (this.length + 1 !== e.length) return !1
    for (let n = 0; n < this.length; n++) if (this.get(n) !== e.get(n)) return !1
    return !0
  }
  forEach(e) {
    for (let n = this.offset, r = this.limit(); n < r; n++) e(this.segments[n])
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit())
  }
  static comparator(e, n) {
    const r = Math.min(e.length, n.length)
    for (let i = 0; i < r; i++) {
      const s = e.get(i),
        o = n.get(i)
      if (s < o) return -1
      if (s > o) return 1
    }
    return e.length < n.length ? -1 : e.length > n.length ? 1 : 0
  }
}
class At extends Tu {
  construct(e, n, r) {
    return new At(e, n, r)
  }
  canonicalString() {
    return this.toArray().join('/')
  }
  toString() {
    return this.canonicalString()
  }
  toUriEncodedString() {
    return this.toArray().map(encodeURIComponent).join('/')
  }
  static fromString(...e) {
    const n = []
    for (const r of e) {
      if (r.indexOf('//') >= 0)
        throw new ue(
          V.INVALID_ARGUMENT,
          `Invalid segment (${r}). Paths must not contain // in them.`
        )
      n.push(...r.split('/').filter((i) => i.length > 0))
    }
    return new At(n)
  }
  static emptyPath() {
    return new At([])
  }
}
const p7 = /^[_a-zA-Z][_a-zA-Z0-9]*$/
class vn extends Tu {
  construct(e, n, r) {
    return new vn(e, n, r)
  }
  static isValidIdentifier(e) {
    return p7.test(e)
  }
  canonicalString() {
    return this.toArray()
      .map(
        (e) => (
          (e = e.replace(/\\/g, '\\\\').replace(/`/g, '\\`')),
          vn.isValidIdentifier(e) || (e = '`' + e + '`'),
          e
        )
      )
      .join('.')
  }
  toString() {
    return this.canonicalString()
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === '__name__'
  }
  static keyField() {
    return new vn(['__name__'])
  }
  static fromServerFormat(e) {
    const n = []
    let r = '',
      i = 0
    const s = () => {
      if (r.length === 0)
        throw new ue(
          V.INVALID_ARGUMENT,
          `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`
        )
      n.push(r), (r = '')
    }
    let o = !1
    for (; i < e.length; ) {
      const a = e[i]
      if (a === '\\') {
        if (i + 1 === e.length)
          throw new ue(V.INVALID_ARGUMENT, 'Path has trailing escape character: ' + e)
        const l = e[i + 1]
        if (l !== '\\' && l !== '.' && l !== '`')
          throw new ue(V.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + e)
        ;(r += l), (i += 2)
      } else a === '`' ? ((o = !o), i++) : a !== '.' || o ? ((r += a), i++) : (s(), i++)
    }
    if ((s(), o)) throw new ue(V.INVALID_ARGUMENT, 'Unterminated ` in path: ' + e)
    return new vn(n)
  }
  static emptyPath() {
    return new vn([])
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _e {
  constructor(e) {
    this.path = e
  }
  static fromPath(e) {
    return new _e(At.fromString(e))
  }
  static fromName(e) {
    return new _e(At.fromString(e).popFirst(5))
  }
  static empty() {
    return new _e(At.emptyPath())
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment()
  }
  hasCollectionId(e) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === e
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2)
  }
  getCollectionPath() {
    return this.path.popLast()
  }
  isEqual(e) {
    return e !== null && At.comparator(this.path, e.path) === 0
  }
  toString() {
    return this.path.toString()
  }
  static comparator(e, n) {
    return At.comparator(e.path, n.path)
  }
  static isDocumentKey(e) {
    return e.length % 2 == 0
  }
  static fromSegments(e) {
    return new _e(new At(e.slice()))
  }
}
function m7(t, e) {
  const n = t.toTimestamp().seconds,
    r = t.toTimestamp().nanoseconds + 1,
    i = Ne.fromTimestamp(r === 1e9 ? new $t(n + 1, 0) : new $t(n, r))
  return new $s(i, _e.empty(), e)
}
function g7(t) {
  return new $s(t.readTime, t.key, -1)
}
class $s {
  constructor(e, n, r) {
    ;(this.readTime = e), (this.documentKey = n), (this.largestBatchId = r)
  }
  static min() {
    return new $s(Ne.min(), _e.empty(), -1)
  }
  static max() {
    return new $s(Ne.max(), _e.empty(), -1)
  }
}
function y7(t, e) {
  let n = t.readTime.compareTo(e.readTime)
  return n !== 0
    ? n
    : ((n = _e.comparator(t.documentKey, e.documentKey)),
      n !== 0 ? n : et(t.largestBatchId, e.largestBatchId))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const _7 =
  'The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.'
class v7 {
  constructor() {
    this.onCommittedListeners = []
  }
  addOnCommittedListener(e) {
    this.onCommittedListeners.push(e)
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((e) => e())
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function hh(t) {
  if (t.code !== V.FAILED_PRECONDITION || t.message !== _7) throw t
  ee('LocalStore', 'Unexpectedly lost primary lease')
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class L {
  constructor(e) {
    ;(this.nextCallback = null),
      (this.catchCallback = null),
      (this.result = void 0),
      (this.error = void 0),
      (this.isDone = !1),
      (this.callbackAttached = !1),
      e(
        (n) => {
          ;(this.isDone = !0), (this.result = n), this.nextCallback && this.nextCallback(n)
        },
        (n) => {
          ;(this.isDone = !0), (this.error = n), this.catchCallback && this.catchCallback(n)
        }
      )
  }
  catch(e) {
    return this.next(void 0, e)
  }
  next(e, n) {
    return (
      this.callbackAttached && Ce(),
      (this.callbackAttached = !0),
      this.isDone
        ? this.error
          ? this.wrapFailure(n, this.error)
          : this.wrapSuccess(e, this.result)
        : new L((r, i) => {
            ;(this.nextCallback = (s) => {
              this.wrapSuccess(e, s).next(r, i)
            }),
              (this.catchCallback = (s) => {
                this.wrapFailure(n, s).next(r, i)
              })
          })
    )
  }
  toPromise() {
    return new Promise((e, n) => {
      this.next(e, n)
    })
  }
  wrapUserFunction(e) {
    try {
      const n = e()
      return n instanceof L ? n : L.resolve(n)
    } catch (n) {
      return L.reject(n)
    }
  }
  wrapSuccess(e, n) {
    return e ? this.wrapUserFunction(() => e(n)) : L.resolve(n)
  }
  wrapFailure(e, n) {
    return e ? this.wrapUserFunction(() => e(n)) : L.reject(n)
  }
  static resolve(e) {
    return new L((n, r) => {
      n(e)
    })
  }
  static reject(e) {
    return new L((n, r) => {
      r(e)
    })
  }
  static waitFor(e) {
    return new L((n, r) => {
      let i = 0,
        s = 0,
        o = !1
      e.forEach((a) => {
        ++i,
          a.next(
            () => {
              ++s, o && s === i && n()
            },
            (l) => r(l)
          )
      }),
        (o = !0),
        s === i && n()
    })
  }
  static or(e) {
    let n = L.resolve(!1)
    for (const r of e) n = n.next((i) => (i ? L.resolve(i) : r()))
    return n
  }
  static forEach(e, n) {
    const r = []
    return (
      e.forEach((i, s) => {
        r.push(n.call(this, i, s))
      }),
      this.waitFor(r)
    )
  }
  static mapArray(e, n) {
    return new L((r, i) => {
      const s = e.length,
        o = new Array(s)
      let a = 0
      for (let l = 0; l < s; l++) {
        const c = l
        n(e[c]).next(
          (u) => {
            ;(o[c] = u), ++a, a === s && r(o)
          },
          (u) => i(u)
        )
      }
    })
  }
  static doWhile(e, n) {
    return new L((r, i) => {
      const s = () => {
        e() === !0
          ? n().next(() => {
              s()
            }, i)
          : r()
      }
      s()
    })
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class q0 {
  constructor(e, n) {
    ;(this.action = e),
      (this.transaction = n),
      (this.aborted = !1),
      (this.V = new ui()),
      (this.transaction.oncomplete = () => {
        this.V.resolve()
      }),
      (this.transaction.onabort = () => {
        n.error ? this.V.reject(new Lc(e, n.error)) : this.V.resolve()
      }),
      (this.transaction.onerror = (r) => {
        const i = K0(r.target.error)
        this.V.reject(new Lc(e, i))
      })
  }
  static open(e, n, r, i) {
    try {
      return new q0(n, e.transaction(i, r))
    } catch (s) {
      throw new Lc(n, s)
    }
  }
  get m() {
    return this.V.promise
  }
  abort(e) {
    e && this.V.reject(e),
      this.aborted ||
        (ee('SimpleDb', 'Aborting transaction:', e ? e.message : 'Client-initiated abort'),
        (this.aborted = !0),
        this.transaction.abort())
  }
  g() {
    const e = this.transaction
    this.aborted || typeof e.commit != 'function' || e.commit()
  }
  store(e) {
    const n = this.transaction.objectStore(e)
    return new E7(n)
  }
}
class So {
  constructor(e, n, r) {
    ;(this.name = e),
      (this.version = n),
      (this.p = r),
      So.S(Ht()) === 12.2 &&
        yi(
          'Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.'
        )
  }
  static delete(e) {
    return (
      ee('SimpleDb', 'Removing database:', e), go(window.indexedDB.deleteDatabase(e)).toPromise()
    )
  }
  static D() {
    if (!Hv()) return !1
    if (So.C()) return !0
    const e = Ht(),
      n = So.S(e),
      r = 0 < n && n < 10,
      i = So.v(e),
      s = 0 < i && i < 4.5
    return !(
      e.indexOf('MSIE ') > 0 ||
      e.indexOf('Trident/') > 0 ||
      e.indexOf('Edge/') > 0 ||
      r ||
      s
    )
  }
  static C() {
    var e
    return (
      typeof process < 'u' &&
      ((e = process.__PRIVATE_env) === null || e === void 0 ? void 0 : e.F) === 'YES'
    )
  }
  static M(e, n) {
    return e.store(n)
  }
  static S(e) {
    const n = e.match(/i(?:phone|pad|pod) os ([\d_]+)/i),
      r = n ? n[1].split('_').slice(0, 2).join('.') : '-1'
    return Number(r)
  }
  static v(e) {
    const n = e.match(/Android ([\d.]+)/i),
      r = n ? n[1].split('.').slice(0, 2).join('.') : '-1'
    return Number(r)
  }
  async O(e) {
    return (
      this.db ||
        (ee('SimpleDb', 'Opening database:', this.name),
        (this.db = await new Promise((n, r) => {
          const i = indexedDB.open(this.name, this.version)
          ;(i.onsuccess = (s) => {
            const o = s.target.result
            n(o)
          }),
            (i.onblocked = () => {
              r(
                new Lc(
                  e,
                  'Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.'
                )
              )
            }),
            (i.onerror = (s) => {
              const o = s.target.error
              o.name === 'VersionError'
                ? r(
                    new ue(
                      V.FAILED_PRECONDITION,
                      'A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.'
                    )
                  )
                : o.name === 'InvalidStateError'
                ? r(
                    new ue(
                      V.FAILED_PRECONDITION,
                      'Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: ' +
                        o
                    )
                  )
                : r(new Lc(e, o))
            }),
            (i.onupgradeneeded = (s) => {
              ee(
                'SimpleDb',
                'Database "' + this.name + '" requires upgrade from version:',
                s.oldVersion
              )
              const o = s.target.result
              this.p.N(o, i.transaction, s.oldVersion, this.version).next(() => {
                ee('SimpleDb', 'Database upgrade to version ' + this.version + ' complete')
              })
            })
        }))),
      this.L && (this.db.onversionchange = (n) => this.L(n)),
      this.db
    )
  }
  B(e) {
    ;(this.L = e), this.db && (this.db.onversionchange = (n) => e(n))
  }
  async runTransaction(e, n, r, i) {
    const s = n === 'readonly'
    let o = 0
    for (;;) {
      ++o
      try {
        this.db = await this.O(e)
        const a = q0.open(this.db, e, s ? 'readonly' : 'readwrite', r),
          l = i(a)
            .next((c) => (a.g(), c))
            .catch((c) => (a.abort(c), L.reject(c)))
            .toPromise()
        return l.catch(() => {}), await a.m, l
      } catch (a) {
        const l = a,
          c = l.name !== 'FirebaseError' && o < 3
        if (
          (ee('SimpleDb', 'Transaction failed with error:', l.message, 'Retrying:', c),
          this.close(),
          !c)
        )
          return Promise.reject(l)
      }
    }
  }
  close() {
    this.db && this.db.close(), (this.db = void 0)
  }
}
class b7 {
  constructor(e) {
    ;(this.k = e), (this.q = !1), (this.K = null)
  }
  get isDone() {
    return this.q
  }
  get $() {
    return this.K
  }
  set cursor(e) {
    this.k = e
  }
  done() {
    this.q = !0
  }
  U(e) {
    this.K = e
  }
  delete() {
    return go(this.k.delete())
  }
}
class Lc extends ue {
  constructor(e, n) {
    super(V.UNAVAILABLE, `IndexedDB transaction '${e}' failed: ${n}`),
      (this.name = 'IndexedDbTransactionError')
  }
}
function dh(t) {
  return t.name === 'IndexedDbTransactionError'
}
class E7 {
  constructor(e) {
    this.store = e
  }
  put(e, n) {
    let r
    return (
      n !== void 0
        ? (ee('SimpleDb', 'PUT', this.store.name, e, n), (r = this.store.put(n, e)))
        : (ee('SimpleDb', 'PUT', this.store.name, '<auto-key>', e), (r = this.store.put(e))),
      go(r)
    )
  }
  add(e) {
    return ee('SimpleDb', 'ADD', this.store.name, e, e), go(this.store.add(e))
  }
  get(e) {
    return go(this.store.get(e)).next(
      (n) => (n === void 0 && (n = null), ee('SimpleDb', 'GET', this.store.name, e, n), n)
    )
  }
  delete(e) {
    return ee('SimpleDb', 'DELETE', this.store.name, e), go(this.store.delete(e))
  }
  count() {
    return ee('SimpleDb', 'COUNT', this.store.name), go(this.store.count())
  }
  W(e, n) {
    const r = this.options(e, n),
      i = r.index ? this.store.index(r.index) : this.store
    if (typeof i.getAll == 'function') {
      const s = i.getAll(r.range)
      return new L((o, a) => {
        ;(s.onerror = (l) => {
          a(l.target.error)
        }),
          (s.onsuccess = (l) => {
            o(l.target.result)
          })
      })
    }
    {
      const s = this.cursor(r),
        o = []
      return this.G(s, (a, l) => {
        o.push(l)
      }).next(() => o)
    }
  }
  j(e, n) {
    const r = this.store.getAll(e, n === null ? void 0 : n)
    return new L((i, s) => {
      ;(r.onerror = (o) => {
        s(o.target.error)
      }),
        (r.onsuccess = (o) => {
          i(o.target.result)
        })
    })
  }
  H(e, n) {
    ee('SimpleDb', 'DELETE ALL', this.store.name)
    const r = this.options(e, n)
    r.J = !1
    const i = this.cursor(r)
    return this.G(i, (s, o, a) => a.delete())
  }
  Y(e, n) {
    let r
    n ? (r = e) : ((r = {}), (n = e))
    const i = this.cursor(r)
    return this.G(i, n)
  }
  Z(e) {
    const n = this.cursor({})
    return new L((r, i) => {
      ;(n.onerror = (s) => {
        const o = K0(s.target.error)
        i(o)
      }),
        (n.onsuccess = (s) => {
          const o = s.target.result
          o
            ? e(o.primaryKey, o.value).next((a) => {
                a ? o.continue() : r()
              })
            : r()
        })
    })
  }
  G(e, n) {
    const r = []
    return new L((i, s) => {
      ;(e.onerror = (o) => {
        s(o.target.error)
      }),
        (e.onsuccess = (o) => {
          const a = o.target.result
          if (!a) return void i()
          const l = new b7(a),
            c = n(a.primaryKey, a.value, l)
          if (c instanceof L) {
            const u = c.catch((h) => (l.done(), L.reject(h)))
            r.push(u)
          }
          l.isDone ? i() : l.$ === null ? a.continue() : a.continue(l.$)
        })
    }).next(() => L.waitFor(r))
  }
  options(e, n) {
    let r
    return e !== void 0 && (typeof e == 'string' ? (r = e) : (n = e)), { index: r, range: n }
  }
  cursor(e) {
    let n = 'next'
    if ((e.reverse && (n = 'prev'), e.index)) {
      const r = this.store.index(e.index)
      return e.J ? r.openKeyCursor(e.range, n) : r.openCursor(e.range, n)
    }
    return this.store.openCursor(e.range, n)
  }
}
function go(t) {
  return new L((e, n) => {
    ;(t.onsuccess = (r) => {
      const i = r.target.result
      e(i)
    }),
      (t.onerror = (r) => {
        const i = K0(r.target.error)
        n(i)
      })
  })
}
let PT = !1
function K0(t) {
  const e = So.S(Ht())
  if (e >= 12.2 && e < 13) {
    const n = 'An internal error was encountered in the Indexed Database server'
    if (t.message.indexOf(n) >= 0) {
      const r = new ue(
        'internal',
        `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${n}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`
      )
      return (
        PT ||
          ((PT = !0),
          setTimeout(() => {
            throw r
          }, 0)),
        r
      )
    }
  }
  return t
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Y0 {
  constructor(e, n) {
    ;(this.previousValue = e),
      n &&
        ((n.sequenceNumberHandler = (r) => this.se(r)), (this.oe = (r) => n.writeSequenceNumber(r)))
  }
  se(e) {
    return (this.previousValue = Math.max(e, this.previousValue)), this.previousValue
  }
  next() {
    const e = ++this.previousValue
    return this.oe && this.oe(e), e
  }
}
Y0._e = -1
function Zp(t) {
  return t == null
}
function Sf(t) {
  return t === 0 && 1 / t == -1 / 0
}
function T7(t) {
  return (
    typeof t == 'number' &&
    Number.isInteger(t) &&
    !Sf(t) &&
    t <= Number.MAX_SAFE_INTEGER &&
    t >= Number.MIN_SAFE_INTEGER
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function xT(t) {
  let e = 0
  for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && e++
  return e
}
function pa(t, e) {
  for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n])
}
function Zk(t) {
  for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1
  return !0
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Rt {
  constructor(e, n) {
    ;(this.comparator = e), (this.root = n || fn.EMPTY)
  }
  insert(e, n) {
    return new Rt(
      this.comparator,
      this.root.insert(e, n, this.comparator).copy(null, null, fn.BLACK, null, null)
    )
  }
  remove(e) {
    return new Rt(
      this.comparator,
      this.root.remove(e, this.comparator).copy(null, null, fn.BLACK, null, null)
    )
  }
  get(e) {
    let n = this.root
    for (; !n.isEmpty(); ) {
      const r = this.comparator(e, n.key)
      if (r === 0) return n.value
      r < 0 ? (n = n.left) : r > 0 && (n = n.right)
    }
    return null
  }
  indexOf(e) {
    let n = 0,
      r = this.root
    for (; !r.isEmpty(); ) {
      const i = this.comparator(e, r.key)
      if (i === 0) return n + r.left.size
      i < 0 ? (r = r.left) : ((n += r.left.size + 1), (r = r.right))
    }
    return -1
  }
  isEmpty() {
    return this.root.isEmpty()
  }
  get size() {
    return this.root.size
  }
  minKey() {
    return this.root.minKey()
  }
  maxKey() {
    return this.root.maxKey()
  }
  inorderTraversal(e) {
    return this.root.inorderTraversal(e)
  }
  forEach(e) {
    this.inorderTraversal((n, r) => (e(n, r), !1))
  }
  toString() {
    const e = []
    return this.inorderTraversal((n, r) => (e.push(`${n}:${r}`), !1)), `{${e.join(', ')}}`
  }
  reverseTraversal(e) {
    return this.root.reverseTraversal(e)
  }
  getIterator() {
    return new Qh(this.root, null, this.comparator, !1)
  }
  getIteratorFrom(e) {
    return new Qh(this.root, e, this.comparator, !1)
  }
  getReverseIterator() {
    return new Qh(this.root, null, this.comparator, !0)
  }
  getReverseIteratorFrom(e) {
    return new Qh(this.root, e, this.comparator, !0)
  }
}
class Qh {
  constructor(e, n, r, i) {
    ;(this.isReverse = i), (this.nodeStack = [])
    let s = 1
    for (; !e.isEmpty(); )
      if (((s = n ? r(e.key, n) : 1), n && i && (s *= -1), s < 0))
        e = this.isReverse ? e.left : e.right
      else {
        if (s === 0) {
          this.nodeStack.push(e)
          break
        }
        this.nodeStack.push(e), (e = this.isReverse ? e.right : e.left)
      }
  }
  getNext() {
    let e = this.nodeStack.pop()
    const n = { key: e.key, value: e.value }
    if (this.isReverse) for (e = e.left; !e.isEmpty(); ) this.nodeStack.push(e), (e = e.right)
    else for (e = e.right; !e.isEmpty(); ) this.nodeStack.push(e), (e = e.left)
    return n
  }
  hasNext() {
    return this.nodeStack.length > 0
  }
  peek() {
    if (this.nodeStack.length === 0) return null
    const e = this.nodeStack[this.nodeStack.length - 1]
    return { key: e.key, value: e.value }
  }
}
class fn {
  constructor(e, n, r, i, s) {
    ;(this.key = e),
      (this.value = n),
      (this.color = r ?? fn.RED),
      (this.left = i ?? fn.EMPTY),
      (this.right = s ?? fn.EMPTY),
      (this.size = this.left.size + 1 + this.right.size)
  }
  copy(e, n, r, i, s) {
    return new fn(e ?? this.key, n ?? this.value, r ?? this.color, i ?? this.left, s ?? this.right)
  }
  isEmpty() {
    return !1
  }
  inorderTraversal(e) {
    return (
      this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e)
    )
  }
  reverseTraversal(e) {
    return (
      this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e)
    )
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min()
  }
  minKey() {
    return this.min().key
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey()
  }
  insert(e, n, r) {
    let i = this
    const s = r(e, i.key)
    return (
      (i =
        s < 0
          ? i.copy(null, null, null, i.left.insert(e, n, r), null)
          : s === 0
          ? i.copy(null, n, null, null, null)
          : i.copy(null, null, null, null, i.right.insert(e, n, r))),
      i.fixUp()
    )
  }
  removeMin() {
    if (this.left.isEmpty()) return fn.EMPTY
    let e = this
    return (
      e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()),
      (e = e.copy(null, null, null, e.left.removeMin(), null)),
      e.fixUp()
    )
  }
  remove(e, n) {
    let r,
      i = this
    if (n(e, i.key) < 0)
      i.left.isEmpty() || i.left.isRed() || i.left.left.isRed() || (i = i.moveRedLeft()),
        (i = i.copy(null, null, null, i.left.remove(e, n), null))
    else {
      if (
        (i.left.isRed() && (i = i.rotateRight()),
        i.right.isEmpty() || i.right.isRed() || i.right.left.isRed() || (i = i.moveRedRight()),
        n(e, i.key) === 0)
      ) {
        if (i.right.isEmpty()) return fn.EMPTY
        ;(r = i.right.min()), (i = i.copy(r.key, r.value, null, null, i.right.removeMin()))
      }
      i = i.copy(null, null, null, null, i.right.remove(e, n))
    }
    return i.fixUp()
  }
  isRed() {
    return this.color
  }
  fixUp() {
    let e = this
    return (
      e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()),
      e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()),
      e.left.isRed() && e.right.isRed() && (e = e.colorFlip()),
      e
    )
  }
  moveRedLeft() {
    let e = this.colorFlip()
    return (
      e.right.left.isRed() &&
        ((e = e.copy(null, null, null, null, e.right.rotateRight())),
        (e = e.rotateLeft()),
        (e = e.colorFlip())),
      e
    )
  }
  moveRedRight() {
    let e = this.colorFlip()
    return e.left.left.isRed() && ((e = e.rotateRight()), (e = e.colorFlip())), e
  }
  rotateLeft() {
    const e = this.copy(null, null, fn.RED, null, this.right.left)
    return this.right.copy(null, null, this.color, e, null)
  }
  rotateRight() {
    const e = this.copy(null, null, fn.RED, this.left.right, null)
    return this.left.copy(null, null, this.color, null, e)
  }
  colorFlip() {
    const e = this.left.copy(null, null, !this.left.color, null, null),
      n = this.right.copy(null, null, !this.right.color, null, null)
    return this.copy(null, null, !this.color, e, n)
  }
  checkMaxDepth() {
    const e = this.check()
    return Math.pow(2, e) <= this.size + 1
  }
  check() {
    if ((this.isRed() && this.left.isRed()) || this.right.isRed()) throw Ce()
    const e = this.left.check()
    if (e !== this.right.check()) throw Ce()
    return e + (this.isRed() ? 0 : 1)
  }
}
;(fn.EMPTY = null), (fn.RED = !0), (fn.BLACK = !1)
fn.EMPTY = new (class {
  constructor() {
    this.size = 0
  }
  get key() {
    throw Ce()
  }
  get value() {
    throw Ce()
  }
  get color() {
    throw Ce()
  }
  get left() {
    throw Ce()
  }
  get right() {
    throw Ce()
  }
  copy(e, n, r, i, s) {
    return this
  }
  insert(e, n, r) {
    return new fn(e, n)
  }
  remove(e, n) {
    return this
  }
  isEmpty() {
    return !0
  }
  inorderTraversal(e) {
    return !1
  }
  reverseTraversal(e) {
    return !1
  }
  minKey() {
    return null
  }
  maxKey() {
    return null
  }
  isRed() {
    return !1
  }
  checkMaxDepth() {
    return !0
  }
  check() {
    return 0
  }
})()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class En {
  constructor(e) {
    ;(this.comparator = e), (this.data = new Rt(this.comparator))
  }
  has(e) {
    return this.data.get(e) !== null
  }
  first() {
    return this.data.minKey()
  }
  last() {
    return this.data.maxKey()
  }
  get size() {
    return this.data.size
  }
  indexOf(e) {
    return this.data.indexOf(e)
  }
  forEach(e) {
    this.data.inorderTraversal((n, r) => (e(n), !1))
  }
  forEachInRange(e, n) {
    const r = this.data.getIteratorFrom(e[0])
    for (; r.hasNext(); ) {
      const i = r.getNext()
      if (this.comparator(i.key, e[1]) >= 0) return
      n(i.key)
    }
  }
  forEachWhile(e, n) {
    let r
    for (r = n !== void 0 ? this.data.getIteratorFrom(n) : this.data.getIterator(); r.hasNext(); )
      if (!e(r.getNext().key)) return
  }
  firstAfterOrEqual(e) {
    const n = this.data.getIteratorFrom(e)
    return n.hasNext() ? n.getNext().key : null
  }
  getIterator() {
    return new DT(this.data.getIterator())
  }
  getIteratorFrom(e) {
    return new DT(this.data.getIteratorFrom(e))
  }
  add(e) {
    return this.copy(this.data.remove(e).insert(e, !0))
  }
  delete(e) {
    return this.has(e) ? this.copy(this.data.remove(e)) : this
  }
  isEmpty() {
    return this.data.isEmpty()
  }
  unionWith(e) {
    let n = this
    return (
      n.size < e.size && ((n = e), (e = this)),
      e.forEach((r) => {
        n = n.add(r)
      }),
      n
    )
  }
  isEqual(e) {
    if (!(e instanceof En) || this.size !== e.size) return !1
    const n = this.data.getIterator(),
      r = e.data.getIterator()
    for (; n.hasNext(); ) {
      const i = n.getNext().key,
        s = r.getNext().key
      if (this.comparator(i, s) !== 0) return !1
    }
    return !0
  }
  toArray() {
    const e = []
    return (
      this.forEach((n) => {
        e.push(n)
      }),
      e
    )
  }
  toString() {
    const e = []
    return this.forEach((n) => e.push(n)), 'SortedSet(' + e.toString() + ')'
  }
  copy(e) {
    const n = new En(this.comparator)
    return (n.data = e), n
  }
}
class DT {
  constructor(e) {
    this.iter = e
  }
  getNext() {
    return this.iter.getNext().key
  }
  hasNext() {
    return this.iter.hasNext()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class or {
  constructor(e) {
    ;(this.fields = e), e.sort(vn.comparator)
  }
  static empty() {
    return new or([])
  }
  unionWith(e) {
    let n = new En(vn.comparator)
    for (const r of this.fields) n = n.add(r)
    for (const r of e) n = n.add(r)
    return new or(n.toArray())
  }
  covers(e) {
    for (const n of this.fields) if (n.isPrefixOf(e)) return !0
    return !1
  }
  isEqual(e) {
    return fl(this.fields, e.fields, (n, r) => n.isEqual(r))
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class e2 extends Error {
  constructor() {
    super(...arguments), (this.name = 'Base64DecodeError')
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class xn {
  constructor(e) {
    this.binaryString = e
  }
  static fromBase64String(e) {
    const n = (function (i) {
      try {
        return atob(i)
      } catch (s) {
        throw typeof DOMException < 'u' && s instanceof DOMException
          ? new e2('Invalid base64 string: ' + s)
          : s
      }
    })(e)
    return new xn(n)
  }
  static fromUint8Array(e) {
    const n = (function (i) {
      let s = ''
      for (let o = 0; o < i.length; ++o) s += String.fromCharCode(i[o])
      return s
    })(e)
    return new xn(n)
  }
  [Symbol.iterator]() {
    let e = 0
    return {
      next: () =>
        e < this.binaryString.length
          ? { value: this.binaryString.charCodeAt(e++), done: !1 }
          : { value: void 0, done: !0 }
    }
  }
  toBase64() {
    return (function (n) {
      return btoa(n)
    })(this.binaryString)
  }
  toUint8Array() {
    return (function (n) {
      const r = new Uint8Array(n.length)
      for (let i = 0; i < n.length; i++) r[i] = n.charCodeAt(i)
      return r
    })(this.binaryString)
  }
  approximateByteSize() {
    return 2 * this.binaryString.length
  }
  compareTo(e) {
    return et(this.binaryString, e.binaryString)
  }
  isEqual(e) {
    return this.binaryString === e.binaryString
  }
}
xn.EMPTY_BYTE_STRING = new xn('')
const w7 = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/)
function Hs(t) {
  if ((mt(!!t), typeof t == 'string')) {
    let e = 0
    const n = w7.exec(t)
    if ((mt(!!n), n[1])) {
      let i = n[1]
      ;(i = (i + '000000000').substr(0, 9)), (e = Number(i))
    }
    const r = new Date(t)
    return { seconds: Math.floor(r.getTime() / 1e3), nanos: e }
  }
  return { seconds: Vt(t.seconds), nanos: Vt(t.nanos) }
}
function Vt(t) {
  return typeof t == 'number' ? t : typeof t == 'string' ? Number(t) : 0
}
function Zo(t) {
  return typeof t == 'string' ? xn.fromBase64String(t) : xn.fromUint8Array(t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function J0(t) {
  var e, n
  return (
    ((n = (
      ((e = t == null ? void 0 : t.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}
    ).__type__) === null || n === void 0
      ? void 0
      : n.stringValue) === 'server_timestamp'
  )
}
function Q0(t) {
  const e = t.mapValue.fields.__previous_value__
  return J0(e) ? Q0(e) : e
}
function wu(t) {
  const e = Hs(t.mapValue.fields.__local_write_time__.timestampValue)
  return new $t(e.seconds, e.nanos)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class S7 {
  constructor(e, n, r, i, s, o, a, l, c) {
    ;(this.databaseId = e),
      (this.appId = n),
      (this.persistenceKey = r),
      (this.host = i),
      (this.ssl = s),
      (this.forceLongPolling = o),
      (this.autoDetectLongPolling = a),
      (this.longPollingOptions = l),
      (this.useFetchStreams = c)
  }
}
class Su {
  constructor(e, n) {
    ;(this.projectId = e), (this.database = n || '(default)')
  }
  static empty() {
    return new Su('', '')
  }
  get isDefaultDatabase() {
    return this.database === '(default)'
  }
  isEqual(e) {
    return e instanceof Su && e.projectId === this.projectId && e.database === this.database
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Xh = { mapValue: { fields: { __type__: { stringValue: '__max__' } } } }
function ea(t) {
  return 'nullValue' in t
    ? 0
    : 'booleanValue' in t
    ? 1
    : 'integerValue' in t || 'doubleValue' in t
    ? 2
    : 'timestampValue' in t
    ? 3
    : 'stringValue' in t
    ? 5
    : 'bytesValue' in t
    ? 6
    : 'referenceValue' in t
    ? 7
    : 'geoPointValue' in t
    ? 8
    : 'arrayValue' in t
    ? 9
    : 'mapValue' in t
    ? J0(t)
      ? 4
      : I7(t)
      ? 9007199254740991
      : 10
    : Ce()
}
function _i(t, e) {
  if (t === e) return !0
  const n = ea(t)
  if (n !== ea(e)) return !1
  switch (n) {
    case 0:
    case 9007199254740991:
      return !0
    case 1:
      return t.booleanValue === e.booleanValue
    case 4:
      return wu(t).isEqual(wu(e))
    case 3:
      return (function (i, s) {
        if (
          typeof i.timestampValue == 'string' &&
          typeof s.timestampValue == 'string' &&
          i.timestampValue.length === s.timestampValue.length
        )
          return i.timestampValue === s.timestampValue
        const o = Hs(i.timestampValue),
          a = Hs(s.timestampValue)
        return o.seconds === a.seconds && o.nanos === a.nanos
      })(t, e)
    case 5:
      return t.stringValue === e.stringValue
    case 6:
      return (function (i, s) {
        return Zo(i.bytesValue).isEqual(Zo(s.bytesValue))
      })(t, e)
    case 7:
      return t.referenceValue === e.referenceValue
    case 8:
      return (function (i, s) {
        return (
          Vt(i.geoPointValue.latitude) === Vt(s.geoPointValue.latitude) &&
          Vt(i.geoPointValue.longitude) === Vt(s.geoPointValue.longitude)
        )
      })(t, e)
    case 2:
      return (function (i, s) {
        if ('integerValue' in i && 'integerValue' in s)
          return Vt(i.integerValue) === Vt(s.integerValue)
        if ('doubleValue' in i && 'doubleValue' in s) {
          const o = Vt(i.doubleValue),
            a = Vt(s.doubleValue)
          return o === a ? Sf(o) === Sf(a) : isNaN(o) && isNaN(a)
        }
        return !1
      })(t, e)
    case 9:
      return fl(t.arrayValue.values || [], e.arrayValue.values || [], _i)
    case 10:
      return (function (i, s) {
        const o = i.mapValue.fields || {},
          a = s.mapValue.fields || {}
        if (xT(o) !== xT(a)) return !1
        for (const l in o)
          if (o.hasOwnProperty(l) && (a[l] === void 0 || !_i(o[l], a[l]))) return !1
        return !0
      })(t, e)
    default:
      return Ce()
  }
}
function Iu(t, e) {
  return (t.values || []).find((n) => _i(n, e)) !== void 0
}
function pl(t, e) {
  if (t === e) return 0
  const n = ea(t),
    r = ea(e)
  if (n !== r) return et(n, r)
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0
    case 1:
      return et(t.booleanValue, e.booleanValue)
    case 2:
      return (function (s, o) {
        const a = Vt(s.integerValue || s.doubleValue),
          l = Vt(o.integerValue || o.doubleValue)
        return a < l ? -1 : a > l ? 1 : a === l ? 0 : isNaN(a) ? (isNaN(l) ? 0 : -1) : 1
      })(t, e)
    case 3:
      return LT(t.timestampValue, e.timestampValue)
    case 4:
      return LT(wu(t), wu(e))
    case 5:
      return et(t.stringValue, e.stringValue)
    case 6:
      return (function (s, o) {
        const a = Zo(s),
          l = Zo(o)
        return a.compareTo(l)
      })(t.bytesValue, e.bytesValue)
    case 7:
      return (function (s, o) {
        const a = s.split('/'),
          l = o.split('/')
        for (let c = 0; c < a.length && c < l.length; c++) {
          const u = et(a[c], l[c])
          if (u !== 0) return u
        }
        return et(a.length, l.length)
      })(t.referenceValue, e.referenceValue)
    case 8:
      return (function (s, o) {
        const a = et(Vt(s.latitude), Vt(o.latitude))
        return a !== 0 ? a : et(Vt(s.longitude), Vt(o.longitude))
      })(t.geoPointValue, e.geoPointValue)
    case 9:
      return (function (s, o) {
        const a = s.values || [],
          l = o.values || []
        for (let c = 0; c < a.length && c < l.length; ++c) {
          const u = pl(a[c], l[c])
          if (u) return u
        }
        return et(a.length, l.length)
      })(t.arrayValue, e.arrayValue)
    case 10:
      return (function (s, o) {
        if (s === Xh.mapValue && o === Xh.mapValue) return 0
        if (s === Xh.mapValue) return 1
        if (o === Xh.mapValue) return -1
        const a = s.fields || {},
          l = Object.keys(a),
          c = o.fields || {},
          u = Object.keys(c)
        l.sort(), u.sort()
        for (let h = 0; h < l.length && h < u.length; ++h) {
          const d = et(l[h], u[h])
          if (d !== 0) return d
          const f = pl(a[l[h]], c[u[h]])
          if (f !== 0) return f
        }
        return et(l.length, u.length)
      })(t.mapValue, e.mapValue)
    default:
      throw Ce()
  }
}
function LT(t, e) {
  if (typeof t == 'string' && typeof e == 'string' && t.length === e.length) return et(t, e)
  const n = Hs(t),
    r = Hs(e),
    i = et(n.seconds, r.seconds)
  return i !== 0 ? i : et(n.nanos, r.nanos)
}
function ml(t) {
  return d_(t)
}
function d_(t) {
  return 'nullValue' in t
    ? 'null'
    : 'booleanValue' in t
    ? '' + t.booleanValue
    : 'integerValue' in t
    ? '' + t.integerValue
    : 'doubleValue' in t
    ? '' + t.doubleValue
    : 'timestampValue' in t
    ? (function (n) {
        const r = Hs(n)
        return `time(${r.seconds},${r.nanos})`
      })(t.timestampValue)
    : 'stringValue' in t
    ? t.stringValue
    : 'bytesValue' in t
    ? (function (n) {
        return Zo(n).toBase64()
      })(t.bytesValue)
    : 'referenceValue' in t
    ? (function (n) {
        return _e.fromName(n).toString()
      })(t.referenceValue)
    : 'geoPointValue' in t
    ? (function (n) {
        return `geo(${n.latitude},${n.longitude})`
      })(t.geoPointValue)
    : 'arrayValue' in t
    ? (function (n) {
        let r = '[',
          i = !0
        for (const s of n.values || []) i ? (i = !1) : (r += ','), (r += d_(s))
        return r + ']'
      })(t.arrayValue)
    : 'mapValue' in t
    ? (function (n) {
        const r = Object.keys(n.fields || {}).sort()
        let i = '{',
          s = !0
        for (const o of r) s ? (s = !1) : (i += ','), (i += `${o}:${d_(n.fields[o])}`)
        return i + '}'
      })(t.mapValue)
    : Ce()
}
function f_(t) {
  return !!t && 'integerValue' in t
}
function X0(t) {
  return !!t && 'arrayValue' in t
}
function VT(t) {
  return !!t && 'nullValue' in t
}
function FT(t) {
  return !!t && 'doubleValue' in t && isNaN(Number(t.doubleValue))
}
function Rd(t) {
  return !!t && 'mapValue' in t
}
function Vc(t) {
  if (t.geoPointValue) return { geoPointValue: Object.assign({}, t.geoPointValue) }
  if (t.timestampValue && typeof t.timestampValue == 'object')
    return { timestampValue: Object.assign({}, t.timestampValue) }
  if (t.mapValue) {
    const e = { mapValue: { fields: {} } }
    return pa(t.mapValue.fields, (n, r) => (e.mapValue.fields[n] = Vc(r))), e
  }
  if (t.arrayValue) {
    const e = { arrayValue: { values: [] } }
    for (let n = 0; n < (t.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Vc(t.arrayValue.values[n])
    return e
  }
  return Object.assign({}, t)
}
function I7(t) {
  return (((t.mapValue || {}).fields || {}).__type__ || {}).stringValue === '__max__'
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class qn {
  constructor(e) {
    this.value = e
  }
  static empty() {
    return new qn({ mapValue: {} })
  }
  field(e) {
    if (e.isEmpty()) return this.value
    {
      let n = this.value
      for (let r = 0; r < e.length - 1; ++r)
        if (((n = (n.mapValue.fields || {})[e.get(r)]), !Rd(n))) return null
      return (n = (n.mapValue.fields || {})[e.lastSegment()]), n || null
    }
  }
  set(e, n) {
    this.getFieldsMap(e.popLast())[e.lastSegment()] = Vc(n)
  }
  setAll(e) {
    let n = vn.emptyPath(),
      r = {},
      i = []
    e.forEach((o, a) => {
      if (!n.isImmediateParentOf(a)) {
        const l = this.getFieldsMap(n)
        this.applyChanges(l, r, i), (r = {}), (i = []), (n = a.popLast())
      }
      o ? (r[a.lastSegment()] = Vc(o)) : i.push(a.lastSegment())
    })
    const s = this.getFieldsMap(n)
    this.applyChanges(s, r, i)
  }
  delete(e) {
    const n = this.field(e.popLast())
    Rd(n) && n.mapValue.fields && delete n.mapValue.fields[e.lastSegment()]
  }
  isEqual(e) {
    return _i(this.value, e.value)
  }
  getFieldsMap(e) {
    let n = this.value
    n.mapValue.fields || (n.mapValue = { fields: {} })
    for (let r = 0; r < e.length; ++r) {
      let i = n.mapValue.fields[e.get(r)]
      ;(Rd(i) && i.mapValue.fields) ||
        ((i = { mapValue: { fields: {} } }), (n.mapValue.fields[e.get(r)] = i)),
        (n = i)
    }
    return n.mapValue.fields
  }
  applyChanges(e, n, r) {
    pa(n, (i, s) => (e[i] = s))
    for (const i of r) delete e[i]
  }
  clone() {
    return new qn(Vc(this.value))
  }
}
function t2(t) {
  const e = []
  return (
    pa(t.fields, (n, r) => {
      const i = new vn([n])
      if (Rd(r)) {
        const s = t2(r.mapValue).fields
        if (s.length === 0) e.push(i)
        else for (const o of s) e.push(i.child(o))
      } else e.push(i)
    }),
    new or(e)
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class kn {
  constructor(e, n, r, i, s, o, a) {
    ;(this.key = e),
      (this.documentType = n),
      (this.version = r),
      (this.readTime = i),
      (this.createTime = s),
      (this.data = o),
      (this.documentState = a)
  }
  static newInvalidDocument(e) {
    return new kn(e, 0, Ne.min(), Ne.min(), Ne.min(), qn.empty(), 0)
  }
  static newFoundDocument(e, n, r, i) {
    return new kn(e, 1, n, Ne.min(), r, i, 0)
  }
  static newNoDocument(e, n) {
    return new kn(e, 2, n, Ne.min(), Ne.min(), qn.empty(), 0)
  }
  static newUnknownDocument(e, n) {
    return new kn(e, 3, n, Ne.min(), Ne.min(), qn.empty(), 2)
  }
  convertToFoundDocument(e, n) {
    return (
      !this.createTime.isEqual(Ne.min()) ||
        (this.documentType !== 2 && this.documentType !== 0) ||
        (this.createTime = e),
      (this.version = e),
      (this.documentType = 1),
      (this.data = n),
      (this.documentState = 0),
      this
    )
  }
  convertToNoDocument(e) {
    return (
      (this.version = e),
      (this.documentType = 2),
      (this.data = qn.empty()),
      (this.documentState = 0),
      this
    )
  }
  convertToUnknownDocument(e) {
    return (
      (this.version = e),
      (this.documentType = 3),
      (this.data = qn.empty()),
      (this.documentState = 2),
      this
    )
  }
  setHasCommittedMutations() {
    return (this.documentState = 2), this
  }
  setHasLocalMutations() {
    return (this.documentState = 1), (this.version = Ne.min()), this
  }
  setReadTime(e) {
    return (this.readTime = e), this
  }
  get hasLocalMutations() {
    return this.documentState === 1
  }
  get hasCommittedMutations() {
    return this.documentState === 2
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations
  }
  isValidDocument() {
    return this.documentType !== 0
  }
  isFoundDocument() {
    return this.documentType === 1
  }
  isNoDocument() {
    return this.documentType === 2
  }
  isUnknownDocument() {
    return this.documentType === 3
  }
  isEqual(e) {
    return (
      e instanceof kn &&
      this.key.isEqual(e.key) &&
      this.version.isEqual(e.version) &&
      this.documentType === e.documentType &&
      this.documentState === e.documentState &&
      this.data.isEqual(e.data)
    )
  }
  mutableCopy() {
    return new kn(
      this.key,
      this.documentType,
      this.version,
      this.readTime,
      this.createTime,
      this.data.clone(),
      this.documentState
    )
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(
      this.data.value
    )}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${
      this.documentState
    }})`
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class If {
  constructor(e, n) {
    ;(this.position = e), (this.inclusive = n)
  }
}
function BT(t, e, n) {
  let r = 0
  for (let i = 0; i < t.position.length; i++) {
    const s = e[i],
      o = t.position[i]
    if (
      (s.field.isKeyField()
        ? (r = _e.comparator(_e.fromName(o.referenceValue), n.key))
        : (r = pl(o, n.data.field(s.field))),
      s.dir === 'desc' && (r *= -1),
      r !== 0)
    )
      break
  }
  return r
}
function UT(t, e) {
  if (t === null) return e === null
  if (e === null || t.inclusive !== e.inclusive || t.position.length !== e.position.length)
    return !1
  for (let n = 0; n < t.position.length; n++) if (!_i(t.position[n], e.position[n])) return !1
  return !0
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Af {
  constructor(e, n = 'asc') {
    ;(this.field = e), (this.dir = n)
  }
}
function A7(t, e) {
  return t.dir === e.dir && t.field.isEqual(e.field)
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class n2 {}
class jt extends n2 {
  constructor(e, n, r) {
    super(), (this.field = e), (this.op = n), (this.value = r)
  }
  static create(e, n, r) {
    return e.isKeyField()
      ? n === 'in' || n === 'not-in'
        ? this.createKeyFieldInFilter(e, n, r)
        : new R7(e, n, r)
      : n === 'array-contains'
      ? new N7(e, r)
      : n === 'in'
      ? new M7(e, r)
      : n === 'not-in'
      ? new P7(e, r)
      : n === 'array-contains-any'
      ? new x7(e, r)
      : new jt(e, n, r)
  }
  static createKeyFieldInFilter(e, n, r) {
    return n === 'in' ? new k7(e, r) : new O7(e, r)
  }
  matches(e) {
    const n = e.data.field(this.field)
    return this.op === '!='
      ? n !== null && this.matchesComparison(pl(n, this.value))
      : n !== null && ea(this.value) === ea(n) && this.matchesComparison(pl(n, this.value))
  }
  matchesComparison(e) {
    switch (this.op) {
      case '<':
        return e < 0
      case '<=':
        return e <= 0
      case '==':
        return e === 0
      case '!=':
        return e !== 0
      case '>':
        return e > 0
      case '>=':
        return e >= 0
      default:
        return Ce()
    }
  }
  isInequality() {
    return ['<', '<=', '>', '>=', '!=', 'not-in'].indexOf(this.op) >= 0
  }
  getFlattenedFilters() {
    return [this]
  }
  getFilters() {
    return [this]
  }
}
class vi extends n2 {
  constructor(e, n) {
    super(), (this.filters = e), (this.op = n), (this.ue = null)
  }
  static create(e, n) {
    return new vi(e, n)
  }
  matches(e) {
    return r2(this)
      ? this.filters.find((n) => !n.matches(e)) === void 0
      : this.filters.find((n) => n.matches(e)) !== void 0
  }
  getFlattenedFilters() {
    return (
      this.ue !== null ||
        (this.ue = this.filters.reduce((e, n) => e.concat(n.getFlattenedFilters()), [])),
      this.ue
    )
  }
  getFilters() {
    return Object.assign([], this.filters)
  }
}
function r2(t) {
  return t.op === 'and'
}
function i2(t) {
  return C7(t) && r2(t)
}
function C7(t) {
  for (const e of t.filters) if (e instanceof vi) return !1
  return !0
}
function p_(t) {
  if (t instanceof jt) return t.field.canonicalString() + t.op.toString() + ml(t.value)
  if (i2(t)) return t.filters.map((e) => p_(e)).join(',')
  {
    const e = t.filters.map((n) => p_(n)).join(',')
    return `${t.op}(${e})`
  }
}
function s2(t, e) {
  return t instanceof jt
    ? (function (r, i) {
        return i instanceof jt && r.op === i.op && r.field.isEqual(i.field) && _i(r.value, i.value)
      })(t, e)
    : t instanceof vi
    ? (function (r, i) {
        return i instanceof vi && r.op === i.op && r.filters.length === i.filters.length
          ? r.filters.reduce((s, o, a) => s && s2(o, i.filters[a]), !0)
          : !1
      })(t, e)
    : void Ce()
}
function o2(t) {
  return t instanceof jt
    ? (function (n) {
        return `${n.field.canonicalString()} ${n.op} ${ml(n.value)}`
      })(t)
    : t instanceof vi
    ? (function (n) {
        return n.op.toString() + ' {' + n.getFilters().map(o2).join(' ,') + '}'
      })(t)
    : 'Filter'
}
class R7 extends jt {
  constructor(e, n, r) {
    super(e, n, r), (this.key = _e.fromName(r.referenceValue))
  }
  matches(e) {
    const n = _e.comparator(e.key, this.key)
    return this.matchesComparison(n)
  }
}
class k7 extends jt {
  constructor(e, n) {
    super(e, 'in', n), (this.keys = a2('in', n))
  }
  matches(e) {
    return this.keys.some((n) => n.isEqual(e.key))
  }
}
class O7 extends jt {
  constructor(e, n) {
    super(e, 'not-in', n), (this.keys = a2('not-in', n))
  }
  matches(e) {
    return !this.keys.some((n) => n.isEqual(e.key))
  }
}
function a2(t, e) {
  var n
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((r) =>
    _e.fromName(r.referenceValue)
  )
}
class N7 extends jt {
  constructor(e, n) {
    super(e, 'array-contains', n)
  }
  matches(e) {
    const n = e.data.field(this.field)
    return X0(n) && Iu(n.arrayValue, this.value)
  }
}
class M7 extends jt {
  constructor(e, n) {
    super(e, 'in', n)
  }
  matches(e) {
    const n = e.data.field(this.field)
    return n !== null && Iu(this.value.arrayValue, n)
  }
}
class P7 extends jt {
  constructor(e, n) {
    super(e, 'not-in', n)
  }
  matches(e) {
    if (Iu(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) return !1
    const n = e.data.field(this.field)
    return n !== null && !Iu(this.value.arrayValue, n)
  }
}
class x7 extends jt {
  constructor(e, n) {
    super(e, 'array-contains-any', n)
  }
  matches(e) {
    const n = e.data.field(this.field)
    return (
      !(!X0(n) || !n.arrayValue.values) &&
      n.arrayValue.values.some((r) => Iu(this.value.arrayValue, r))
    )
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class D7 {
  constructor(e, n = null, r = [], i = [], s = null, o = null, a = null) {
    ;(this.path = e),
      (this.collectionGroup = n),
      (this.orderBy = r),
      (this.filters = i),
      (this.limit = s),
      (this.startAt = o),
      (this.endAt = a),
      (this.ce = null)
  }
}
function $T(t, e = null, n = [], r = [], i = null, s = null, o = null) {
  return new D7(t, e, n, r, i, s, o)
}
function Z0(t) {
  const e = Pe(t)
  if (e.ce === null) {
    let n = e.path.canonicalString()
    e.collectionGroup !== null && (n += '|cg:' + e.collectionGroup),
      (n += '|f:'),
      (n += e.filters.map((r) => p_(r)).join(',')),
      (n += '|ob:'),
      (n += e.orderBy
        .map((r) =>
          (function (s) {
            return s.field.canonicalString() + s.dir
          })(r)
        )
        .join(',')),
      Zp(e.limit) || ((n += '|l:'), (n += e.limit)),
      e.startAt &&
        ((n += '|lb:'),
        (n += e.startAt.inclusive ? 'b:' : 'a:'),
        (n += e.startAt.position.map((r) => ml(r)).join(','))),
      e.endAt &&
        ((n += '|ub:'),
        (n += e.endAt.inclusive ? 'a:' : 'b:'),
        (n += e.endAt.position.map((r) => ml(r)).join(','))),
      (e.ce = n)
  }
  return e.ce
}
function e1(t, e) {
  if (t.limit !== e.limit || t.orderBy.length !== e.orderBy.length) return !1
  for (let n = 0; n < t.orderBy.length; n++) if (!A7(t.orderBy[n], e.orderBy[n])) return !1
  if (t.filters.length !== e.filters.length) return !1
  for (let n = 0; n < t.filters.length; n++) if (!s2(t.filters[n], e.filters[n])) return !1
  return (
    t.collectionGroup === e.collectionGroup &&
    !!t.path.isEqual(e.path) &&
    !!UT(t.startAt, e.startAt) &&
    UT(t.endAt, e.endAt)
  )
}
function m_(t) {
  return _e.isDocumentKey(t.path) && t.collectionGroup === null && t.filters.length === 0
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class em {
  constructor(e, n = null, r = [], i = [], s = null, o = 'F', a = null, l = null) {
    ;(this.path = e),
      (this.collectionGroup = n),
      (this.explicitOrderBy = r),
      (this.filters = i),
      (this.limit = s),
      (this.limitType = o),
      (this.startAt = a),
      (this.endAt = l),
      (this.le = null),
      (this.he = null),
      (this.Pe = null),
      this.startAt,
      this.endAt
  }
}
function L7(t, e, n, r, i, s, o, a) {
  return new em(t, e, n, r, i, s, o, a)
}
function tm(t) {
  return new em(t)
}
function HT(t) {
  return (
    t.filters.length === 0 &&
    t.limit === null &&
    t.startAt == null &&
    t.endAt == null &&
    (t.explicitOrderBy.length === 0 ||
      (t.explicitOrderBy.length === 1 && t.explicitOrderBy[0].field.isKeyField()))
  )
}
function V7(t) {
  return t.collectionGroup !== null
}
function Fc(t) {
  const e = Pe(t)
  if (e.le === null) {
    e.le = []
    const n = new Set()
    for (const s of e.explicitOrderBy) e.le.push(s), n.add(s.field.canonicalString())
    const r =
      e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : 'asc'
    ;(function (o) {
      let a = new En(vn.comparator)
      return (
        o.filters.forEach((l) => {
          l.getFlattenedFilters().forEach((c) => {
            c.isInequality() && (a = a.add(c.field))
          })
        }),
        a
      )
    })(e).forEach((s) => {
      n.has(s.canonicalString()) || s.isKeyField() || e.le.push(new Af(s, r))
    }),
      n.has(vn.keyField().canonicalString()) || e.le.push(new Af(vn.keyField(), r))
  }
  return e.le
}
function hi(t) {
  const e = Pe(t)
  return e.he || (e.he = F7(e, Fc(t))), e.he
}
function F7(t, e) {
  if (t.limitType === 'F')
    return $T(t.path, t.collectionGroup, e, t.filters, t.limit, t.startAt, t.endAt)
  {
    e = e.map((i) => {
      const s = i.dir === 'desc' ? 'asc' : 'desc'
      return new Af(i.field, s)
    })
    const n = t.endAt ? new If(t.endAt.position, t.endAt.inclusive) : null,
      r = t.startAt ? new If(t.startAt.position, t.startAt.inclusive) : null
    return $T(t.path, t.collectionGroup, e, t.filters, t.limit, n, r)
  }
}
function g_(t, e, n) {
  return new em(
    t.path,
    t.collectionGroup,
    t.explicitOrderBy.slice(),
    t.filters.slice(),
    e,
    n,
    t.startAt,
    t.endAt
  )
}
function nm(t, e) {
  return e1(hi(t), hi(e)) && t.limitType === e.limitType
}
function l2(t) {
  return `${Z0(hi(t))}|lt:${t.limitType}`
}
function Sa(t) {
  return `Query(target=${(function (n) {
    let r = n.path.canonicalString()
    return (
      n.collectionGroup !== null && (r += ' collectionGroup=' + n.collectionGroup),
      n.filters.length > 0 && (r += `, filters: [${n.filters.map((i) => o2(i)).join(', ')}]`),
      Zp(n.limit) || (r += ', limit: ' + n.limit),
      n.orderBy.length > 0 &&
        (r += `, orderBy: [${n.orderBy
          .map((i) =>
            (function (o) {
              return `${o.field.canonicalString()} (${o.dir})`
            })(i)
          )
          .join(', ')}]`),
      n.startAt &&
        ((r += ', startAt: '),
        (r += n.startAt.inclusive ? 'b:' : 'a:'),
        (r += n.startAt.position.map((i) => ml(i)).join(','))),
      n.endAt &&
        ((r += ', endAt: '),
        (r += n.endAt.inclusive ? 'a:' : 'b:'),
        (r += n.endAt.position.map((i) => ml(i)).join(','))),
      `Target(${r})`
    )
  })(hi(t))}; limitType=${t.limitType})`
}
function rm(t, e) {
  return (
    e.isFoundDocument() &&
    (function (r, i) {
      const s = i.key.path
      return r.collectionGroup !== null
        ? i.key.hasCollectionId(r.collectionGroup) && r.path.isPrefixOf(s)
        : _e.isDocumentKey(r.path)
        ? r.path.isEqual(s)
        : r.path.isImmediateParentOf(s)
    })(t, e) &&
    (function (r, i) {
      for (const s of Fc(r)) if (!s.field.isKeyField() && i.data.field(s.field) === null) return !1
      return !0
    })(t, e) &&
    (function (r, i) {
      for (const s of r.filters) if (!s.matches(i)) return !1
      return !0
    })(t, e) &&
    (function (r, i) {
      return !(
        (r.startAt &&
          !(function (o, a, l) {
            const c = BT(o, a, l)
            return o.inclusive ? c <= 0 : c < 0
          })(r.startAt, Fc(r), i)) ||
        (r.endAt &&
          !(function (o, a, l) {
            const c = BT(o, a, l)
            return o.inclusive ? c >= 0 : c > 0
          })(r.endAt, Fc(r), i))
      )
    })(t, e)
  )
}
function B7(t) {
  return (
    t.collectionGroup ||
    (t.path.length % 2 == 1 ? t.path.lastSegment() : t.path.get(t.path.length - 2))
  )
}
function c2(t) {
  return (e, n) => {
    let r = !1
    for (const i of Fc(t)) {
      const s = U7(i, e, n)
      if (s !== 0) return s
      r = r || i.field.isKeyField()
    }
    return 0
  }
}
function U7(t, e, n) {
  const r = t.field.isKeyField()
    ? _e.comparator(e.key, n.key)
    : (function (s, o, a) {
        const l = o.data.field(s),
          c = a.data.field(s)
        return l !== null && c !== null ? pl(l, c) : Ce()
      })(t.field, e, n)
  switch (t.dir) {
    case 'asc':
      return r
    case 'desc':
      return -1 * r
    default:
      return Ce()
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class jl {
  constructor(e, n) {
    ;(this.mapKeyFn = e), (this.equalsFn = n), (this.inner = {}), (this.innerSize = 0)
  }
  get(e) {
    const n = this.mapKeyFn(e),
      r = this.inner[n]
    if (r !== void 0) {
      for (const [i, s] of r) if (this.equalsFn(i, e)) return s
    }
  }
  has(e) {
    return this.get(e) !== void 0
  }
  set(e, n) {
    const r = this.mapKeyFn(e),
      i = this.inner[r]
    if (i === void 0) return (this.inner[r] = [[e, n]]), void this.innerSize++
    for (let s = 0; s < i.length; s++) if (this.equalsFn(i[s][0], e)) return void (i[s] = [e, n])
    i.push([e, n]), this.innerSize++
  }
  delete(e) {
    const n = this.mapKeyFn(e),
      r = this.inner[n]
    if (r === void 0) return !1
    for (let i = 0; i < r.length; i++)
      if (this.equalsFn(r[i][0], e))
        return r.length === 1 ? delete this.inner[n] : r.splice(i, 1), this.innerSize--, !0
    return !1
  }
  forEach(e) {
    pa(this.inner, (n, r) => {
      for (const [i, s] of r) e(i, s)
    })
  }
  isEmpty() {
    return Zk(this.inner)
  }
  size() {
    return this.innerSize
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const $7 = new Rt(_e.comparator)
function Wi() {
  return $7
}
const u2 = new Rt(_e.comparator)
function fc(...t) {
  let e = u2
  for (const n of t) e = e.insert(n.key, n)
  return e
}
function h2(t) {
  let e = u2
  return t.forEach((n, r) => (e = e.insert(n, r.overlayedDocument))), e
}
function Io() {
  return Bc()
}
function d2() {
  return Bc()
}
function Bc() {
  return new jl(
    (t) => t.toString(),
    (t, e) => t.isEqual(e)
  )
}
const H7 = new Rt(_e.comparator),
  z7 = new En(_e.comparator)
function ze(...t) {
  let e = z7
  for (const n of t) e = e.add(n)
  return e
}
const j7 = new En(et)
function W7() {
  return j7
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function f2(t, e) {
  if (t.useProto3Json) {
    if (isNaN(e)) return { doubleValue: 'NaN' }
    if (e === 1 / 0) return { doubleValue: 'Infinity' }
    if (e === -1 / 0) return { doubleValue: '-Infinity' }
  }
  return { doubleValue: Sf(e) ? '-0' : e }
}
function p2(t) {
  return { integerValue: '' + t }
}
function G7(t, e) {
  return T7(e) ? p2(e) : f2(t, e)
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class im {
  constructor() {
    this._ = void 0
  }
}
function q7(t, e, n) {
  return t instanceof Cf
    ? (function (i, s) {
        const o = {
          fields: {
            __type__: { stringValue: 'server_timestamp' },
            __local_write_time__: { timestampValue: { seconds: i.seconds, nanos: i.nanoseconds } }
          }
        }
        return s && J0(s) && (s = Q0(s)), s && (o.fields.__previous_value__ = s), { mapValue: o }
      })(n, e)
    : t instanceof gl
    ? g2(t, e)
    : t instanceof Au
    ? y2(t, e)
    : (function (i, s) {
        const o = m2(i, s),
          a = zT(o) + zT(i.Ie)
        return f_(o) && f_(i.Ie) ? p2(a) : f2(i.serializer, a)
      })(t, e)
}
function K7(t, e, n) {
  return t instanceof gl ? g2(t, e) : t instanceof Au ? y2(t, e) : n
}
function m2(t, e) {
  return t instanceof Rf
    ? (function (r) {
        return (
          f_(r) ||
          (function (s) {
            return !!s && 'doubleValue' in s
          })(r)
        )
      })(e)
      ? e
      : { integerValue: 0 }
    : null
}
class Cf extends im {}
class gl extends im {
  constructor(e) {
    super(), (this.elements = e)
  }
}
function g2(t, e) {
  const n = _2(e)
  for (const r of t.elements) n.some((i) => _i(i, r)) || n.push(r)
  return { arrayValue: { values: n } }
}
class Au extends im {
  constructor(e) {
    super(), (this.elements = e)
  }
}
function y2(t, e) {
  let n = _2(e)
  for (const r of t.elements) n = n.filter((i) => !_i(i, r))
  return { arrayValue: { values: n } }
}
class Rf extends im {
  constructor(e, n) {
    super(), (this.serializer = e), (this.Ie = n)
  }
}
function zT(t) {
  return Vt(t.integerValue || t.doubleValue)
}
function _2(t) {
  return X0(t) && t.arrayValue.values ? t.arrayValue.values.slice() : []
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Y7 {
  constructor(e, n) {
    ;(this.field = e), (this.transform = n)
  }
}
function J7(t, e) {
  return (
    t.field.isEqual(e.field) &&
    (function (r, i) {
      return (r instanceof gl && i instanceof gl) || (r instanceof Au && i instanceof Au)
        ? fl(r.elements, i.elements, _i)
        : r instanceof Rf && i instanceof Rf
        ? _i(r.Ie, i.Ie)
        : r instanceof Cf && i instanceof Cf
    })(t.transform, e.transform)
  )
}
class Q7 {
  constructor(e, n) {
    ;(this.version = e), (this.transformResults = n)
  }
}
class cr {
  constructor(e, n) {
    ;(this.updateTime = e), (this.exists = n)
  }
  static none() {
    return new cr()
  }
  static exists(e) {
    return new cr(void 0, e)
  }
  static updateTime(e) {
    return new cr(e)
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0
  }
  isEqual(e) {
    return (
      this.exists === e.exists &&
      (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime)
    )
  }
}
function kd(t, e) {
  return t.updateTime !== void 0
    ? e.isFoundDocument() && e.version.isEqual(t.updateTime)
    : t.exists === void 0 || t.exists === e.isFoundDocument()
}
class sm {}
function v2(t, e) {
  if (!t.hasLocalMutations || (e && e.fields.length === 0)) return null
  if (e === null)
    return t.isNoDocument() ? new t1(t.key, cr.none()) : new fh(t.key, t.data, cr.none())
  {
    const n = t.data,
      r = qn.empty()
    let i = new En(vn.comparator)
    for (let s of e.fields)
      if (!i.has(s)) {
        let o = n.field(s)
        o === null && s.length > 1 && ((s = s.popLast()), (o = n.field(s))),
          o === null ? r.delete(s) : r.set(s, o),
          (i = i.add(s))
      }
    return new Xs(t.key, r, new or(i.toArray()), cr.none())
  }
}
function X7(t, e, n) {
  t instanceof fh
    ? (function (i, s, o) {
        const a = i.value.clone(),
          l = WT(i.fieldTransforms, s, o.transformResults)
        a.setAll(l), s.convertToFoundDocument(o.version, a).setHasCommittedMutations()
      })(t, e, n)
    : t instanceof Xs
    ? (function (i, s, o) {
        if (!kd(i.precondition, s)) return void s.convertToUnknownDocument(o.version)
        const a = WT(i.fieldTransforms, s, o.transformResults),
          l = s.data
        l.setAll(b2(i)),
          l.setAll(a),
          s.convertToFoundDocument(o.version, l).setHasCommittedMutations()
      })(t, e, n)
    : (function (i, s, o) {
        s.convertToNoDocument(o.version).setHasCommittedMutations()
      })(0, e, n)
}
function Uc(t, e, n, r) {
  return t instanceof fh
    ? (function (s, o, a, l) {
        if (!kd(s.precondition, o)) return a
        const c = s.value.clone(),
          u = GT(s.fieldTransforms, l, o)
        return c.setAll(u), o.convertToFoundDocument(o.version, c).setHasLocalMutations(), null
      })(t, e, n, r)
    : t instanceof Xs
    ? (function (s, o, a, l) {
        if (!kd(s.precondition, o)) return a
        const c = GT(s.fieldTransforms, l, o),
          u = o.data
        return (
          u.setAll(b2(s)),
          u.setAll(c),
          o.convertToFoundDocument(o.version, u).setHasLocalMutations(),
          a === null
            ? null
            : a.unionWith(s.fieldMask.fields).unionWith(s.fieldTransforms.map((h) => h.field))
        )
      })(t, e, n, r)
    : (function (s, o, a) {
        return kd(s.precondition, o)
          ? (o.convertToNoDocument(o.version).setHasLocalMutations(), null)
          : a
      })(t, e, n)
}
function Z7(t, e) {
  let n = null
  for (const r of t.fieldTransforms) {
    const i = e.data.field(r.field),
      s = m2(r.transform, i || null)
    s != null && (n === null && (n = qn.empty()), n.set(r.field, s))
  }
  return n || null
}
function jT(t, e) {
  return (
    t.type === e.type &&
    !!t.key.isEqual(e.key) &&
    !!t.precondition.isEqual(e.precondition) &&
    !!(function (r, i) {
      return (r === void 0 && i === void 0) || (!(!r || !i) && fl(r, i, (s, o) => J7(s, o)))
    })(t.fieldTransforms, e.fieldTransforms) &&
    (t.type === 0
      ? t.value.isEqual(e.value)
      : t.type !== 1 || (t.data.isEqual(e.data) && t.fieldMask.isEqual(e.fieldMask)))
  )
}
class fh extends sm {
  constructor(e, n, r, i = []) {
    super(),
      (this.key = e),
      (this.value = n),
      (this.precondition = r),
      (this.fieldTransforms = i),
      (this.type = 0)
  }
  getFieldMask() {
    return null
  }
}
class Xs extends sm {
  constructor(e, n, r, i, s = []) {
    super(),
      (this.key = e),
      (this.data = n),
      (this.fieldMask = r),
      (this.precondition = i),
      (this.fieldTransforms = s),
      (this.type = 1)
  }
  getFieldMask() {
    return this.fieldMask
  }
}
function b2(t) {
  const e = new Map()
  return (
    t.fieldMask.fields.forEach((n) => {
      if (!n.isEmpty()) {
        const r = t.data.field(n)
        e.set(n, r)
      }
    }),
    e
  )
}
function WT(t, e, n) {
  const r = new Map()
  mt(t.length === n.length)
  for (let i = 0; i < n.length; i++) {
    const s = t[i],
      o = s.transform,
      a = e.data.field(s.field)
    r.set(s.field, K7(o, a, n[i]))
  }
  return r
}
function GT(t, e, n) {
  const r = new Map()
  for (const i of t) {
    const s = i.transform,
      o = n.data.field(i.field)
    r.set(i.field, q7(s, o, e))
  }
  return r
}
class t1 extends sm {
  constructor(e, n) {
    super(), (this.key = e), (this.precondition = n), (this.type = 2), (this.fieldTransforms = [])
  }
  getFieldMask() {
    return null
  }
}
class eB extends sm {
  constructor(e, n) {
    super(), (this.key = e), (this.precondition = n), (this.type = 3), (this.fieldTransforms = [])
  }
  getFieldMask() {
    return null
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class tB {
  constructor(e, n, r, i) {
    ;(this.batchId = e), (this.localWriteTime = n), (this.baseMutations = r), (this.mutations = i)
  }
  applyToRemoteDocument(e, n) {
    const r = n.mutationResults
    for (let i = 0; i < this.mutations.length; i++) {
      const s = this.mutations[i]
      s.key.isEqual(e.key) && X7(s, e, r[i])
    }
  }
  applyToLocalView(e, n) {
    for (const r of this.baseMutations)
      r.key.isEqual(e.key) && (n = Uc(r, e, n, this.localWriteTime))
    for (const r of this.mutations) r.key.isEqual(e.key) && (n = Uc(r, e, n, this.localWriteTime))
    return n
  }
  applyToLocalDocumentSet(e, n) {
    const r = d2()
    return (
      this.mutations.forEach((i) => {
        const s = e.get(i.key),
          o = s.overlayedDocument
        let a = this.applyToLocalView(o, s.mutatedFields)
        a = n.has(i.key) ? null : a
        const l = v2(o, a)
        l !== null && r.set(i.key, l), o.isValidDocument() || o.convertToNoDocument(Ne.min())
      }),
      r
    )
  }
  keys() {
    return this.mutations.reduce((e, n) => e.add(n.key), ze())
  }
  isEqual(e) {
    return (
      this.batchId === e.batchId &&
      fl(this.mutations, e.mutations, (n, r) => jT(n, r)) &&
      fl(this.baseMutations, e.baseMutations, (n, r) => jT(n, r))
    )
  }
}
class n1 {
  constructor(e, n, r, i) {
    ;(this.batch = e), (this.commitVersion = n), (this.mutationResults = r), (this.docVersions = i)
  }
  static from(e, n, r) {
    mt(e.mutations.length === r.length)
    let i = (function () {
      return H7
    })()
    const s = e.mutations
    for (let o = 0; o < s.length; o++) i = i.insert(s[o].key, r[o].version)
    return new n1(e, n, r, i)
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class nB {
  constructor(e, n) {
    ;(this.largestBatchId = e), (this.mutation = n)
  }
  getKey() {
    return this.mutation.key
  }
  isEqual(e) {
    return e !== null && this.mutation === e.mutation
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class rB {
  constructor(e, n) {
    ;(this.count = e), (this.unchangedNames = n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Dt, Ge
function iB(t) {
  switch (t) {
    default:
      return Ce()
    case V.CANCELLED:
    case V.UNKNOWN:
    case V.DEADLINE_EXCEEDED:
    case V.RESOURCE_EXHAUSTED:
    case V.INTERNAL:
    case V.UNAVAILABLE:
    case V.UNAUTHENTICATED:
      return !1
    case V.INVALID_ARGUMENT:
    case V.NOT_FOUND:
    case V.ALREADY_EXISTS:
    case V.PERMISSION_DENIED:
    case V.FAILED_PRECONDITION:
    case V.ABORTED:
    case V.OUT_OF_RANGE:
    case V.UNIMPLEMENTED:
    case V.DATA_LOSS:
      return !0
  }
}
function E2(t) {
  if (t === void 0) return yi('GRPC error has no .code'), V.UNKNOWN
  switch (t) {
    case Dt.OK:
      return V.OK
    case Dt.CANCELLED:
      return V.CANCELLED
    case Dt.UNKNOWN:
      return V.UNKNOWN
    case Dt.DEADLINE_EXCEEDED:
      return V.DEADLINE_EXCEEDED
    case Dt.RESOURCE_EXHAUSTED:
      return V.RESOURCE_EXHAUSTED
    case Dt.INTERNAL:
      return V.INTERNAL
    case Dt.UNAVAILABLE:
      return V.UNAVAILABLE
    case Dt.UNAUTHENTICATED:
      return V.UNAUTHENTICATED
    case Dt.INVALID_ARGUMENT:
      return V.INVALID_ARGUMENT
    case Dt.NOT_FOUND:
      return V.NOT_FOUND
    case Dt.ALREADY_EXISTS:
      return V.ALREADY_EXISTS
    case Dt.PERMISSION_DENIED:
      return V.PERMISSION_DENIED
    case Dt.FAILED_PRECONDITION:
      return V.FAILED_PRECONDITION
    case Dt.ABORTED:
      return V.ABORTED
    case Dt.OUT_OF_RANGE:
      return V.OUT_OF_RANGE
    case Dt.UNIMPLEMENTED:
      return V.UNIMPLEMENTED
    case Dt.DATA_LOSS:
      return V.DATA_LOSS
    default:
      return Ce()
  }
}
;((Ge = Dt || (Dt = {}))[(Ge.OK = 0)] = 'OK'),
  (Ge[(Ge.CANCELLED = 1)] = 'CANCELLED'),
  (Ge[(Ge.UNKNOWN = 2)] = 'UNKNOWN'),
  (Ge[(Ge.INVALID_ARGUMENT = 3)] = 'INVALID_ARGUMENT'),
  (Ge[(Ge.DEADLINE_EXCEEDED = 4)] = 'DEADLINE_EXCEEDED'),
  (Ge[(Ge.NOT_FOUND = 5)] = 'NOT_FOUND'),
  (Ge[(Ge.ALREADY_EXISTS = 6)] = 'ALREADY_EXISTS'),
  (Ge[(Ge.PERMISSION_DENIED = 7)] = 'PERMISSION_DENIED'),
  (Ge[(Ge.UNAUTHENTICATED = 16)] = 'UNAUTHENTICATED'),
  (Ge[(Ge.RESOURCE_EXHAUSTED = 8)] = 'RESOURCE_EXHAUSTED'),
  (Ge[(Ge.FAILED_PRECONDITION = 9)] = 'FAILED_PRECONDITION'),
  (Ge[(Ge.ABORTED = 10)] = 'ABORTED'),
  (Ge[(Ge.OUT_OF_RANGE = 11)] = 'OUT_OF_RANGE'),
  (Ge[(Ge.UNIMPLEMENTED = 12)] = 'UNIMPLEMENTED'),
  (Ge[(Ge.INTERNAL = 13)] = 'INTERNAL'),
  (Ge[(Ge.UNAVAILABLE = 14)] = 'UNAVAILABLE'),
  (Ge[(Ge.DATA_LOSS = 15)] = 'DATA_LOSS')
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function sB() {
  return new TextEncoder()
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const oB = new Ja([4294967295, 4294967295], 0)
function qT(t) {
  const e = sB().encode(t),
    n = new s7()
  return n.update(e), new Uint8Array(n.digest())
}
function KT(t) {
  const e = new DataView(t.buffer),
    n = e.getUint32(0, !0),
    r = e.getUint32(4, !0),
    i = e.getUint32(8, !0),
    s = e.getUint32(12, !0)
  return [new Ja([n, r], 0), new Ja([i, s], 0)]
}
class r1 {
  constructor(e, n, r) {
    if (((this.bitmap = e), (this.padding = n), (this.hashCount = r), n < 0 || n >= 8))
      throw new pc(`Invalid padding: ${n}`)
    if (r < 0) throw new pc(`Invalid hash count: ${r}`)
    if (e.length > 0 && this.hashCount === 0) throw new pc(`Invalid hash count: ${r}`)
    if (e.length === 0 && n !== 0) throw new pc(`Invalid padding when bitmap length is 0: ${n}`)
    ;(this.Te = 8 * e.length - n), (this.Ee = Ja.fromNumber(this.Te))
  }
  de(e, n, r) {
    let i = e.add(n.multiply(Ja.fromNumber(r)))
    return (
      i.compare(oB) === 1 && (i = new Ja([i.getBits(0), i.getBits(1)], 0)),
      i.modulo(this.Ee).toNumber()
    )
  }
  Ae(e) {
    return (this.bitmap[Math.floor(e / 8)] & (1 << e % 8)) != 0
  }
  mightContain(e) {
    if (this.Te === 0) return !1
    const n = qT(e),
      [r, i] = KT(n)
    for (let s = 0; s < this.hashCount; s++) {
      const o = this.de(r, i, s)
      if (!this.Ae(o)) return !1
    }
    return !0
  }
  static create(e, n, r) {
    const i = e % 8 == 0 ? 0 : 8 - (e % 8),
      s = new Uint8Array(Math.ceil(e / 8)),
      o = new r1(s, i, n)
    return r.forEach((a) => o.insert(a)), o
  }
  insert(e) {
    if (this.Te === 0) return
    const n = qT(e),
      [r, i] = KT(n)
    for (let s = 0; s < this.hashCount; s++) {
      const o = this.de(r, i, s)
      this.Re(o)
    }
  }
  Re(e) {
    const n = Math.floor(e / 8),
      r = e % 8
    this.bitmap[n] |= 1 << r
  }
}
class pc extends Error {
  constructor() {
    super(...arguments), (this.name = 'BloomFilterError')
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class om {
  constructor(e, n, r, i, s) {
    ;(this.snapshotVersion = e),
      (this.targetChanges = n),
      (this.targetMismatches = r),
      (this.documentUpdates = i),
      (this.resolvedLimboDocuments = s)
  }
  static createSynthesizedRemoteEventForCurrentChange(e, n, r) {
    const i = new Map()
    return (
      i.set(e, ph.createSynthesizedTargetChangeForCurrentChange(e, n, r)),
      new om(Ne.min(), i, new Rt(et), Wi(), ze())
    )
  }
}
class ph {
  constructor(e, n, r, i, s) {
    ;(this.resumeToken = e),
      (this.current = n),
      (this.addedDocuments = r),
      (this.modifiedDocuments = i),
      (this.removedDocuments = s)
  }
  static createSynthesizedTargetChangeForCurrentChange(e, n, r) {
    return new ph(r, n, ze(), ze(), ze())
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Od {
  constructor(e, n, r, i) {
    ;(this.Ve = e), (this.removedTargetIds = n), (this.key = r), (this.me = i)
  }
}
class T2 {
  constructor(e, n) {
    ;(this.targetId = e), (this.fe = n)
  }
}
class w2 {
  constructor(e, n, r = xn.EMPTY_BYTE_STRING, i = null) {
    ;(this.state = e), (this.targetIds = n), (this.resumeToken = r), (this.cause = i)
  }
}
class YT {
  constructor() {
    ;(this.ge = 0),
      (this.pe = QT()),
      (this.ye = xn.EMPTY_BYTE_STRING),
      (this.we = !1),
      (this.Se = !0)
  }
  get current() {
    return this.we
  }
  get resumeToken() {
    return this.ye
  }
  get be() {
    return this.ge !== 0
  }
  get De() {
    return this.Se
  }
  Ce(e) {
    e.approximateByteSize() > 0 && ((this.Se = !0), (this.ye = e))
  }
  ve() {
    let e = ze(),
      n = ze(),
      r = ze()
    return (
      this.pe.forEach((i, s) => {
        switch (s) {
          case 0:
            e = e.add(i)
            break
          case 2:
            n = n.add(i)
            break
          case 1:
            r = r.add(i)
            break
          default:
            Ce()
        }
      }),
      new ph(this.ye, this.we, e, n, r)
    )
  }
  Fe() {
    ;(this.Se = !1), (this.pe = QT())
  }
  Me(e, n) {
    ;(this.Se = !0), (this.pe = this.pe.insert(e, n))
  }
  xe(e) {
    ;(this.Se = !0), (this.pe = this.pe.remove(e))
  }
  Oe() {
    this.ge += 1
  }
  Ne() {
    ;(this.ge -= 1), mt(this.ge >= 0)
  }
  Le() {
    ;(this.Se = !0), (this.we = !0)
  }
}
class aB {
  constructor(e) {
    ;(this.Be = e),
      (this.ke = new Map()),
      (this.qe = Wi()),
      (this.Qe = JT()),
      (this.Ke = new Rt(et))
  }
  $e(e) {
    for (const n of e.Ve)
      e.me && e.me.isFoundDocument() ? this.Ue(n, e.me) : this.We(n, e.key, e.me)
    for (const n of e.removedTargetIds) this.We(n, e.key, e.me)
  }
  Ge(e) {
    this.forEachTarget(e, (n) => {
      const r = this.ze(n)
      switch (e.state) {
        case 0:
          this.je(n) && r.Ce(e.resumeToken)
          break
        case 1:
          r.Ne(), r.be || r.Fe(), r.Ce(e.resumeToken)
          break
        case 2:
          r.Ne(), r.be || this.removeTarget(n)
          break
        case 3:
          this.je(n) && (r.Le(), r.Ce(e.resumeToken))
          break
        case 4:
          this.je(n) && (this.He(n), r.Ce(e.resumeToken))
          break
        default:
          Ce()
      }
    })
  }
  forEachTarget(e, n) {
    e.targetIds.length > 0
      ? e.targetIds.forEach(n)
      : this.ke.forEach((r, i) => {
          this.je(i) && n(i)
        })
  }
  Je(e) {
    const n = e.targetId,
      r = e.fe.count,
      i = this.Ye(n)
    if (i) {
      const s = i.target
      if (m_(s))
        if (r === 0) {
          const o = new _e(s.path)
          this.We(n, o, kn.newNoDocument(o, Ne.min()))
        } else mt(r === 1)
      else {
        const o = this.Ze(n)
        if (o !== r) {
          const a = this.Xe(e),
            l = a ? this.et(a, e, o) : 1
          if (l !== 0) {
            this.He(n)
            const c =
              l === 2
                ? 'TargetPurposeExistenceFilterMismatchBloom'
                : 'TargetPurposeExistenceFilterMismatch'
            this.Ke = this.Ke.insert(n, c)
          }
        }
      }
    }
  }
  Xe(e) {
    const n = e.fe.unchangedNames
    if (!n || !n.bits) return null
    const {
      bits: { bitmap: r = '', padding: i = 0 },
      hashCount: s = 0
    } = n
    let o, a
    try {
      o = Zo(r).toUint8Array()
    } catch (l) {
      if (l instanceof e2)
        return (
          dl(
            'Decoding the base64 bloom filter in existence filter failed (' +
              l.message +
              '); ignoring the bloom filter and falling back to full re-query.'
          ),
          null
        )
      throw l
    }
    try {
      a = new r1(o, i, s)
    } catch (l) {
      return dl(l instanceof pc ? 'BloomFilter error: ' : 'Applying bloom filter failed: ', l), null
    }
    return a.Te === 0 ? null : a
  }
  et(e, n, r) {
    return n.fe.count === r - this.rt(e, n.targetId) ? 0 : 2
  }
  rt(e, n) {
    const r = this.Be.getRemoteKeysForTarget(n)
    let i = 0
    return (
      r.forEach((s) => {
        const o = this.Be.nt(),
          a = `projects/${o.projectId}/databases/${
            o.database
          }/documents/${s.path.canonicalString()}`
        e.mightContain(a) || (this.We(n, s, null), i++)
      }),
      i
    )
  }
  it(e) {
    const n = new Map()
    this.ke.forEach((s, o) => {
      const a = this.Ye(o)
      if (a) {
        if (s.current && m_(a.target)) {
          const l = new _e(a.target.path)
          this.qe.get(l) !== null || this.st(o, l) || this.We(o, l, kn.newNoDocument(l, e))
        }
        s.De && (n.set(o, s.ve()), s.Fe())
      }
    })
    let r = ze()
    this.Qe.forEach((s, o) => {
      let a = !0
      o.forEachWhile((l) => {
        const c = this.Ye(l)
        return !c || c.purpose === 'TargetPurposeLimboResolution' || ((a = !1), !1)
      }),
        a && (r = r.add(s))
    }),
      this.qe.forEach((s, o) => o.setReadTime(e))
    const i = new om(e, n, this.Ke, this.qe, r)
    return (this.qe = Wi()), (this.Qe = JT()), (this.Ke = new Rt(et)), i
  }
  Ue(e, n) {
    if (!this.je(e)) return
    const r = this.st(e, n.key) ? 2 : 0
    this.ze(e).Me(n.key, r),
      (this.qe = this.qe.insert(n.key, n)),
      (this.Qe = this.Qe.insert(n.key, this.ot(n.key).add(e)))
  }
  We(e, n, r) {
    if (!this.je(e)) return
    const i = this.ze(e)
    this.st(e, n) ? i.Me(n, 1) : i.xe(n),
      (this.Qe = this.Qe.insert(n, this.ot(n).delete(e))),
      r && (this.qe = this.qe.insert(n, r))
  }
  removeTarget(e) {
    this.ke.delete(e)
  }
  Ze(e) {
    const n = this.ze(e).ve()
    return this.Be.getRemoteKeysForTarget(e).size + n.addedDocuments.size - n.removedDocuments.size
  }
  Oe(e) {
    this.ze(e).Oe()
  }
  ze(e) {
    let n = this.ke.get(e)
    return n || ((n = new YT()), this.ke.set(e, n)), n
  }
  ot(e) {
    let n = this.Qe.get(e)
    return n || ((n = new En(et)), (this.Qe = this.Qe.insert(e, n))), n
  }
  je(e) {
    const n = this.Ye(e) !== null
    return n || ee('WatchChangeAggregator', 'Detected inactive target', e), n
  }
  Ye(e) {
    const n = this.ke.get(e)
    return n && n.be ? null : this.Be._t(e)
  }
  He(e) {
    this.ke.set(e, new YT()),
      this.Be.getRemoteKeysForTarget(e).forEach((n) => {
        this.We(e, n, null)
      })
  }
  st(e, n) {
    return this.Be.getRemoteKeysForTarget(e).has(n)
  }
}
function JT() {
  return new Rt(_e.comparator)
}
function QT() {
  return new Rt(_e.comparator)
}
const lB = { asc: 'ASCENDING', desc: 'DESCENDING' },
  cB = {
    '<': 'LESS_THAN',
    '<=': 'LESS_THAN_OR_EQUAL',
    '>': 'GREATER_THAN',
    '>=': 'GREATER_THAN_OR_EQUAL',
    '==': 'EQUAL',
    '!=': 'NOT_EQUAL',
    'array-contains': 'ARRAY_CONTAINS',
    in: 'IN',
    'not-in': 'NOT_IN',
    'array-contains-any': 'ARRAY_CONTAINS_ANY'
  },
  uB = { and: 'AND', or: 'OR' }
class hB {
  constructor(e, n) {
    ;(this.databaseId = e), (this.useProto3Json = n)
  }
}
function y_(t, e) {
  return t.useProto3Json || Zp(e) ? e : { value: e }
}
function kf(t, e) {
  return t.useProto3Json
    ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, '').replace('Z', '')}.${(
        '000000000' + e.nanoseconds
      ).slice(-9)}Z`
    : { seconds: '' + e.seconds, nanos: e.nanoseconds }
}
function S2(t, e) {
  return t.useProto3Json ? e.toBase64() : e.toUint8Array()
}
function dB(t, e) {
  return kf(t, e.toTimestamp())
}
function di(t) {
  return (
    mt(!!t),
    Ne.fromTimestamp(
      (function (n) {
        const r = Hs(n)
        return new $t(r.seconds, r.nanos)
      })(t)
    )
  )
}
function i1(t, e) {
  return __(t, e).canonicalString()
}
function __(t, e) {
  const n = (function (i) {
    return new At(['projects', i.projectId, 'databases', i.database])
  })(t).child('documents')
  return e === void 0 ? n : n.child(e)
}
function I2(t) {
  const e = At.fromString(t)
  return mt(O2(e)), e
}
function v_(t, e) {
  return i1(t.databaseId, e.path)
}
function fg(t, e) {
  const n = I2(e)
  if (n.get(1) !== t.databaseId.projectId)
    throw new ue(
      V.INVALID_ARGUMENT,
      'Tried to deserialize key from different project: ' +
        n.get(1) +
        ' vs ' +
        t.databaseId.projectId
    )
  if (n.get(3) !== t.databaseId.database)
    throw new ue(
      V.INVALID_ARGUMENT,
      'Tried to deserialize key from different database: ' +
        n.get(3) +
        ' vs ' +
        t.databaseId.database
    )
  return new _e(C2(n))
}
function A2(t, e) {
  return i1(t.databaseId, e)
}
function fB(t) {
  const e = I2(t)
  return e.length === 4 ? At.emptyPath() : C2(e)
}
function b_(t) {
  return new At([
    'projects',
    t.databaseId.projectId,
    'databases',
    t.databaseId.database
  ]).canonicalString()
}
function C2(t) {
  return mt(t.length > 4 && t.get(4) === 'documents'), t.popFirst(5)
}
function XT(t, e, n) {
  return { name: v_(t, e), fields: n.value.mapValue.fields }
}
function pB(t, e) {
  let n
  if ('targetChange' in e) {
    e.targetChange
    const r = (function (c) {
        return c === 'NO_CHANGE'
          ? 0
          : c === 'ADD'
          ? 1
          : c === 'REMOVE'
          ? 2
          : c === 'CURRENT'
          ? 3
          : c === 'RESET'
          ? 4
          : Ce()
      })(e.targetChange.targetChangeType || 'NO_CHANGE'),
      i = e.targetChange.targetIds || [],
      s = (function (c, u) {
        return c.useProto3Json
          ? (mt(u === void 0 || typeof u == 'string'), xn.fromBase64String(u || ''))
          : (mt(u === void 0 || u instanceof Uint8Array), xn.fromUint8Array(u || new Uint8Array()))
      })(t, e.targetChange.resumeToken),
      o = e.targetChange.cause,
      a =
        o &&
        (function (c) {
          const u = c.code === void 0 ? V.UNKNOWN : E2(c.code)
          return new ue(u, c.message || '')
        })(o)
    n = new w2(r, i, s, a || null)
  } else if ('documentChange' in e) {
    e.documentChange
    const r = e.documentChange
    r.document, r.document.name, r.document.updateTime
    const i = fg(t, r.document.name),
      s = di(r.document.updateTime),
      o = r.document.createTime ? di(r.document.createTime) : Ne.min(),
      a = new qn({ mapValue: { fields: r.document.fields } }),
      l = kn.newFoundDocument(i, s, o, a),
      c = r.targetIds || [],
      u = r.removedTargetIds || []
    n = new Od(c, u, l.key, l)
  } else if ('documentDelete' in e) {
    e.documentDelete
    const r = e.documentDelete
    r.document
    const i = fg(t, r.document),
      s = r.readTime ? di(r.readTime) : Ne.min(),
      o = kn.newNoDocument(i, s),
      a = r.removedTargetIds || []
    n = new Od([], a, o.key, o)
  } else if ('documentRemove' in e) {
    e.documentRemove
    const r = e.documentRemove
    r.document
    const i = fg(t, r.document),
      s = r.removedTargetIds || []
    n = new Od([], s, i, null)
  } else {
    if (!('filter' in e)) return Ce()
    {
      e.filter
      const r = e.filter
      r.targetId
      const { count: i = 0, unchangedNames: s } = r,
        o = new rB(i, s),
        a = r.targetId
      n = new T2(a, o)
    }
  }
  return n
}
function mB(t, e) {
  let n
  if (e instanceof fh) n = { update: XT(t, e.key, e.value) }
  else if (e instanceof t1) n = { delete: v_(t, e.key) }
  else if (e instanceof Xs) n = { update: XT(t, e.key, e.data), updateMask: SB(e.fieldMask) }
  else {
    if (!(e instanceof eB)) return Ce()
    n = { verify: v_(t, e.key) }
  }
  return (
    e.fieldTransforms.length > 0 &&
      (n.updateTransforms = e.fieldTransforms.map((r) =>
        (function (s, o) {
          const a = o.transform
          if (a instanceof Cf)
            return { fieldPath: o.field.canonicalString(), setToServerValue: 'REQUEST_TIME' }
          if (a instanceof gl)
            return {
              fieldPath: o.field.canonicalString(),
              appendMissingElements: { values: a.elements }
            }
          if (a instanceof Au)
            return {
              fieldPath: o.field.canonicalString(),
              removeAllFromArray: { values: a.elements }
            }
          if (a instanceof Rf) return { fieldPath: o.field.canonicalString(), increment: a.Ie }
          throw Ce()
        })(0, r)
      )),
    e.precondition.isNone ||
      (n.currentDocument = (function (i, s) {
        return s.updateTime !== void 0
          ? { updateTime: dB(i, s.updateTime) }
          : s.exists !== void 0
          ? { exists: s.exists }
          : Ce()
      })(t, e.precondition)),
    n
  )
}
function gB(t, e) {
  return t && t.length > 0
    ? (mt(e !== void 0),
      t.map((n) =>
        (function (i, s) {
          let o = i.updateTime ? di(i.updateTime) : di(s)
          return o.isEqual(Ne.min()) && (o = di(s)), new Q7(o, i.transformResults || [])
        })(n, e)
      ))
    : []
}
function yB(t, e) {
  return { documents: [A2(t, e.path)] }
}
function _B(t, e) {
  const n = { structuredQuery: {} },
    r = e.path
  let i
  e.collectionGroup !== null
    ? ((i = r),
      (n.structuredQuery.from = [{ collectionId: e.collectionGroup, allDescendants: !0 }]))
    : ((i = r.popLast()), (n.structuredQuery.from = [{ collectionId: r.lastSegment() }])),
    (n.parent = A2(t, i))
  const s = (function (c) {
    if (c.length !== 0) return k2(vi.create(c, 'and'))
  })(e.filters)
  s && (n.structuredQuery.where = s)
  const o = (function (c) {
    if (c.length !== 0)
      return c.map((u) =>
        (function (d) {
          return { field: Ia(d.field), direction: EB(d.dir) }
        })(u)
      )
  })(e.orderBy)
  o && (n.structuredQuery.orderBy = o)
  const a = y_(t, e.limit)
  return (
    a !== null && (n.structuredQuery.limit = a),
    e.startAt &&
      (n.structuredQuery.startAt = (function (c) {
        return { before: c.inclusive, values: c.position }
      })(e.startAt)),
    e.endAt &&
      (n.structuredQuery.endAt = (function (c) {
        return { before: !c.inclusive, values: c.position }
      })(e.endAt)),
    { ut: n, parent: i }
  )
}
function vB(t) {
  let e = fB(t.parent)
  const n = t.structuredQuery,
    r = n.from ? n.from.length : 0
  let i = null
  if (r > 0) {
    mt(r === 1)
    const u = n.from[0]
    u.allDescendants ? (i = u.collectionId) : (e = e.child(u.collectionId))
  }
  let s = []
  n.where &&
    (s = (function (h) {
      const d = R2(h)
      return d instanceof vi && i2(d) ? d.getFilters() : [d]
    })(n.where))
  let o = []
  n.orderBy &&
    (o = (function (h) {
      return h.map((d) =>
        (function (p) {
          return new Af(
            Aa(p.field),
            (function (g) {
              switch (g) {
                case 'ASCENDING':
                  return 'asc'
                case 'DESCENDING':
                  return 'desc'
                default:
                  return
              }
            })(p.direction)
          )
        })(d)
      )
    })(n.orderBy))
  let a = null
  n.limit &&
    (a = (function (h) {
      let d
      return (d = typeof h == 'object' ? h.value : h), Zp(d) ? null : d
    })(n.limit))
  let l = null
  n.startAt &&
    (l = (function (h) {
      const d = !!h.before,
        f = h.values || []
      return new If(f, d)
    })(n.startAt))
  let c = null
  return (
    n.endAt &&
      (c = (function (h) {
        const d = !h.before,
          f = h.values || []
        return new If(f, d)
      })(n.endAt)),
    L7(e, i, o, s, a, 'F', l, c)
  )
}
function bB(t, e) {
  const n = (function (i) {
    switch (i) {
      case 'TargetPurposeListen':
        return null
      case 'TargetPurposeExistenceFilterMismatch':
        return 'existence-filter-mismatch'
      case 'TargetPurposeExistenceFilterMismatchBloom':
        return 'existence-filter-mismatch-bloom'
      case 'TargetPurposeLimboResolution':
        return 'limbo-document'
      default:
        return Ce()
    }
  })(e.purpose)
  return n == null ? null : { 'goog-listen-tags': n }
}
function R2(t) {
  return t.unaryFilter !== void 0
    ? (function (n) {
        switch (n.unaryFilter.op) {
          case 'IS_NAN':
            const r = Aa(n.unaryFilter.field)
            return jt.create(r, '==', { doubleValue: NaN })
          case 'IS_NULL':
            const i = Aa(n.unaryFilter.field)
            return jt.create(i, '==', { nullValue: 'NULL_VALUE' })
          case 'IS_NOT_NAN':
            const s = Aa(n.unaryFilter.field)
            return jt.create(s, '!=', { doubleValue: NaN })
          case 'IS_NOT_NULL':
            const o = Aa(n.unaryFilter.field)
            return jt.create(o, '!=', { nullValue: 'NULL_VALUE' })
          default:
            return Ce()
        }
      })(t)
    : t.fieldFilter !== void 0
    ? (function (n) {
        return jt.create(
          Aa(n.fieldFilter.field),
          (function (i) {
            switch (i) {
              case 'EQUAL':
                return '=='
              case 'NOT_EQUAL':
                return '!='
              case 'GREATER_THAN':
                return '>'
              case 'GREATER_THAN_OR_EQUAL':
                return '>='
              case 'LESS_THAN':
                return '<'
              case 'LESS_THAN_OR_EQUAL':
                return '<='
              case 'ARRAY_CONTAINS':
                return 'array-contains'
              case 'IN':
                return 'in'
              case 'NOT_IN':
                return 'not-in'
              case 'ARRAY_CONTAINS_ANY':
                return 'array-contains-any'
              default:
                return Ce()
            }
          })(n.fieldFilter.op),
          n.fieldFilter.value
        )
      })(t)
    : t.compositeFilter !== void 0
    ? (function (n) {
        return vi.create(
          n.compositeFilter.filters.map((r) => R2(r)),
          (function (i) {
            switch (i) {
              case 'AND':
                return 'and'
              case 'OR':
                return 'or'
              default:
                return Ce()
            }
          })(n.compositeFilter.op)
        )
      })(t)
    : Ce()
}
function EB(t) {
  return lB[t]
}
function TB(t) {
  return cB[t]
}
function wB(t) {
  return uB[t]
}
function Ia(t) {
  return { fieldPath: t.canonicalString() }
}
function Aa(t) {
  return vn.fromServerFormat(t.fieldPath)
}
function k2(t) {
  return t instanceof jt
    ? (function (n) {
        if (n.op === '==') {
          if (FT(n.value)) return { unaryFilter: { field: Ia(n.field), op: 'IS_NAN' } }
          if (VT(n.value)) return { unaryFilter: { field: Ia(n.field), op: 'IS_NULL' } }
        } else if (n.op === '!=') {
          if (FT(n.value)) return { unaryFilter: { field: Ia(n.field), op: 'IS_NOT_NAN' } }
          if (VT(n.value)) return { unaryFilter: { field: Ia(n.field), op: 'IS_NOT_NULL' } }
        }
        return { fieldFilter: { field: Ia(n.field), op: TB(n.op), value: n.value } }
      })(t)
    : t instanceof vi
    ? (function (n) {
        const r = n.getFilters().map((i) => k2(i))
        return r.length === 1 ? r[0] : { compositeFilter: { op: wB(n.op), filters: r } }
      })(t)
    : Ce()
}
function SB(t) {
  const e = []
  return t.fields.forEach((n) => e.push(n.canonicalString())), { fieldPaths: e }
}
function O2(t) {
  return t.length >= 4 && t.get(0) === 'projects' && t.get(2) === 'databases'
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ts {
  constructor(e, n, r, i, s = Ne.min(), o = Ne.min(), a = xn.EMPTY_BYTE_STRING, l = null) {
    ;(this.target = e),
      (this.targetId = n),
      (this.purpose = r),
      (this.sequenceNumber = i),
      (this.snapshotVersion = s),
      (this.lastLimboFreeSnapshotVersion = o),
      (this.resumeToken = a),
      (this.expectedCount = l)
  }
  withSequenceNumber(e) {
    return new Ts(
      this.target,
      this.targetId,
      this.purpose,
      e,
      this.snapshotVersion,
      this.lastLimboFreeSnapshotVersion,
      this.resumeToken,
      this.expectedCount
    )
  }
  withResumeToken(e, n) {
    return new Ts(
      this.target,
      this.targetId,
      this.purpose,
      this.sequenceNumber,
      n,
      this.lastLimboFreeSnapshotVersion,
      e,
      null
    )
  }
  withExpectedCount(e) {
    return new Ts(
      this.target,
      this.targetId,
      this.purpose,
      this.sequenceNumber,
      this.snapshotVersion,
      this.lastLimboFreeSnapshotVersion,
      this.resumeToken,
      e
    )
  }
  withLastLimboFreeSnapshotVersion(e) {
    return new Ts(
      this.target,
      this.targetId,
      this.purpose,
      this.sequenceNumber,
      this.snapshotVersion,
      e,
      this.resumeToken,
      this.expectedCount
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class IB {
  constructor(e) {
    this.ct = e
  }
}
function AB(t) {
  const e = vB({ parent: t.parent, structuredQuery: t.structuredQuery })
  return t.limitType === 'LAST' ? g_(e, e.limit, 'L') : e
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class CB {
  constructor() {
    this._n = new RB()
  }
  addToCollectionParentIndex(e, n) {
    return this._n.add(n), L.resolve()
  }
  getCollectionParents(e, n) {
    return L.resolve(this._n.getEntries(n))
  }
  addFieldIndex(e, n) {
    return L.resolve()
  }
  deleteFieldIndex(e, n) {
    return L.resolve()
  }
  deleteAllFieldIndexes(e) {
    return L.resolve()
  }
  createTargetIndexes(e, n) {
    return L.resolve()
  }
  getDocumentsMatchingTarget(e, n) {
    return L.resolve(null)
  }
  getIndexType(e, n) {
    return L.resolve(0)
  }
  getFieldIndexes(e, n) {
    return L.resolve([])
  }
  getNextCollectionGroupToUpdate(e) {
    return L.resolve(null)
  }
  getMinOffset(e, n) {
    return L.resolve($s.min())
  }
  getMinOffsetFromCollectionGroup(e, n) {
    return L.resolve($s.min())
  }
  updateCollectionGroup(e, n, r) {
    return L.resolve()
  }
  updateIndexEntries(e, n) {
    return L.resolve()
  }
}
class RB {
  constructor() {
    this.index = {}
  }
  add(e) {
    const n = e.lastSegment(),
      r = e.popLast(),
      i = this.index[n] || new En(At.comparator),
      s = !i.has(r)
    return (this.index[n] = i.add(r)), s
  }
  has(e) {
    const n = e.lastSegment(),
      r = e.popLast(),
      i = this.index[n]
    return i && i.has(r)
  }
  getEntries(e) {
    return (this.index[e] || new En(At.comparator)).toArray()
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class yl {
  constructor(e) {
    this.On = e
  }
  next() {
    return (this.On += 2), this.On
  }
  static Nn() {
    return new yl(0)
  }
  static Ln() {
    return new yl(-1)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class kB {
  constructor() {
    ;(this.changes = new jl(
      (e) => e.toString(),
      (e, n) => e.isEqual(n)
    )),
      (this.changesApplied = !1)
  }
  addEntry(e) {
    this.assertNotApplied(), this.changes.set(e.key, e)
  }
  removeEntry(e, n) {
    this.assertNotApplied(), this.changes.set(e, kn.newInvalidDocument(e).setReadTime(n))
  }
  getEntry(e, n) {
    this.assertNotApplied()
    const r = this.changes.get(n)
    return r !== void 0 ? L.resolve(r) : this.getFromCache(e, n)
  }
  getEntries(e, n) {
    return this.getAllFromCache(e, n)
  }
  apply(e) {
    return this.assertNotApplied(), (this.changesApplied = !0), this.applyChanges(e)
  }
  assertNotApplied() {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class OB {
  constructor(e, n) {
    ;(this.overlayedDocument = e), (this.mutatedFields = n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class NB {
  constructor(e, n, r, i) {
    ;(this.remoteDocumentCache = e),
      (this.mutationQueue = n),
      (this.documentOverlayCache = r),
      (this.indexManager = i)
  }
  getDocument(e, n) {
    let r = null
    return this.documentOverlayCache
      .getOverlay(e, n)
      .next((i) => ((r = i), this.remoteDocumentCache.getEntry(e, n)))
      .next((i) => (r !== null && Uc(r.mutation, i, or.empty(), $t.now()), i))
  }
  getDocuments(e, n) {
    return this.remoteDocumentCache
      .getEntries(e, n)
      .next((r) => this.getLocalViewOfDocuments(e, r, ze()).next(() => r))
  }
  getLocalViewOfDocuments(e, n, r = ze()) {
    const i = Io()
    return this.populateOverlays(e, i, n).next(() =>
      this.computeViews(e, n, i, r).next((s) => {
        let o = fc()
        return (
          s.forEach((a, l) => {
            o = o.insert(a, l.overlayedDocument)
          }),
          o
        )
      })
    )
  }
  getOverlayedDocuments(e, n) {
    const r = Io()
    return this.populateOverlays(e, r, n).next(() => this.computeViews(e, n, r, ze()))
  }
  populateOverlays(e, n, r) {
    const i = []
    return (
      r.forEach((s) => {
        n.has(s) || i.push(s)
      }),
      this.documentOverlayCache.getOverlays(e, i).next((s) => {
        s.forEach((o, a) => {
          n.set(o, a)
        })
      })
    )
  }
  computeViews(e, n, r, i) {
    let s = Wi()
    const o = Bc(),
      a = (function () {
        return Bc()
      })()
    return (
      n.forEach((l, c) => {
        const u = r.get(c.key)
        i.has(c.key) && (u === void 0 || u.mutation instanceof Xs)
          ? (s = s.insert(c.key, c))
          : u !== void 0
          ? (o.set(c.key, u.mutation.getFieldMask()),
            Uc(u.mutation, c, u.mutation.getFieldMask(), $t.now()))
          : o.set(c.key, or.empty())
      }),
      this.recalculateAndSaveOverlays(e, s).next(
        (l) => (
          l.forEach((c, u) => o.set(c, u)),
          n.forEach((c, u) => {
            var h
            return a.set(c, new OB(u, (h = o.get(c)) !== null && h !== void 0 ? h : null))
          }),
          a
        )
      )
    )
  }
  recalculateAndSaveOverlays(e, n) {
    const r = Bc()
    let i = new Rt((o, a) => o - a),
      s = ze()
    return this.mutationQueue
      .getAllMutationBatchesAffectingDocumentKeys(e, n)
      .next((o) => {
        for (const a of o)
          a.keys().forEach((l) => {
            const c = n.get(l)
            if (c === null) return
            let u = r.get(l) || or.empty()
            ;(u = a.applyToLocalView(c, u)), r.set(l, u)
            const h = (i.get(a.batchId) || ze()).add(l)
            i = i.insert(a.batchId, h)
          })
      })
      .next(() => {
        const o = [],
          a = i.getReverseIterator()
        for (; a.hasNext(); ) {
          const l = a.getNext(),
            c = l.key,
            u = l.value,
            h = d2()
          u.forEach((d) => {
            if (!s.has(d)) {
              const f = v2(n.get(d), r.get(d))
              f !== null && h.set(d, f), (s = s.add(d))
            }
          }),
            o.push(this.documentOverlayCache.saveOverlays(e, c, h))
        }
        return L.waitFor(o)
      })
      .next(() => r)
  }
  recalculateAndSaveOverlaysForDocumentKeys(e, n) {
    return this.remoteDocumentCache
      .getEntries(e, n)
      .next((r) => this.recalculateAndSaveOverlays(e, r))
  }
  getDocumentsMatchingQuery(e, n, r, i) {
    return (function (o) {
      return _e.isDocumentKey(o.path) && o.collectionGroup === null && o.filters.length === 0
    })(n)
      ? this.getDocumentsMatchingDocumentQuery(e, n.path)
      : V7(n)
      ? this.getDocumentsMatchingCollectionGroupQuery(e, n, r, i)
      : this.getDocumentsMatchingCollectionQuery(e, n, r, i)
  }
  getNextDocuments(e, n, r, i) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(e, n, r, i).next((s) => {
      const o =
        i - s.size > 0
          ? this.documentOverlayCache.getOverlaysForCollectionGroup(
              e,
              n,
              r.largestBatchId,
              i - s.size
            )
          : L.resolve(Io())
      let a = -1,
        l = s
      return o.next((c) =>
        L.forEach(
          c,
          (u, h) => (
            a < h.largestBatchId && (a = h.largestBatchId),
            s.get(u)
              ? L.resolve()
              : this.remoteDocumentCache.getEntry(e, u).next((d) => {
                  l = l.insert(u, d)
                })
          )
        )
          .next(() => this.populateOverlays(e, c, s))
          .next(() => this.computeViews(e, l, c, ze()))
          .next((u) => ({ batchId: a, changes: h2(u) }))
      )
    })
  }
  getDocumentsMatchingDocumentQuery(e, n) {
    return this.getDocument(e, new _e(n)).next((r) => {
      let i = fc()
      return r.isFoundDocument() && (i = i.insert(r.key, r)), i
    })
  }
  getDocumentsMatchingCollectionGroupQuery(e, n, r, i) {
    const s = n.collectionGroup
    let o = fc()
    return this.indexManager.getCollectionParents(e, s).next((a) =>
      L.forEach(a, (l) => {
        const c = (function (h, d) {
          return new em(
            d,
            null,
            h.explicitOrderBy.slice(),
            h.filters.slice(),
            h.limit,
            h.limitType,
            h.startAt,
            h.endAt
          )
        })(n, l.child(s))
        return this.getDocumentsMatchingCollectionQuery(e, c, r, i).next((u) => {
          u.forEach((h, d) => {
            o = o.insert(h, d)
          })
        })
      }).next(() => o)
    )
  }
  getDocumentsMatchingCollectionQuery(e, n, r, i) {
    let s
    return this.documentOverlayCache
      .getOverlaysForCollection(e, n.path, r.largestBatchId)
      .next((o) => ((s = o), this.remoteDocumentCache.getDocumentsMatchingQuery(e, n, r, s, i)))
      .next((o) => {
        s.forEach((l, c) => {
          const u = c.getKey()
          o.get(u) === null && (o = o.insert(u, kn.newInvalidDocument(u)))
        })
        let a = fc()
        return (
          o.forEach((l, c) => {
            const u = s.get(l)
            u !== void 0 && Uc(u.mutation, c, or.empty(), $t.now()),
              rm(n, c) && (a = a.insert(l, c))
          }),
          a
        )
      })
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class MB {
  constructor(e) {
    ;(this.serializer = e), (this.cr = new Map()), (this.lr = new Map())
  }
  getBundleMetadata(e, n) {
    return L.resolve(this.cr.get(n))
  }
  saveBundleMetadata(e, n) {
    return (
      this.cr.set(
        n.id,
        (function (i) {
          return { id: i.id, version: i.version, createTime: di(i.createTime) }
        })(n)
      ),
      L.resolve()
    )
  }
  getNamedQuery(e, n) {
    return L.resolve(this.lr.get(n))
  }
  saveNamedQuery(e, n) {
    return (
      this.lr.set(
        n.name,
        (function (i) {
          return { name: i.name, query: AB(i.bundledQuery), readTime: di(i.readTime) }
        })(n)
      ),
      L.resolve()
    )
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class PB {
  constructor() {
    ;(this.overlays = new Rt(_e.comparator)), (this.hr = new Map())
  }
  getOverlay(e, n) {
    return L.resolve(this.overlays.get(n))
  }
  getOverlays(e, n) {
    const r = Io()
    return L.forEach(n, (i) =>
      this.getOverlay(e, i).next((s) => {
        s !== null && r.set(i, s)
      })
    ).next(() => r)
  }
  saveOverlays(e, n, r) {
    return (
      r.forEach((i, s) => {
        this.ht(e, n, s)
      }),
      L.resolve()
    )
  }
  removeOverlaysForBatchId(e, n, r) {
    const i = this.hr.get(r)
    return (
      i !== void 0 &&
        (i.forEach((s) => (this.overlays = this.overlays.remove(s))), this.hr.delete(r)),
      L.resolve()
    )
  }
  getOverlaysForCollection(e, n, r) {
    const i = Io(),
      s = n.length + 1,
      o = new _e(n.child('')),
      a = this.overlays.getIteratorFrom(o)
    for (; a.hasNext(); ) {
      const l = a.getNext().value,
        c = l.getKey()
      if (!n.isPrefixOf(c.path)) break
      c.path.length === s && l.largestBatchId > r && i.set(l.getKey(), l)
    }
    return L.resolve(i)
  }
  getOverlaysForCollectionGroup(e, n, r, i) {
    let s = new Rt((c, u) => c - u)
    const o = this.overlays.getIterator()
    for (; o.hasNext(); ) {
      const c = o.getNext().value
      if (c.getKey().getCollectionGroup() === n && c.largestBatchId > r) {
        let u = s.get(c.largestBatchId)
        u === null && ((u = Io()), (s = s.insert(c.largestBatchId, u))), u.set(c.getKey(), c)
      }
    }
    const a = Io(),
      l = s.getIterator()
    for (; l.hasNext() && (l.getNext().value.forEach((c, u) => a.set(c, u)), !(a.size() >= i)); );
    return L.resolve(a)
  }
  ht(e, n, r) {
    const i = this.overlays.get(r.key)
    if (i !== null) {
      const o = this.hr.get(i.largestBatchId).delete(r.key)
      this.hr.set(i.largestBatchId, o)
    }
    this.overlays = this.overlays.insert(r.key, new nB(n, r))
    let s = this.hr.get(n)
    s === void 0 && ((s = ze()), this.hr.set(n, s)), this.hr.set(n, s.add(r.key))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class s1 {
  constructor() {
    ;(this.Pr = new En(Xt.Ir)), (this.Tr = new En(Xt.Er))
  }
  isEmpty() {
    return this.Pr.isEmpty()
  }
  addReference(e, n) {
    const r = new Xt(e, n)
    ;(this.Pr = this.Pr.add(r)), (this.Tr = this.Tr.add(r))
  }
  dr(e, n) {
    e.forEach((r) => this.addReference(r, n))
  }
  removeReference(e, n) {
    this.Ar(new Xt(e, n))
  }
  Rr(e, n) {
    e.forEach((r) => this.removeReference(r, n))
  }
  Vr(e) {
    const n = new _e(new At([])),
      r = new Xt(n, e),
      i = new Xt(n, e + 1),
      s = []
    return (
      this.Tr.forEachInRange([r, i], (o) => {
        this.Ar(o), s.push(o.key)
      }),
      s
    )
  }
  mr() {
    this.Pr.forEach((e) => this.Ar(e))
  }
  Ar(e) {
    ;(this.Pr = this.Pr.delete(e)), (this.Tr = this.Tr.delete(e))
  }
  gr(e) {
    const n = new _e(new At([])),
      r = new Xt(n, e),
      i = new Xt(n, e + 1)
    let s = ze()
    return (
      this.Tr.forEachInRange([r, i], (o) => {
        s = s.add(o.key)
      }),
      s
    )
  }
  containsKey(e) {
    const n = new Xt(e, 0),
      r = this.Pr.firstAfterOrEqual(n)
    return r !== null && e.isEqual(r.key)
  }
}
class Xt {
  constructor(e, n) {
    ;(this.key = e), (this.pr = n)
  }
  static Ir(e, n) {
    return _e.comparator(e.key, n.key) || et(e.pr, n.pr)
  }
  static Er(e, n) {
    return et(e.pr, n.pr) || _e.comparator(e.key, n.key)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class xB {
  constructor(e, n) {
    ;(this.indexManager = e),
      (this.referenceDelegate = n),
      (this.mutationQueue = []),
      (this.yr = 1),
      (this.wr = new En(Xt.Ir))
  }
  checkEmpty(e) {
    return L.resolve(this.mutationQueue.length === 0)
  }
  addMutationBatch(e, n, r, i) {
    const s = this.yr
    this.yr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1]
    const o = new tB(s, n, r, i)
    this.mutationQueue.push(o)
    for (const a of i)
      (this.wr = this.wr.add(new Xt(a.key, s))),
        this.indexManager.addToCollectionParentIndex(e, a.key.path.popLast())
    return L.resolve(o)
  }
  lookupMutationBatch(e, n) {
    return L.resolve(this.Sr(n))
  }
  getNextMutationBatchAfterBatchId(e, n) {
    const r = n + 1,
      i = this.br(r),
      s = i < 0 ? 0 : i
    return L.resolve(this.mutationQueue.length > s ? this.mutationQueue[s] : null)
  }
  getHighestUnacknowledgedBatchId() {
    return L.resolve(this.mutationQueue.length === 0 ? -1 : this.yr - 1)
  }
  getAllMutationBatches(e) {
    return L.resolve(this.mutationQueue.slice())
  }
  getAllMutationBatchesAffectingDocumentKey(e, n) {
    const r = new Xt(n, 0),
      i = new Xt(n, Number.POSITIVE_INFINITY),
      s = []
    return (
      this.wr.forEachInRange([r, i], (o) => {
        const a = this.Sr(o.pr)
        s.push(a)
      }),
      L.resolve(s)
    )
  }
  getAllMutationBatchesAffectingDocumentKeys(e, n) {
    let r = new En(et)
    return (
      n.forEach((i) => {
        const s = new Xt(i, 0),
          o = new Xt(i, Number.POSITIVE_INFINITY)
        this.wr.forEachInRange([s, o], (a) => {
          r = r.add(a.pr)
        })
      }),
      L.resolve(this.Dr(r))
    )
  }
  getAllMutationBatchesAffectingQuery(e, n) {
    const r = n.path,
      i = r.length + 1
    let s = r
    _e.isDocumentKey(s) || (s = s.child(''))
    const o = new Xt(new _e(s), 0)
    let a = new En(et)
    return (
      this.wr.forEachWhile((l) => {
        const c = l.key.path
        return !!r.isPrefixOf(c) && (c.length === i && (a = a.add(l.pr)), !0)
      }, o),
      L.resolve(this.Dr(a))
    )
  }
  Dr(e) {
    const n = []
    return (
      e.forEach((r) => {
        const i = this.Sr(r)
        i !== null && n.push(i)
      }),
      n
    )
  }
  removeMutationBatch(e, n) {
    mt(this.Cr(n.batchId, 'removed') === 0), this.mutationQueue.shift()
    let r = this.wr
    return L.forEach(n.mutations, (i) => {
      const s = new Xt(i.key, n.batchId)
      return (r = r.delete(s)), this.referenceDelegate.markPotentiallyOrphaned(e, i.key)
    }).next(() => {
      this.wr = r
    })
  }
  Mn(e) {}
  containsKey(e, n) {
    const r = new Xt(n, 0),
      i = this.wr.firstAfterOrEqual(r)
    return L.resolve(n.isEqual(i && i.key))
  }
  performConsistencyCheck(e) {
    return this.mutationQueue.length, L.resolve()
  }
  Cr(e, n) {
    return this.br(e)
  }
  br(e) {
    return this.mutationQueue.length === 0 ? 0 : e - this.mutationQueue[0].batchId
  }
  Sr(e) {
    const n = this.br(e)
    return n < 0 || n >= this.mutationQueue.length ? null : this.mutationQueue[n]
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class DB {
  constructor(e) {
    ;(this.vr = e),
      (this.docs = (function () {
        return new Rt(_e.comparator)
      })()),
      (this.size = 0)
  }
  setIndexManager(e) {
    this.indexManager = e
  }
  addEntry(e, n) {
    const r = n.key,
      i = this.docs.get(r),
      s = i ? i.size : 0,
      o = this.vr(n)
    return (
      (this.docs = this.docs.insert(r, { document: n.mutableCopy(), size: o })),
      (this.size += o - s),
      this.indexManager.addToCollectionParentIndex(e, r.path.popLast())
    )
  }
  removeEntry(e) {
    const n = this.docs.get(e)
    n && ((this.docs = this.docs.remove(e)), (this.size -= n.size))
  }
  getEntry(e, n) {
    const r = this.docs.get(n)
    return L.resolve(r ? r.document.mutableCopy() : kn.newInvalidDocument(n))
  }
  getEntries(e, n) {
    let r = Wi()
    return (
      n.forEach((i) => {
        const s = this.docs.get(i)
        r = r.insert(i, s ? s.document.mutableCopy() : kn.newInvalidDocument(i))
      }),
      L.resolve(r)
    )
  }
  getDocumentsMatchingQuery(e, n, r, i) {
    let s = Wi()
    const o = n.path,
      a = new _e(o.child('')),
      l = this.docs.getIteratorFrom(a)
    for (; l.hasNext(); ) {
      const {
        key: c,
        value: { document: u }
      } = l.getNext()
      if (!o.isPrefixOf(c.path)) break
      c.path.length > o.length + 1 ||
        y7(g7(u), r) <= 0 ||
        ((i.has(u.key) || rm(n, u)) && (s = s.insert(u.key, u.mutableCopy())))
    }
    return L.resolve(s)
  }
  getAllFromCollectionGroup(e, n, r, i) {
    Ce()
  }
  Fr(e, n) {
    return L.forEach(this.docs, (r) => n(r))
  }
  newChangeBuffer(e) {
    return new LB(this)
  }
  getSize(e) {
    return L.resolve(this.size)
  }
}
class LB extends kB {
  constructor(e) {
    super(), (this.ar = e)
  }
  applyChanges(e) {
    const n = []
    return (
      this.changes.forEach((r, i) => {
        i.isValidDocument() ? n.push(this.ar.addEntry(e, i)) : this.ar.removeEntry(r)
      }),
      L.waitFor(n)
    )
  }
  getFromCache(e, n) {
    return this.ar.getEntry(e, n)
  }
  getAllFromCache(e, n) {
    return this.ar.getEntries(e, n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class VB {
  constructor(e) {
    ;(this.persistence = e),
      (this.Mr = new jl((n) => Z0(n), e1)),
      (this.lastRemoteSnapshotVersion = Ne.min()),
      (this.highestTargetId = 0),
      (this.Or = 0),
      (this.Nr = new s1()),
      (this.targetCount = 0),
      (this.Lr = yl.Nn())
  }
  forEachTarget(e, n) {
    return this.Mr.forEach((r, i) => n(i)), L.resolve()
  }
  getLastRemoteSnapshotVersion(e) {
    return L.resolve(this.lastRemoteSnapshotVersion)
  }
  getHighestSequenceNumber(e) {
    return L.resolve(this.Or)
  }
  allocateTargetId(e) {
    return (this.highestTargetId = this.Lr.next()), L.resolve(this.highestTargetId)
  }
  setTargetsMetadata(e, n, r) {
    return r && (this.lastRemoteSnapshotVersion = r), n > this.Or && (this.Or = n), L.resolve()
  }
  qn(e) {
    this.Mr.set(e.target, e)
    const n = e.targetId
    n > this.highestTargetId && ((this.Lr = new yl(n)), (this.highestTargetId = n)),
      e.sequenceNumber > this.Or && (this.Or = e.sequenceNumber)
  }
  addTargetData(e, n) {
    return this.qn(n), (this.targetCount += 1), L.resolve()
  }
  updateTargetData(e, n) {
    return this.qn(n), L.resolve()
  }
  removeTargetData(e, n) {
    return this.Mr.delete(n.target), this.Nr.Vr(n.targetId), (this.targetCount -= 1), L.resolve()
  }
  removeTargets(e, n, r) {
    let i = 0
    const s = []
    return (
      this.Mr.forEach((o, a) => {
        a.sequenceNumber <= n &&
          r.get(a.targetId) === null &&
          (this.Mr.delete(o), s.push(this.removeMatchingKeysForTargetId(e, a.targetId)), i++)
      }),
      L.waitFor(s).next(() => i)
    )
  }
  getTargetCount(e) {
    return L.resolve(this.targetCount)
  }
  getTargetData(e, n) {
    const r = this.Mr.get(n) || null
    return L.resolve(r)
  }
  addMatchingKeys(e, n, r) {
    return this.Nr.dr(n, r), L.resolve()
  }
  removeMatchingKeys(e, n, r) {
    this.Nr.Rr(n, r)
    const i = this.persistence.referenceDelegate,
      s = []
    return (
      i &&
        n.forEach((o) => {
          s.push(i.markPotentiallyOrphaned(e, o))
        }),
      L.waitFor(s)
    )
  }
  removeMatchingKeysForTargetId(e, n) {
    return this.Nr.Vr(n), L.resolve()
  }
  getMatchingKeysForTargetId(e, n) {
    const r = this.Nr.gr(n)
    return L.resolve(r)
  }
  containsKey(e, n) {
    return L.resolve(this.Nr.containsKey(n))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class FB {
  constructor(e, n) {
    ;(this.Br = {}),
      (this.overlays = {}),
      (this.kr = new Y0(0)),
      (this.qr = !1),
      (this.qr = !0),
      (this.referenceDelegate = e(this)),
      (this.Qr = new VB(this)),
      (this.indexManager = new CB()),
      (this.remoteDocumentCache = (function (i) {
        return new DB(i)
      })((r) => this.referenceDelegate.Kr(r))),
      (this.serializer = new IB(n)),
      (this.$r = new MB(this.serializer))
  }
  start() {
    return Promise.resolve()
  }
  shutdown() {
    return (this.qr = !1), Promise.resolve()
  }
  get started() {
    return this.qr
  }
  setDatabaseDeletedListener() {}
  setNetworkEnabled() {}
  getIndexManager(e) {
    return this.indexManager
  }
  getDocumentOverlayCache(e) {
    let n = this.overlays[e.toKey()]
    return n || ((n = new PB()), (this.overlays[e.toKey()] = n)), n
  }
  getMutationQueue(e, n) {
    let r = this.Br[e.toKey()]
    return r || ((r = new xB(n, this.referenceDelegate)), (this.Br[e.toKey()] = r)), r
  }
  getTargetCache() {
    return this.Qr
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache
  }
  getBundleCache() {
    return this.$r
  }
  runTransaction(e, n, r) {
    ee('MemoryPersistence', 'Starting transaction:', e)
    const i = new BB(this.kr.next())
    return (
      this.referenceDelegate.Ur(),
      r(i)
        .next((s) => this.referenceDelegate.Wr(i).next(() => s))
        .toPromise()
        .then((s) => (i.raiseOnCommittedEvent(), s))
    )
  }
  Gr(e, n) {
    return L.or(Object.values(this.Br).map((r) => () => r.containsKey(e, n)))
  }
}
class BB extends v7 {
  constructor(e) {
    super(), (this.currentSequenceNumber = e)
  }
}
class o1 {
  constructor(e) {
    ;(this.persistence = e), (this.zr = new s1()), (this.jr = null)
  }
  static Hr(e) {
    return new o1(e)
  }
  get Jr() {
    if (this.jr) return this.jr
    throw Ce()
  }
  addReference(e, n, r) {
    return this.zr.addReference(r, n), this.Jr.delete(r.toString()), L.resolve()
  }
  removeReference(e, n, r) {
    return this.zr.removeReference(r, n), this.Jr.add(r.toString()), L.resolve()
  }
  markPotentiallyOrphaned(e, n) {
    return this.Jr.add(n.toString()), L.resolve()
  }
  removeTarget(e, n) {
    this.zr.Vr(n.targetId).forEach((i) => this.Jr.add(i.toString()))
    const r = this.persistence.getTargetCache()
    return r
      .getMatchingKeysForTargetId(e, n.targetId)
      .next((i) => {
        i.forEach((s) => this.Jr.add(s.toString()))
      })
      .next(() => r.removeTargetData(e, n))
  }
  Ur() {
    this.jr = new Set()
  }
  Wr(e) {
    const n = this.persistence.getRemoteDocumentCache().newChangeBuffer()
    return L.forEach(this.Jr, (r) => {
      const i = _e.fromPath(r)
      return this.Yr(e, i).next((s) => {
        s || n.removeEntry(i, Ne.min())
      })
    }).next(() => ((this.jr = null), n.apply(e)))
  }
  updateLimboDocument(e, n) {
    return this.Yr(e, n).next((r) => {
      r ? this.Jr.delete(n.toString()) : this.Jr.add(n.toString())
    })
  }
  Kr(e) {
    return 0
  }
  Yr(e, n) {
    return L.or([
      () => L.resolve(this.zr.containsKey(n)),
      () => this.persistence.getTargetCache().containsKey(e, n),
      () => this.persistence.Gr(e, n)
    ])
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class a1 {
  constructor(e, n, r, i) {
    ;(this.targetId = e), (this.fromCache = n), (this.qi = r), (this.Qi = i)
  }
  static Ki(e, n) {
    let r = ze(),
      i = ze()
    for (const s of n.docChanges)
      switch (s.type) {
        case 0:
          r = r.add(s.doc.key)
          break
        case 1:
          i = i.add(s.doc.key)
      }
    return new a1(e, n.fromCache, r, i)
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class UB {
  constructor() {
    this._documentReadCount = 0
  }
  get documentReadCount() {
    return this._documentReadCount
  }
  incrementDocumentReadCount(e) {
    this._documentReadCount += e
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class $B {
  constructor() {
    ;(this.$i = !1),
      (this.Ui = !1),
      (this.Wi = 100),
      (this.Gi = (function () {
        return p4() ? 8 : So.v(Ht()) > 0 ? 6 : 4
      })())
  }
  initialize(e, n) {
    ;(this.zi = e), (this.indexManager = n), (this.$i = !0)
  }
  getDocumentsMatchingQuery(e, n, r, i) {
    const s = { result: null }
    return this.ji(e, n)
      .next((o) => {
        s.result = o
      })
      .next(() => {
        if (!s.result)
          return this.Hi(e, n, i, r).next((o) => {
            s.result = o
          })
      })
      .next(() => {
        if (s.result) return
        const o = new UB()
        return this.Ji(e, n, o).next((a) => {
          if (((s.result = a), this.Ui)) return this.Yi(e, n, o, a.size)
        })
      })
      .next(() => s.result)
  }
  Yi(e, n, r, i) {
    return r.documentReadCount < this.Wi
      ? (sc() <= He.DEBUG &&
          ee(
            'QueryEngine',
            'SDK will not create cache indexes for query:',
            Sa(n),
            'since it only creates cache indexes for collection contains',
            'more than or equal to',
            this.Wi,
            'documents'
          ),
        L.resolve())
      : (sc() <= He.DEBUG &&
          ee(
            'QueryEngine',
            'Query:',
            Sa(n),
            'scans',
            r.documentReadCount,
            'local documents and returns',
            i,
            'documents as results.'
          ),
        r.documentReadCount > this.Gi * i
          ? (sc() <= He.DEBUG &&
              ee(
                'QueryEngine',
                'The SDK decides to create cache indexes for query:',
                Sa(n),
                'as using cache indexes may help improve performance.'
              ),
            this.indexManager.createTargetIndexes(e, hi(n)))
          : L.resolve())
  }
  ji(e, n) {
    if (HT(n)) return L.resolve(null)
    let r = hi(n)
    return this.indexManager.getIndexType(e, r).next((i) =>
      i === 0
        ? null
        : (n.limit !== null && i === 1 && ((n = g_(n, null, 'F')), (r = hi(n))),
          this.indexManager.getDocumentsMatchingTarget(e, r).next((s) => {
            const o = ze(...s)
            return this.zi.getDocuments(e, o).next((a) =>
              this.indexManager.getMinOffset(e, r).next((l) => {
                const c = this.Zi(n, a)
                return this.Xi(n, c, o, l.readTime)
                  ? this.ji(e, g_(n, null, 'F'))
                  : this.es(e, c, n, l)
              })
            )
          }))
    )
  }
  Hi(e, n, r, i) {
    return HT(n) || i.isEqual(Ne.min())
      ? L.resolve(null)
      : this.zi.getDocuments(e, r).next((s) => {
          const o = this.Zi(n, s)
          return this.Xi(n, o, r, i)
            ? L.resolve(null)
            : (sc() <= He.DEBUG &&
                ee(
                  'QueryEngine',
                  'Re-using previous result from %s to execute query: %s',
                  i.toString(),
                  Sa(n)
                ),
              this.es(e, o, n, m7(i, -1)).next((a) => a))
        })
  }
  Zi(e, n) {
    let r = new En(c2(e))
    return (
      n.forEach((i, s) => {
        rm(e, s) && (r = r.add(s))
      }),
      r
    )
  }
  Xi(e, n, r, i) {
    if (e.limit === null) return !1
    if (r.size !== n.size) return !0
    const s = e.limitType === 'F' ? n.last() : n.first()
    return !!s && (s.hasPendingWrites || s.version.compareTo(i) > 0)
  }
  Ji(e, n, r) {
    return (
      sc() <= He.DEBUG && ee('QueryEngine', 'Using full collection scan to execute query:', Sa(n)),
      this.zi.getDocumentsMatchingQuery(e, n, $s.min(), r)
    )
  }
  es(e, n, r, i) {
    return this.zi.getDocumentsMatchingQuery(e, r, i).next(
      (s) => (
        n.forEach((o) => {
          s = s.insert(o.key, o)
        }),
        s
      )
    )
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class HB {
  constructor(e, n, r, i) {
    ;(this.persistence = e),
      (this.ts = n),
      (this.serializer = i),
      (this.ns = new Rt(et)),
      (this.rs = new jl((s) => Z0(s), e1)),
      (this.ss = new Map()),
      (this.os = e.getRemoteDocumentCache()),
      (this.Qr = e.getTargetCache()),
      (this.$r = e.getBundleCache()),
      this._s(r)
  }
  _s(e) {
    ;(this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e)),
      (this.indexManager = this.persistence.getIndexManager(e)),
      (this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager)),
      (this.localDocuments = new NB(
        this.os,
        this.mutationQueue,
        this.documentOverlayCache,
        this.indexManager
      )),
      this.os.setIndexManager(this.indexManager),
      this.ts.initialize(this.localDocuments, this.indexManager)
  }
  collectGarbage(e) {
    return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', (n) =>
      e.collect(n, this.ns)
    )
  }
}
function zB(t, e, n, r) {
  return new HB(t, e, n, r)
}
async function N2(t, e) {
  const n = Pe(t)
  return await n.persistence.runTransaction('Handle user change', 'readonly', (r) => {
    let i
    return n.mutationQueue
      .getAllMutationBatches(r)
      .next((s) => ((i = s), n._s(e), n.mutationQueue.getAllMutationBatches(r)))
      .next((s) => {
        const o = [],
          a = []
        let l = ze()
        for (const c of i) {
          o.push(c.batchId)
          for (const u of c.mutations) l = l.add(u.key)
        }
        for (const c of s) {
          a.push(c.batchId)
          for (const u of c.mutations) l = l.add(u.key)
        }
        return n.localDocuments
          .getDocuments(r, l)
          .next((c) => ({ us: c, removedBatchIds: o, addedBatchIds: a }))
      })
  })
}
function jB(t, e) {
  const n = Pe(t)
  return n.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', (r) => {
    const i = e.batch.keys(),
      s = n.os.newChangeBuffer({ trackRemovals: !0 })
    return (function (a, l, c, u) {
      const h = c.batch,
        d = h.keys()
      let f = L.resolve()
      return (
        d.forEach((p) => {
          f = f
            .next(() => u.getEntry(l, p))
            .next((m) => {
              const g = c.docVersions.get(p)
              mt(g !== null),
                m.version.compareTo(g) < 0 &&
                  (h.applyToRemoteDocument(m, c),
                  m.isValidDocument() && (m.setReadTime(c.commitVersion), u.addEntry(m)))
            })
        }),
        f.next(() => a.mutationQueue.removeMutationBatch(l, h))
      )
    })(n, r, e, s)
      .next(() => s.apply(r))
      .next(() => n.mutationQueue.performConsistencyCheck(r))
      .next(() => n.documentOverlayCache.removeOverlaysForBatchId(r, i, e.batch.batchId))
      .next(() =>
        n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(
          r,
          (function (a) {
            let l = ze()
            for (let c = 0; c < a.mutationResults.length; ++c)
              a.mutationResults[c].transformResults.length > 0 &&
                (l = l.add(a.batch.mutations[c].key))
            return l
          })(e)
        )
      )
      .next(() => n.localDocuments.getDocuments(r, i))
  })
}
function M2(t) {
  const e = Pe(t)
  return e.persistence.runTransaction('Get last remote snapshot version', 'readonly', (n) =>
    e.Qr.getLastRemoteSnapshotVersion(n)
  )
}
function WB(t, e) {
  const n = Pe(t),
    r = e.snapshotVersion
  let i = n.ns
  return n.persistence
    .runTransaction('Apply remote event', 'readwrite-primary', (s) => {
      const o = n.os.newChangeBuffer({ trackRemovals: !0 })
      i = n.ns
      const a = []
      e.targetChanges.forEach((u, h) => {
        const d = i.get(h)
        if (!d) return
        a.push(
          n.Qr.removeMatchingKeys(s, u.removedDocuments, h).next(() =>
            n.Qr.addMatchingKeys(s, u.addedDocuments, h)
          )
        )
        let f = d.withSequenceNumber(s.currentSequenceNumber)
        e.targetMismatches.get(h) !== null
          ? (f = f
              .withResumeToken(xn.EMPTY_BYTE_STRING, Ne.min())
              .withLastLimboFreeSnapshotVersion(Ne.min()))
          : u.resumeToken.approximateByteSize() > 0 && (f = f.withResumeToken(u.resumeToken, r)),
          (i = i.insert(h, f)),
          (function (m, g, _) {
            return m.resumeToken.approximateByteSize() === 0 ||
              g.snapshotVersion.toMicroseconds() - m.snapshotVersion.toMicroseconds() >= 3e8
              ? !0
              : _.addedDocuments.size + _.modifiedDocuments.size + _.removedDocuments.size > 0
          })(d, f, u) && a.push(n.Qr.updateTargetData(s, f))
      })
      let l = Wi(),
        c = ze()
      if (
        (e.documentUpdates.forEach((u) => {
          e.resolvedLimboDocuments.has(u) &&
            a.push(n.persistence.referenceDelegate.updateLimboDocument(s, u))
        }),
        a.push(
          GB(s, o, e.documentUpdates).next((u) => {
            ;(l = u.cs), (c = u.ls)
          })
        ),
        !r.isEqual(Ne.min()))
      ) {
        const u = n.Qr.getLastRemoteSnapshotVersion(s).next((h) =>
          n.Qr.setTargetsMetadata(s, s.currentSequenceNumber, r)
        )
        a.push(u)
      }
      return L.waitFor(a)
        .next(() => o.apply(s))
        .next(() => n.localDocuments.getLocalViewOfDocuments(s, l, c))
        .next(() => l)
    })
    .then((s) => ((n.ns = i), s))
}
function GB(t, e, n) {
  let r = ze(),
    i = ze()
  return (
    n.forEach((s) => (r = r.add(s))),
    e.getEntries(t, r).next((s) => {
      let o = Wi()
      return (
        n.forEach((a, l) => {
          const c = s.get(a)
          l.isFoundDocument() !== c.isFoundDocument() && (i = i.add(a)),
            l.isNoDocument() && l.version.isEqual(Ne.min())
              ? (e.removeEntry(a, l.readTime), (o = o.insert(a, l)))
              : !c.isValidDocument() ||
                l.version.compareTo(c.version) > 0 ||
                (l.version.compareTo(c.version) === 0 && c.hasPendingWrites)
              ? (e.addEntry(l), (o = o.insert(a, l)))
              : ee(
                  'LocalStore',
                  'Ignoring outdated watch update for ',
                  a,
                  '. Current version:',
                  c.version,
                  ' Watch version:',
                  l.version
                )
        }),
        { cs: o, ls: i }
      )
    })
  )
}
function qB(t, e) {
  const n = Pe(t)
  return n.persistence.runTransaction(
    'Get next mutation batch',
    'readonly',
    (r) => (e === void 0 && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(r, e))
  )
}
function KB(t, e) {
  const n = Pe(t)
  return n.persistence
    .runTransaction('Allocate target', 'readwrite', (r) => {
      let i
      return n.Qr.getTargetData(r, e).next((s) =>
        s
          ? ((i = s), L.resolve(i))
          : n.Qr.allocateTargetId(r).next(
              (o) => (
                (i = new Ts(e, o, 'TargetPurposeListen', r.currentSequenceNumber)),
                n.Qr.addTargetData(r, i).next(() => i)
              )
            )
      )
    })
    .then((r) => {
      const i = n.ns.get(r.targetId)
      return (
        (i === null || r.snapshotVersion.compareTo(i.snapshotVersion) > 0) &&
          ((n.ns = n.ns.insert(r.targetId, r)), n.rs.set(e, r.targetId)),
        r
      )
    })
}
async function E_(t, e, n) {
  const r = Pe(t),
    i = r.ns.get(e),
    s = n ? 'readwrite' : 'readwrite-primary'
  try {
    n ||
      (await r.persistence.runTransaction('Release target', s, (o) =>
        r.persistence.referenceDelegate.removeTarget(o, i)
      ))
  } catch (o) {
    if (!dh(o)) throw o
    ee('LocalStore', `Failed to update sequence numbers for target ${e}: ${o}`)
  }
  ;(r.ns = r.ns.remove(e)), r.rs.delete(i.target)
}
function ZT(t, e, n) {
  const r = Pe(t)
  let i = Ne.min(),
    s = ze()
  return r.persistence.runTransaction('Execute query', 'readwrite', (o) =>
    (function (l, c, u) {
      const h = Pe(l),
        d = h.rs.get(u)
      return d !== void 0 ? L.resolve(h.ns.get(d)) : h.Qr.getTargetData(c, u)
    })(r, o, hi(e))
      .next((a) => {
        if (a)
          return (
            (i = a.lastLimboFreeSnapshotVersion),
            r.Qr.getMatchingKeysForTargetId(o, a.targetId).next((l) => {
              s = l
            })
          )
      })
      .next(() => r.ts.getDocumentsMatchingQuery(o, e, n ? i : Ne.min(), n ? s : ze()))
      .next((a) => (YB(r, B7(e), a), { documents: a, hs: s }))
  )
}
function YB(t, e, n) {
  let r = t.ss.get(e) || Ne.min()
  n.forEach((i, s) => {
    s.readTime.compareTo(r) > 0 && (r = s.readTime)
  }),
    t.ss.set(e, r)
}
class ew {
  constructor() {
    this.activeTargetIds = W7()
  }
  As(e) {
    this.activeTargetIds = this.activeTargetIds.add(e)
  }
  Rs(e) {
    this.activeTargetIds = this.activeTargetIds.delete(e)
  }
  ds() {
    const e = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() }
    return JSON.stringify(e)
  }
}
class JB {
  constructor() {
    ;(this.no = new ew()),
      (this.ro = {}),
      (this.onlineStateHandler = null),
      (this.sequenceNumberHandler = null)
  }
  addPendingMutation(e) {}
  updateMutationState(e, n, r) {}
  addLocalQueryTarget(e) {
    return this.no.As(e), this.ro[e] || 'not-current'
  }
  updateQueryState(e, n, r) {
    this.ro[e] = n
  }
  removeLocalQueryTarget(e) {
    this.no.Rs(e)
  }
  isLocalQueryTarget(e) {
    return this.no.activeTargetIds.has(e)
  }
  clearQueryState(e) {
    delete this.ro[e]
  }
  getAllActiveQueryTargets() {
    return this.no.activeTargetIds
  }
  isActiveQueryTarget(e) {
    return this.no.activeTargetIds.has(e)
  }
  start() {
    return (this.no = new ew()), Promise.resolve()
  }
  handleUserChange(e, n, r) {}
  setOnlineState(e) {}
  shutdown() {}
  writeSequenceNumber(e) {}
  notifyBundleLoaded(e) {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class QB {
  io(e) {}
  shutdown() {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class tw {
  constructor() {
    ;(this.so = () => this.oo()), (this._o = () => this.ao()), (this.uo = []), this.co()
  }
  io(e) {
    this.uo.push(e)
  }
  shutdown() {
    window.removeEventListener('online', this.so), window.removeEventListener('offline', this._o)
  }
  co() {
    window.addEventListener('online', this.so), window.addEventListener('offline', this._o)
  }
  oo() {
    ee('ConnectivityMonitor', 'Network connectivity changed: AVAILABLE')
    for (const e of this.uo) e(0)
  }
  ao() {
    ee('ConnectivityMonitor', 'Network connectivity changed: UNAVAILABLE')
    for (const e of this.uo) e(1)
  }
  static D() {
    return (
      typeof window < 'u' &&
      window.addEventListener !== void 0 &&
      window.removeEventListener !== void 0
    )
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Zh = null
function pg() {
  return (
    Zh === null
      ? (Zh = (function () {
          return 268435456 + Math.round(2147483648 * Math.random())
        })())
      : Zh++,
    '0x' + Zh.toString(16)
  )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const XB = {
  BatchGetDocuments: 'batchGet',
  Commit: 'commit',
  RunQuery: 'runQuery',
  RunAggregationQuery: 'runAggregationQuery'
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ZB {
  constructor(e) {
    ;(this.lo = e.lo), (this.ho = e.ho)
  }
  Po(e) {
    this.Io = e
  }
  To(e) {
    this.Eo = e
  }
  onMessage(e) {
    this.Ao = e
  }
  close() {
    this.ho()
  }
  send(e) {
    this.lo(e)
  }
  Ro() {
    this.Io()
  }
  Vo(e) {
    this.Eo(e)
  }
  mo(e) {
    this.Ao(e)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Tn = 'WebChannelConnection'
class e8 extends class {
  constructor(n) {
    ;(this.databaseInfo = n), (this.databaseId = n.databaseId)
    const r = n.ssl ? 'https' : 'http',
      i = encodeURIComponent(this.databaseId.projectId),
      s = encodeURIComponent(this.databaseId.database)
    ;(this.fo = r + '://' + n.host),
      (this.po = `projects/${i}/databases/${s}`),
      (this.yo =
        this.databaseId.database === '(default)'
          ? `project_id=${i}`
          : `project_id=${i}&database_id=${s}`)
  }
  get wo() {
    return !1
  }
  So(n, r, i, s, o) {
    const a = pg(),
      l = this.bo(n, r.toUriEncodedString())
    ee('RestConnection', `Sending RPC '${n}' ${a}:`, l, i)
    const c = { 'google-cloud-resource-prefix': this.po, 'x-goog-request-params': this.yo }
    return (
      this.Do(c, s, o),
      this.Co(n, l, c, i).then(
        (u) => (ee('RestConnection', `Received RPC '${n}' ${a}: `, u), u),
        (u) => {
          throw (
            (dl(
              'RestConnection',
              `RPC '${n}' ${a} failed with error: `,
              u,
              'url: ',
              l,
              'request:',
              i
            ),
            u)
          )
        }
      )
    )
  }
  vo(n, r, i, s, o, a) {
    return this.So(n, r, i, s, o)
  }
  Do(n, r, i) {
    ;(n['X-Goog-Api-Client'] = (function () {
      return 'gl-js/ fire/' + zl
    })()),
      (n['Content-Type'] = 'text/plain'),
      this.databaseInfo.appId && (n['X-Firebase-GMPID'] = this.databaseInfo.appId),
      r && r.headers.forEach((s, o) => (n[o] = s)),
      i && i.headers.forEach((s, o) => (n[o] = s))
  }
  bo(n, r) {
    const i = XB[n]
    return `${this.fo}/v1/${r}:${i}`
  }
  terminate() {}
} {
  constructor(e) {
    super(e),
      (this.forceLongPolling = e.forceLongPolling),
      (this.autoDetectLongPolling = e.autoDetectLongPolling),
      (this.useFetchStreams = e.useFetchStreams),
      (this.longPollingOptions = e.longPollingOptions)
  }
  Co(e, n, r, i) {
    const s = pg()
    return new Promise((o, a) => {
      const l = new i7()
      l.setWithCredentials(!0),
        l.listenOnce(n7.COMPLETE, () => {
          try {
            switch (l.getLastErrorCode()) {
              case dg.NO_ERROR:
                const u = l.getResponseJson()
                ee(Tn, `XHR for RPC '${e}' ${s} received:`, JSON.stringify(u)), o(u)
                break
              case dg.TIMEOUT:
                ee(Tn, `RPC '${e}' ${s} timed out`),
                  a(new ue(V.DEADLINE_EXCEEDED, 'Request time out'))
                break
              case dg.HTTP_ERROR:
                const h = l.getStatus()
                if (
                  (ee(
                    Tn,
                    `RPC '${e}' ${s} failed with status:`,
                    h,
                    'response text:',
                    l.getResponseText()
                  ),
                  h > 0)
                ) {
                  let d = l.getResponseJson()
                  Array.isArray(d) && (d = d[0])
                  const f = d == null ? void 0 : d.error
                  if (f && f.status && f.message) {
                    const p = (function (g) {
                      const _ = g.toLowerCase().replace(/_/g, '-')
                      return Object.values(V).indexOf(_) >= 0 ? _ : V.UNKNOWN
                    })(f.status)
                    a(new ue(p, f.message))
                  } else a(new ue(V.UNKNOWN, 'Server responded with status ' + l.getStatus()))
                } else a(new ue(V.UNAVAILABLE, 'Connection failed.'))
                break
              default:
                Ce()
            }
          } finally {
            ee(Tn, `RPC '${e}' ${s} completed.`)
          }
        })
      const c = JSON.stringify(i)
      ee(Tn, `RPC '${e}' ${s} sending request:`, i), l.send(n, 'POST', c, r, 15)
    })
  }
  Fo(e, n, r) {
    const i = pg(),
      s = [this.fo, '/', 'google.firestore.v1.Firestore', '/', e, '/channel'],
      o = e7(),
      a = t7(),
      l = {
        httpSessionIdParam: 'gsessionid',
        initMessageHeaders: {},
        messageUrlParams: {
          database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
        },
        sendRawJson: !0,
        supportsCrossDomainXhr: !0,
        internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 },
        forceLongPolling: this.forceLongPolling,
        detectBufferingProxy: this.autoDetectLongPolling
      },
      c = this.longPollingOptions.timeoutSeconds
    c !== void 0 && (l.longPollingTimeout = Math.round(1e3 * c)),
      this.useFetchStreams && (l.useFetchStreams = !0),
      this.Do(l.initMessageHeaders, n, r),
      (l.encodeInitMessageHeaders = !0)
    const u = s.join('')
    ee(Tn, `Creating RPC '${e}' stream ${i}: ${u}`, l)
    const h = o.createWebChannel(u, l)
    let d = !1,
      f = !1
    const p = new ZB({
        lo: (g) => {
          f
            ? ee(Tn, `Not sending because RPC '${e}' stream ${i} is closed:`, g)
            : (d || (ee(Tn, `Opening RPC '${e}' stream ${i} transport.`), h.open(), (d = !0)),
              ee(Tn, `RPC '${e}' stream ${i} sending:`, g),
              h.send(g))
        },
        ho: () => h.close()
      }),
      m = (g, _, v) => {
        g.listen(_, (T) => {
          try {
            v(T)
          } catch (S) {
            setTimeout(() => {
              throw S
            }, 0)
          }
        })
      }
    return (
      m(h, Jh.EventType.OPEN, () => {
        f || ee(Tn, `RPC '${e}' stream ${i} transport opened.`)
      }),
      m(h, Jh.EventType.CLOSE, () => {
        f || ((f = !0), ee(Tn, `RPC '${e}' stream ${i} transport closed`), p.Vo())
      }),
      m(h, Jh.EventType.ERROR, (g) => {
        f ||
          ((f = !0),
          dl(Tn, `RPC '${e}' stream ${i} transport errored:`, g),
          p.Vo(new ue(V.UNAVAILABLE, 'The operation could not be completed')))
      }),
      m(h, Jh.EventType.MESSAGE, (g) => {
        var _
        if (!f) {
          const v = g.data[0]
          mt(!!v)
          const T = v,
            S = T.error || ((_ = T[0]) === null || _ === void 0 ? void 0 : _.error)
          if (S) {
            ee(Tn, `RPC '${e}' stream ${i} received error:`, S)
            const I = S.status
            let w = (function (k) {
                const U = Dt[k]
                if (U !== void 0) return E2(U)
              })(I),
              O = S.message
            w === void 0 &&
              ((w = V.INTERNAL), (O = 'Unknown error status: ' + I + ' with message ' + S.message)),
              (f = !0),
              p.Vo(new ue(w, O)),
              h.close()
          } else ee(Tn, `RPC '${e}' stream ${i} received:`, v), p.mo(v)
        }
      }),
      m(a, r7.STAT_EVENT, (g) => {
        g.stat === NT.PROXY
          ? ee(Tn, `RPC '${e}' stream ${i} detected buffering proxy`)
          : g.stat === NT.NOPROXY && ee(Tn, `RPC '${e}' stream ${i} detected no buffering proxy`)
      }),
      setTimeout(() => {
        p.Ro()
      }, 0),
      p
    )
  }
}
function mg() {
  return typeof document < 'u' ? document : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function am(t) {
  return new hB(t, !0)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class P2 {
  constructor(e, n, r = 1e3, i = 1.5, s = 6e4) {
    ;(this.oi = e),
      (this.timerId = n),
      (this.Mo = r),
      (this.xo = i),
      (this.Oo = s),
      (this.No = 0),
      (this.Lo = null),
      (this.Bo = Date.now()),
      this.reset()
  }
  reset() {
    this.No = 0
  }
  ko() {
    this.No = this.Oo
  }
  qo(e) {
    this.cancel()
    const n = Math.floor(this.No + this.Qo()),
      r = Math.max(0, Date.now() - this.Bo),
      i = Math.max(0, n - r)
    i > 0 &&
      ee(
        'ExponentialBackoff',
        `Backing off for ${i} ms (base delay: ${this.No} ms, delay with jitter: ${n} ms, last attempt: ${r} ms ago)`
      ),
      (this.Lo = this.oi.enqueueAfterDelay(this.timerId, i, () => ((this.Bo = Date.now()), e()))),
      (this.No *= this.xo),
      this.No < this.Mo && (this.No = this.Mo),
      this.No > this.Oo && (this.No = this.Oo)
  }
  Ko() {
    this.Lo !== null && (this.Lo.skipDelay(), (this.Lo = null))
  }
  cancel() {
    this.Lo !== null && (this.Lo.cancel(), (this.Lo = null))
  }
  Qo() {
    return (Math.random() - 0.5) * this.No
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class x2 {
  constructor(e, n, r, i, s, o, a, l) {
    ;(this.oi = e),
      (this.$o = r),
      (this.Uo = i),
      (this.connection = s),
      (this.authCredentialsProvider = o),
      (this.appCheckCredentialsProvider = a),
      (this.listener = l),
      (this.state = 0),
      (this.Wo = 0),
      (this.Go = null),
      (this.zo = null),
      (this.stream = null),
      (this.jo = new P2(e, n))
  }
  Ho() {
    return this.state === 1 || this.state === 5 || this.Jo()
  }
  Jo() {
    return this.state === 2 || this.state === 3
  }
  start() {
    this.state !== 4 ? this.auth() : this.Yo()
  }
  async stop() {
    this.Ho() && (await this.close(0))
  }
  Zo() {
    ;(this.state = 0), this.jo.reset()
  }
  Xo() {
    this.Jo() &&
      this.Go === null &&
      (this.Go = this.oi.enqueueAfterDelay(this.$o, 6e4, () => this.e_()))
  }
  t_(e) {
    this.n_(), this.stream.send(e)
  }
  async e_() {
    if (this.Jo()) return this.close(0)
  }
  n_() {
    this.Go && (this.Go.cancel(), (this.Go = null))
  }
  r_() {
    this.zo && (this.zo.cancel(), (this.zo = null))
  }
  async close(e, n) {
    this.n_(),
      this.r_(),
      this.jo.cancel(),
      this.Wo++,
      e !== 4
        ? this.jo.reset()
        : n && n.code === V.RESOURCE_EXHAUSTED
        ? (yi(n.toString()),
          yi('Using maximum backoff delay to prevent overloading the backend.'),
          this.jo.ko())
        : n &&
          n.code === V.UNAUTHENTICATED &&
          this.state !== 3 &&
          (this.authCredentialsProvider.invalidateToken(),
          this.appCheckCredentialsProvider.invalidateToken()),
      this.stream !== null && (this.i_(), this.stream.close(), (this.stream = null)),
      (this.state = e),
      await this.listener.To(n)
  }
  i_() {}
  auth() {
    this.state = 1
    const e = this.s_(this.Wo),
      n = this.Wo
    Promise.all([
      this.authCredentialsProvider.getToken(),
      this.appCheckCredentialsProvider.getToken()
    ]).then(
      ([r, i]) => {
        this.Wo === n && this.o_(r, i)
      },
      (r) => {
        e(() => {
          const i = new ue(V.UNKNOWN, 'Fetching auth token failed: ' + r.message)
          return this.__(i)
        })
      }
    )
  }
  o_(e, n) {
    const r = this.s_(this.Wo)
    ;(this.stream = this.a_(e, n)),
      this.stream.Po(() => {
        r(
          () => (
            (this.state = 2),
            (this.zo = this.oi.enqueueAfterDelay(
              this.Uo,
              1e4,
              () => (this.Jo() && (this.state = 3), Promise.resolve())
            )),
            this.listener.Po()
          )
        )
      }),
      this.stream.To((i) => {
        r(() => this.__(i))
      }),
      this.stream.onMessage((i) => {
        r(() => this.onMessage(i))
      })
  }
  Yo() {
    ;(this.state = 5),
      this.jo.qo(async () => {
        ;(this.state = 0), this.start()
      })
  }
  __(e) {
    return ee('PersistentStream', `close with error: ${e}`), (this.stream = null), this.close(4, e)
  }
  s_(e) {
    return (n) => {
      this.oi.enqueueAndForget(() =>
        this.Wo === e
          ? n()
          : (ee('PersistentStream', 'stream callback skipped by getCloseGuardedDispatcher.'),
            Promise.resolve())
      )
    }
  }
}
class t8 extends x2 {
  constructor(e, n, r, i, s, o) {
    super(
      e,
      'listen_stream_connection_backoff',
      'listen_stream_idle',
      'health_check_timeout',
      n,
      r,
      i,
      o
    ),
      (this.serializer = s)
  }
  a_(e, n) {
    return this.connection.Fo('Listen', e, n)
  }
  onMessage(e) {
    this.jo.reset()
    const n = pB(this.serializer, e),
      r = (function (s) {
        if (!('targetChange' in s)) return Ne.min()
        const o = s.targetChange
        return o.targetIds && o.targetIds.length ? Ne.min() : o.readTime ? di(o.readTime) : Ne.min()
      })(e)
    return this.listener.u_(n, r)
  }
  c_(e) {
    const n = {}
    ;(n.database = b_(this.serializer)),
      (n.addTarget = (function (s, o) {
        let a
        const l = o.target
        if (
          ((a = m_(l) ? { documents: yB(s, l) } : { query: _B(s, l).ut }),
          (a.targetId = o.targetId),
          o.resumeToken.approximateByteSize() > 0)
        ) {
          a.resumeToken = S2(s, o.resumeToken)
          const c = y_(s, o.expectedCount)
          c !== null && (a.expectedCount = c)
        } else if (o.snapshotVersion.compareTo(Ne.min()) > 0) {
          a.readTime = kf(s, o.snapshotVersion.toTimestamp())
          const c = y_(s, o.expectedCount)
          c !== null && (a.expectedCount = c)
        }
        return a
      })(this.serializer, e))
    const r = bB(this.serializer, e)
    r && (n.labels = r), this.t_(n)
  }
  l_(e) {
    const n = {}
    ;(n.database = b_(this.serializer)), (n.removeTarget = e), this.t_(n)
  }
}
class n8 extends x2 {
  constructor(e, n, r, i, s, o) {
    super(
      e,
      'write_stream_connection_backoff',
      'write_stream_idle',
      'health_check_timeout',
      n,
      r,
      i,
      o
    ),
      (this.serializer = s),
      (this.h_ = !1)
  }
  get P_() {
    return this.h_
  }
  start() {
    ;(this.h_ = !1), (this.lastStreamToken = void 0), super.start()
  }
  i_() {
    this.h_ && this.I_([])
  }
  a_(e, n) {
    return this.connection.Fo('Write', e, n)
  }
  onMessage(e) {
    if ((mt(!!e.streamToken), (this.lastStreamToken = e.streamToken), this.h_)) {
      this.jo.reset()
      const n = gB(e.writeResults, e.commitTime),
        r = di(e.commitTime)
      return this.listener.T_(r, n)
    }
    return mt(!e.writeResults || e.writeResults.length === 0), (this.h_ = !0), this.listener.E_()
  }
  d_() {
    const e = {}
    ;(e.database = b_(this.serializer)), this.t_(e)
  }
  I_(e) {
    const n = { streamToken: this.lastStreamToken, writes: e.map((r) => mB(this.serializer, r)) }
    this.t_(n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class r8 extends class {} {
  constructor(e, n, r, i) {
    super(),
      (this.authCredentials = e),
      (this.appCheckCredentials = n),
      (this.connection = r),
      (this.serializer = i),
      (this.A_ = !1)
  }
  R_() {
    if (this.A_) throw new ue(V.FAILED_PRECONDITION, 'The client has already been terminated.')
  }
  So(e, n, r, i) {
    return (
      this.R_(),
      Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
        .then(([s, o]) => this.connection.So(e, __(n, r), i, s, o))
        .catch((s) => {
          throw s.name === 'FirebaseError'
            ? (s.code === V.UNAUTHENTICATED &&
                (this.authCredentials.invalidateToken(),
                this.appCheckCredentials.invalidateToken()),
              s)
            : new ue(V.UNKNOWN, s.toString())
        })
    )
  }
  vo(e, n, r, i, s) {
    return (
      this.R_(),
      Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
        .then(([o, a]) => this.connection.vo(e, __(n, r), i, o, a, s))
        .catch((o) => {
          throw o.name === 'FirebaseError'
            ? (o.code === V.UNAUTHENTICATED &&
                (this.authCredentials.invalidateToken(),
                this.appCheckCredentials.invalidateToken()),
              o)
            : new ue(V.UNKNOWN, o.toString())
        })
    )
  }
  terminate() {
    ;(this.A_ = !0), this.connection.terminate()
  }
}
class i8 {
  constructor(e, n) {
    ;(this.asyncQueue = e),
      (this.onlineStateHandler = n),
      (this.state = 'Unknown'),
      (this.m_ = 0),
      (this.f_ = null),
      (this.g_ = !0)
  }
  p_() {
    this.m_ === 0 &&
      (this.y_('Unknown'),
      (this.f_ = this.asyncQueue.enqueueAfterDelay(
        'online_state_timeout',
        1e4,
        () => (
          (this.f_ = null),
          this.w_("Backend didn't respond within 10 seconds."),
          this.y_('Offline'),
          Promise.resolve()
        )
      )))
  }
  S_(e) {
    this.state === 'Online'
      ? this.y_('Unknown')
      : (this.m_++,
        this.m_ >= 1 &&
          (this.b_(),
          this.w_(`Connection failed 1 times. Most recent error: ${e.toString()}`),
          this.y_('Offline')))
  }
  set(e) {
    this.b_(), (this.m_ = 0), e === 'Online' && (this.g_ = !1), this.y_(e)
  }
  y_(e) {
    e !== this.state && ((this.state = e), this.onlineStateHandler(e))
  }
  w_(e) {
    const n = `Could not reach Cloud Firestore backend. ${e}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`
    this.g_ ? (yi(n), (this.g_ = !1)) : ee('OnlineStateTracker', n)
  }
  b_() {
    this.f_ !== null && (this.f_.cancel(), (this.f_ = null))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class s8 {
  constructor(e, n, r, i, s) {
    ;(this.localStore = e),
      (this.datastore = n),
      (this.asyncQueue = r),
      (this.remoteSyncer = {}),
      (this.D_ = []),
      (this.C_ = new Map()),
      (this.v_ = new Set()),
      (this.F_ = []),
      (this.M_ = s),
      this.M_.io((o) => {
        r.enqueueAndForget(async () => {
          ma(this) &&
            (ee('RemoteStore', 'Restarting streams for network reachability change.'),
            await (async function (l) {
              const c = Pe(l)
              c.v_.add(4), await mh(c), c.x_.set('Unknown'), c.v_.delete(4), await lm(c)
            })(this))
        })
      }),
      (this.x_ = new i8(r, i))
  }
}
async function lm(t) {
  if (ma(t)) for (const e of t.F_) await e(!0)
}
async function mh(t) {
  for (const e of t.F_) await e(!1)
}
function D2(t, e) {
  const n = Pe(t)
  n.C_.has(e.targetId) || (n.C_.set(e.targetId, e), h1(n) ? u1(n) : Wl(n).Jo() && c1(n, e))
}
function l1(t, e) {
  const n = Pe(t),
    r = Wl(n)
  n.C_.delete(e),
    r.Jo() && L2(n, e),
    n.C_.size === 0 && (r.Jo() ? r.Xo() : ma(n) && n.x_.set('Unknown'))
}
function c1(t, e) {
  if (
    (t.O_.Oe(e.targetId),
    e.resumeToken.approximateByteSize() > 0 || e.snapshotVersion.compareTo(Ne.min()) > 0)
  ) {
    const n = t.remoteSyncer.getRemoteKeysForTarget(e.targetId).size
    e = e.withExpectedCount(n)
  }
  Wl(t).c_(e)
}
function L2(t, e) {
  t.O_.Oe(e), Wl(t).l_(e)
}
function u1(t) {
  ;(t.O_ = new aB({
    getRemoteKeysForTarget: (e) => t.remoteSyncer.getRemoteKeysForTarget(e),
    _t: (e) => t.C_.get(e) || null,
    nt: () => t.datastore.serializer.databaseId
  })),
    Wl(t).start(),
    t.x_.p_()
}
function h1(t) {
  return ma(t) && !Wl(t).Ho() && t.C_.size > 0
}
function ma(t) {
  return Pe(t).v_.size === 0
}
function V2(t) {
  t.O_ = void 0
}
async function o8(t) {
  t.C_.forEach((e, n) => {
    c1(t, e)
  })
}
async function a8(t, e) {
  V2(t), h1(t) ? (t.x_.S_(e), u1(t)) : t.x_.set('Unknown')
}
async function l8(t, e, n) {
  if ((t.x_.set('Online'), e instanceof w2 && e.state === 2 && e.cause))
    try {
      await (async function (i, s) {
        const o = s.cause
        for (const a of s.targetIds)
          i.C_.has(a) &&
            (await i.remoteSyncer.rejectListen(a, o), i.C_.delete(a), i.O_.removeTarget(a))
      })(t, e)
    } catch (r) {
      ee('RemoteStore', 'Failed to remove targets %s: %s ', e.targetIds.join(','), r),
        await Of(t, r)
    }
  else if (
    (e instanceof Od ? t.O_.$e(e) : e instanceof T2 ? t.O_.Je(e) : t.O_.Ge(e), !n.isEqual(Ne.min()))
  )
    try {
      const r = await M2(t.localStore)
      n.compareTo(r) >= 0 &&
        (await (function (s, o) {
          const a = s.O_.it(o)
          return (
            a.targetChanges.forEach((l, c) => {
              if (l.resumeToken.approximateByteSize() > 0) {
                const u = s.C_.get(c)
                u && s.C_.set(c, u.withResumeToken(l.resumeToken, o))
              }
            }),
            a.targetMismatches.forEach((l, c) => {
              const u = s.C_.get(l)
              if (!u) return
              s.C_.set(l, u.withResumeToken(xn.EMPTY_BYTE_STRING, u.snapshotVersion)), L2(s, l)
              const h = new Ts(u.target, l, c, u.sequenceNumber)
              c1(s, h)
            }),
            s.remoteSyncer.applyRemoteEvent(a)
          )
        })(t, n))
    } catch (r) {
      ee('RemoteStore', 'Failed to raise snapshot:', r), await Of(t, r)
    }
}
async function Of(t, e, n) {
  if (!dh(e)) throw e
  t.v_.add(1),
    await mh(t),
    t.x_.set('Offline'),
    n || (n = () => M2(t.localStore)),
    t.asyncQueue.enqueueRetryable(async () => {
      ee('RemoteStore', 'Retrying IndexedDB access'), await n(), t.v_.delete(1), await lm(t)
    })
}
function F2(t, e) {
  return e().catch((n) => Of(t, n, e))
}
async function cm(t) {
  const e = Pe(t),
    n = zs(e)
  let r = e.D_.length > 0 ? e.D_[e.D_.length - 1].batchId : -1
  for (; c8(e); )
    try {
      const i = await qB(e.localStore, r)
      if (i === null) {
        e.D_.length === 0 && n.Xo()
        break
      }
      ;(r = i.batchId), u8(e, i)
    } catch (i) {
      await Of(e, i)
    }
  B2(e) && U2(e)
}
function c8(t) {
  return ma(t) && t.D_.length < 10
}
function u8(t, e) {
  t.D_.push(e)
  const n = zs(t)
  n.Jo() && n.P_ && n.I_(e.mutations)
}
function B2(t) {
  return ma(t) && !zs(t).Ho() && t.D_.length > 0
}
function U2(t) {
  zs(t).start()
}
async function h8(t) {
  zs(t).d_()
}
async function d8(t) {
  const e = zs(t)
  for (const n of t.D_) e.I_(n.mutations)
}
async function f8(t, e, n) {
  const r = t.D_.shift(),
    i = n1.from(r, e, n)
  await F2(t, () => t.remoteSyncer.applySuccessfulWrite(i)), await cm(t)
}
async function p8(t, e) {
  e &&
    zs(t).P_ &&
    (await (async function (r, i) {
      if (
        (function (o) {
          return iB(o) && o !== V.ABORTED
        })(i.code)
      ) {
        const s = r.D_.shift()
        zs(r).Zo(), await F2(r, () => r.remoteSyncer.rejectFailedWrite(s.batchId, i)), await cm(r)
      }
    })(t, e)),
    B2(t) && U2(t)
}
async function nw(t, e) {
  const n = Pe(t)
  n.asyncQueue.verifyOperationInProgress(),
    ee('RemoteStore', 'RemoteStore received new credentials')
  const r = ma(n)
  n.v_.add(3),
    await mh(n),
    r && n.x_.set('Unknown'),
    await n.remoteSyncer.handleCredentialChange(e),
    n.v_.delete(3),
    await lm(n)
}
async function m8(t, e) {
  const n = Pe(t)
  e ? (n.v_.delete(2), await lm(n)) : e || (n.v_.add(2), await mh(n), n.x_.set('Unknown'))
}
function Wl(t) {
  return (
    t.N_ ||
      ((t.N_ = (function (n, r, i) {
        const s = Pe(n)
        return (
          s.R_(), new t8(r, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, i)
        )
      })(t.datastore, t.asyncQueue, {
        Po: o8.bind(null, t),
        To: a8.bind(null, t),
        u_: l8.bind(null, t)
      })),
      t.F_.push(async (e) => {
        e ? (t.N_.Zo(), h1(t) ? u1(t) : t.x_.set('Unknown')) : (await t.N_.stop(), V2(t))
      })),
    t.N_
  )
}
function zs(t) {
  return (
    t.L_ ||
      ((t.L_ = (function (n, r, i) {
        const s = Pe(n)
        return (
          s.R_(), new n8(r, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, i)
        )
      })(t.datastore, t.asyncQueue, {
        Po: h8.bind(null, t),
        To: p8.bind(null, t),
        E_: d8.bind(null, t),
        T_: f8.bind(null, t)
      })),
      t.F_.push(async (e) => {
        e
          ? (t.L_.Zo(), await cm(t))
          : (await t.L_.stop(),
            t.D_.length > 0 &&
              (ee('RemoteStore', `Stopping write stream with ${t.D_.length} pending writes`),
              (t.D_ = [])))
      })),
    t.L_
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class d1 {
  constructor(e, n, r, i, s) {
    ;(this.asyncQueue = e),
      (this.timerId = n),
      (this.targetTimeMs = r),
      (this.op = i),
      (this.removalCallback = s),
      (this.deferred = new ui()),
      (this.then = this.deferred.promise.then.bind(this.deferred.promise)),
      this.deferred.promise.catch((o) => {})
  }
  get promise() {
    return this.deferred.promise
  }
  static createAndSchedule(e, n, r, i, s) {
    const o = Date.now() + r,
      a = new d1(e, n, o, i, s)
    return a.start(r), a
  }
  start(e) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e)
  }
  skipDelay() {
    return this.handleDelayElapsed()
  }
  cancel(e) {
    this.timerHandle !== null &&
      (this.clearTimeout(),
      this.deferred.reject(new ue(V.CANCELLED, 'Operation cancelled' + (e ? ': ' + e : ''))))
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() =>
      this.timerHandle !== null
        ? (this.clearTimeout(), this.op().then((e) => this.deferred.resolve(e)))
        : Promise.resolve()
    )
  }
  clearTimeout() {
    this.timerHandle !== null &&
      (this.removalCallback(this), clearTimeout(this.timerHandle), (this.timerHandle = null))
  }
}
function f1(t, e) {
  if ((yi('AsyncQueue', `${e}: ${t}`), dh(t))) return new ue(V.UNAVAILABLE, `${e}: ${t}`)
  throw t
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Qa {
  constructor(e) {
    ;(this.comparator = e
      ? (n, r) => e(n, r) || _e.comparator(n.key, r.key)
      : (n, r) => _e.comparator(n.key, r.key)),
      (this.keyedMap = fc()),
      (this.sortedSet = new Rt(this.comparator))
  }
  static emptySet(e) {
    return new Qa(e.comparator)
  }
  has(e) {
    return this.keyedMap.get(e) != null
  }
  get(e) {
    return this.keyedMap.get(e)
  }
  first() {
    return this.sortedSet.minKey()
  }
  last() {
    return this.sortedSet.maxKey()
  }
  isEmpty() {
    return this.sortedSet.isEmpty()
  }
  indexOf(e) {
    const n = this.keyedMap.get(e)
    return n ? this.sortedSet.indexOf(n) : -1
  }
  get size() {
    return this.sortedSet.size
  }
  forEach(e) {
    this.sortedSet.inorderTraversal((n, r) => (e(n), !1))
  }
  add(e) {
    const n = this.delete(e.key)
    return n.copy(n.keyedMap.insert(e.key, e), n.sortedSet.insert(e, null))
  }
  delete(e) {
    const n = this.get(e)
    return n ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(n)) : this
  }
  isEqual(e) {
    if (!(e instanceof Qa) || this.size !== e.size) return !1
    const n = this.sortedSet.getIterator(),
      r = e.sortedSet.getIterator()
    for (; n.hasNext(); ) {
      const i = n.getNext().key,
        s = r.getNext().key
      if (!i.isEqual(s)) return !1
    }
    return !0
  }
  toString() {
    const e = []
    return (
      this.forEach((n) => {
        e.push(n.toString())
      }),
      e.length === 0
        ? 'DocumentSet ()'
        : `DocumentSet (
  ` +
          e.join(`  
`) +
          `
)`
    )
  }
  copy(e, n) {
    const r = new Qa()
    return (r.comparator = this.comparator), (r.keyedMap = e), (r.sortedSet = n), r
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class rw {
  constructor() {
    this.B_ = new Rt(_e.comparator)
  }
  track(e) {
    const n = e.doc.key,
      r = this.B_.get(n)
    r
      ? e.type !== 0 && r.type === 3
        ? (this.B_ = this.B_.insert(n, e))
        : e.type === 3 && r.type !== 1
        ? (this.B_ = this.B_.insert(n, { type: r.type, doc: e.doc }))
        : e.type === 2 && r.type === 2
        ? (this.B_ = this.B_.insert(n, { type: 2, doc: e.doc }))
        : e.type === 2 && r.type === 0
        ? (this.B_ = this.B_.insert(n, { type: 0, doc: e.doc }))
        : e.type === 1 && r.type === 0
        ? (this.B_ = this.B_.remove(n))
        : e.type === 1 && r.type === 2
        ? (this.B_ = this.B_.insert(n, { type: 1, doc: r.doc }))
        : e.type === 0 && r.type === 1
        ? (this.B_ = this.B_.insert(n, { type: 2, doc: e.doc }))
        : Ce()
      : (this.B_ = this.B_.insert(n, e))
  }
  k_() {
    const e = []
    return (
      this.B_.inorderTraversal((n, r) => {
        e.push(r)
      }),
      e
    )
  }
}
class _l {
  constructor(e, n, r, i, s, o, a, l, c) {
    ;(this.query = e),
      (this.docs = n),
      (this.oldDocs = r),
      (this.docChanges = i),
      (this.mutatedKeys = s),
      (this.fromCache = o),
      (this.syncStateChanged = a),
      (this.excludesMetadataChanges = l),
      (this.hasCachedResults = c)
  }
  static fromInitialDocuments(e, n, r, i, s) {
    const o = []
    return (
      n.forEach((a) => {
        o.push({ type: 0, doc: a })
      }),
      new _l(e, n, Qa.emptySet(n), o, r, i, !0, !1, s)
    )
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty()
  }
  isEqual(e) {
    if (
      !(
        this.fromCache === e.fromCache &&
        this.hasCachedResults === e.hasCachedResults &&
        this.syncStateChanged === e.syncStateChanged &&
        this.mutatedKeys.isEqual(e.mutatedKeys) &&
        nm(this.query, e.query) &&
        this.docs.isEqual(e.docs) &&
        this.oldDocs.isEqual(e.oldDocs)
      )
    )
      return !1
    const n = this.docChanges,
      r = e.docChanges
    if (n.length !== r.length) return !1
    for (let i = 0; i < n.length; i++)
      if (n[i].type !== r[i].type || !n[i].doc.isEqual(r[i].doc)) return !1
    return !0
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class g8 {
  constructor() {
    ;(this.q_ = void 0), (this.Q_ = [])
  }
  K_() {
    return this.Q_.some((e) => e.U_())
  }
}
class y8 {
  constructor() {
    ;(this.queries = new jl((e) => l2(e), nm)),
      (this.onlineState = 'Unknown'),
      (this.W_ = new Set())
  }
}
async function p1(t, e) {
  const n = Pe(t)
  let r = 3
  const i = e.query
  let s = n.queries.get(i)
  s ? !s.K_() && e.U_() && (r = 2) : ((s = new g8()), (r = e.U_() ? 0 : 1))
  try {
    switch (r) {
      case 0:
        s.q_ = await n.onListen(i, !0)
        break
      case 1:
        s.q_ = await n.onListen(i, !1)
        break
      case 2:
        await n.onFirstRemoteStoreListen(i)
    }
  } catch (o) {
    const a = f1(o, `Initialization of query '${Sa(e.query)}' failed`)
    return void e.onError(a)
  }
  n.queries.set(i, s), s.Q_.push(e), e.G_(n.onlineState), s.q_ && e.z_(s.q_) && g1(n)
}
async function m1(t, e) {
  const n = Pe(t),
    r = e.query
  let i = 3
  const s = n.queries.get(r)
  if (s) {
    const o = s.Q_.indexOf(e)
    o >= 0 &&
      (s.Q_.splice(o, 1), s.Q_.length === 0 ? (i = e.U_() ? 0 : 1) : !s.K_() && e.U_() && (i = 2))
  }
  switch (i) {
    case 0:
      return n.queries.delete(r), n.onUnlisten(r, !0)
    case 1:
      return n.queries.delete(r), n.onUnlisten(r, !1)
    case 2:
      return n.onLastRemoteStoreUnlisten(r)
    default:
      return
  }
}
function _8(t, e) {
  const n = Pe(t)
  let r = !1
  for (const i of e) {
    const s = i.query,
      o = n.queries.get(s)
    if (o) {
      for (const a of o.Q_) a.z_(i) && (r = !0)
      o.q_ = i
    }
  }
  r && g1(n)
}
function v8(t, e, n) {
  const r = Pe(t),
    i = r.queries.get(e)
  if (i) for (const s of i.Q_) s.onError(n)
  r.queries.delete(e)
}
function g1(t) {
  t.W_.forEach((e) => {
    e.next()
  })
}
var T_, iw
;((iw = T_ || (T_ = {})).j_ = 'default'), (iw.Cache = 'cache')
class y1 {
  constructor(e, n, r) {
    ;(this.query = e),
      (this.H_ = n),
      (this.J_ = !1),
      (this.Y_ = null),
      (this.onlineState = 'Unknown'),
      (this.options = r || {})
  }
  z_(e) {
    if (!this.options.includeMetadataChanges) {
      const r = []
      for (const i of e.docChanges) i.type !== 3 && r.push(i)
      e = new _l(
        e.query,
        e.docs,
        e.oldDocs,
        r,
        e.mutatedKeys,
        e.fromCache,
        e.syncStateChanged,
        !0,
        e.hasCachedResults
      )
    }
    let n = !1
    return (
      this.J_
        ? this.Z_(e) && (this.H_.next(e), (n = !0))
        : this.X_(e, this.onlineState) && (this.ea(e), (n = !0)),
      (this.Y_ = e),
      n
    )
  }
  onError(e) {
    this.H_.error(e)
  }
  G_(e) {
    this.onlineState = e
    let n = !1
    return this.Y_ && !this.J_ && this.X_(this.Y_, e) && (this.ea(this.Y_), (n = !0)), n
  }
  X_(e, n) {
    if (!e.fromCache || !this.U_()) return !0
    const r = n !== 'Offline'
    return (!this.options.ta || !r) && (!e.docs.isEmpty() || e.hasCachedResults || n === 'Offline')
  }
  Z_(e) {
    if (e.docChanges.length > 0) return !0
    const n = this.Y_ && this.Y_.hasPendingWrites !== e.hasPendingWrites
    return !(!e.syncStateChanged && !n) && this.options.includeMetadataChanges === !0
  }
  ea(e) {
    ;(e = _l.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults)),
      (this.J_ = !0),
      this.H_.next(e)
  }
  U_() {
    return this.options.source !== T_.Cache
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class $2 {
  constructor(e) {
    this.key = e
  }
}
class H2 {
  constructor(e) {
    this.key = e
  }
}
class b8 {
  constructor(e, n) {
    ;(this.query = e),
      (this.ua = n),
      (this.ca = null),
      (this.hasCachedResults = !1),
      (this.current = !1),
      (this.la = ze()),
      (this.mutatedKeys = ze()),
      (this.ha = c2(e)),
      (this.Pa = new Qa(this.ha))
  }
  get Ia() {
    return this.ua
  }
  Ta(e, n) {
    const r = n ? n.Ea : new rw(),
      i = n ? n.Pa : this.Pa
    let s = n ? n.mutatedKeys : this.mutatedKeys,
      o = i,
      a = !1
    const l = this.query.limitType === 'F' && i.size === this.query.limit ? i.last() : null,
      c = this.query.limitType === 'L' && i.size === this.query.limit ? i.first() : null
    if (
      (e.inorderTraversal((u, h) => {
        const d = i.get(u),
          f = rm(this.query, h) ? h : null,
          p = !!d && this.mutatedKeys.has(d.key),
          m =
            !!f && (f.hasLocalMutations || (this.mutatedKeys.has(f.key) && f.hasCommittedMutations))
        let g = !1
        d && f
          ? d.data.isEqual(f.data)
            ? p !== m && (r.track({ type: 3, doc: f }), (g = !0))
            : this.da(d, f) ||
              (r.track({ type: 2, doc: f }),
              (g = !0),
              ((l && this.ha(f, l) > 0) || (c && this.ha(f, c) < 0)) && (a = !0))
          : !d && f
          ? (r.track({ type: 0, doc: f }), (g = !0))
          : d && !f && (r.track({ type: 1, doc: d }), (g = !0), (l || c) && (a = !0)),
          g &&
            (f
              ? ((o = o.add(f)), (s = m ? s.add(u) : s.delete(u)))
              : ((o = o.delete(u)), (s = s.delete(u))))
      }),
      this.query.limit !== null)
    )
      for (; o.size > this.query.limit; ) {
        const u = this.query.limitType === 'F' ? o.last() : o.first()
        ;(o = o.delete(u.key)), (s = s.delete(u.key)), r.track({ type: 1, doc: u })
      }
    return { Pa: o, Ea: r, Xi: a, mutatedKeys: s }
  }
  da(e, n) {
    return e.hasLocalMutations && n.hasCommittedMutations && !n.hasLocalMutations
  }
  applyChanges(e, n, r, i) {
    const s = this.Pa
    ;(this.Pa = e.Pa), (this.mutatedKeys = e.mutatedKeys)
    const o = e.Ea.k_()
    o.sort(
      (u, h) =>
        (function (f, p) {
          const m = (g) => {
            switch (g) {
              case 0:
                return 1
              case 2:
              case 3:
                return 2
              case 1:
                return 0
              default:
                return Ce()
            }
          }
          return m(f) - m(p)
        })(u.type, h.type) || this.ha(u.doc, h.doc)
    ),
      this.Aa(r),
      (i = i != null && i)
    const a = n && !i ? this.Ra() : [],
      l = this.la.size === 0 && this.current && !i ? 1 : 0,
      c = l !== this.ca
    return (
      (this.ca = l),
      o.length !== 0 || c
        ? {
            snapshot: new _l(
              this.query,
              e.Pa,
              s,
              o,
              e.mutatedKeys,
              l === 0,
              c,
              !1,
              !!r && r.resumeToken.approximateByteSize() > 0
            ),
            Va: a
          }
        : { Va: a }
    )
  }
  G_(e) {
    return this.current && e === 'Offline'
      ? ((this.current = !1),
        this.applyChanges({ Pa: this.Pa, Ea: new rw(), mutatedKeys: this.mutatedKeys, Xi: !1 }, !1))
      : { Va: [] }
  }
  ma(e) {
    return !this.ua.has(e) && !!this.Pa.has(e) && !this.Pa.get(e).hasLocalMutations
  }
  Aa(e) {
    e &&
      (e.addedDocuments.forEach((n) => (this.ua = this.ua.add(n))),
      e.modifiedDocuments.forEach((n) => {}),
      e.removedDocuments.forEach((n) => (this.ua = this.ua.delete(n))),
      (this.current = e.current))
  }
  Ra() {
    if (!this.current) return []
    const e = this.la
    ;(this.la = ze()),
      this.Pa.forEach((r) => {
        this.ma(r.key) && (this.la = this.la.add(r.key))
      })
    const n = []
    return (
      e.forEach((r) => {
        this.la.has(r) || n.push(new H2(r))
      }),
      this.la.forEach((r) => {
        e.has(r) || n.push(new $2(r))
      }),
      n
    )
  }
  fa(e) {
    ;(this.ua = e.hs), (this.la = ze())
    const n = this.Ta(e.documents)
    return this.applyChanges(n, !0)
  }
  ga() {
    return _l.fromInitialDocuments(
      this.query,
      this.Pa,
      this.mutatedKeys,
      this.ca === 0,
      this.hasCachedResults
    )
  }
}
class E8 {
  constructor(e, n, r) {
    ;(this.query = e), (this.targetId = n), (this.view = r)
  }
}
class T8 {
  constructor(e) {
    ;(this.key = e), (this.pa = !1)
  }
}
class w8 {
  constructor(e, n, r, i, s, o) {
    ;(this.localStore = e),
      (this.remoteStore = n),
      (this.eventManager = r),
      (this.sharedClientState = i),
      (this.currentUser = s),
      (this.maxConcurrentLimboResolutions = o),
      (this.ya = {}),
      (this.wa = new jl((a) => l2(a), nm)),
      (this.Sa = new Map()),
      (this.ba = new Set()),
      (this.Da = new Rt(_e.comparator)),
      (this.Ca = new Map()),
      (this.va = new s1()),
      (this.Fa = {}),
      (this.Ma = new Map()),
      (this.xa = yl.Ln()),
      (this.onlineState = 'Unknown'),
      (this.Oa = void 0)
  }
  get isPrimaryClient() {
    return this.Oa === !0
  }
}
async function S8(t, e, n = !0) {
  const r = K2(t)
  let i
  const s = r.wa.get(e)
  return (
    s
      ? (r.sharedClientState.addLocalQueryTarget(s.targetId), (i = s.view.ga()))
      : (i = await z2(r, e, n, !0)),
    i
  )
}
async function I8(t, e) {
  const n = K2(t)
  await z2(n, e, !0, !1)
}
async function z2(t, e, n, r) {
  const i = await KB(t.localStore, hi(e)),
    s = i.targetId,
    o = n ? t.sharedClientState.addLocalQueryTarget(s) : 'not-current'
  let a
  return (
    r && (a = await A8(t, e, s, o === 'current', i.resumeToken)),
    t.isPrimaryClient && n && D2(t.remoteStore, i),
    a
  )
}
async function A8(t, e, n, r, i) {
  t.Na = (h, d, f) =>
    (async function (m, g, _, v) {
      let T = g.view.Ta(_)
      T.Xi && (T = await ZT(m.localStore, g.query, !1).then(({ documents: O }) => g.view.Ta(O, T)))
      const S = v && v.targetChanges.get(g.targetId),
        I = v && v.targetMismatches.get(g.targetId) != null,
        w = g.view.applyChanges(T, m.isPrimaryClient, S, I)
      return ow(m, g.targetId, w.Va), w.snapshot
    })(t, h, d, f)
  const s = await ZT(t.localStore, e, !0),
    o = new b8(e, s.hs),
    a = o.Ta(s.documents),
    l = ph.createSynthesizedTargetChangeForCurrentChange(n, r && t.onlineState !== 'Offline', i),
    c = o.applyChanges(a, t.isPrimaryClient, l)
  ow(t, n, c.Va)
  const u = new E8(e, n, o)
  return t.wa.set(e, u), t.Sa.has(n) ? t.Sa.get(n).push(e) : t.Sa.set(n, [e]), c.snapshot
}
async function C8(t, e, n) {
  const r = Pe(t),
    i = r.wa.get(e),
    s = r.Sa.get(i.targetId)
  if (s.length > 1)
    return (
      r.Sa.set(
        i.targetId,
        s.filter((o) => !nm(o, e))
      ),
      void r.wa.delete(e)
    )
  r.isPrimaryClient
    ? (r.sharedClientState.removeLocalQueryTarget(i.targetId),
      r.sharedClientState.isActiveQueryTarget(i.targetId) ||
        (await E_(r.localStore, i.targetId, !1)
          .then(() => {
            r.sharedClientState.clearQueryState(i.targetId),
              n && l1(r.remoteStore, i.targetId),
              w_(r, i.targetId)
          })
          .catch(hh)))
    : (w_(r, i.targetId), await E_(r.localStore, i.targetId, !0))
}
async function R8(t, e) {
  const n = Pe(t),
    r = n.wa.get(e),
    i = n.Sa.get(r.targetId)
  n.isPrimaryClient &&
    i.length === 1 &&
    (n.sharedClientState.removeLocalQueryTarget(r.targetId), l1(n.remoteStore, r.targetId))
}
async function k8(t, e, n) {
  const r = L8(t)
  try {
    const i = await (function (o, a) {
      const l = Pe(o),
        c = $t.now(),
        u = a.reduce((f, p) => f.add(p.key), ze())
      let h, d
      return l.persistence
        .runTransaction('Locally write mutations', 'readwrite', (f) => {
          let p = Wi(),
            m = ze()
          return l.os
            .getEntries(f, u)
            .next((g) => {
              ;(p = g),
                p.forEach((_, v) => {
                  v.isValidDocument() || (m = m.add(_))
                })
            })
            .next(() => l.localDocuments.getOverlayedDocuments(f, p))
            .next((g) => {
              h = g
              const _ = []
              for (const v of a) {
                const T = Z7(v, h.get(v.key).overlayedDocument)
                T != null && _.push(new Xs(v.key, T, t2(T.value.mapValue), cr.exists(!0)))
              }
              return l.mutationQueue.addMutationBatch(f, c, _, a)
            })
            .next((g) => {
              d = g
              const _ = g.applyToLocalDocumentSet(h, m)
              return l.documentOverlayCache.saveOverlays(f, g.batchId, _)
            })
        })
        .then(() => ({ batchId: d.batchId, changes: h2(h) }))
    })(r.localStore, e)
    r.sharedClientState.addPendingMutation(i.batchId),
      (function (o, a, l) {
        let c = o.Fa[o.currentUser.toKey()]
        c || (c = new Rt(et)), (c = c.insert(a, l)), (o.Fa[o.currentUser.toKey()] = c)
      })(r, i.batchId, n),
      await gh(r, i.changes),
      await cm(r.remoteStore)
  } catch (i) {
    const s = f1(i, 'Failed to persist write')
    n.reject(s)
  }
}
async function j2(t, e) {
  const n = Pe(t)
  try {
    const r = await WB(n.localStore, e)
    e.targetChanges.forEach((i, s) => {
      const o = n.Ca.get(s)
      o &&
        (mt(i.addedDocuments.size + i.modifiedDocuments.size + i.removedDocuments.size <= 1),
        i.addedDocuments.size > 0
          ? (o.pa = !0)
          : i.modifiedDocuments.size > 0
          ? mt(o.pa)
          : i.removedDocuments.size > 0 && (mt(o.pa), (o.pa = !1)))
    }),
      await gh(n, r, e)
  } catch (r) {
    await hh(r)
  }
}
function sw(t, e, n) {
  const r = Pe(t)
  if ((r.isPrimaryClient && n === 0) || (!r.isPrimaryClient && n === 1)) {
    const i = []
    r.wa.forEach((s, o) => {
      const a = o.view.G_(e)
      a.snapshot && i.push(a.snapshot)
    }),
      (function (o, a) {
        const l = Pe(o)
        l.onlineState = a
        let c = !1
        l.queries.forEach((u, h) => {
          for (const d of h.Q_) d.G_(a) && (c = !0)
        }),
          c && g1(l)
      })(r.eventManager, e),
      i.length && r.ya.u_(i),
      (r.onlineState = e),
      r.isPrimaryClient && r.sharedClientState.setOnlineState(e)
  }
}
async function O8(t, e, n) {
  const r = Pe(t)
  r.sharedClientState.updateQueryState(e, 'rejected', n)
  const i = r.Ca.get(e),
    s = i && i.key
  if (s) {
    let o = new Rt(_e.comparator)
    o = o.insert(s, kn.newNoDocument(s, Ne.min()))
    const a = ze().add(s),
      l = new om(Ne.min(), new Map(), new Rt(et), o, a)
    await j2(r, l), (r.Da = r.Da.remove(s)), r.Ca.delete(e), _1(r)
  } else
    await E_(r.localStore, e, !1)
      .then(() => w_(r, e, n))
      .catch(hh)
}
async function N8(t, e) {
  const n = Pe(t),
    r = e.batch.batchId
  try {
    const i = await jB(n.localStore, e)
    G2(n, r, null),
      W2(n, r),
      n.sharedClientState.updateMutationState(r, 'acknowledged'),
      await gh(n, i)
  } catch (i) {
    await hh(i)
  }
}
async function M8(t, e, n) {
  const r = Pe(t)
  try {
    const i = await (function (o, a) {
      const l = Pe(o)
      return l.persistence.runTransaction('Reject batch', 'readwrite-primary', (c) => {
        let u
        return l.mutationQueue
          .lookupMutationBatch(c, a)
          .next((h) => (mt(h !== null), (u = h.keys()), l.mutationQueue.removeMutationBatch(c, h)))
          .next(() => l.mutationQueue.performConsistencyCheck(c))
          .next(() => l.documentOverlayCache.removeOverlaysForBatchId(c, u, a))
          .next(() => l.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(c, u))
          .next(() => l.localDocuments.getDocuments(c, u))
      })
    })(r.localStore, e)
    G2(r, e, n), W2(r, e), r.sharedClientState.updateMutationState(e, 'rejected', n), await gh(r, i)
  } catch (i) {
    await hh(i)
  }
}
function W2(t, e) {
  ;(t.Ma.get(e) || []).forEach((n) => {
    n.resolve()
  }),
    t.Ma.delete(e)
}
function G2(t, e, n) {
  const r = Pe(t)
  let i = r.Fa[r.currentUser.toKey()]
  if (i) {
    const s = i.get(e)
    s && (n ? s.reject(n) : s.resolve(), (i = i.remove(e))), (r.Fa[r.currentUser.toKey()] = i)
  }
}
function w_(t, e, n = null) {
  t.sharedClientState.removeLocalQueryTarget(e)
  for (const r of t.Sa.get(e)) t.wa.delete(r), n && t.ya.La(r, n)
  t.Sa.delete(e),
    t.isPrimaryClient &&
      t.va.Vr(e).forEach((r) => {
        t.va.containsKey(r) || q2(t, r)
      })
}
function q2(t, e) {
  t.ba.delete(e.path.canonicalString())
  const n = t.Da.get(e)
  n !== null && (l1(t.remoteStore, n), (t.Da = t.Da.remove(e)), t.Ca.delete(n), _1(t))
}
function ow(t, e, n) {
  for (const r of n)
    r instanceof $2
      ? (t.va.addReference(r.key, e), P8(t, r))
      : r instanceof H2
      ? (ee('SyncEngine', 'Document no longer in limbo: ' + r.key),
        t.va.removeReference(r.key, e),
        t.va.containsKey(r.key) || q2(t, r.key))
      : Ce()
}
function P8(t, e) {
  const n = e.key,
    r = n.path.canonicalString()
  t.Da.get(n) ||
    t.ba.has(r) ||
    (ee('SyncEngine', 'New document in limbo: ' + n), t.ba.add(r), _1(t))
}
function _1(t) {
  for (; t.ba.size > 0 && t.Da.size < t.maxConcurrentLimboResolutions; ) {
    const e = t.ba.values().next().value
    t.ba.delete(e)
    const n = new _e(At.fromString(e)),
      r = t.xa.next()
    t.Ca.set(r, new T8(n)),
      (t.Da = t.Da.insert(n, r)),
      D2(t.remoteStore, new Ts(hi(tm(n.path)), r, 'TargetPurposeLimboResolution', Y0._e))
  }
}
async function gh(t, e, n) {
  const r = Pe(t),
    i = [],
    s = [],
    o = []
  r.wa.isEmpty() ||
    (r.wa.forEach((a, l) => {
      o.push(
        r.Na(l, e, n).then((c) => {
          if (
            ((c || n) &&
              r.isPrimaryClient &&
              r.sharedClientState.updateQueryState(
                l.targetId,
                c != null && c.fromCache ? 'not-current' : 'current'
              ),
            c)
          ) {
            i.push(c)
            const u = a1.Ki(l.targetId, c)
            s.push(u)
          }
        })
      )
    }),
    await Promise.all(o),
    r.ya.u_(i),
    await (async function (l, c) {
      const u = Pe(l)
      try {
        await u.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', (h) =>
          L.forEach(c, (d) =>
            L.forEach(d.qi, (f) =>
              u.persistence.referenceDelegate.addReference(h, d.targetId, f)
            ).next(() =>
              L.forEach(d.Qi, (f) =>
                u.persistence.referenceDelegate.removeReference(h, d.targetId, f)
              )
            )
          )
        )
      } catch (h) {
        if (!dh(h)) throw h
        ee('LocalStore', 'Failed to update sequence numbers: ' + h)
      }
      for (const h of c) {
        const d = h.targetId
        if (!h.fromCache) {
          const f = u.ns.get(d),
            p = f.snapshotVersion,
            m = f.withLastLimboFreeSnapshotVersion(p)
          u.ns = u.ns.insert(d, m)
        }
      }
    })(r.localStore, s))
}
async function x8(t, e) {
  const n = Pe(t)
  if (!n.currentUser.isEqual(e)) {
    ee('SyncEngine', 'User change. New user:', e.toKey())
    const r = await N2(n.localStore, e)
    ;(n.currentUser = e),
      (function (s, o) {
        s.Ma.forEach((a) => {
          a.forEach((l) => {
            l.reject(new ue(V.CANCELLED, o))
          })
        }),
          s.Ma.clear()
      })(n, "'waitForPendingWrites' promise is rejected due to a user change."),
      n.sharedClientState.handleUserChange(e, r.removedBatchIds, r.addedBatchIds),
      await gh(n, r.us)
  }
}
function D8(t, e) {
  const n = Pe(t),
    r = n.Ca.get(e)
  if (r && r.pa) return ze().add(r.key)
  {
    let i = ze()
    const s = n.Sa.get(e)
    if (!s) return i
    for (const o of s) {
      const a = n.wa.get(o)
      i = i.unionWith(a.view.Ia)
    }
    return i
  }
}
function K2(t) {
  const e = Pe(t)
  return (
    (e.remoteStore.remoteSyncer.applyRemoteEvent = j2.bind(null, e)),
    (e.remoteStore.remoteSyncer.getRemoteKeysForTarget = D8.bind(null, e)),
    (e.remoteStore.remoteSyncer.rejectListen = O8.bind(null, e)),
    (e.ya.u_ = _8.bind(null, e.eventManager)),
    (e.ya.La = v8.bind(null, e.eventManager)),
    e
  )
}
function L8(t) {
  const e = Pe(t)
  return (
    (e.remoteStore.remoteSyncer.applySuccessfulWrite = N8.bind(null, e)),
    (e.remoteStore.remoteSyncer.rejectFailedWrite = M8.bind(null, e)),
    e
  )
}
class aw {
  constructor() {
    this.synchronizeTabs = !1
  }
  async initialize(e) {
    ;(this.serializer = am(e.databaseInfo.databaseId)),
      (this.sharedClientState = this.createSharedClientState(e)),
      (this.persistence = this.createPersistence(e)),
      await this.persistence.start(),
      (this.localStore = this.createLocalStore(e)),
      (this.gcScheduler = this.createGarbageCollectionScheduler(e, this.localStore)),
      (this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(e, this.localStore))
  }
  createGarbageCollectionScheduler(e, n) {
    return null
  }
  createIndexBackfillerScheduler(e, n) {
    return null
  }
  createLocalStore(e) {
    return zB(this.persistence, new $B(), e.initialUser, this.serializer)
  }
  createPersistence(e) {
    return new FB(o1.Hr, this.serializer)
  }
  createSharedClientState(e) {
    return new JB()
  }
  async terminate() {
    var e, n
    ;(e = this.gcScheduler) === null || e === void 0 || e.stop(),
      (n = this.indexBackfillerScheduler) === null || n === void 0 || n.stop(),
      this.sharedClientState.shutdown(),
      await this.persistence.shutdown()
  }
}
class V8 {
  async initialize(e, n) {
    this.localStore ||
      ((this.localStore = e.localStore),
      (this.sharedClientState = e.sharedClientState),
      (this.datastore = this.createDatastore(n)),
      (this.remoteStore = this.createRemoteStore(n)),
      (this.eventManager = this.createEventManager(n)),
      (this.syncEngine = this.createSyncEngine(n, !e.synchronizeTabs)),
      (this.sharedClientState.onlineStateHandler = (r) => sw(this.syncEngine, r, 1)),
      (this.remoteStore.remoteSyncer.handleCredentialChange = x8.bind(null, this.syncEngine)),
      await m8(this.remoteStore, this.syncEngine.isPrimaryClient))
  }
  createEventManager(e) {
    return (function () {
      return new y8()
    })()
  }
  createDatastore(e) {
    const n = am(e.databaseInfo.databaseId),
      r = (function (s) {
        return new e8(s)
      })(e.databaseInfo)
    return (function (s, o, a, l) {
      return new r8(s, o, a, l)
    })(e.authCredentials, e.appCheckCredentials, r, n)
  }
  createRemoteStore(e) {
    return (function (r, i, s, o, a) {
      return new s8(r, i, s, o, a)
    })(
      this.localStore,
      this.datastore,
      e.asyncQueue,
      (n) => sw(this.syncEngine, n, 0),
      (function () {
        return tw.D() ? new tw() : new QB()
      })()
    )
  }
  createSyncEngine(e, n) {
    return (function (i, s, o, a, l, c, u) {
      const h = new w8(i, s, o, a, l, c)
      return u && (h.Oa = !0), h
    })(
      this.localStore,
      this.remoteStore,
      this.eventManager,
      this.sharedClientState,
      e.initialUser,
      e.maxConcurrentLimboResolutions,
      n
    )
  }
  async terminate() {
    var e
    await (async function (r) {
      const i = Pe(r)
      ee('RemoteStore', 'RemoteStore shutting down.'),
        i.v_.add(5),
        await mh(i),
        i.M_.shutdown(),
        i.x_.set('Unknown')
    })(this.remoteStore),
      (e = this.datastore) === null || e === void 0 || e.terminate()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class v1 {
  constructor(e) {
    ;(this.observer = e), (this.muted = !1)
  }
  next(e) {
    this.observer.next && this.qa(this.observer.next, e)
  }
  error(e) {
    this.observer.error
      ? this.qa(this.observer.error, e)
      : yi('Uncaught Error in snapshot listener:', e.toString())
  }
  Qa() {
    this.muted = !0
  }
  qa(e, n) {
    this.muted ||
      setTimeout(() => {
        this.muted || e(n)
      }, 0)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class F8 {
  constructor(e, n, r, i) {
    ;(this.authCredentials = e),
      (this.appCheckCredentials = n),
      (this.asyncQueue = r),
      (this.databaseInfo = i),
      (this.user = An.UNAUTHENTICATED),
      (this.clientId = Xk.newId()),
      (this.authCredentialListener = () => Promise.resolve()),
      (this.appCheckCredentialListener = () => Promise.resolve()),
      this.authCredentials.start(r, async (s) => {
        ee('FirestoreClient', 'Received user=', s.uid),
          await this.authCredentialListener(s),
          (this.user = s)
      }),
      this.appCheckCredentials.start(
        r,
        (s) => (
          ee('FirestoreClient', 'Received new app check token=', s),
          this.appCheckCredentialListener(s, this.user)
        )
      )
  }
  get configuration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    }
  }
  setCredentialChangeListener(e) {
    this.authCredentialListener = e
  }
  setAppCheckTokenChangeListener(e) {
    this.appCheckCredentialListener = e
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new ue(V.FAILED_PRECONDITION, 'The client has already been terminated.')
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode()
    const e = new ui()
    return (
      this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
        try {
          this._onlineComponents && (await this._onlineComponents.terminate()),
            this._offlineComponents && (await this._offlineComponents.terminate()),
            this.authCredentials.shutdown(),
            this.appCheckCredentials.shutdown(),
            e.resolve()
        } catch (n) {
          const r = f1(n, 'Failed to shutdown persistence')
          e.reject(r)
        }
      }),
      e.promise
    )
  }
}
async function gg(t, e) {
  t.asyncQueue.verifyOperationInProgress(),
    ee('FirestoreClient', 'Initializing OfflineComponentProvider')
  const n = t.configuration
  await e.initialize(n)
  let r = n.initialUser
  t.setCredentialChangeListener(async (i) => {
    r.isEqual(i) || (await N2(e.localStore, i), (r = i))
  }),
    e.persistence.setDatabaseDeletedListener(() => t.terminate()),
    (t._offlineComponents = e)
}
async function lw(t, e) {
  t.asyncQueue.verifyOperationInProgress()
  const n = await U8(t)
  ee('FirestoreClient', 'Initializing OnlineComponentProvider'),
    await e.initialize(n, t.configuration),
    t.setCredentialChangeListener((r) => nw(e.remoteStore, r)),
    t.setAppCheckTokenChangeListener((r, i) => nw(e.remoteStore, i)),
    (t._onlineComponents = e)
}
function B8(t) {
  return t.name === 'FirebaseError'
    ? t.code === V.FAILED_PRECONDITION || t.code === V.UNIMPLEMENTED
    : !(typeof DOMException < 'u' && t instanceof DOMException) ||
        t.code === 22 ||
        t.code === 20 ||
        t.code === 11
}
async function U8(t) {
  if (!t._offlineComponents)
    if (t._uninitializedComponentsProvider) {
      ee('FirestoreClient', 'Using user provided OfflineComponentProvider')
      try {
        await gg(t, t._uninitializedComponentsProvider._offline)
      } catch (e) {
        const n = e
        if (!B8(n)) throw n
        dl('Error using user provided cache. Falling back to memory cache: ' + n),
          await gg(t, new aw())
      }
    } else ee('FirestoreClient', 'Using default OfflineComponentProvider'), await gg(t, new aw())
  return t._offlineComponents
}
async function Y2(t) {
  return (
    t._onlineComponents ||
      (t._uninitializedComponentsProvider
        ? (ee('FirestoreClient', 'Using user provided OnlineComponentProvider'),
          await lw(t, t._uninitializedComponentsProvider._online))
        : (ee('FirestoreClient', 'Using default OnlineComponentProvider'), await lw(t, new V8()))),
    t._onlineComponents
  )
}
function $8(t) {
  return Y2(t).then((e) => e.syncEngine)
}
async function Nf(t) {
  const e = await Y2(t),
    n = e.eventManager
  return (
    (n.onListen = S8.bind(null, e.syncEngine)),
    (n.onUnlisten = C8.bind(null, e.syncEngine)),
    (n.onFirstRemoteStoreListen = I8.bind(null, e.syncEngine)),
    (n.onLastRemoteStoreUnlisten = R8.bind(null, e.syncEngine)),
    n
  )
}
function H8(t, e, n = {}) {
  const r = new ui()
  return (
    t.asyncQueue.enqueueAndForget(async () =>
      (function (s, o, a, l, c) {
        const u = new v1({
            next: (d) => {
              o.enqueueAndForget(() => m1(s, h))
              const f = d.docs.has(a)
              !f && d.fromCache
                ? c.reject(
                    new ue(V.UNAVAILABLE, 'Failed to get document because the client is offline.')
                  )
                : f && d.fromCache && l && l.source === 'server'
                ? c.reject(
                    new ue(
                      V.UNAVAILABLE,
                      'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)'
                    )
                  )
                : c.resolve(d)
            },
            error: (d) => c.reject(d)
          }),
          h = new y1(tm(a.path), u, { includeMetadataChanges: !0, ta: !0 })
        return p1(s, h)
      })(await Nf(t), t.asyncQueue, e, n, r)
    ),
    r.promise
  )
}
function z8(t, e, n = {}) {
  const r = new ui()
  return (
    t.asyncQueue.enqueueAndForget(async () =>
      (function (s, o, a, l, c) {
        const u = new v1({
            next: (d) => {
              o.enqueueAndForget(() => m1(s, h)),
                d.fromCache && l.source === 'server'
                  ? c.reject(
                      new ue(
                        V.UNAVAILABLE,
                        'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)'
                      )
                    )
                  : c.resolve(d)
            },
            error: (d) => c.reject(d)
          }),
          h = new y1(a, u, { includeMetadataChanges: !0, ta: !0 })
        return p1(s, h)
      })(await Nf(t), t.asyncQueue, e, n, r)
    ),
    r.promise
  )
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function J2(t) {
  const e = {}
  return t.timeoutSeconds !== void 0 && (e.timeoutSeconds = t.timeoutSeconds), e
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const cw = new Map()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Q2(t, e, n) {
  if (!n) throw new ue(V.INVALID_ARGUMENT, `Function ${t}() cannot be called with an empty ${e}.`)
}
function j8(t, e, n, r) {
  if (e === !0 && r === !0)
    throw new ue(V.INVALID_ARGUMENT, `${t} and ${n} cannot be used together.`)
}
function uw(t) {
  if (!_e.isDocumentKey(t))
    throw new ue(
      V.INVALID_ARGUMENT,
      `Invalid document reference. Document references must have an even number of segments, but ${t} has ${t.length}.`
    )
}
function hw(t) {
  if (_e.isDocumentKey(t))
    throw new ue(
      V.INVALID_ARGUMENT,
      `Invalid collection reference. Collection references must have an odd number of segments, but ${t} has ${t.length}.`
    )
}
function b1(t) {
  if (t === void 0) return 'undefined'
  if (t === null) return 'null'
  if (typeof t == 'string')
    return t.length > 20 && (t = `${t.substring(0, 20)}...`), JSON.stringify(t)
  if (typeof t == 'number' || typeof t == 'boolean') return '' + t
  if (typeof t == 'object') {
    if (t instanceof Array) return 'an array'
    {
      const e = (function (r) {
        return r.constructor ? r.constructor.name : null
      })(t)
      return e ? `a custom ${e} object` : 'an object'
    }
  }
  return typeof t == 'function' ? 'a function' : Ce()
}
function ur(t, e) {
  if (('_delegate' in t && (t = t._delegate), !(t instanceof e))) {
    if (e.name === t.constructor.name)
      throw new ue(
        V.INVALID_ARGUMENT,
        'Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?'
      )
    {
      const n = b1(t)
      throw new ue(V.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`)
    }
  }
  return t
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class dw {
  constructor(e) {
    var n, r
    if (e.host === void 0) {
      if (e.ssl !== void 0)
        throw new ue(V.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set")
      ;(this.host = 'firestore.googleapis.com'), (this.ssl = !0)
    } else (this.host = e.host), (this.ssl = (n = e.ssl) === null || n === void 0 || n)
    if (
      ((this.credentials = e.credentials),
      (this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties),
      (this.localCache = e.localCache),
      e.cacheSizeBytes === void 0)
    )
      this.cacheSizeBytes = 41943040
    else {
      if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
        throw new ue(V.INVALID_ARGUMENT, 'cacheSizeBytes must be at least 1048576')
      this.cacheSizeBytes = e.cacheSizeBytes
    }
    j8(
      'experimentalForceLongPolling',
      e.experimentalForceLongPolling,
      'experimentalAutoDetectLongPolling',
      e.experimentalAutoDetectLongPolling
    ),
      (this.experimentalForceLongPolling = !!e.experimentalForceLongPolling),
      this.experimentalForceLongPolling
        ? (this.experimentalAutoDetectLongPolling = !1)
        : e.experimentalAutoDetectLongPolling === void 0
        ? (this.experimentalAutoDetectLongPolling = !0)
        : (this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling),
      (this.experimentalLongPollingOptions = J2(
        (r = e.experimentalLongPollingOptions) !== null && r !== void 0 ? r : {}
      )),
      (function (s) {
        if (s.timeoutSeconds !== void 0) {
          if (isNaN(s.timeoutSeconds))
            throw new ue(
              V.INVALID_ARGUMENT,
              `invalid long polling timeout: ${s.timeoutSeconds} (must not be NaN)`
            )
          if (s.timeoutSeconds < 5)
            throw new ue(
              V.INVALID_ARGUMENT,
              `invalid long polling timeout: ${s.timeoutSeconds} (minimum allowed value is 5)`
            )
          if (s.timeoutSeconds > 30)
            throw new ue(
              V.INVALID_ARGUMENT,
              `invalid long polling timeout: ${s.timeoutSeconds} (maximum allowed value is 30)`
            )
        }
      })(this.experimentalLongPollingOptions),
      (this.useFetchStreams = !!e.useFetchStreams)
  }
  isEqual(e) {
    return (
      this.host === e.host &&
      this.ssl === e.ssl &&
      this.credentials === e.credentials &&
      this.cacheSizeBytes === e.cacheSizeBytes &&
      this.experimentalForceLongPolling === e.experimentalForceLongPolling &&
      this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling &&
      (function (r, i) {
        return r.timeoutSeconds === i.timeoutSeconds
      })(this.experimentalLongPollingOptions, e.experimentalLongPollingOptions) &&
      this.ignoreUndefinedProperties === e.ignoreUndefinedProperties &&
      this.useFetchStreams === e.useFetchStreams
    )
  }
}
class um {
  constructor(e, n, r, i) {
    ;(this._authCredentials = e),
      (this._appCheckCredentials = n),
      (this._databaseId = r),
      (this._app = i),
      (this.type = 'firestore-lite'),
      (this._persistenceKey = '(lite)'),
      (this._settings = new dw({})),
      (this._settingsFrozen = !1)
  }
  get app() {
    if (!this._app)
      throw new ue(
        V.FAILED_PRECONDITION,
        "Firestore was not initialized using the Firebase SDK. 'app' is not available"
      )
    return this._app
  }
  get _initialized() {
    return this._settingsFrozen
  }
  get _terminated() {
    return this._terminateTask !== void 0
  }
  _setSettings(e) {
    if (this._settingsFrozen)
      throw new ue(
        V.FAILED_PRECONDITION,
        'Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.'
      )
    ;(this._settings = new dw(e)),
      e.credentials !== void 0 &&
        (this._authCredentials = (function (r) {
          if (!r) return new o7()
          switch (r.type) {
            case 'firstParty':
              return new u7(r.sessionIndex || '0', r.iamToken || null, r.authTokenFactory || null)
            case 'provider':
              return r.client
            default:
              throw new ue(
                V.INVALID_ARGUMENT,
                'makeAuthCredentialsProvider failed due to invalid credential type'
              )
          }
        })(e.credentials))
  }
  _getSettings() {
    return this._settings
  }
  _freezeSettings() {
    return (this._settingsFrozen = !0), this._settings
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask
  }
  toJSON() {
    return { app: this._app, databaseId: this._databaseId, settings: this._settings }
  }
  _terminate() {
    return (
      (function (n) {
        const r = cw.get(n)
        r && (ee('ComponentProvider', 'Removing Datastore'), cw.delete(n), r.terminate())
      })(this),
      Promise.resolve()
    )
  }
}
function W8(t, e, n, r = {}) {
  var i
  const s = (t = ur(t, um))._getSettings(),
    o = `${e}:${n}`
  if (
    (s.host !== 'firestore.googleapis.com' &&
      s.host !== o &&
      dl(
        'Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used.'
      ),
    t._setSettings(Object.assign(Object.assign({}, s), { host: o, ssl: !1 })),
    r.mockUserToken)
  ) {
    let a, l
    if (typeof r.mockUserToken == 'string') (a = r.mockUserToken), (l = An.MOCK_USER)
    else {
      a = u4(r.mockUserToken, (i = t._app) === null || i === void 0 ? void 0 : i.options.projectId)
      const c = r.mockUserToken.sub || r.mockUserToken.user_id
      if (!c)
        throw new ue(V.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!")
      l = new An(c)
    }
    t._authCredentials = new a7(new Qk(a, l))
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class yh {
  constructor(e, n, r) {
    ;(this.converter = n), (this._query = r), (this.type = 'query'), (this.firestore = e)
  }
  withConverter(e) {
    return new yh(this.firestore, e, this._query)
  }
}
class Un {
  constructor(e, n, r) {
    ;(this.converter = n), (this._key = r), (this.type = 'document'), (this.firestore = e)
  }
  get _path() {
    return this._key.path
  }
  get id() {
    return this._key.path.lastSegment()
  }
  get path() {
    return this._key.path.canonicalString()
  }
  get parent() {
    return new Ms(this.firestore, this.converter, this._key.path.popLast())
  }
  withConverter(e) {
    return new Un(this.firestore, e, this._key)
  }
}
class Ms extends yh {
  constructor(e, n, r) {
    super(e, n, tm(r)), (this._path = r), (this.type = 'collection')
  }
  get id() {
    return this._query.path.lastSegment()
  }
  get path() {
    return this._query.path.canonicalString()
  }
  get parent() {
    const e = this._path.popLast()
    return e.isEmpty() ? null : new Un(this.firestore, null, new _e(e))
  }
  withConverter(e) {
    return new Ms(this.firestore, e, this._path)
  }
}
function mc(t, e, ...n) {
  if (((t = sn(t)), Q2('collection', 'path', e), t instanceof um)) {
    const r = At.fromString(e, ...n)
    return hw(r), new Ms(t, null, r)
  }
  {
    if (!(t instanceof Un || t instanceof Ms))
      throw new ue(
        V.INVALID_ARGUMENT,
        'Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore'
      )
    const r = t._path.child(At.fromString(e, ...n))
    return hw(r), new Ms(t.firestore, null, r)
  }
}
function _r(t, e, ...n) {
  if (
    ((t = sn(t)), arguments.length === 1 && (e = Xk.newId()), Q2('doc', 'path', e), t instanceof um)
  ) {
    const r = At.fromString(e, ...n)
    return uw(r), new Un(t, null, new _e(r))
  }
  {
    if (!(t instanceof Un || t instanceof Ms))
      throw new ue(
        V.INVALID_ARGUMENT,
        'Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore'
      )
    const r = t._path.child(At.fromString(e, ...n))
    return uw(r), new Un(t.firestore, t instanceof Ms ? t.converter : null, new _e(r))
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class G8 {
  constructor() {
    ;(this.nu = Promise.resolve()),
      (this.ru = []),
      (this.iu = !1),
      (this.su = []),
      (this.ou = null),
      (this._u = !1),
      (this.au = !1),
      (this.uu = []),
      (this.jo = new P2(this, 'async_queue_retry')),
      (this.cu = () => {
        const n = mg()
        n && ee('AsyncQueue', 'Visibility state changed to ' + n.visibilityState), this.jo.Ko()
      })
    const e = mg()
    e && typeof e.addEventListener == 'function' && e.addEventListener('visibilitychange', this.cu)
  }
  get isShuttingDown() {
    return this.iu
  }
  enqueueAndForget(e) {
    this.enqueue(e)
  }
  enqueueAndForgetEvenWhileRestricted(e) {
    this.lu(), this.hu(e)
  }
  enterRestrictedMode(e) {
    if (!this.iu) {
      ;(this.iu = !0), (this.au = e || !1)
      const n = mg()
      n &&
        typeof n.removeEventListener == 'function' &&
        n.removeEventListener('visibilitychange', this.cu)
    }
  }
  enqueue(e) {
    if ((this.lu(), this.iu)) return new Promise(() => {})
    const n = new ui()
    return this.hu(() =>
      this.iu && this.au ? Promise.resolve() : (e().then(n.resolve, n.reject), n.promise)
    ).then(() => n.promise)
  }
  enqueueRetryable(e) {
    this.enqueueAndForget(() => (this.ru.push(e), this.Pu()))
  }
  async Pu() {
    if (this.ru.length !== 0) {
      try {
        await this.ru[0](), this.ru.shift(), this.jo.reset()
      } catch (e) {
        if (!dh(e)) throw e
        ee('AsyncQueue', 'Operation failed with retryable error: ' + e)
      }
      this.ru.length > 0 && this.jo.qo(() => this.Pu())
    }
  }
  hu(e) {
    const n = this.nu.then(
      () => (
        (this._u = !0),
        e()
          .catch((r) => {
            ;(this.ou = r), (this._u = !1)
            const i = (function (o) {
              let a = o.message || ''
              return (
                o.stack &&
                  (a = o.stack.includes(o.message)
                    ? o.stack
                    : o.message +
                      `
` +
                      o.stack),
                a
              )
            })(r)
            throw (yi('INTERNAL UNHANDLED ERROR: ', i), r)
          })
          .then((r) => ((this._u = !1), r))
      )
    )
    return (this.nu = n), n
  }
  enqueueAfterDelay(e, n, r) {
    this.lu(), this.uu.indexOf(e) > -1 && (n = 0)
    const i = d1.createAndSchedule(this, e, n, r, (s) => this.Iu(s))
    return this.su.push(i), i
  }
  lu() {
    this.ou && Ce()
  }
  verifyOperationInProgress() {}
  async Tu() {
    let e
    do (e = this.nu), await e
    while (e !== this.nu)
  }
  Eu(e) {
    for (const n of this.su) if (n.timerId === e) return !0
    return !1
  }
  du(e) {
    return this.Tu().then(() => {
      this.su.sort((n, r) => n.targetTimeMs - r.targetTimeMs)
      for (const n of this.su) if ((n.skipDelay(), e !== 'all' && n.timerId === e)) break
      return this.Tu()
    })
  }
  Au(e) {
    this.uu.push(e)
  }
  Iu(e) {
    const n = this.su.indexOf(e)
    this.su.splice(n, 1)
  }
}
function fw(t) {
  return (function (n, r) {
    if (typeof n != 'object' || n === null) return !1
    const i = n
    for (const s of r) if (s in i && typeof i[s] == 'function') return !0
    return !1
  })(t, ['next', 'error', 'complete'])
}
class js extends um {
  constructor(e, n, r, i) {
    super(e, n, r, i),
      (this.type = 'firestore'),
      (this._queue = (function () {
        return new G8()
      })()),
      (this._persistenceKey = (i == null ? void 0 : i.name) || '[DEFAULT]')
  }
  _terminate() {
    return this._firestoreClient || X2(this), this._firestoreClient.terminate()
  }
}
function q8(t, e) {
  const n = typeof t == 'object' ? t : ZA(),
    r = typeof t == 'string' ? t : e || '(default)',
    i = QA(n, 'firestore').getImmediate({ identifier: r })
  if (!i._initialized) {
    const s = l4('firestore')
    s && W8(i, ...s)
  }
  return i
}
function _h(t) {
  return t._firestoreClient || X2(t), t._firestoreClient.verifyNotTerminated(), t._firestoreClient
}
function X2(t) {
  var e, n, r
  const i = t._freezeSettings(),
    s = (function (a, l, c, u) {
      return new S7(
        a,
        l,
        c,
        u.host,
        u.ssl,
        u.experimentalForceLongPolling,
        u.experimentalAutoDetectLongPolling,
        J2(u.experimentalLongPollingOptions),
        u.useFetchStreams
      )
    })(
      t._databaseId,
      ((e = t._app) === null || e === void 0 ? void 0 : e.options.appId) || '',
      t._persistenceKey,
      i
    )
  ;(t._firestoreClient = new F8(t._authCredentials, t._appCheckCredentials, t._queue, s)),
    !((n = i.localCache) === null || n === void 0) &&
      n._offlineComponentProvider &&
      !((r = i.localCache) === null || r === void 0) &&
      r._onlineComponentProvider &&
      (t._firestoreClient._uninitializedComponentsProvider = {
        _offlineKind: i.localCache.kind,
        _offline: i.localCache._offlineComponentProvider,
        _online: i.localCache._onlineComponentProvider
      })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class vl {
  constructor(e) {
    this._byteString = e
  }
  static fromBase64String(e) {
    try {
      return new vl(xn.fromBase64String(e))
    } catch (n) {
      throw new ue(V.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + n)
    }
  }
  static fromUint8Array(e) {
    return new vl(xn.fromUint8Array(e))
  }
  toBase64() {
    return this._byteString.toBase64()
  }
  toUint8Array() {
    return this._byteString.toUint8Array()
  }
  toString() {
    return 'Bytes(base64: ' + this.toBase64() + ')'
  }
  isEqual(e) {
    return this._byteString.isEqual(e._byteString)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class vh {
  constructor(...e) {
    for (let n = 0; n < e.length; ++n)
      if (e[n].length === 0)
        throw new ue(
          V.INVALID_ARGUMENT,
          'Invalid field name at argument $(i + 1). Field names must not be empty.'
        )
    this._internalPath = new vn(e)
  }
  isEqual(e) {
    return this._internalPath.isEqual(e._internalPath)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class hm {
  constructor(e) {
    this._methodName = e
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class dm {
  constructor(e, n) {
    if (!isFinite(e) || e < -90 || e > 90)
      throw new ue(
        V.INVALID_ARGUMENT,
        'Latitude must be a number between -90 and 90, but was: ' + e
      )
    if (!isFinite(n) || n < -180 || n > 180)
      throw new ue(
        V.INVALID_ARGUMENT,
        'Longitude must be a number between -180 and 180, but was: ' + n
      )
    ;(this._lat = e), (this._long = n)
  }
  get latitude() {
    return this._lat
  }
  get longitude() {
    return this._long
  }
  isEqual(e) {
    return this._lat === e._lat && this._long === e._long
  }
  toJSON() {
    return { latitude: this._lat, longitude: this._long }
  }
  _compareTo(e) {
    return et(this._lat, e._lat) || et(this._long, e._long)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const K8 = /^__.*__$/
class Y8 {
  constructor(e, n, r) {
    ;(this.data = e), (this.fieldMask = n), (this.fieldTransforms = r)
  }
  toMutation(e, n) {
    return this.fieldMask !== null
      ? new Xs(e, this.data, this.fieldMask, n, this.fieldTransforms)
      : new fh(e, this.data, n, this.fieldTransforms)
  }
}
class Z2 {
  constructor(e, n, r) {
    ;(this.data = e), (this.fieldMask = n), (this.fieldTransforms = r)
  }
  toMutation(e, n) {
    return new Xs(e, this.data, this.fieldMask, n, this.fieldTransforms)
  }
}
function eO(t) {
  switch (t) {
    case 0:
    case 2:
    case 1:
      return !0
    case 3:
    case 4:
      return !1
    default:
      throw Ce()
  }
}
class fm {
  constructor(e, n, r, i, s, o) {
    ;(this.settings = e),
      (this.databaseId = n),
      (this.serializer = r),
      (this.ignoreUndefinedProperties = i),
      s === void 0 && this.Ru(),
      (this.fieldTransforms = s || []),
      (this.fieldMask = o || [])
  }
  get path() {
    return this.settings.path
  }
  get Vu() {
    return this.settings.Vu
  }
  mu(e) {
    return new fm(
      Object.assign(Object.assign({}, this.settings), e),
      this.databaseId,
      this.serializer,
      this.ignoreUndefinedProperties,
      this.fieldTransforms,
      this.fieldMask
    )
  }
  fu(e) {
    var n
    const r = (n = this.path) === null || n === void 0 ? void 0 : n.child(e),
      i = this.mu({ path: r, gu: !1 })
    return i.pu(e), i
  }
  yu(e) {
    var n
    const r = (n = this.path) === null || n === void 0 ? void 0 : n.child(e),
      i = this.mu({ path: r, gu: !1 })
    return i.Ru(), i
  }
  wu(e) {
    return this.mu({ path: void 0, gu: !0 })
  }
  Su(e) {
    return Mf(e, this.settings.methodName, this.settings.bu || !1, this.path, this.settings.Du)
  }
  contains(e) {
    return (
      this.fieldMask.find((n) => e.isPrefixOf(n)) !== void 0 ||
      this.fieldTransforms.find((n) => e.isPrefixOf(n.field)) !== void 0
    )
  }
  Ru() {
    if (this.path) for (let e = 0; e < this.path.length; e++) this.pu(this.path.get(e))
  }
  pu(e) {
    if (e.length === 0) throw this.Su('Document fields must not be empty')
    if (eO(this.Vu) && K8.test(e)) throw this.Su('Document fields cannot begin and end with "__"')
  }
}
class J8 {
  constructor(e, n, r) {
    ;(this.databaseId = e), (this.ignoreUndefinedProperties = n), (this.serializer = r || am(e))
  }
  Cu(e, n, r, i = !1) {
    return new fm(
      { Vu: e, methodName: n, Du: r, path: vn.emptyPath(), gu: !1, bu: i },
      this.databaseId,
      this.serializer,
      this.ignoreUndefinedProperties
    )
  }
}
function E1(t) {
  const e = t._freezeSettings(),
    n = am(t._databaseId)
  return new J8(t._databaseId, !!e.ignoreUndefinedProperties, n)
}
function tO(t, e, n, r, i, s = {}) {
  const o = t.Cu(s.merge || s.mergeFields ? 2 : 0, e, n, i)
  w1('Data must be an object, but it was:', o, r)
  const a = iO(r, o)
  let l, c
  if (s.merge) (l = new or(o.fieldMask)), (c = o.fieldTransforms)
  else if (s.mergeFields) {
    const u = []
    for (const h of s.mergeFields) {
      const d = S_(e, h, n)
      if (!o.contains(d))
        throw new ue(
          V.INVALID_ARGUMENT,
          `Field '${d}' is specified in your field mask but missing from your input data.`
        )
      oO(u, d) || u.push(d)
    }
    ;(l = new or(u)), (c = o.fieldTransforms.filter((h) => l.covers(h.field)))
  } else (l = null), (c = o.fieldTransforms)
  return new Y8(new qn(a), l, c)
}
class pm extends hm {
  _toFieldTransform(e) {
    if (e.Vu !== 2)
      throw e.Vu === 1
        ? e.Su(`${this._methodName}() can only appear at the top level of your update data`)
        : e.Su(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`)
    return e.fieldMask.push(e.path), null
  }
  isEqual(e) {
    return e instanceof pm
  }
}
function Q8(t, e, n) {
  return new fm(
    { Vu: 3, Du: e.settings.Du, methodName: t._methodName, gu: n },
    e.databaseId,
    e.serializer,
    e.ignoreUndefinedProperties
  )
}
class T1 extends hm {
  constructor(e, n) {
    super(e), (this.vu = n)
  }
  _toFieldTransform(e) {
    const n = Q8(this, e, !0),
      r = this.vu.map((s) => bh(s, n)),
      i = new gl(r)
    return new Y7(e.path, i)
  }
  isEqual(e) {
    return e instanceof T1 && lu(this.vu, e.vu)
  }
}
function nO(t, e, n, r) {
  const i = t.Cu(1, e, n)
  w1('Data must be an object, but it was:', i, r)
  const s = [],
    o = qn.empty()
  pa(r, (l, c) => {
    const u = S1(e, l, n)
    c = sn(c)
    const h = i.yu(u)
    if (c instanceof pm) s.push(u)
    else {
      const d = bh(c, h)
      d != null && (s.push(u), o.set(u, d))
    }
  })
  const a = new or(s)
  return new Z2(o, a, i.fieldTransforms)
}
function rO(t, e, n, r, i, s) {
  const o = t.Cu(1, e, n),
    a = [S_(e, r, n)],
    l = [i]
  if (s.length % 2 != 0)
    throw new ue(
      V.INVALID_ARGUMENT,
      `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`
    )
  for (let d = 0; d < s.length; d += 2) a.push(S_(e, s[d])), l.push(s[d + 1])
  const c = [],
    u = qn.empty()
  for (let d = a.length - 1; d >= 0; --d)
    if (!oO(c, a[d])) {
      const f = a[d]
      let p = l[d]
      p = sn(p)
      const m = o.yu(f)
      if (p instanceof pm) c.push(f)
      else {
        const g = bh(p, m)
        g != null && (c.push(f), u.set(f, g))
      }
    }
  const h = new or(c)
  return new Z2(u, h, o.fieldTransforms)
}
function bh(t, e) {
  if (sO((t = sn(t)))) return w1('Unsupported field value:', e, t), iO(t, e)
  if (t instanceof hm)
    return (
      (function (r, i) {
        if (!eO(i.Vu)) throw i.Su(`${r._methodName}() can only be used with update() and set()`)
        if (!i.path) throw i.Su(`${r._methodName}() is not currently supported inside arrays`)
        const s = r._toFieldTransform(i)
        s && i.fieldTransforms.push(s)
      })(t, e),
      null
    )
  if (t === void 0 && e.ignoreUndefinedProperties) return null
  if ((e.path && e.fieldMask.push(e.path), t instanceof Array)) {
    if (e.settings.gu && e.Vu !== 4) throw e.Su('Nested arrays are not supported')
    return (function (r, i) {
      const s = []
      let o = 0
      for (const a of r) {
        let l = bh(a, i.wu(o))
        l == null && (l = { nullValue: 'NULL_VALUE' }), s.push(l), o++
      }
      return { arrayValue: { values: s } }
    })(t, e)
  }
  return (function (r, i) {
    if ((r = sn(r)) === null) return { nullValue: 'NULL_VALUE' }
    if (typeof r == 'number') return G7(i.serializer, r)
    if (typeof r == 'boolean') return { booleanValue: r }
    if (typeof r == 'string') return { stringValue: r }
    if (r instanceof Date) {
      const s = $t.fromDate(r)
      return { timestampValue: kf(i.serializer, s) }
    }
    if (r instanceof $t) {
      const s = new $t(r.seconds, 1e3 * Math.floor(r.nanoseconds / 1e3))
      return { timestampValue: kf(i.serializer, s) }
    }
    if (r instanceof dm) return { geoPointValue: { latitude: r.latitude, longitude: r.longitude } }
    if (r instanceof vl) return { bytesValue: S2(i.serializer, r._byteString) }
    if (r instanceof Un) {
      const s = i.databaseId,
        o = r.firestore._databaseId
      if (!o.isEqual(s))
        throw i.Su(
          `Document reference is for database ${o.projectId}/${o.database} but should be for database ${s.projectId}/${s.database}`
        )
      return { referenceValue: i1(r.firestore._databaseId || i.databaseId, r._key.path) }
    }
    throw i.Su(`Unsupported field value: ${b1(r)}`)
  })(t, e)
}
function iO(t, e) {
  const n = {}
  return (
    Zk(t)
      ? e.path && e.path.length > 0 && e.fieldMask.push(e.path)
      : pa(t, (r, i) => {
          const s = bh(i, e.fu(r))
          s != null && (n[r] = s)
        }),
    { mapValue: { fields: n } }
  )
}
function sO(t) {
  return !(
    typeof t != 'object' ||
    t === null ||
    t instanceof Array ||
    t instanceof Date ||
    t instanceof $t ||
    t instanceof dm ||
    t instanceof vl ||
    t instanceof Un ||
    t instanceof hm
  )
}
function w1(t, e, n) {
  if (
    !sO(n) ||
    !(function (i) {
      return (
        typeof i == 'object' &&
        i !== null &&
        (Object.getPrototypeOf(i) === Object.prototype || Object.getPrototypeOf(i) === null)
      )
    })(n)
  ) {
    const r = b1(n)
    throw r === 'an object' ? e.Su(t + ' a custom object') : e.Su(t + ' ' + r)
  }
}
function S_(t, e, n) {
  if ((e = sn(e)) instanceof vh) return e._internalPath
  if (typeof e == 'string') return S1(t, e)
  throw Mf('Field path arguments must be of type string or ', t, !1, void 0, n)
}
const X8 = new RegExp('[~\\*/\\[\\]]')
function S1(t, e, n) {
  if (e.search(X8) >= 0)
    throw Mf(
      `Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,
      t,
      !1,
      void 0,
      n
    )
  try {
    return new vh(...e.split('.'))._internalPath
  } catch {
    throw Mf(
      `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      t,
      !1,
      void 0,
      n
    )
  }
}
function Mf(t, e, n, r, i) {
  const s = r && !r.isEmpty(),
    o = i !== void 0
  let a = `Function ${e}() called with invalid data`
  n && (a += ' (via `toFirestore()`)'), (a += '. ')
  let l = ''
  return (
    (s || o) &&
      ((l += ' (found'), s && (l += ` in field ${r}`), o && (l += ` in document ${i}`), (l += ')')),
    new ue(V.INVALID_ARGUMENT, a + t + l)
  )
}
function oO(t, e) {
  return t.some((n) => n.isEqual(e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class aO {
  constructor(e, n, r, i, s) {
    ;(this._firestore = e),
      (this._userDataWriter = n),
      (this._key = r),
      (this._document = i),
      (this._converter = s)
  }
  get id() {
    return this._key.path.lastSegment()
  }
  get ref() {
    return new Un(this._firestore, this._converter, this._key)
  }
  exists() {
    return this._document !== null
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const e = new Z8(this._firestore, this._userDataWriter, this._key, this._document, null)
        return this._converter.fromFirestore(e)
      }
      return this._userDataWriter.convertValue(this._document.data.value)
    }
  }
  get(e) {
    if (this._document) {
      const n = this._document.data.field(lO('DocumentSnapshot.get', e))
      if (n !== null) return this._userDataWriter.convertValue(n)
    }
  }
}
class Z8 extends aO {
  data() {
    return super.data()
  }
}
function lO(t, e) {
  return typeof e == 'string'
    ? S1(t, e)
    : e instanceof vh
    ? e._internalPath
    : e._delegate._internalPath
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function cO(t) {
  if (t.limitType === 'L' && t.explicitOrderBy.length === 0)
    throw new ue(
      V.UNIMPLEMENTED,
      'limitToLast() queries require specifying at least one orderBy() clause'
    )
}
class eU {
  convertValue(e, n = 'none') {
    switch (ea(e)) {
      case 0:
        return null
      case 1:
        return e.booleanValue
      case 2:
        return Vt(e.integerValue || e.doubleValue)
      case 3:
        return this.convertTimestamp(e.timestampValue)
      case 4:
        return this.convertServerTimestamp(e, n)
      case 5:
        return e.stringValue
      case 6:
        return this.convertBytes(Zo(e.bytesValue))
      case 7:
        return this.convertReference(e.referenceValue)
      case 8:
        return this.convertGeoPoint(e.geoPointValue)
      case 9:
        return this.convertArray(e.arrayValue, n)
      case 10:
        return this.convertObject(e.mapValue, n)
      default:
        throw Ce()
    }
  }
  convertObject(e, n) {
    return this.convertObjectMap(e.fields, n)
  }
  convertObjectMap(e, n = 'none') {
    const r = {}
    return (
      pa(e, (i, s) => {
        r[i] = this.convertValue(s, n)
      }),
      r
    )
  }
  convertGeoPoint(e) {
    return new dm(Vt(e.latitude), Vt(e.longitude))
  }
  convertArray(e, n) {
    return (e.values || []).map((r) => this.convertValue(r, n))
  }
  convertServerTimestamp(e, n) {
    switch (n) {
      case 'previous':
        const r = Q0(e)
        return r == null ? null : this.convertValue(r, n)
      case 'estimate':
        return this.convertTimestamp(wu(e))
      default:
        return null
    }
  }
  convertTimestamp(e) {
    const n = Hs(e)
    return new $t(n.seconds, n.nanos)
  }
  convertDocumentKey(e, n) {
    const r = At.fromString(e)
    mt(O2(r))
    const i = new Su(r.get(1), r.get(3)),
      s = new _e(r.popFirst(5))
    return (
      i.isEqual(n) ||
        yi(
          `Document ${s} contains a document reference within a different database (${i.projectId}/${i.database}) which is not supported. It will be treated as a reference in the current database (${n.projectId}/${n.database}) instead.`
        ),
      s
    )
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function uO(t, e, n) {
  let r
  return (r = t ? (n && (n.merge || n.mergeFields) ? t.toFirestore(e, n) : t.toFirestore(e)) : e), r
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class gc {
  constructor(e, n) {
    ;(this.hasPendingWrites = e), (this.fromCache = n)
  }
  isEqual(e) {
    return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache
  }
}
class hO extends aO {
  constructor(e, n, r, i, s, o) {
    super(e, n, r, i, o), (this._firestore = e), (this._firestoreImpl = e), (this.metadata = s)
  }
  exists() {
    return super.exists()
  }
  data(e = {}) {
    if (this._document) {
      if (this._converter) {
        const n = new Nd(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          this.metadata,
          null
        )
        return this._converter.fromFirestore(n, e)
      }
      return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps)
    }
  }
  get(e, n = {}) {
    if (this._document) {
      const r = this._document.data.field(lO('DocumentSnapshot.get', e))
      if (r !== null) return this._userDataWriter.convertValue(r, n.serverTimestamps)
    }
  }
}
class Nd extends hO {
  data(e = {}) {
    return super.data(e)
  }
}
class dO {
  constructor(e, n, r, i) {
    ;(this._firestore = e),
      (this._userDataWriter = n),
      (this._snapshot = i),
      (this.metadata = new gc(i.hasPendingWrites, i.fromCache)),
      (this.query = r)
  }
  get docs() {
    const e = []
    return this.forEach((n) => e.push(n)), e
  }
  get size() {
    return this._snapshot.docs.size
  }
  get empty() {
    return this.size === 0
  }
  forEach(e, n) {
    this._snapshot.docs.forEach((r) => {
      e.call(
        n,
        new Nd(
          this._firestore,
          this._userDataWriter,
          r.key,
          r,
          new gc(this._snapshot.mutatedKeys.has(r.key), this._snapshot.fromCache),
          this.query.converter
        )
      )
    })
  }
  docChanges(e = {}) {
    const n = !!e.includeMetadataChanges
    if (n && this._snapshot.excludesMetadataChanges)
      throw new ue(
        V.INVALID_ARGUMENT,
        'To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().'
      )
    return (
      (this._cachedChanges && this._cachedChangesIncludeMetadataChanges === n) ||
        ((this._cachedChanges = (function (i, s) {
          if (i._snapshot.oldDocs.isEmpty()) {
            let o = 0
            return i._snapshot.docChanges.map((a) => {
              const l = new Nd(
                i._firestore,
                i._userDataWriter,
                a.doc.key,
                a.doc,
                new gc(i._snapshot.mutatedKeys.has(a.doc.key), i._snapshot.fromCache),
                i.query.converter
              )
              return a.doc, { type: 'added', doc: l, oldIndex: -1, newIndex: o++ }
            })
          }
          {
            let o = i._snapshot.oldDocs
            return i._snapshot.docChanges
              .filter((a) => s || a.type !== 3)
              .map((a) => {
                const l = new Nd(
                  i._firestore,
                  i._userDataWriter,
                  a.doc.key,
                  a.doc,
                  new gc(i._snapshot.mutatedKeys.has(a.doc.key), i._snapshot.fromCache),
                  i.query.converter
                )
                let c = -1,
                  u = -1
                return (
                  a.type !== 0 && ((c = o.indexOf(a.doc.key)), (o = o.delete(a.doc.key))),
                  a.type !== 1 && ((o = o.add(a.doc)), (u = o.indexOf(a.doc.key))),
                  { type: tU(a.type), doc: l, oldIndex: c, newIndex: u }
                )
              })
          }
        })(this, n)),
        (this._cachedChangesIncludeMetadataChanges = n)),
      this._cachedChanges
    )
  }
}
function tU(t) {
  switch (t) {
    case 0:
      return 'added'
    case 2:
    case 3:
      return 'modified'
    case 1:
      return 'removed'
    default:
      return Ce()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function I1(t) {
  t = ur(t, Un)
  const e = ur(t.firestore, js)
  return H8(_h(e), t._key).then((n) => pO(e, t, n))
}
class A1 extends eU {
  constructor(e) {
    super(), (this.firestore = e)
  }
  convertBytes(e) {
    return new vl(e)
  }
  convertReference(e) {
    const n = this.convertDocumentKey(e, this.firestore._databaseId)
    return new Un(this.firestore, null, n)
  }
}
function fO(t) {
  t = ur(t, yh)
  const e = ur(t.firestore, js),
    n = _h(e),
    r = new A1(e)
  return cO(t._query), z8(n, t._query).then((i) => new dO(e, r, t, i))
}
function pw(t, e, n) {
  t = ur(t, Un)
  const r = ur(t.firestore, js),
    i = uO(t.converter, e, n)
  return R1(r, [
    tO(E1(r), 'setDoc', t._key, i, t.converter !== null, n).toMutation(t._key, cr.none())
  ])
}
function I_(t, e, n, ...r) {
  t = ur(t, Un)
  const i = ur(t.firestore, js),
    s = E1(i)
  let o
  return (
    (o =
      typeof (e = sn(e)) == 'string' || e instanceof vh
        ? rO(s, 'updateDoc', t._key, e, n, r)
        : nO(s, 'updateDoc', t._key, e)),
    R1(i, [o.toMutation(t._key, cr.exists(!0))])
  )
}
function C1(t, ...e) {
  var n, r, i
  t = sn(t)
  let s = { includeMetadataChanges: !1, source: 'default' },
    o = 0
  typeof e[o] != 'object' || fw(e[o]) || ((s = e[o]), o++)
  const a = { includeMetadataChanges: s.includeMetadataChanges, source: s.source }
  if (fw(e[o])) {
    const h = e[o]
    ;(e[o] = (n = h.next) === null || n === void 0 ? void 0 : n.bind(h)),
      (e[o + 1] = (r = h.error) === null || r === void 0 ? void 0 : r.bind(h)),
      (e[o + 2] = (i = h.complete) === null || i === void 0 ? void 0 : i.bind(h))
  }
  let l, c, u
  if (t instanceof Un)
    (c = ur(t.firestore, js)),
      (u = tm(t._key.path)),
      (l = {
        next: (h) => {
          e[o] && e[o](pO(c, t, h))
        },
        error: e[o + 1],
        complete: e[o + 2]
      })
  else {
    const h = ur(t, yh)
    ;(c = ur(h.firestore, js)), (u = h._query)
    const d = new A1(c)
    ;(l = {
      next: (f) => {
        e[o] && e[o](new dO(c, d, h, f))
      },
      error: e[o + 1],
      complete: e[o + 2]
    }),
      cO(t._query)
  }
  return (function (d, f, p, m) {
    const g = new v1(m),
      _ = new y1(f, g, p)
    return (
      d.asyncQueue.enqueueAndForget(async () => p1(await Nf(d), _)),
      () => {
        g.Qa(), d.asyncQueue.enqueueAndForget(async () => m1(await Nf(d), _))
      }
    )
  })(_h(c), u, a, l)
}
function R1(t, e) {
  return (function (r, i) {
    const s = new ui()
    return r.asyncQueue.enqueueAndForget(async () => k8(await $8(r), i, s)), s.promise
  })(_h(t), e)
}
function pO(t, e, n) {
  const r = n.docs.get(e._key),
    i = new A1(t)
  return new hO(t, i, e._key, r, new gc(n.hasPendingWrites, n.fromCache), e.converter)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class nU {
  constructor(e, n) {
    ;(this._firestore = e),
      (this._commitHandler = n),
      (this._mutations = []),
      (this._committed = !1),
      (this._dataReader = E1(e))
  }
  set(e, n, r) {
    this._verifyNotCommitted()
    const i = yg(e, this._firestore),
      s = uO(i.converter, n, r),
      o = tO(this._dataReader, 'WriteBatch.set', i._key, s, i.converter !== null, r)
    return this._mutations.push(o.toMutation(i._key, cr.none())), this
  }
  update(e, n, r, ...i) {
    this._verifyNotCommitted()
    const s = yg(e, this._firestore)
    let o
    return (
      (o =
        typeof (n = sn(n)) == 'string' || n instanceof vh
          ? rO(this._dataReader, 'WriteBatch.update', s._key, n, r, i)
          : nO(this._dataReader, 'WriteBatch.update', s._key, n)),
      this._mutations.push(o.toMutation(s._key, cr.exists(!0))),
      this
    )
  }
  delete(e) {
    this._verifyNotCommitted()
    const n = yg(e, this._firestore)
    return (this._mutations = this._mutations.concat(new t1(n._key, cr.none()))), this
  }
  commit() {
    return (
      this._verifyNotCommitted(),
      (this._committed = !0),
      this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
    )
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new ue(
        V.FAILED_PRECONDITION,
        'A write batch can no longer be used after commit() has been called.'
      )
  }
}
function yg(t, e) {
  if ((t = sn(t)).firestore !== e)
    throw new ue(
      V.INVALID_ARGUMENT,
      'Provided document reference is from a different Firestore instance.'
    )
  return t
}
function rU(...t) {
  return new T1('arrayUnion', t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function iU(t) {
  return _h((t = ur(t, js))), new nU(t, (e) => R1(t, e))
}
;(function (e, n = !0) {
  ;(function (i) {
    zl = i
  })(Ys),
    mi(
      new Ur(
        'firestore',
        (r, { instanceIdentifier: i, options: s }) => {
          const o = r.getProvider('app').getImmediate(),
            a = new js(
              new l7(r.getProvider('auth-internal')),
              new d7(r.getProvider('app-check-internal')),
              (function (c, u) {
                if (!Object.prototype.hasOwnProperty.apply(c.options, ['projectId']))
                  throw new ue(
                    V.INVALID_ARGUMENT,
                    '"projectId" not provided in firebase.initializeApp.'
                  )
                return new Su(c.options.projectId, u)
              })(o, i),
              o
            )
          return (s = Object.assign({ useFetchStreams: n }, s)), a._setSettings(s), a
        },
        'PUBLIC'
      ).setMultipleInstances(!0)
    ),
    ar(MT, '4.5.0', e),
    ar(MT, '4.5.0', 'esm2017')
})()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const mO = 'firebasestorage.googleapis.com',
  sU = 'storageBucket',
  oU = 2 * 60 * 1e3,
  aU = 10 * 60 * 1e3
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ai extends Ii {
  constructor(e, n, r = 0) {
    super(_g(e), `Firebase Storage: ${n} (${_g(e)})`),
      (this.status_ = r),
      (this.customData = { serverResponse: null }),
      (this._baseMessage = this.message),
      Object.setPrototypeOf(this, Ai.prototype)
  }
  get status() {
    return this.status_
  }
  set status(e) {
    this.status_ = e
  }
  _codeEquals(e) {
    return _g(e) === this.code
  }
  get serverResponse() {
    return this.customData.serverResponse
  }
  set serverResponse(e) {
    ;(this.customData.serverResponse = e),
      this.customData.serverResponse
        ? (this.message = `${this._baseMessage}
${this.customData.serverResponse}`)
        : (this.message = this._baseMessage)
  }
}
var bi
;(function (t) {
  ;(t.UNKNOWN = 'unknown'),
    (t.OBJECT_NOT_FOUND = 'object-not-found'),
    (t.BUCKET_NOT_FOUND = 'bucket-not-found'),
    (t.PROJECT_NOT_FOUND = 'project-not-found'),
    (t.QUOTA_EXCEEDED = 'quota-exceeded'),
    (t.UNAUTHENTICATED = 'unauthenticated'),
    (t.UNAUTHORIZED = 'unauthorized'),
    (t.UNAUTHORIZED_APP = 'unauthorized-app'),
    (t.RETRY_LIMIT_EXCEEDED = 'retry-limit-exceeded'),
    (t.INVALID_CHECKSUM = 'invalid-checksum'),
    (t.CANCELED = 'canceled'),
    (t.INVALID_EVENT_NAME = 'invalid-event-name'),
    (t.INVALID_URL = 'invalid-url'),
    (t.INVALID_DEFAULT_BUCKET = 'invalid-default-bucket'),
    (t.NO_DEFAULT_BUCKET = 'no-default-bucket'),
    (t.CANNOT_SLICE_BLOB = 'cannot-slice-blob'),
    (t.SERVER_FILE_WRONG_SIZE = 'server-file-wrong-size'),
    (t.NO_DOWNLOAD_URL = 'no-download-url'),
    (t.INVALID_ARGUMENT = 'invalid-argument'),
    (t.INVALID_ARGUMENT_COUNT = 'invalid-argument-count'),
    (t.APP_DELETED = 'app-deleted'),
    (t.INVALID_ROOT_OPERATION = 'invalid-root-operation'),
    (t.INVALID_FORMAT = 'invalid-format'),
    (t.INTERNAL_ERROR = 'internal-error'),
    (t.UNSUPPORTED_ENVIRONMENT = 'unsupported-environment')
})(bi || (bi = {}))
function _g(t) {
  return 'storage/' + t
}
function lU() {
  const t = 'An unknown error occurred, please check the error payload for server response.'
  return new Ai(bi.UNKNOWN, t)
}
function cU() {
  return new Ai(bi.RETRY_LIMIT_EXCEEDED, 'Max retry time for operation exceeded, please try again.')
}
function uU() {
  return new Ai(bi.CANCELED, 'User canceled the upload/download.')
}
function hU(t) {
  return new Ai(bi.INVALID_URL, "Invalid URL '" + t + "'.")
}
function dU(t) {
  return new Ai(bi.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + t + "'.")
}
function mw(t) {
  return new Ai(bi.INVALID_ARGUMENT, t)
}
function gO() {
  return new Ai(bi.APP_DELETED, 'The Firebase app was deleted.')
}
function fU(t) {
  return new Ai(
    bi.INVALID_ROOT_OPERATION,
    "The operation '" +
      t +
      "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png')."
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Lr {
  constructor(e, n) {
    ;(this.bucket = e), (this.path_ = n)
  }
  get path() {
    return this.path_
  }
  get isRoot() {
    return this.path.length === 0
  }
  fullServerUrl() {
    const e = encodeURIComponent
    return '/b/' + e(this.bucket) + '/o/' + e(this.path)
  }
  bucketOnlyServerUrl() {
    return '/b/' + encodeURIComponent(this.bucket) + '/o'
  }
  static makeFromBucketSpec(e, n) {
    let r
    try {
      r = Lr.makeFromUrl(e, n)
    } catch {
      return new Lr(e, '')
    }
    if (r.path === '') return r
    throw dU(e)
  }
  static makeFromUrl(e, n) {
    let r = null
    const i = '([A-Za-z0-9.\\-_]+)'
    function s(S) {
      S.path.charAt(S.path.length - 1) === '/' && (S.path_ = S.path_.slice(0, -1))
    }
    const o = '(/(.*))?$',
      a = new RegExp('^gs://' + i + o, 'i'),
      l = { bucket: 1, path: 3 }
    function c(S) {
      S.path_ = decodeURIComponent(S.path)
    }
    const u = 'v[A-Za-z0-9_]+',
      h = n.replace(/[.]/g, '\\.'),
      d = '(/([^?#]*).*)?$',
      f = new RegExp(`^https?://${h}/${u}/b/${i}/o${d}`, 'i'),
      p = { bucket: 1, path: 3 },
      m = n === mO ? '(?:storage.googleapis.com|storage.cloud.google.com)' : n,
      g = '([^?#]*)',
      _ = new RegExp(`^https?://${m}/${i}/${g}`, 'i'),
      T = [
        { regex: a, indices: l, postModify: s },
        { regex: f, indices: p, postModify: c },
        { regex: _, indices: { bucket: 1, path: 2 }, postModify: c }
      ]
    for (let S = 0; S < T.length; S++) {
      const I = T[S],
        w = I.regex.exec(e)
      if (w) {
        const O = w[I.indices.bucket]
        let P = w[I.indices.path]
        P || (P = ''), (r = new Lr(O, P)), I.postModify(r)
        break
      }
    }
    if (r == null) throw hU(e)
    return r
  }
}
class pU {
  constructor(e) {
    this.promise_ = Promise.reject(e)
  }
  getPromise() {
    return this.promise_
  }
  cancel(e = !1) {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function mU(t, e, n) {
  let r = 1,
    i = null,
    s = null,
    o = !1,
    a = 0
  function l() {
    return a === 2
  }
  let c = !1
  function u(...g) {
    c || ((c = !0), e.apply(null, g))
  }
  function h(g) {
    i = setTimeout(() => {
      ;(i = null), t(f, l())
    }, g)
  }
  function d() {
    s && clearTimeout(s)
  }
  function f(g, ..._) {
    if (c) {
      d()
      return
    }
    if (g) {
      d(), u.call(null, g, ..._)
      return
    }
    if (l() || o) {
      d(), u.call(null, g, ..._)
      return
    }
    r < 64 && (r *= 2)
    let T
    a === 1 ? ((a = 2), (T = 0)) : (T = (r + Math.random()) * 1e3), h(T)
  }
  let p = !1
  function m(g) {
    p || ((p = !0), d(), !c && (i !== null ? (g || (a = 2), clearTimeout(i), h(0)) : g || (a = 1)))
  }
  return (
    h(0),
    (s = setTimeout(() => {
      ;(o = !0), m(!0)
    }, n)),
    m
  )
}
function gU(t) {
  t(!1)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function yU(t) {
  return t !== void 0
}
function gw(t, e, n, r) {
  if (r < e) throw mw(`Invalid value for '${t}'. Expected ${e} or greater.`)
  if (r > n) throw mw(`Invalid value for '${t}'. Expected ${n} or less.`)
}
function _U(t) {
  const e = encodeURIComponent
  let n = '?'
  for (const r in t)
    if (t.hasOwnProperty(r)) {
      const i = e(r) + '=' + e(t[r])
      n = n + i + '&'
    }
  return (n = n.slice(0, -1)), n
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Pf
;(function (t) {
  ;(t[(t.NO_ERROR = 0)] = 'NO_ERROR'),
    (t[(t.NETWORK_ERROR = 1)] = 'NETWORK_ERROR'),
    (t[(t.ABORT = 2)] = 'ABORT')
})(Pf || (Pf = {}))
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function vU(t, e) {
  const n = t >= 500 && t < 600,
    i = [408, 429].indexOf(t) !== -1,
    s = e.indexOf(t) !== -1
  return n || i || s
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class bU {
  constructor(e, n, r, i, s, o, a, l, c, u, h, d = !0) {
    ;(this.url_ = e),
      (this.method_ = n),
      (this.headers_ = r),
      (this.body_ = i),
      (this.successCodes_ = s),
      (this.additionalRetryCodes_ = o),
      (this.callback_ = a),
      (this.errorCallback_ = l),
      (this.timeout_ = c),
      (this.progressCallback_ = u),
      (this.connectionFactory_ = h),
      (this.retry = d),
      (this.pendingConnection_ = null),
      (this.backoffId_ = null),
      (this.canceled_ = !1),
      (this.appDelete_ = !1),
      (this.promise_ = new Promise((f, p) => {
        ;(this.resolve_ = f), (this.reject_ = p), this.start_()
      }))
  }
  start_() {
    const e = (r, i) => {
        if (i) {
          r(!1, new ed(!1, null, !0))
          return
        }
        const s = this.connectionFactory_()
        this.pendingConnection_ = s
        const o = (a) => {
          const l = a.loaded,
            c = a.lengthComputable ? a.total : -1
          this.progressCallback_ !== null && this.progressCallback_(l, c)
        }
        this.progressCallback_ !== null && s.addUploadProgressListener(o),
          s.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
            this.progressCallback_ !== null && s.removeUploadProgressListener(o),
              (this.pendingConnection_ = null)
            const a = s.getErrorCode() === Pf.NO_ERROR,
              l = s.getStatus()
            if (!a || (vU(l, this.additionalRetryCodes_) && this.retry)) {
              const u = s.getErrorCode() === Pf.ABORT
              r(!1, new ed(!1, null, u))
              return
            }
            const c = this.successCodes_.indexOf(l) !== -1
            r(!0, new ed(c, s))
          })
      },
      n = (r, i) => {
        const s = this.resolve_,
          o = this.reject_,
          a = i.connection
        if (i.wasSuccessCode)
          try {
            const l = this.callback_(a, a.getResponse())
            yU(l) ? s(l) : s()
          } catch (l) {
            o(l)
          }
        else if (a !== null) {
          const l = lU()
          ;(l.serverResponse = a.getErrorText()),
            this.errorCallback_ ? o(this.errorCallback_(a, l)) : o(l)
        } else if (i.canceled) {
          const l = this.appDelete_ ? gO() : uU()
          o(l)
        } else {
          const l = cU()
          o(l)
        }
      }
    this.canceled_ ? n(!1, new ed(!1, null, !0)) : (this.backoffId_ = mU(e, n, this.timeout_))
  }
  getPromise() {
    return this.promise_
  }
  cancel(e) {
    ;(this.canceled_ = !0),
      (this.appDelete_ = e || !1),
      this.backoffId_ !== null && gU(this.backoffId_),
      this.pendingConnection_ !== null && this.pendingConnection_.abort()
  }
}
class ed {
  constructor(e, n, r) {
    ;(this.wasSuccessCode = e), (this.connection = n), (this.canceled = !!r)
  }
}
function EU(t, e) {
  e !== null && e.length > 0 && (t.Authorization = 'Firebase ' + e)
}
function TU(t, e) {
  t['X-Firebase-Storage-Version'] = 'webjs/' + (e ?? 'AppManager')
}
function wU(t, e) {
  e && (t['X-Firebase-GMPID'] = e)
}
function SU(t, e) {
  e !== null && (t['X-Firebase-AppCheck'] = e)
}
function IU(t, e, n, r, i, s, o = !0) {
  const a = _U(t.urlParams),
    l = t.url + a,
    c = Object.assign({}, t.headers)
  return (
    wU(c, e),
    EU(c, n),
    TU(c, s),
    SU(c, r),
    new bU(
      l,
      t.method,
      c,
      t.body,
      t.successCodes,
      t.additionalRetryCodes,
      t.handler,
      t.errorHandler,
      t.timeout,
      t.progressCallback,
      i,
      o
    )
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function AU(t) {
  if (t.length === 0) return null
  const e = t.lastIndexOf('/')
  return e === -1 ? '' : t.slice(0, e)
}
function CU(t) {
  const e = t.lastIndexOf('/', t.length - 2)
  return e === -1 ? t : t.slice(e + 1)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class xf {
  constructor(e, n) {
    ;(this._service = e),
      n instanceof Lr ? (this._location = n) : (this._location = Lr.makeFromUrl(n, e.host))
  }
  toString() {
    return 'gs://' + this._location.bucket + '/' + this._location.path
  }
  _newRef(e, n) {
    return new xf(e, n)
  }
  get root() {
    const e = new Lr(this._location.bucket, '')
    return this._newRef(this._service, e)
  }
  get bucket() {
    return this._location.bucket
  }
  get fullPath() {
    return this._location.path
  }
  get name() {
    return CU(this._location.path)
  }
  get storage() {
    return this._service
  }
  get parent() {
    const e = AU(this._location.path)
    if (e === null) return null
    const n = new Lr(this._location.bucket, e)
    return new xf(this._service, n)
  }
  _throwIfRoot(e) {
    if (this._location.path === '') throw fU(e)
  }
}
function yw(t, e) {
  const n = e == null ? void 0 : e[sU]
  return n == null ? null : Lr.makeFromBucketSpec(n, t)
}
class RU {
  constructor(e, n, r, i, s) {
    ;(this.app = e),
      (this._authProvider = n),
      (this._appCheckProvider = r),
      (this._url = i),
      (this._firebaseVersion = s),
      (this._bucket = null),
      (this._host = mO),
      (this._protocol = 'https'),
      (this._appId = null),
      (this._deleted = !1),
      (this._maxOperationRetryTime = oU),
      (this._maxUploadRetryTime = aU),
      (this._requests = new Set()),
      i != null
        ? (this._bucket = Lr.makeFromBucketSpec(i, this._host))
        : (this._bucket = yw(this._host, this.app.options))
  }
  get host() {
    return this._host
  }
  set host(e) {
    ;(this._host = e),
      this._url != null
        ? (this._bucket = Lr.makeFromBucketSpec(this._url, e))
        : (this._bucket = yw(e, this.app.options))
  }
  get maxUploadRetryTime() {
    return this._maxUploadRetryTime
  }
  set maxUploadRetryTime(e) {
    gw('time', 0, Number.POSITIVE_INFINITY, e), (this._maxUploadRetryTime = e)
  }
  get maxOperationRetryTime() {
    return this._maxOperationRetryTime
  }
  set maxOperationRetryTime(e) {
    gw('time', 0, Number.POSITIVE_INFINITY, e), (this._maxOperationRetryTime = e)
  }
  async _getAuthToken() {
    if (this._overrideAuthToken) return this._overrideAuthToken
    const e = this._authProvider.getImmediate({ optional: !0 })
    if (e) {
      const n = await e.getToken()
      if (n !== null) return n.accessToken
    }
    return null
  }
  async _getAppCheckToken() {
    const e = this._appCheckProvider.getImmediate({ optional: !0 })
    return e ? (await e.getToken()).token : null
  }
  _delete() {
    return (
      this._deleted ||
        ((this._deleted = !0), this._requests.forEach((e) => e.cancel()), this._requests.clear()),
      Promise.resolve()
    )
  }
  _makeStorageReference(e) {
    return new xf(this, e)
  }
  _makeRequest(e, n, r, i, s = !0) {
    if (this._deleted) return new pU(gO())
    {
      const o = IU(e, this._appId, r, i, n, this._firebaseVersion, s)
      return (
        this._requests.add(o),
        o.getPromise().then(
          () => this._requests.delete(o),
          () => this._requests.delete(o)
        ),
        o
      )
    }
  }
  async makeRequestWithTokens(e, n) {
    const [r, i] = await Promise.all([this._getAuthToken(), this._getAppCheckToken()])
    return this._makeRequest(e, n, r, i).getPromise()
  }
}
const _w = '@firebase/storage',
  vw = '0.12.2'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const kU = 'storage'
function OU(t, { instanceIdentifier: e }) {
  const n = t.getProvider('app').getImmediate(),
    r = t.getProvider('auth-internal'),
    i = t.getProvider('app-check-internal')
  return new RU(n, r, i, e, Ys)
}
function NU() {
  mi(new Ur(kU, OU, 'PUBLIC').setMultipleInstances(!0)), ar(_w, vw, ''), ar(_w, vw, 'esm2017')
}
NU()
const vg = new WeakMap()
function yO(t, e) {
  return vg.has(e) || vg.set(e, t || { f: {}, r: {}, s: {}, u: {} }), vg.get(e)
}
function MU(t, e, n, r) {
  if (!t) return n
  const [i, s] = _O(t)
  if (!i) return n
  const o = yO(void 0, r)[i] || {},
    a = e || s
  return a && a in o ? o[a] : n
}
function PU(t, e, n, r) {
  if (!t) return
  const [i, s] = _O(t)
  if (!i) return
  const o = yO(void 0, r)[i],
    a = e || s
  if (a)
    return (
      n
        .then((l) => {
          o[a] = l
        })
        .catch(ei),
      a
    )
}
function _O(t) {
  return o5(t) || a5(t)
    ? ['f', t.path]
    : l5(t)
    ? ['r', t.toString()]
    : c5(t)
    ? ['s', t.toString()]
    : []
}
const bg = new WeakMap()
function xU(t, e, n) {
  const r = Np()
  bg.has(r) || bg.set(r, new Map())
  const i = bg.get(r),
    s = PU(e, n, t, r)
  return s && i.set(s, t), s ? () => i.delete(s) : ei
}
const DU = {
  toFirestore(t) {
    return t
  },
  fromFirestore(t, e) {
    return t.exists() ? Object.defineProperties(t.data(e), { id: { value: t.id } }) : null
  }
}
function A_(t, e, n, r) {
  if (!i5(t)) return [t, {}]
  const i = [{}, {}],
    s = Object.keys(n).reduce((a, l) => {
      const c = n[l]
      return (a[c.path] = c.data()), a
    }, {})
  function o(a, l, c, u) {
    l = l || {}
    const [h, d] = u
    Object.getOwnPropertyNames(a).forEach((f) => {
      const p = Object.getOwnPropertyDescriptor(a, f)
      p && !p.enumerable && Object.defineProperty(h, f, p)
    })
    for (const f in a) {
      const p = a[f]
      if (p == null || p instanceof Date || p instanceof $t || p instanceof dm) h[f] = p
      else if (n0(p)) {
        const m = c + f
        ;(h[f] = m in n ? l[f] : p.path), (d[m] = p.converter ? p : p.withConverter(r.converter))
      } else if (Array.isArray(p)) {
        h[f] = Array(p.length)
        for (let m = 0; m < p.length; m++) {
          const g = p[m]
          g && g.path in s && (h[f][m] = s[g.path])
        }
        o(p, l[f] || h[f], c + f + '.', [h[f], d])
      } else ua(p) ? ((h[f] = {}), o(p, l[f], c + f + '.', [h[f], d])) : (h[f] = p)
    }
  }
  return o(t, e, '', i), i
}
const k1 = {
  reset: !1,
  wait: !0,
  maxRefDepth: 2,
  converter: DU,
  snapshotOptions: { serverTimestamps: 'estimate' }
}
function Df(t) {
  for (const e in t) t[e].unsub()
}
function C_(t, e, n, r, i, s, o, a, l) {
  const [c, u] = A_(r.data(t.snapshotOptions), t0(e, n), i, t)
  s.set(e, n, c), R_(t, e, n, i, u, s, o, a, l)
}
function LU({ ref: t, target: e, path: n, depth: r, resolve: i, reject: s, ops: o }, a) {
  const l = Object.create(null)
  let c = ei
  return (
    a.once
      ? I1(t)
          .then((u) => {
            u.exists() ? C_(a, e, n, u, l, o, r, i, s) : (o.set(e, n, null), i())
          })
          .catch(s)
      : (c = C1(
          t,
          (u) => {
            u.exists() ? C_(a, e, n, u, l, o, r, i, s) : (o.set(e, n, null), i())
          },
          s
        )),
    () => {
      c(), Df(l)
    }
  )
}
function R_(t, e, n, r, i, s, o, a, l) {
  const c = Object.keys(i)
  if (
    (Object.keys(r)
      .filter((m) => c.indexOf(m) < 0)
      .forEach((m) => {
        r[m].unsub(), delete r[m]
      }),
    !c.length || ++o > t.maxRefDepth)
  )
    return a(n)
  let h = 0
  const d = c.length,
    f = Object.create(null)
  function p(m) {
    m in f && ++h >= d && a(n)
  }
  c.forEach((m) => {
    const g = r[m],
      _ = i[m],
      v = `${n}.${m}`
    if (((f[v] = !0), g))
      if (g.path !== _.path) g.unsub()
      else return
    r[m] = {
      data: () => t0(e, v),
      unsub: LU(
        { ref: _, target: e, path: v, depth: o, ops: s, resolve: p.bind(null, v), reject: l },
        t
      ),
      path: _.path
    }
  })
}
function VU(t, e, n, r, i, s) {
  const o = Object.assign({}, k1, s),
    { snapshotListenOptions: a, snapshotOptions: l, wait: c, once: u } = o,
    h = 'value'
  let d = Ue(c ? [] : t.value)
  c || n.set(t, h, [])
  const f = r
  let p,
    m = ei
  const g = [],
    _ = {
      added: ({ newIndex: T, doc: S }) => {
        g.splice(T, 0, Object.create(null))
        const I = g[T],
          [w, O] = A_(S.data(l), void 0, I, o)
        n.add(Oi(d), T, w), R_(o, d, `${h}.${T}`, I, O, n, 0, r.bind(null, S), i)
      },
      modified: ({ oldIndex: T, newIndex: S, doc: I }) => {
        const w = Oi(d),
          O = g[T],
          P = w[T],
          [k, U] = A_(I.data(l), P, O, o)
        g.splice(S, 0, O), n.remove(w, T), n.add(w, S, k), R_(o, d, `${h}.${S}`, O, U, n, 0, r, i)
      },
      removed: ({ oldIndex: T }) => {
        const S = Oi(d)
        n.remove(S, T), Df(g.splice(T, 1)[0])
      }
    }
  function v(T) {
    const S = T.docChanges(a)
    if (!p && S.length) {
      p = !0
      let I = 0
      const w = S.length,
        O = Object.create(null)
      for (let P = 0; P < w; P++) O[S[P].doc.id] = !0
      r = (P) => {
        P && P.id in O && ++I >= w && (c && (n.set(t, h, Oi(d)), (d = t)), f(Oi(d)), (r = ei))
      }
    }
    S.forEach((I) => {
      _[I.type](I)
    }),
      S.length || (c && (n.set(t, h, Oi(d)), (d = t)), r(Oi(d)))
  }
  return (
    u ? fO(e).then(v).catch(i) : (m = C1(e, v, i)),
    (T) => {
      if ((m(), T)) {
        const S = typeof T == 'function' ? T() : []
        n.set(t, h, S)
      }
      g.forEach(Df)
    }
  )
}
function FU(t, e, n, r, i, s) {
  const o = Object.assign({}, k1, s),
    a = 'value',
    l = Object.create(null)
  r = u5(r, () => t0(t, a))
  let c = ei
  function u(h) {
    h.exists() ? C_(o, t, a, h, l, n, 0, r, i) : (n.set(t, a, null), r(null))
  }
  return (
    o.once ? I1(e).then(u).catch(i) : (c = C1(e, u, i)),
    (h) => {
      if ((c(), h)) {
        const d = typeof h == 'function' ? h() : null
        n.set(t, a, d)
      }
      Df(l)
    }
  )
}
const bw = Symbol()
function vO(t, e) {
  let n = ei
  const r = Object.assign({}, k1, e),
    i = Oi(t),
    s = r.target || Ue()
  d5() && (r.once = !0)
  const o = MU(i, r.ssrKey, bw, Np()),
    a = o !== bw
  a && (s.value = o)
  let l = !a
  const c = Ue(!1),
    u = Ue(),
    h = oA(),
    d = Tv()
  let f = ei
  function p() {
    let _ = Oi(t)
    const v = new Promise((T, S) => {
      if ((n(r.reset), !_)) return (n = ei), T(null)
      ;(c.value = l),
        (l = !0),
        _.converter || (_ = _.withConverter(r.converter)),
        (n = (n0(_) ? FU : VU)(s, _, BU, T, S, r))
    })
      .catch((T) => (h.value === v && (u.value = T), Promise.reject(T)))
      .finally(() => {
        h.value === v && (c.value = !1)
      })
    h.value = v
  }
  let m = ei
  ;(rn(t) || typeof t == 'function') && (m = Bi(t, p)),
    p(),
    i && (f = xU(h.value, i, r.ssrKey)),
    ca() && TA(() => h.value),
    d && WI(g)
  function g(_ = r.reset) {
    m(), f(), n(_)
  }
  return Object.defineProperties(s, {
    error: { get: () => u },
    data: { get: () => s },
    pending: { get: () => c },
    promise: { get: () => h },
    stop: { get: () => g }
  })
}
const BU = {
  set: (t, e, n) => n5(t, e, n),
  add: (t, e, n) => t.splice(e, 0, n),
  remove: (t, e) => t.splice(e, 1)
}
function Eg(t, e) {
  return vO(t, { target: Ue([]), ...e })
}
function bO(t, e) {
  return vO(t, e)
}
function UU(t) {
  return $U({
    initialUser: t,
    dependencies: { popupRedirectResolver: w6, persistence: [xL, TL, wC] }
  })
}
const EO = Symbol('VueFireAuth')
function $U({ dependencies: t, initialUser: e }) {
  return (n, r) => {
    const [i, s] = HU(n, r, e, t)
    m5(i, s)
  }
}
function HU(t, e, n, r, i = hL(t, r)) {
  const s = f5(t, e).run(() => Ue(n))
  return xC.set(t, s), e.provide(EO, i), [s, i]
}
function zU(t) {
  return t5 ? Kn(EO) : null
}
function jU(t, { firebaseApp: e, modules: n = [] }) {
  t.provide(PC, e)
  for (const r of n) r(e, t)
}
/*!
 * vue-router v4.3.0
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */ const Ca = typeof document < 'u'
function WU(t) {
  return t.__esModule || t[Symbol.toStringTag] === 'Module'
}
const rt = Object.assign
function Tg(t, e) {
  const n = {}
  for (const r in e) {
    const i = e[r]
    n[r] = zr(i) ? i.map(t) : t(i)
  }
  return n
}
const $c = () => {},
  zr = Array.isArray,
  TO = /#/g,
  GU = /&/g,
  qU = /\//g,
  KU = /=/g,
  YU = /\?/g,
  wO = /\+/g,
  JU = /%5B/g,
  QU = /%5D/g,
  SO = /%5E/g,
  XU = /%60/g,
  IO = /%7B/g,
  ZU = /%7C/g,
  AO = /%7D/g,
  e$ = /%20/g
function O1(t) {
  return encodeURI('' + t)
    .replace(ZU, '|')
    .replace(JU, '[')
    .replace(QU, ']')
}
function t$(t) {
  return O1(t).replace(IO, '{').replace(AO, '}').replace(SO, '^')
}
function k_(t) {
  return O1(t)
    .replace(wO, '%2B')
    .replace(e$, '+')
    .replace(TO, '%23')
    .replace(GU, '%26')
    .replace(XU, '`')
    .replace(IO, '{')
    .replace(AO, '}')
    .replace(SO, '^')
}
function n$(t) {
  return k_(t).replace(KU, '%3D')
}
function r$(t) {
  return O1(t).replace(TO, '%23').replace(YU, '%3F')
}
function i$(t) {
  return t == null ? '' : r$(t).replace(qU, '%2F')
}
function Cu(t) {
  try {
    return decodeURIComponent('' + t)
  } catch {}
  return '' + t
}
const s$ = /\/$/,
  o$ = (t) => t.replace(s$, '')
function wg(t, e, n = '/') {
  let r,
    i = {},
    s = '',
    o = ''
  const a = e.indexOf('#')
  let l = e.indexOf('?')
  return (
    a < l && a >= 0 && (l = -1),
    l > -1 && ((r = e.slice(0, l)), (s = e.slice(l + 1, a > -1 ? a : e.length)), (i = t(s))),
    a > -1 && ((r = r || e.slice(0, a)), (o = e.slice(a, e.length))),
    (r = u$(r ?? e, n)),
    { fullPath: r + (s && '?') + s + o, path: r, query: i, hash: Cu(o) }
  )
}
function a$(t, e) {
  const n = e.query ? t(e.query) : ''
  return e.path + (n && '?') + n + (e.hash || '')
}
function Ew(t, e) {
  return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || '/'
}
function l$(t, e, n) {
  const r = e.matched.length - 1,
    i = n.matched.length - 1
  return (
    r > -1 &&
    r === i &&
    bl(e.matched[r], n.matched[i]) &&
    CO(e.params, n.params) &&
    t(e.query) === t(n.query) &&
    e.hash === n.hash
  )
}
function bl(t, e) {
  return (t.aliasOf || t) === (e.aliasOf || e)
}
function CO(t, e) {
  if (Object.keys(t).length !== Object.keys(e).length) return !1
  for (const n in t) if (!c$(t[n], e[n])) return !1
  return !0
}
function c$(t, e) {
  return zr(t) ? Tw(t, e) : zr(e) ? Tw(e, t) : t === e
}
function Tw(t, e) {
  return zr(e)
    ? t.length === e.length && t.every((n, r) => n === e[r])
    : t.length === 1 && t[0] === e
}
function u$(t, e) {
  if (t.startsWith('/')) return t
  if (!t) return e
  const n = e.split('/'),
    r = t.split('/'),
    i = r[r.length - 1]
  ;(i === '..' || i === '.') && r.push('')
  let s = n.length - 1,
    o,
    a
  for (o = 0; o < r.length; o++)
    if (((a = r[o]), a !== '.'))
      if (a === '..') s > 1 && s--
      else break
  return n.slice(0, s).join('/') + '/' + r.slice(o).join('/')
}
var Ru
;(function (t) {
  ;(t.pop = 'pop'), (t.push = 'push')
})(Ru || (Ru = {}))
var Hc
;(function (t) {
  ;(t.back = 'back'), (t.forward = 'forward'), (t.unknown = '')
})(Hc || (Hc = {}))
function h$(t) {
  if (!t)
    if (Ca) {
      const e = document.querySelector('base')
      ;(t = (e && e.getAttribute('href')) || '/'), (t = t.replace(/^\w+:\/\/[^\/]+/, ''))
    } else t = '/'
  return t[0] !== '/' && t[0] !== '#' && (t = '/' + t), o$(t)
}
const d$ = /^[^#]+#/
function f$(t, e) {
  return t.replace(d$, '#') + e
}
function p$(t, e) {
  const n = document.documentElement.getBoundingClientRect(),
    r = t.getBoundingClientRect()
  return {
    behavior: e.behavior,
    left: r.left - n.left - (e.left || 0),
    top: r.top - n.top - (e.top || 0)
  }
}
const mm = () => ({ left: window.scrollX, top: window.scrollY })
function m$(t) {
  let e
  if ('el' in t) {
    const n = t.el,
      r = typeof n == 'string' && n.startsWith('#'),
      i =
        typeof n == 'string'
          ? r
            ? document.getElementById(n.slice(1))
            : document.querySelector(n)
          : n
    if (!i) return
    e = p$(i, t)
  } else e = t
  'scrollBehavior' in document.documentElement.style
    ? window.scrollTo(e)
    : window.scrollTo(
        e.left != null ? e.left : window.scrollX,
        e.top != null ? e.top : window.scrollY
      )
}
function ww(t, e) {
  return (history.state ? history.state.position - e : -1) + t
}
const O_ = new Map()
function g$(t, e) {
  O_.set(t, e)
}
function y$(t) {
  const e = O_.get(t)
  return O_.delete(t), e
}
let _$ = () => location.protocol + '//' + location.host
function RO(t, e) {
  const { pathname: n, search: r, hash: i } = e,
    s = t.indexOf('#')
  if (s > -1) {
    let a = i.includes(t.slice(s)) ? t.slice(s).length : 1,
      l = i.slice(a)
    return l[0] !== '/' && (l = '/' + l), Ew(l, '')
  }
  return Ew(n, t) + r + i
}
function v$(t, e, n, r) {
  let i = [],
    s = [],
    o = null
  const a = ({ state: d }) => {
    const f = RO(t, location),
      p = n.value,
      m = e.value
    let g = 0
    if (d) {
      if (((n.value = f), (e.value = d), o && o === p)) {
        o = null
        return
      }
      g = m ? d.position - m.position : 0
    } else r(f)
    i.forEach((_) => {
      _(n.value, p, {
        delta: g,
        type: Ru.pop,
        direction: g ? (g > 0 ? Hc.forward : Hc.back) : Hc.unknown
      })
    })
  }
  function l() {
    o = n.value
  }
  function c(d) {
    i.push(d)
    const f = () => {
      const p = i.indexOf(d)
      p > -1 && i.splice(p, 1)
    }
    return s.push(f), f
  }
  function u() {
    const { history: d } = window
    d.state && d.replaceState(rt({}, d.state, { scroll: mm() }), '')
  }
  function h() {
    for (const d of s) d()
    ;(s = []),
      window.removeEventListener('popstate', a),
      window.removeEventListener('beforeunload', u)
  }
  return (
    window.addEventListener('popstate', a),
    window.addEventListener('beforeunload', u, { passive: !0 }),
    { pauseListeners: l, listen: c, destroy: h }
  )
}
function Sw(t, e, n, r = !1, i = !1) {
  return {
    back: t,
    current: e,
    forward: n,
    replaced: r,
    position: window.history.length,
    scroll: i ? mm() : null
  }
}
function b$(t) {
  const { history: e, location: n } = window,
    r = { value: RO(t, n) },
    i = { value: e.state }
  i.value ||
    s(
      r.value,
      {
        back: null,
        current: r.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
      },
      !0
    )
  function s(l, c, u) {
    const h = t.indexOf('#'),
      d = h > -1 ? (n.host && document.querySelector('base') ? t : t.slice(h)) + l : _$() + t + l
    try {
      e[u ? 'replaceState' : 'pushState'](c, '', d), (i.value = c)
    } catch (f) {
      console.error(f), n[u ? 'replace' : 'assign'](d)
    }
  }
  function o(l, c) {
    const u = rt({}, e.state, Sw(i.value.back, l, i.value.forward, !0), c, {
      position: i.value.position
    })
    s(l, u, !0), (r.value = l)
  }
  function a(l, c) {
    const u = rt({}, i.value, e.state, { forward: l, scroll: mm() })
    s(u.current, u, !0)
    const h = rt({}, Sw(r.value, l, null), { position: u.position + 1 }, c)
    s(l, h, !1), (r.value = l)
  }
  return { location: r, state: i, push: a, replace: o }
}
function E$(t) {
  t = h$(t)
  const e = b$(t),
    n = v$(t, e.state, e.location, e.replace)
  function r(s, o = !0) {
    o || n.pauseListeners(), history.go(s)
  }
  const i = rt({ location: '', base: t, go: r, createHref: f$.bind(null, t) }, e, n)
  return (
    Object.defineProperty(i, 'location', { enumerable: !0, get: () => e.location.value }),
    Object.defineProperty(i, 'state', { enumerable: !0, get: () => e.state.value }),
    i
  )
}
function T$(t) {
  return (
    (t = location.host ? t || location.pathname + location.search : ''),
    t.includes('#') || (t += '#'),
    E$(t)
  )
}
function w$(t) {
  return typeof t == 'string' || (t && typeof t == 'object')
}
function kO(t) {
  return typeof t == 'string' || typeof t == 'symbol'
}
const is = {
    path: '/',
    name: void 0,
    params: {},
    query: {},
    hash: '',
    fullPath: '/',
    matched: [],
    meta: {},
    redirectedFrom: void 0
  },
  OO = Symbol('')
var Iw
;(function (t) {
  ;(t[(t.aborted = 4)] = 'aborted'),
    (t[(t.cancelled = 8)] = 'cancelled'),
    (t[(t.duplicated = 16)] = 'duplicated')
})(Iw || (Iw = {}))
function El(t, e) {
  return rt(new Error(), { type: t, [OO]: !0 }, e)
}
function Ci(t, e) {
  return t instanceof Error && OO in t && (e == null || !!(t.type & e))
}
const Aw = '[^/]+?',
  S$ = { sensitive: !1, strict: !1, start: !0, end: !0 },
  I$ = /[.+*?^${}()[\]/\\]/g
function A$(t, e) {
  const n = rt({}, S$, e),
    r = []
  let i = n.start ? '^' : ''
  const s = []
  for (const c of t) {
    const u = c.length ? [] : [90]
    n.strict && !c.length && (i += '/')
    for (let h = 0; h < c.length; h++) {
      const d = c[h]
      let f = 40 + (n.sensitive ? 0.25 : 0)
      if (d.type === 0) h || (i += '/'), (i += d.value.replace(I$, '\\$&')), (f += 40)
      else if (d.type === 1) {
        const { value: p, repeatable: m, optional: g, regexp: _ } = d
        s.push({ name: p, repeatable: m, optional: g })
        const v = _ || Aw
        if (v !== Aw) {
          f += 10
          try {
            new RegExp(`(${v})`)
          } catch (S) {
            throw new Error(`Invalid custom RegExp for param "${p}" (${v}): ` + S.message)
          }
        }
        let T = m ? `((?:${v})(?:/(?:${v}))*)` : `(${v})`
        h || (T = g && c.length < 2 ? `(?:/${T})` : '/' + T),
          g && (T += '?'),
          (i += T),
          (f += 20),
          g && (f += -8),
          m && (f += -20),
          v === '.*' && (f += -50)
      }
      u.push(f)
    }
    r.push(u)
  }
  if (n.strict && n.end) {
    const c = r.length - 1
    r[c][r[c].length - 1] += 0.7000000000000001
  }
  n.strict || (i += '/?'), n.end ? (i += '$') : n.strict && (i += '(?:/|$)')
  const o = new RegExp(i, n.sensitive ? '' : 'i')
  function a(c) {
    const u = c.match(o),
      h = {}
    if (!u) return null
    for (let d = 1; d < u.length; d++) {
      const f = u[d] || '',
        p = s[d - 1]
      h[p.name] = f && p.repeatable ? f.split('/') : f
    }
    return h
  }
  function l(c) {
    let u = '',
      h = !1
    for (const d of t) {
      ;(!h || !u.endsWith('/')) && (u += '/'), (h = !1)
      for (const f of d)
        if (f.type === 0) u += f.value
        else if (f.type === 1) {
          const { value: p, repeatable: m, optional: g } = f,
            _ = p in c ? c[p] : ''
          if (zr(_) && !m)
            throw new Error(
              `Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`
            )
          const v = zr(_) ? _.join('/') : _
          if (!v)
            if (g) d.length < 2 && (u.endsWith('/') ? (u = u.slice(0, -1)) : (h = !0))
            else throw new Error(`Missing required param "${p}"`)
          u += v
        }
    }
    return u || '/'
  }
  return { re: o, score: r, keys: s, parse: a, stringify: l }
}
function C$(t, e) {
  let n = 0
  for (; n < t.length && n < e.length; ) {
    const r = e[n] - t[n]
    if (r) return r
    n++
  }
  return t.length < e.length
    ? t.length === 1 && t[0] === 80
      ? -1
      : 1
    : t.length > e.length
    ? e.length === 1 && e[0] === 80
      ? 1
      : -1
    : 0
}
function R$(t, e) {
  let n = 0
  const r = t.score,
    i = e.score
  for (; n < r.length && n < i.length; ) {
    const s = C$(r[n], i[n])
    if (s) return s
    n++
  }
  if (Math.abs(i.length - r.length) === 1) {
    if (Cw(r)) return 1
    if (Cw(i)) return -1
  }
  return i.length - r.length
}
function Cw(t) {
  const e = t[t.length - 1]
  return t.length > 0 && e[e.length - 1] < 0
}
const k$ = { type: 0, value: '' },
  O$ = /[a-zA-Z0-9_]/
function N$(t) {
  if (!t) return [[]]
  if (t === '/') return [[k$]]
  if (!t.startsWith('/')) throw new Error(`Invalid path "${t}"`)
  function e(f) {
    throw new Error(`ERR (${n})/"${c}": ${f}`)
  }
  let n = 0,
    r = n
  const i = []
  let s
  function o() {
    s && i.push(s), (s = [])
  }
  let a = 0,
    l,
    c = '',
    u = ''
  function h() {
    c &&
      (n === 0
        ? s.push({ type: 0, value: c })
        : n === 1 || n === 2 || n === 3
        ? (s.length > 1 &&
            (l === '*' || l === '+') &&
            e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
          s.push({
            type: 1,
            value: c,
            regexp: u,
            repeatable: l === '*' || l === '+',
            optional: l === '*' || l === '?'
          }))
        : e('Invalid state to consume buffer'),
      (c = ''))
  }
  function d() {
    c += l
  }
  for (; a < t.length; ) {
    if (((l = t[a++]), l === '\\' && n !== 2)) {
      ;(r = n), (n = 4)
      continue
    }
    switch (n) {
      case 0:
        l === '/' ? (c && h(), o()) : l === ':' ? (h(), (n = 1)) : d()
        break
      case 4:
        d(), (n = r)
        break
      case 1:
        l === '('
          ? (n = 2)
          : O$.test(l)
          ? d()
          : (h(), (n = 0), l !== '*' && l !== '?' && l !== '+' && a--)
        break
      case 2:
        l === ')' ? (u[u.length - 1] == '\\' ? (u = u.slice(0, -1) + l) : (n = 3)) : (u += l)
        break
      case 3:
        h(), (n = 0), l !== '*' && l !== '?' && l !== '+' && a--, (u = '')
        break
      default:
        e('Unknown state')
        break
    }
  }
  return n === 2 && e(`Unfinished custom RegExp for param "${c}"`), h(), o(), i
}
function M$(t, e, n) {
  const r = A$(N$(t.path), n),
    i = rt(r, { record: t, parent: e, children: [], alias: [] })
  return e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i), i
}
function P$(t, e) {
  const n = [],
    r = new Map()
  e = Ow({ strict: !1, end: !0, sensitive: !1 }, e)
  function i(u) {
    return r.get(u)
  }
  function s(u, h, d) {
    const f = !d,
      p = x$(u)
    p.aliasOf = d && d.record
    const m = Ow(e, u),
      g = [p]
    if ('alias' in u) {
      const T = typeof u.alias == 'string' ? [u.alias] : u.alias
      for (const S of T)
        g.push(
          rt({}, p, {
            components: d ? d.record.components : p.components,
            path: S,
            aliasOf: d ? d.record : p
          })
        )
    }
    let _, v
    for (const T of g) {
      const { path: S } = T
      if (h && S[0] !== '/') {
        const I = h.record.path,
          w = I[I.length - 1] === '/' ? '' : '/'
        T.path = h.record.path + (S && w + S)
      }
      if (
        ((_ = M$(T, h, m)),
        d
          ? d.alias.push(_)
          : ((v = v || _), v !== _ && v.alias.push(_), f && u.name && !kw(_) && o(u.name)),
        p.children)
      ) {
        const I = p.children
        for (let w = 0; w < I.length; w++) s(I[w], _, d && d.children[w])
      }
      ;(d = d || _),
        ((_.record.components && Object.keys(_.record.components).length) ||
          _.record.name ||
          _.record.redirect) &&
          l(_)
    }
    return v
      ? () => {
          o(v)
        }
      : $c
  }
  function o(u) {
    if (kO(u)) {
      const h = r.get(u)
      h && (r.delete(u), n.splice(n.indexOf(h), 1), h.children.forEach(o), h.alias.forEach(o))
    } else {
      const h = n.indexOf(u)
      h > -1 &&
        (n.splice(h, 1),
        u.record.name && r.delete(u.record.name),
        u.children.forEach(o),
        u.alias.forEach(o))
    }
  }
  function a() {
    return n
  }
  function l(u) {
    let h = 0
    for (
      ;
      h < n.length && R$(u, n[h]) >= 0 && (u.record.path !== n[h].record.path || !NO(u, n[h]));

    )
      h++
    n.splice(h, 0, u), u.record.name && !kw(u) && r.set(u.record.name, u)
  }
  function c(u, h) {
    let d,
      f = {},
      p,
      m
    if ('name' in u && u.name) {
      if (((d = r.get(u.name)), !d)) throw El(1, { location: u })
      ;(m = d.record.name),
        (f = rt(
          Rw(
            h.params,
            d.keys
              .filter((v) => !v.optional)
              .concat(d.parent ? d.parent.keys.filter((v) => v.optional) : [])
              .map((v) => v.name)
          ),
          u.params &&
            Rw(
              u.params,
              d.keys.map((v) => v.name)
            )
        )),
        (p = d.stringify(f))
    } else if (u.path != null)
      (p = u.path), (d = n.find((v) => v.re.test(p))), d && ((f = d.parse(p)), (m = d.record.name))
    else {
      if (((d = h.name ? r.get(h.name) : n.find((v) => v.re.test(h.path))), !d))
        throw El(1, { location: u, currentLocation: h })
      ;(m = d.record.name), (f = rt({}, h.params, u.params)), (p = d.stringify(f))
    }
    const g = []
    let _ = d
    for (; _; ) g.unshift(_.record), (_ = _.parent)
    return { name: m, path: p, params: f, matched: g, meta: L$(g) }
  }
  return (
    t.forEach((u) => s(u)),
    { addRoute: s, resolve: c, removeRoute: o, getRoutes: a, getRecordMatcher: i }
  )
}
function Rw(t, e) {
  const n = {}
  for (const r of e) r in t && (n[r] = t[r])
  return n
}
function x$(t) {
  return {
    path: t.path,
    redirect: t.redirect,
    name: t.name,
    meta: t.meta || {},
    aliasOf: void 0,
    beforeEnter: t.beforeEnter,
    props: D$(t),
    children: t.children || [],
    instances: {},
    leaveGuards: new Set(),
    updateGuards: new Set(),
    enterCallbacks: {},
    components: 'components' in t ? t.components || null : t.component && { default: t.component }
  }
}
function D$(t) {
  const e = {},
    n = t.props || !1
  if ('component' in t) e.default = n
  else for (const r in t.components) e[r] = typeof n == 'object' ? n[r] : n
  return e
}
function kw(t) {
  for (; t; ) {
    if (t.record.aliasOf) return !0
    t = t.parent
  }
  return !1
}
function L$(t) {
  return t.reduce((e, n) => rt(e, n.meta), {})
}
function Ow(t, e) {
  const n = {}
  for (const r in t) n[r] = r in e ? e[r] : t[r]
  return n
}
function NO(t, e) {
  return e.children.some((n) => n === t || NO(t, n))
}
function V$(t) {
  const e = {}
  if (t === '' || t === '?') return e
  const r = (t[0] === '?' ? t.slice(1) : t).split('&')
  for (let i = 0; i < r.length; ++i) {
    const s = r[i].replace(wO, ' '),
      o = s.indexOf('='),
      a = Cu(o < 0 ? s : s.slice(0, o)),
      l = o < 0 ? null : Cu(s.slice(o + 1))
    if (a in e) {
      let c = e[a]
      zr(c) || (c = e[a] = [c]), c.push(l)
    } else e[a] = l
  }
  return e
}
function Nw(t) {
  let e = ''
  for (let n in t) {
    const r = t[n]
    if (((n = n$(n)), r == null)) {
      r !== void 0 && (e += (e.length ? '&' : '') + n)
      continue
    }
    ;(zr(r) ? r.map((s) => s && k_(s)) : [r && k_(r)]).forEach((s) => {
      s !== void 0 && ((e += (e.length ? '&' : '') + n), s != null && (e += '=' + s))
    })
  }
  return e
}
function F$(t) {
  const e = {}
  for (const n in t) {
    const r = t[n]
    r !== void 0 &&
      (e[n] = zr(r) ? r.map((i) => (i == null ? null : '' + i)) : r == null ? r : '' + r)
  }
  return e
}
const B$ = Symbol(''),
  Mw = Symbol(''),
  gm = Symbol(''),
  N1 = Symbol(''),
  N_ = Symbol('')
function oc() {
  let t = []
  function e(r) {
    return (
      t.push(r),
      () => {
        const i = t.indexOf(r)
        i > -1 && t.splice(i, 1)
      }
    )
  }
  function n() {
    t = []
  }
  return { add: e, list: () => t.slice(), reset: n }
}
function fs(t, e, n, r, i, s = (o) => o()) {
  const o = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || [])
  return () =>
    new Promise((a, l) => {
      const c = (d) => {
          d === !1
            ? l(El(4, { from: n, to: e }))
            : d instanceof Error
            ? l(d)
            : w$(d)
            ? l(El(2, { from: e, to: d }))
            : (o && r.enterCallbacks[i] === o && typeof d == 'function' && o.push(d), a())
        },
        u = s(() => t.call(r && r.instances[i], e, n, c))
      let h = Promise.resolve(u)
      t.length < 3 && (h = h.then(c)), h.catch((d) => l(d))
    })
}
function Sg(t, e, n, r, i = (s) => s()) {
  const s = []
  for (const o of t)
    for (const a in o.components) {
      let l = o.components[a]
      if (!(e !== 'beforeRouteEnter' && !o.instances[a]))
        if (U$(l)) {
          const u = (l.__vccOpts || l)[e]
          u && s.push(fs(u, n, r, o, a, i))
        } else {
          let c = l()
          s.push(() =>
            c.then((u) => {
              if (!u)
                return Promise.reject(new Error(`Couldn't resolve component "${a}" at "${o.path}"`))
              const h = WU(u) ? u.default : u
              o.components[a] = h
              const f = (h.__vccOpts || h)[e]
              return f && fs(f, n, r, o, a, i)()
            })
          )
        }
    }
  return s
}
function U$(t) {
  return typeof t == 'object' || 'displayName' in t || 'props' in t || '__vccOpts' in t
}
function Pw(t) {
  const e = Kn(gm),
    n = Kn(N1),
    r = Bt(() => e.resolve(Xe(t.to))),
    i = Bt(() => {
      const { matched: l } = r.value,
        { length: c } = l,
        u = l[c - 1],
        h = n.matched
      if (!u || !h.length) return -1
      const d = h.findIndex(bl.bind(null, u))
      if (d > -1) return d
      const f = xw(l[c - 2])
      return c > 1 && xw(u) === f && h[h.length - 1].path !== f
        ? h.findIndex(bl.bind(null, l[c - 2]))
        : d
    }),
    s = Bt(() => i.value > -1 && j$(n.params, r.value.params)),
    o = Bt(() => i.value > -1 && i.value === n.matched.length - 1 && CO(n.params, r.value.params))
  function a(l = {}) {
    return z$(l) ? e[Xe(t.replace) ? 'replace' : 'push'](Xe(t.to)).catch($c) : Promise.resolve()
  }
  return { route: r, href: Bt(() => r.value.href), isActive: s, isExactActive: o, navigate: a }
}
const $$ = Wr({
    name: 'RouterLink',
    compatConfig: { MODE: 3 },
    props: {
      to: { type: [String, Object], required: !0 },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: { type: String, default: 'page' }
    },
    useLink: Pw,
    setup(t, { slots: e }) {
      const n = ju(Pw(t)),
        { options: r } = Kn(gm),
        i = Bt(() => ({
          [Dw(t.activeClass, r.linkActiveClass, 'router-link-active')]: n.isActive,
          [Dw(t.exactActiveClass, r.linkExactActiveClass, 'router-link-exact-active')]:
            n.isExactActive
        }))
      return () => {
        const s = e.default && e.default(n)
        return t.custom
          ? s
          : Do(
              'a',
              {
                'aria-current': n.isExactActive ? t.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: i.value
              },
              s
            )
      }
    }
  }),
  H$ = $$
function z$(t) {
  if (
    !(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) &&
    !t.defaultPrevented &&
    !(t.button !== void 0 && t.button !== 0)
  ) {
    if (t.currentTarget && t.currentTarget.getAttribute) {
      const e = t.currentTarget.getAttribute('target')
      if (/\b_blank\b/i.test(e)) return
    }
    return t.preventDefault && t.preventDefault(), !0
  }
}
function j$(t, e) {
  for (const n in e) {
    const r = e[n],
      i = t[n]
    if (typeof r == 'string') {
      if (r !== i) return !1
    } else if (!zr(i) || i.length !== r.length || r.some((s, o) => s !== i[o])) return !1
  }
  return !0
}
function xw(t) {
  return t ? (t.aliasOf ? t.aliasOf.path : t.path) : ''
}
const Dw = (t, e, n) => t ?? e ?? n,
  W$ = Wr({
    name: 'RouterView',
    inheritAttrs: !1,
    props: { name: { type: String, default: 'default' }, route: Object },
    compatConfig: { MODE: 3 },
    setup(t, { attrs: e, slots: n }) {
      const r = Kn(N_),
        i = Bt(() => t.route || r.value),
        s = Kn(Mw, 0),
        o = Bt(() => {
          let c = Xe(s)
          const { matched: u } = i.value
          let h
          for (; (h = u[c]) && !h.components; ) c++
          return c
        }),
        a = Bt(() => i.value.matched[o.value])
      vd(
        Mw,
        Bt(() => o.value + 1)
      ),
        vd(B$, a),
        vd(N_, i)
      const l = Ue()
      return (
        Bi(
          () => [l.value, a.value, t.name],
          ([c, u, h], [d, f, p]) => {
            u &&
              ((u.instances[h] = c),
              f &&
                f !== u &&
                c &&
                c === d &&
                (u.leaveGuards.size || (u.leaveGuards = f.leaveGuards),
                u.updateGuards.size || (u.updateGuards = f.updateGuards))),
              c && u && (!f || !bl(u, f) || !d) && (u.enterCallbacks[h] || []).forEach((m) => m(c))
          },
          { flush: 'post' }
        ),
        () => {
          const c = i.value,
            u = t.name,
            h = a.value,
            d = h && h.components[u]
          if (!d) return Lw(n.default, { Component: d, route: c })
          const f = h.props[u],
            p = f ? (f === !0 ? c.params : typeof f == 'function' ? f(c) : f) : null,
            g = Do(
              d,
              rt({}, p, e, {
                onVnodeUnmounted: (_) => {
                  _.component.isUnmounted && (h.instances[u] = null)
                },
                ref: l
              })
            )
          return Lw(n.default, { Component: g, route: c }) || g
        }
      )
    }
  })
function Lw(t, e) {
  if (!t) return null
  const n = t(e)
  return n.length === 1 ? n[0] : n
}
const G$ = W$
function q$(t) {
  const e = P$(t.routes, t),
    n = t.parseQuery || V$,
    r = t.stringifyQuery || Nw,
    i = t.history,
    s = oc(),
    o = oc(),
    a = oc(),
    l = oA(is)
  let c = is
  Ca && t.scrollBehavior && 'scrollRestoration' in history && (history.scrollRestoration = 'manual')
  const u = Tg.bind(null, (R) => '' + R),
    h = Tg.bind(null, i$),
    d = Tg.bind(null, Cu)
  function f(R, X) {
    let W, J
    return kO(R) ? ((W = e.getRecordMatcher(R)), (J = X)) : (J = R), e.addRoute(J, W)
  }
  function p(R) {
    const X = e.getRecordMatcher(R)
    X && e.removeRoute(X)
  }
  function m() {
    return e.getRoutes().map((R) => R.record)
  }
  function g(R) {
    return !!e.getRecordMatcher(R)
  }
  function _(R, X) {
    if (((X = rt({}, X || l.value)), typeof R == 'string')) {
      const E = wg(n, R, X.path),
        A = e.resolve({ path: E.path }, X),
        x = i.createHref(E.fullPath)
      return rt(E, A, { params: d(A.params), hash: Cu(E.hash), redirectedFrom: void 0, href: x })
    }
    let W
    if (R.path != null) W = rt({}, R, { path: wg(n, R.path, X.path).path })
    else {
      const E = rt({}, R.params)
      for (const A in E) E[A] == null && delete E[A]
      ;(W = rt({}, R, { params: h(E) })), (X.params = h(X.params))
    }
    const J = e.resolve(W, X),
      Te = R.hash || ''
    J.params = u(d(J.params))
    const ve = a$(r, rt({}, R, { hash: t$(Te), path: J.path })),
      y = i.createHref(ve)
    return rt({ fullPath: ve, hash: Te, query: r === Nw ? F$(R.query) : R.query || {} }, J, {
      redirectedFrom: void 0,
      href: y
    })
  }
  function v(R) {
    return typeof R == 'string' ? wg(n, R, l.value.path) : rt({}, R)
  }
  function T(R, X) {
    if (c !== R) return El(8, { from: X, to: R })
  }
  function S(R) {
    return O(R)
  }
  function I(R) {
    return S(rt(v(R), { replace: !0 }))
  }
  function w(R) {
    const X = R.matched[R.matched.length - 1]
    if (X && X.redirect) {
      const { redirect: W } = X
      let J = typeof W == 'function' ? W(R) : W
      return (
        typeof J == 'string' &&
          ((J = J.includes('?') || J.includes('#') ? (J = v(J)) : { path: J }), (J.params = {})),
        rt({ query: R.query, hash: R.hash, params: J.path != null ? {} : R.params }, J)
      )
    }
  }
  function O(R, X) {
    const W = (c = _(R)),
      J = l.value,
      Te = R.state,
      ve = R.force,
      y = R.replace === !0,
      E = w(W)
    if (E)
      return O(
        rt(v(E), { state: typeof E == 'object' ? rt({}, Te, E.state) : Te, force: ve, replace: y }),
        X || W
      )
    const A = W
    A.redirectedFrom = X
    let x
    return (
      !ve && l$(r, J, W) && ((x = El(16, { to: A, from: J })), Ie(J, J, !0, !1)),
      (x ? Promise.resolve(x) : U(A, J))
        .catch((M) => (Ci(M) ? (Ci(M, 2) ? M : he(M)) : D(M, A, J)))
        .then((M) => {
          if (M) {
            if (Ci(M, 2))
              return O(
                rt({ replace: y }, v(M.to), {
                  state: typeof M.to == 'object' ? rt({}, Te, M.to.state) : Te,
                  force: ve
                }),
                X || A
              )
          } else M = $(A, J, !0, y, Te)
          return F(A, J, M), M
        })
    )
  }
  function P(R, X) {
    const W = T(R, X)
    return W ? Promise.reject(W) : Promise.resolve()
  }
  function k(R) {
    const X = st.values().next().value
    return X && typeof X.runWithContext == 'function' ? X.runWithContext(R) : R()
  }
  function U(R, X) {
    let W
    const [J, Te, ve] = K$(R, X)
    W = Sg(J.reverse(), 'beforeRouteLeave', R, X)
    for (const E of J)
      E.leaveGuards.forEach((A) => {
        W.push(fs(A, R, X))
      })
    const y = P.bind(null, R, X)
    return (
      W.push(y),
      G(W)
        .then(() => {
          W = []
          for (const E of s.list()) W.push(fs(E, R, X))
          return W.push(y), G(W)
        })
        .then(() => {
          W = Sg(Te, 'beforeRouteUpdate', R, X)
          for (const E of Te)
            E.updateGuards.forEach((A) => {
              W.push(fs(A, R, X))
            })
          return W.push(y), G(W)
        })
        .then(() => {
          W = []
          for (const E of ve)
            if (E.beforeEnter)
              if (zr(E.beforeEnter)) for (const A of E.beforeEnter) W.push(fs(A, R, X))
              else W.push(fs(E.beforeEnter, R, X))
          return W.push(y), G(W)
        })
        .then(
          () => (
            R.matched.forEach((E) => (E.enterCallbacks = {})),
            (W = Sg(ve, 'beforeRouteEnter', R, X, k)),
            W.push(y),
            G(W)
          )
        )
        .then(() => {
          W = []
          for (const E of o.list()) W.push(fs(E, R, X))
          return W.push(y), G(W)
        })
        .catch((E) => (Ci(E, 8) ? E : Promise.reject(E)))
    )
  }
  function F(R, X, W) {
    a.list().forEach((J) => k(() => J(R, X, W)))
  }
  function $(R, X, W, J, Te) {
    const ve = T(R, X)
    if (ve) return ve
    const y = X === is,
      E = Ca ? history.state : {}
    W &&
      (J || y
        ? i.replace(R.fullPath, rt({ scroll: y && E && E.scroll }, Te))
        : i.push(R.fullPath, Te)),
      (l.value = R),
      Ie(R, X, W, y),
      he()
  }
  let pe
  function q() {
    pe ||
      (pe = i.listen((R, X, W) => {
        if (!me.listening) return
        const J = _(R),
          Te = w(J)
        if (Te) {
          O(rt(Te, { replace: !0 }), J).catch($c)
          return
        }
        c = J
        const ve = l.value
        Ca && g$(ww(ve.fullPath, W.delta), mm()),
          U(J, ve)
            .catch((y) =>
              Ci(y, 12)
                ? y
                : Ci(y, 2)
                ? (O(y.to, J)
                    .then((E) => {
                      Ci(E, 20) && !W.delta && W.type === Ru.pop && i.go(-1, !1)
                    })
                    .catch($c),
                  Promise.reject())
                : (W.delta && i.go(-W.delta, !1), D(y, J, ve))
            )
            .then((y) => {
              ;(y = y || $(J, ve, !1)),
                y &&
                  (W.delta && !Ci(y, 8)
                    ? i.go(-W.delta, !1)
                    : W.type === Ru.pop && Ci(y, 20) && i.go(-1, !1)),
                F(J, ve, y)
            })
            .catch($c)
      }))
  }
  let z = oc(),
    N = oc(),
    B
  function D(R, X, W) {
    he(R)
    const J = N.list()
    return J.length ? J.forEach((Te) => Te(R, X, W)) : console.error(R), Promise.reject(R)
  }
  function se() {
    return B && l.value !== is
      ? Promise.resolve()
      : new Promise((R, X) => {
          z.add([R, X])
        })
  }
  function he(R) {
    return B || ((B = !R), q(), z.list().forEach(([X, W]) => (R ? W(R) : X())), z.reset()), R
  }
  function Ie(R, X, W, J) {
    const { scrollBehavior: Te } = t
    if (!Ca || !Te) return Promise.resolve()
    const ve =
      (!W && y$(ww(R.fullPath, 0))) || ((J || !W) && history.state && history.state.scroll) || null
    return Pl()
      .then(() => Te(R, X, ve))
      .then((y) => y && m$(y))
      .catch((y) => D(y, R, X))
  }
  const xe = (R) => i.go(R)
  let tt
  const st = new Set(),
    me = {
      currentRoute: l,
      listening: !0,
      addRoute: f,
      removeRoute: p,
      hasRoute: g,
      getRoutes: m,
      resolve: _,
      options: t,
      push: S,
      replace: I,
      go: xe,
      back: () => xe(-1),
      forward: () => xe(1),
      beforeEach: s.add,
      beforeResolve: o.add,
      afterEach: a.add,
      onError: N.add,
      isReady: se,
      install(R) {
        const X = this
        R.component('RouterLink', H$),
          R.component('RouterView', G$),
          (R.config.globalProperties.$router = X),
          Object.defineProperty(R.config.globalProperties, '$route', {
            enumerable: !0,
            get: () => Xe(l)
          }),
          Ca && !tt && l.value === is && ((tt = !0), S(i.location).catch((Te) => {}))
        const W = {}
        for (const Te in is)
          Object.defineProperty(W, Te, { get: () => l.value[Te], enumerable: !0 })
        R.provide(gm, X), R.provide(N1, rA(W)), R.provide(N_, l)
        const J = R.unmount
        st.add(R),
          (R.unmount = function () {
            st.delete(R),
              st.size < 1 &&
                ((c = is), pe && pe(), (pe = null), (l.value = is), (tt = !1), (B = !1)),
              J()
          })
      }
    }
  function G(R) {
    return R.reduce((X, W) => X.then(() => k(W)), Promise.resolve())
  }
  return me
}
function K$(t, e) {
  const n = [],
    r = [],
    i = [],
    s = Math.max(e.matched.length, t.matched.length)
  for (let o = 0; o < s; o++) {
    const a = e.matched[o]
    a && (t.matched.find((c) => bl(c, a)) ? r.push(a) : n.push(a))
    const l = t.matched[o]
    l && (e.matched.find((c) => bl(c, l)) || i.push(l))
  }
  return [n, r, i]
}
function M1() {
  return Kn(gm)
}
function P1() {
  return Kn(N1)
}
const Y$ = ['current'],
  J$ = ['current'],
  Q$ = ['current'],
  X$ = ['src'],
  Z$ = Wr({
    __name: 'menuBar.vapor',
    setup(t) {
      const e = M1(),
        n = P1(),
        r = DC()
      return (i, s) => (
        de(),
        De('header', null, [
          C('nav', null, [
            C(
              'a',
              {
                class: 'btn',
                current: Xe(n).name == 'Home',
                icon: '',
                onClick: s[0] || (s[0] = ht((o) => Xe(e).push({ name: 'Home' }), ['prevent']))
              },
              'home',
              8,
              Y$
            ),
            C(
              'a',
              {
                class: 'btn',
                current: Xe(n).name == 'loginScreen',
                icon: '',
                onClick:
                  s[1] || (s[1] = ht((o) => Xe(e).push({ name: 'loginScreen' }), ['prevent']))
              },
              'person',
              8,
              J$
            ),
            Xe(r)
              ? (de(),
                De(
                  'a',
                  {
                    key: 0,
                    class: 'imgbtn',
                    current: Xe(n).name == 'loginScreen',
                    onClick:
                      s[2] || (s[2] = ht((o) => Xe(e).push({ name: 'loginScreen' }), ['prevent']))
                  },
                  [
                    Xe(r).photoURL
                      ? (de(),
                        De('img', { key: 0, class: 'bobble', src: Xe(r).photoURL }, null, 8, X$))
                      : ft('', !0)
                  ],
                  8,
                  Q$
                ))
              : ft('', !0)
          ])
        ])
      )
    }
  }),
  ga = (t, e) => {
    const n = t.__vccOpts || t
    for (const [r, i] of e) n[r] = i
    return n
  },
  eH = ga(Z$, [['__scopeId', 'data-v-2c138db2']]),
  tH = Wr({
    __name: 'App',
    setup(t) {
      const e = P1()
      return (n, r) => {
        const i = ax('RouterView')
        return (
          de(),
          De('main', null, [
            Be(eH),
            (de(),
            dn(dx, null, { default: xo(() => [(de(), dn(i, { key: Xe(e).fullPath }))]), _: 1 }))
          ])
        )
      }
    }
  })
function MO(t) {
  return Tv() ? (WI(t), !0) : !1
}
function ku(t) {
  return typeof t == 'function' ? t() : Xe(t)
}
const PO = typeof window < 'u' && typeof document < 'u'
typeof WorkerGlobalScope < 'u' && globalThis instanceof WorkerGlobalScope
const nH = (t) => t != null,
  rH = () => {}
function xO(t) {
  return t || ca()
}
function iH(...t) {
  if (t.length !== 1) return JP(...t)
  const e = t[0]
  return typeof e == 'function' ? Rv(cA(() => ({ get: e, set: rH }))) : Ue(e)
}
function sH(t, e) {
  xO(e) && qu(t, e)
}
function oH(t, e = !0, n) {
  xO() ? Gu(t, n) : e ? t() : Pl(t)
}
function DO(t) {
  var e
  const n = ku(t)
  return (e = n == null ? void 0 : n.$el) != null ? e : n
}
const aH = PO ? window : void 0,
  LO = PO ? window.document : void 0
function lH() {
  const t = Ue(!1),
    e = ca()
  return (
    e &&
      Gu(() => {
        t.value = !0
      }, e),
    t
  )
}
function cH(t) {
  const e = lH()
  return Bt(() => (e.value, !!t()))
}
function uH(t, e, n = {}) {
  const { window: r = aH, ...i } = n
  let s
  const o = cH(() => r && 'MutationObserver' in r),
    a = () => {
      s && (s.disconnect(), (s = void 0))
    },
    l = Bt(() => {
      const d = ku(t),
        f = (Array.isArray(d) ? d : [d]).map(DO).filter(nH)
      return new Set(f)
    }),
    c = Bi(
      () => l.value,
      (d) => {
        a(),
          o.value &&
            r &&
            d.size &&
            ((s = new MutationObserver(e)), d.forEach((f) => s.observe(f, i)))
      },
      { immediate: !0, flush: 'post' }
    ),
    u = () => (s == null ? void 0 : s.takeRecords()),
    h = () => {
      a(), c()
    }
  return MO(h), { isSupported: o, stop: h, takeRecords: u }
}
function x1(t = null, e = {}) {
  var n, r, i
  const { document: s = LO, restoreOnUnmount: o = (h) => h } = e,
    a = (n = s == null ? void 0 : s.title) != null ? n : '',
    l = iH((r = t ?? (s == null ? void 0 : s.title)) != null ? r : null),
    c = t && typeof t == 'function'
  function u(h) {
    if (!('titleTemplate' in e)) return h
    const d = e.titleTemplate || '%s'
    return typeof d == 'function' ? d(h) : ku(d).replace(/%s/g, h)
  }
  return (
    Bi(
      l,
      (h, d) => {
        h !== d && s && (s.title = u(typeof h == 'string' ? h : ''))
      },
      { immediate: !0 }
    ),
    e.observe &&
      !e.titleTemplate &&
      s &&
      !c &&
      uH(
        (i = s.head) == null ? void 0 : i.querySelector('title'),
        () => {
          s && s.title !== l.value && (l.value = u(s.title))
        },
        { childList: !0 }
      ),
    sH(() => {
      if (o) {
        const h = o(a, l.value || '')
        h != null && s && (s.title = h)
      }
    }),
    l
  )
}
const Gl = (t) => (yp('data-v-dceb53fe'), (t = t()), _p(), t),
  hH = Gl(() => C('h1', { class: 'font-size-H' }, [dt('Bingo '), C('em', null, 'Bongo')], -1)),
  dH = Gl(() => C('h2', { class: 'font-size-L' }, 'Simplifying OSRS Clan Bingos', -1)),
  fH = { class: 'col-2' },
  pH = { class: 'ghost-board' },
  mH = Gl(() => C('h2', null, 'No more spreadsheets', -1)),
  gH = Gl(() =>
    C(
      'p',
      null,
      " You know how annoying it is to keep track of scores during clan bingos, right? Yeah, it's a pain. ",
      -1
    )
  ),
  yH = Gl(() =>
    C(
      'p',
      null,
      " No more dealing with spreadsheets or scribbling down scores - Bingo Bongo has got my back on that front. It's like having a reliable sidekick for our clan events, making everything run smoothly and keeping the stress levels down. ",
      -1
    )
  ),
  _H = Gl(() => C('div', null, null, -1)),
  vH = Wr({
    __name: 'home.vapor',
    setup(t) {
      const e = x1()
      e.value = 'Bingo Bongo - an osrs bingo app'
      const n = M1(),
        r = new Set(),
        i = (s) => {
          for (; r.size < 3; ) r.add(Math.floor(Math.random() * 9) + 1)
          return r.has(s) ? 'var(--secondary)' : 'var(--primary)'
        }
      return (s, o) => (
        de(),
        De(
          pt,
          null,
          [
            hH,
            dH,
            C('div', fH, [
              C('div', pH, [
                (de(),
                De(
                  pt,
                  null,
                  Fs(9, (a) =>
                    C(
                      'div',
                      {
                        class: 'tile',
                        key: a + 'tile',
                        style: No({
                          '--rotate': Math.random() * 6 - 3 + 'deg',
                          backgroundColor: i(a)
                        })
                      },
                      null,
                      4
                    )
                  ),
                  64
                ))
              ]),
              C('div', null, [
                mH,
                gH,
                yH,
                C(
                  'a',
                  {
                    class: 'btn',
                    big: '',
                    submit: '',
                    onClick: o[0] || (o[0] = (a) => Xe(n).push({ name: 'createNewBingo' }))
                  },
                  'Start a new event!'
                )
              ])
            ]),
            _H
          ],
          64
        )
      )
    }
  }),
  bH = ga(vH, [['__scopeId', 'data-v-dceb53fe']])
var VO =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {}
function FO(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t
}
var BO = { exports: {} }
;(function (t, e) {
  ;(function (n, r) {
    t.exports = r()
  })(VO, function () {
    var n = 1e3,
      r = 6e4,
      i = 36e5,
      s = 'millisecond',
      o = 'second',
      a = 'minute',
      l = 'hour',
      c = 'day',
      u = 'week',
      h = 'month',
      d = 'quarter',
      f = 'year',
      p = 'date',
      m = 'Invalid Date',
      g =
        /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      _ = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      v = {
        name: 'en',
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        months:
          'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
          ),
        ordinal: function (q) {
          var z = ['th', 'st', 'nd', 'rd'],
            N = q % 100
          return '[' + q + (z[(N - 20) % 10] || z[N] || z[0]) + ']'
        }
      },
      T = function (q, z, N) {
        var B = String(q)
        return !B || B.length >= z ? q : '' + Array(z + 1 - B.length).join(N) + q
      },
      S = {
        s: T,
        z: function (q) {
          var z = -q.utcOffset(),
            N = Math.abs(z),
            B = Math.floor(N / 60),
            D = N % 60
          return (z <= 0 ? '+' : '-') + T(B, 2, '0') + ':' + T(D, 2, '0')
        },
        m: function q(z, N) {
          if (z.date() < N.date()) return -q(N, z)
          var B = 12 * (N.year() - z.year()) + (N.month() - z.month()),
            D = z.clone().add(B, h),
            se = N - D < 0,
            he = z.clone().add(B + (se ? -1 : 1), h)
          return +(-(B + (N - D) / (se ? D - he : he - D)) || 0)
        },
        a: function (q) {
          return q < 0 ? Math.ceil(q) || 0 : Math.floor(q)
        },
        p: function (q) {
          return (
            { M: h, y: f, w: u, d: c, D: p, h: l, m: a, s: o, ms: s, Q: d }[q] ||
            String(q || '')
              .toLowerCase()
              .replace(/s$/, '')
          )
        },
        u: function (q) {
          return q === void 0
        }
      },
      I = 'en',
      w = {}
    w[I] = v
    var O = '$isDayjsObject',
      P = function (q) {
        return q instanceof $ || !(!q || !q[O])
      },
      k = function q(z, N, B) {
        var D
        if (!z) return I
        if (typeof z == 'string') {
          var se = z.toLowerCase()
          w[se] && (D = se), N && ((w[se] = N), (D = se))
          var he = z.split('-')
          if (!D && he.length > 1) return q(he[0])
        } else {
          var Ie = z.name
          ;(w[Ie] = z), (D = Ie)
        }
        return !B && D && (I = D), D || (!B && I)
      },
      U = function (q, z) {
        if (P(q)) return q.clone()
        var N = typeof z == 'object' ? z : {}
        return (N.date = q), (N.args = arguments), new $(N)
      },
      F = S
    ;(F.l = k),
      (F.i = P),
      (F.w = function (q, z) {
        return U(q, { locale: z.$L, utc: z.$u, x: z.$x, $offset: z.$offset })
      })
    var $ = (function () {
        function q(N) {
          ;(this.$L = k(N.locale, null, !0)),
            this.parse(N),
            (this.$x = this.$x || N.x || {}),
            (this[O] = !0)
        }
        var z = q.prototype
        return (
          (z.parse = function (N) {
            ;(this.$d = (function (B) {
              var D = B.date,
                se = B.utc
              if (D === null) return new Date(NaN)
              if (F.u(D)) return new Date()
              if (D instanceof Date) return new Date(D)
              if (typeof D == 'string' && !/Z$/i.test(D)) {
                var he = D.match(g)
                if (he) {
                  var Ie = he[2] - 1 || 0,
                    xe = (he[7] || '0').substring(0, 3)
                  return se
                    ? new Date(
                        Date.UTC(he[1], Ie, he[3] || 1, he[4] || 0, he[5] || 0, he[6] || 0, xe)
                      )
                    : new Date(he[1], Ie, he[3] || 1, he[4] || 0, he[5] || 0, he[6] || 0, xe)
                }
              }
              return new Date(D)
            })(N)),
              this.init()
          }),
          (z.init = function () {
            var N = this.$d
            ;(this.$y = N.getFullYear()),
              (this.$M = N.getMonth()),
              (this.$D = N.getDate()),
              (this.$W = N.getDay()),
              (this.$H = N.getHours()),
              (this.$m = N.getMinutes()),
              (this.$s = N.getSeconds()),
              (this.$ms = N.getMilliseconds())
          }),
          (z.$utils = function () {
            return F
          }),
          (z.isValid = function () {
            return this.$d.toString() !== m
          }),
          (z.isSame = function (N, B) {
            var D = U(N)
            return this.startOf(B) <= D && D <= this.endOf(B)
          }),
          (z.isAfter = function (N, B) {
            return U(N) < this.startOf(B)
          }),
          (z.isBefore = function (N, B) {
            return this.endOf(B) < U(N)
          }),
          (z.$g = function (N, B, D) {
            return F.u(N) ? this[B] : this.set(D, N)
          }),
          (z.unix = function () {
            return Math.floor(this.valueOf() / 1e3)
          }),
          (z.valueOf = function () {
            return this.$d.getTime()
          }),
          (z.startOf = function (N, B) {
            var D = this,
              se = !!F.u(B) || B,
              he = F.p(N),
              Ie = function (W, J) {
                var Te = F.w(D.$u ? Date.UTC(D.$y, J, W) : new Date(D.$y, J, W), D)
                return se ? Te : Te.endOf(c)
              },
              xe = function (W, J) {
                return F.w(
                  D.toDate()[W].apply(
                    D.toDate('s'),
                    (se ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(J)
                  ),
                  D
                )
              },
              tt = this.$W,
              st = this.$M,
              me = this.$D,
              G = 'set' + (this.$u ? 'UTC' : '')
            switch (he) {
              case f:
                return se ? Ie(1, 0) : Ie(31, 11)
              case h:
                return se ? Ie(1, st) : Ie(0, st + 1)
              case u:
                var R = this.$locale().weekStart || 0,
                  X = (tt < R ? tt + 7 : tt) - R
                return Ie(se ? me - X : me + (6 - X), st)
              case c:
              case p:
                return xe(G + 'Hours', 0)
              case l:
                return xe(G + 'Minutes', 1)
              case a:
                return xe(G + 'Seconds', 2)
              case o:
                return xe(G + 'Milliseconds', 3)
              default:
                return this.clone()
            }
          }),
          (z.endOf = function (N) {
            return this.startOf(N, !1)
          }),
          (z.$set = function (N, B) {
            var D,
              se = F.p(N),
              he = 'set' + (this.$u ? 'UTC' : ''),
              Ie = ((D = {}),
              (D[c] = he + 'Date'),
              (D[p] = he + 'Date'),
              (D[h] = he + 'Month'),
              (D[f] = he + 'FullYear'),
              (D[l] = he + 'Hours'),
              (D[a] = he + 'Minutes'),
              (D[o] = he + 'Seconds'),
              (D[s] = he + 'Milliseconds'),
              D)[se],
              xe = se === c ? this.$D + (B - this.$W) : B
            if (se === h || se === f) {
              var tt = this.clone().set(p, 1)
              tt.$d[Ie](xe),
                tt.init(),
                (this.$d = tt.set(p, Math.min(this.$D, tt.daysInMonth())).$d)
            } else Ie && this.$d[Ie](xe)
            return this.init(), this
          }),
          (z.set = function (N, B) {
            return this.clone().$set(N, B)
          }),
          (z.get = function (N) {
            return this[F.p(N)]()
          }),
          (z.add = function (N, B) {
            var D,
              se = this
            N = Number(N)
            var he = F.p(B),
              Ie = function (st) {
                var me = U(se)
                return F.w(me.date(me.date() + Math.round(st * N)), se)
              }
            if (he === h) return this.set(h, this.$M + N)
            if (he === f) return this.set(f, this.$y + N)
            if (he === c) return Ie(1)
            if (he === u) return Ie(7)
            var xe = ((D = {}), (D[a] = r), (D[l] = i), (D[o] = n), D)[he] || 1,
              tt = this.$d.getTime() + N * xe
            return F.w(tt, this)
          }),
          (z.subtract = function (N, B) {
            return this.add(-1 * N, B)
          }),
          (z.format = function (N) {
            var B = this,
              D = this.$locale()
            if (!this.isValid()) return D.invalidDate || m
            var se = N || 'YYYY-MM-DDTHH:mm:ssZ',
              he = F.z(this),
              Ie = this.$H,
              xe = this.$m,
              tt = this.$M,
              st = D.weekdays,
              me = D.months,
              G = D.meridiem,
              R = function (J, Te, ve, y) {
                return (J && (J[Te] || J(B, se))) || ve[Te].slice(0, y)
              },
              X = function (J) {
                return F.s(Ie % 12 || 12, J, '0')
              },
              W =
                G ||
                function (J, Te, ve) {
                  var y = J < 12 ? 'AM' : 'PM'
                  return ve ? y.toLowerCase() : y
                }
            return se.replace(_, function (J, Te) {
              return (
                Te ||
                (function (ve) {
                  switch (ve) {
                    case 'YY':
                      return String(B.$y).slice(-2)
                    case 'YYYY':
                      return F.s(B.$y, 4, '0')
                    case 'M':
                      return tt + 1
                    case 'MM':
                      return F.s(tt + 1, 2, '0')
                    case 'MMM':
                      return R(D.monthsShort, tt, me, 3)
                    case 'MMMM':
                      return R(me, tt)
                    case 'D':
                      return B.$D
                    case 'DD':
                      return F.s(B.$D, 2, '0')
                    case 'd':
                      return String(B.$W)
                    case 'dd':
                      return R(D.weekdaysMin, B.$W, st, 2)
                    case 'ddd':
                      return R(D.weekdaysShort, B.$W, st, 3)
                    case 'dddd':
                      return st[B.$W]
                    case 'H':
                      return String(Ie)
                    case 'HH':
                      return F.s(Ie, 2, '0')
                    case 'h':
                      return X(1)
                    case 'hh':
                      return X(2)
                    case 'a':
                      return W(Ie, xe, !0)
                    case 'A':
                      return W(Ie, xe, !1)
                    case 'm':
                      return String(xe)
                    case 'mm':
                      return F.s(xe, 2, '0')
                    case 's':
                      return String(B.$s)
                    case 'ss':
                      return F.s(B.$s, 2, '0')
                    case 'SSS':
                      return F.s(B.$ms, 3, '0')
                    case 'Z':
                      return he
                  }
                  return null
                })(J) ||
                he.replace(':', '')
              )
            })
          }),
          (z.utcOffset = function () {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
          }),
          (z.diff = function (N, B, D) {
            var se,
              he = this,
              Ie = F.p(B),
              xe = U(N),
              tt = (xe.utcOffset() - this.utcOffset()) * r,
              st = this - xe,
              me = function () {
                return F.m(he, xe)
              }
            switch (Ie) {
              case f:
                se = me() / 12
                break
              case h:
                se = me()
                break
              case d:
                se = me() / 3
                break
              case u:
                se = (st - tt) / 6048e5
                break
              case c:
                se = (st - tt) / 864e5
                break
              case l:
                se = st / i
                break
              case a:
                se = st / r
                break
              case o:
                se = st / n
                break
              default:
                se = st
            }
            return D ? se : F.a(se)
          }),
          (z.daysInMonth = function () {
            return this.endOf(h).$D
          }),
          (z.$locale = function () {
            return w[this.$L]
          }),
          (z.locale = function (N, B) {
            if (!N) return this.$L
            var D = this.clone(),
              se = k(N, B, !0)
            return se && (D.$L = se), D
          }),
          (z.clone = function () {
            return F.w(this.$d, this)
          }),
          (z.toDate = function () {
            return new Date(this.valueOf())
          }),
          (z.toJSON = function () {
            return this.isValid() ? this.toISOString() : null
          }),
          (z.toISOString = function () {
            return this.$d.toISOString()
          }),
          (z.toString = function () {
            return this.$d.toUTCString()
          }),
          q
        )
      })(),
      pe = $.prototype
    return (
      (U.prototype = pe),
      [
        ['$ms', s],
        ['$s', o],
        ['$m', a],
        ['$H', l],
        ['$W', c],
        ['$M', h],
        ['$y', f],
        ['$D', p]
      ].forEach(function (q) {
        pe[q[1]] = function (z) {
          return this.$g(z, q[0], q[1])
        }
      }),
      (U.extend = function (q, z) {
        return q.$i || (q(z, $, U), (q.$i = !0)), U
      }),
      (U.locale = k),
      (U.isDayjs = P),
      (U.unix = function (q) {
        return U(1e3 * q)
      }),
      (U.en = w[I]),
      (U.Ls = w),
      (U.p = {}),
      U
    )
  })
})(BO)
var EH = BO.exports
const UO = FO(EH)
var $O = { exports: {} }
;(function (t, e) {
  ;(function (n, r) {
    t.exports = r()
  })(VO, function () {
    var n = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
      },
      r = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
      i = /\d\d/,
      s = /\d\d?/,
      o = /\d*[^-_:/,()\s\d]+/,
      a = {},
      l = function (m) {
        return (m = +m) + (m > 68 ? 1900 : 2e3)
      },
      c = function (m) {
        return function (g) {
          this[m] = +g
        }
      },
      u = [
        /[+-]\d\d:?(\d\d)?|Z/,
        function (m) {
          ;(this.zone || (this.zone = {})).offset = (function (g) {
            if (!g || g === 'Z') return 0
            var _ = g.match(/([+-]|\d\d)/g),
              v = 60 * _[1] + (+_[2] || 0)
            return v === 0 ? 0 : _[0] === '+' ? -v : v
          })(m)
        }
      ],
      h = function (m) {
        var g = a[m]
        return g && (g.indexOf ? g : g.s.concat(g.f))
      },
      d = function (m, g) {
        var _,
          v = a.meridiem
        if (v) {
          for (var T = 1; T <= 24; T += 1)
            if (m.indexOf(v(T, 0, g)) > -1) {
              _ = T > 12
              break
            }
        } else _ = m === (g ? 'pm' : 'PM')
        return _
      },
      f = {
        A: [
          o,
          function (m) {
            this.afternoon = d(m, !1)
          }
        ],
        a: [
          o,
          function (m) {
            this.afternoon = d(m, !0)
          }
        ],
        S: [
          /\d/,
          function (m) {
            this.milliseconds = 100 * +m
          }
        ],
        SS: [
          i,
          function (m) {
            this.milliseconds = 10 * +m
          }
        ],
        SSS: [
          /\d{3}/,
          function (m) {
            this.milliseconds = +m
          }
        ],
        s: [s, c('seconds')],
        ss: [s, c('seconds')],
        m: [s, c('minutes')],
        mm: [s, c('minutes')],
        H: [s, c('hours')],
        h: [s, c('hours')],
        HH: [s, c('hours')],
        hh: [s, c('hours')],
        D: [s, c('day')],
        DD: [i, c('day')],
        Do: [
          o,
          function (m) {
            var g = a.ordinal,
              _ = m.match(/\d+/)
            if (((this.day = _[0]), g))
              for (var v = 1; v <= 31; v += 1) g(v).replace(/\[|\]/g, '') === m && (this.day = v)
          }
        ],
        M: [s, c('month')],
        MM: [i, c('month')],
        MMM: [
          o,
          function (m) {
            var g = h('months'),
              _ =
                (
                  h('monthsShort') ||
                  g.map(function (v) {
                    return v.slice(0, 3)
                  })
                ).indexOf(m) + 1
            if (_ < 1) throw new Error()
            this.month = _ % 12 || _
          }
        ],
        MMMM: [
          o,
          function (m) {
            var g = h('months').indexOf(m) + 1
            if (g < 1) throw new Error()
            this.month = g % 12 || g
          }
        ],
        Y: [/[+-]?\d+/, c('year')],
        YY: [
          i,
          function (m) {
            this.year = l(m)
          }
        ],
        YYYY: [/\d{4}/, c('year')],
        Z: u,
        ZZ: u
      }
    function p(m) {
      var g, _
      ;(g = m), (_ = a && a.formats)
      for (
        var v = (m = g.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (k, U, F) {
            var $ = F && F.toUpperCase()
            return (
              U ||
              _[F] ||
              n[F] ||
              _[$].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (pe, q, z) {
                return q || z.slice(1)
              })
            )
          })).match(r),
          T = v.length,
          S = 0;
        S < T;
        S += 1
      ) {
        var I = v[S],
          w = f[I],
          O = w && w[0],
          P = w && w[1]
        v[S] = P ? { regex: O, parser: P } : I.replace(/^\[|\]$/g, '')
      }
      return function (k) {
        for (var U = {}, F = 0, $ = 0; F < T; F += 1) {
          var pe = v[F]
          if (typeof pe == 'string') $ += pe.length
          else {
            var q = pe.regex,
              z = pe.parser,
              N = k.slice($),
              B = q.exec(N)[0]
            z.call(U, B), (k = k.replace(B, ''))
          }
        }
        return (
          (function (D) {
            var se = D.afternoon
            if (se !== void 0) {
              var he = D.hours
              se ? he < 12 && (D.hours += 12) : he === 12 && (D.hours = 0), delete D.afternoon
            }
          })(U),
          U
        )
      }
    }
    return function (m, g, _) {
      ;(_.p.customParseFormat = !0), m && m.parseTwoDigitYear && (l = m.parseTwoDigitYear)
      var v = g.prototype,
        T = v.parse
      v.parse = function (S) {
        var I = S.date,
          w = S.utc,
          O = S.args
        this.$u = w
        var P = O[1]
        if (typeof P == 'string') {
          var k = O[2] === !0,
            U = O[3] === !0,
            F = k || U,
            $ = O[2]
          U && ($ = O[2]),
            (a = this.$locale()),
            !k && $ && (a = _.Ls[$]),
            (this.$d = (function (N, B, D) {
              try {
                if (['x', 'X'].indexOf(B) > -1) return new Date((B === 'X' ? 1e3 : 1) * N)
                var se = p(B)(N),
                  he = se.year,
                  Ie = se.month,
                  xe = se.day,
                  tt = se.hours,
                  st = se.minutes,
                  me = se.seconds,
                  G = se.milliseconds,
                  R = se.zone,
                  X = new Date(),
                  W = xe || (he || Ie ? 1 : X.getDate()),
                  J = he || X.getFullYear(),
                  Te = 0
                ;(he && !Ie) || (Te = Ie > 0 ? Ie - 1 : X.getMonth())
                var ve = tt || 0,
                  y = st || 0,
                  E = me || 0,
                  A = G || 0
                return R
                  ? new Date(Date.UTC(J, Te, W, ve, y, E, A + 60 * R.offset * 1e3))
                  : D
                  ? new Date(Date.UTC(J, Te, W, ve, y, E, A))
                  : new Date(J, Te, W, ve, y, E, A)
              } catch {
                return new Date('')
              }
            })(I, P, w)),
            this.init(),
            $ && $ !== !0 && (this.$L = this.locale($).$L),
            F && I != this.format(P) && (this.$d = new Date('')),
            (a = {})
        } else if (P instanceof Array)
          for (var pe = P.length, q = 1; q <= pe; q += 1) {
            O[1] = P[q - 1]
            var z = _.apply(this, O)
            if (z.isValid()) {
              ;(this.$d = z.$d), (this.$L = z.$L), this.init()
              break
            }
            q === pe && (this.$d = new Date(''))
          }
        else T.call(this, S)
      }
    }
  })
})($O)
var TH = $O.exports
const wH = FO(TH)
var SH = {},
  Vw = {
    defaultUserAgent: `WiseOldMan JS Client v${SH.npm_package_version}`,
    baseAPIUrl: 'https://api.wiseoldman.net/v2'
  }
function IH(t, e) {
  var n = {}
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
  if (t != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]])
  return n
}
function ss(t, e, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s)
        })
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u))
      } catch (h) {
        o(h)
      }
    }
    function l(u) {
      try {
        c(r.throw(u))
      } catch (h) {
        o(h)
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l)
    }
    c((r = r.apply(t, e || [])).next())
  })
}
UO.extend(wH)
function M_(t, e) {
  return Array.isArray(t)
    ? t.map((n) => M_(n, e))
    : t !== null && typeof t == 'object'
    ? Object.fromEntries(Object.keys(t).map((n) => [n, M_(t[n], e)]))
    : e(t)
}
function AH(t) {
  return !t || typeof t != 'string'
    ? !1
    : t.endsWith('Z') && UO(t.slice(0, -1), 'YYYY-MM-DDTHH:mm:ss.SSS', !0).isValid()
}
function CH(t) {
  return M_(t, (e) => (AH(e) ? new Date(e) : e))
}
function Fw(t, e, n) {
  if (n) {
    if (t === 400) throw new RH(e, n.message, n.data)
    if (t === 403) throw new kH(e, n.message)
    if (t === 404) throw new OH(e, n.message)
    if (t === 429) throw new NH(e, n.message)
    if (t === 500) throw new MH(e, n.message)
  }
}
class RH extends Error {
  constructor(e, n, r) {
    super(n),
      (this.name = 'BadRequestError'),
      (this.resource = e),
      (this.statusCode = 400),
      (this.data = r)
  }
}
class kH extends Error {
  constructor(e, n) {
    super(n), (this.name = 'ForbiddenError'), (this.resource = e), (this.statusCode = 403)
  }
}
class OH extends Error {
  constructor(e, n) {
    super(n), (this.name = 'NotFoundError'), (this.resource = e), (this.statusCode = 404)
  }
}
class NH extends Error {
  constructor(e, n) {
    super(n), (this.name = 'RateLimitError'), (this.resource = e), (this.statusCode = 429)
  }
}
class MH extends Error {
  constructor(e, n) {
    super(n), (this.name = 'InternalServerError'), (this.resource = e), (this.statusCode = 500)
  }
}
class Zs {
  constructor(e, n) {
    ;(this.baseUrl = n),
      (this.headers = Object.assign(
        { Accept: 'application/json', 'Content-Type': 'application/json' },
        e
      ))
  }
  buildParams(e) {
    var n = IH(e, [])
    const r = new URLSearchParams()
    Object.keys(n)
      .filter((s) => n[s] !== void 0)
      .forEach((s) => r.set(s, n[s]))
    const i = r.toString()
    return i ? `?${i}` : ''
  }
  fetch({ method: e, path: n, body: r, params: i }) {
    return ss(this, void 0, void 0, function* () {
      const s = { method: e, body: void 0, headers: this.headers }
      let o = ''
      return (
        r && (s.body = JSON.stringify(r)),
        i && (o = this.buildParams(i)),
        yield fetch(this.baseUrl + n + o, s)
      )
    })
  }
  request({ method: e, path: n, body: r, params: i }) {
    return ss(this, void 0, void 0, function* () {
      const s = yield this.fetch({ method: e, path: n, body: r, params: i }),
        o = yield s.json()
      if (s.ok) return CH(o)
      Fw(s.status, n, o)
    })
  }
  requestText({ method: e, path: n, body: r, params: i }) {
    return ss(this, void 0, void 0, function* () {
      const s = yield this.fetch({ method: e, path: n, body: r, params: i }),
        o = yield s.text()
      if (s.ok) return o
      Fw(s.status, n, JSON.parse(o))
    })
  }
  postRequest(e, n) {
    return ss(this, void 0, void 0, function* () {
      return yield this.request({ method: 'POST', path: e, body: n || {} })
    })
  }
  putRequest(e, n) {
    return ss(this, void 0, void 0, function* () {
      return yield this.request({ method: 'PUT', path: e, body: n || {} })
    })
  }
  deleteRequest(e, n) {
    return ss(this, void 0, void 0, function* () {
      return yield this.request({ method: 'DELETE', path: e, body: n || {} })
    })
  }
  getRequest(e, n) {
    return ss(this, void 0, void 0, function* () {
      return yield this.request({ method: 'GET', path: e, params: n })
    })
  }
  getText(e, n) {
    return ss(this, void 0, void 0, function* () {
      return yield this.requestText({ method: 'GET', path: e, params: n })
    })
  }
}
class PH extends Zs {
  getDeltaLeaderboard(e) {
    return this.getRequest('/deltas/leaderboard', e)
  }
}
class xH extends Zs {
  searchGroups(e, n) {
    return this.getRequest('/groups', Object.assign({ name: e }, n))
  }
  getGroupDetails(e) {
    return this.getRequest(`/groups/${e}`)
  }
  createGroup(e) {
    return this.postRequest('/groups', e)
  }
  editGroup(e, n, r) {
    return this.putRequest(
      `/groups/${e}`,
      Object.assign(Object.assign({}, n), { verificationCode: r })
    )
  }
  deleteGroup(e, n) {
    return this.deleteRequest(`/groups/${e}`, { verificationCode: n })
  }
  addMembers(e, n, r) {
    return this.postRequest(`/groups/${e}/members`, { verificationCode: r, members: n })
  }
  removeMembers(e, n, r) {
    return this.deleteRequest(`/groups/${e}/members`, { verificationCode: r, members: n })
  }
  changeRole(e, n, r) {
    return this.putRequest(
      `/groups/${e}/role`,
      Object.assign(Object.assign({}, n), { verificationCode: r })
    )
  }
  updateAll(e, n) {
    return this.postRequest(`/groups/${e}/update-all`, { verificationCode: n })
  }
  getGroupCompetitions(e, n) {
    return this.getRequest(`/groups/${e}/competitions`, Object.assign({}, n))
  }
  getGroupGains(e, n, r) {
    return this.getRequest(`/groups/${e}/gained`, Object.assign(Object.assign({}, r), n))
  }
  getGroupAchievements(e, n) {
    return this.getRequest(`/groups/${e}/achievements`, Object.assign({}, n))
  }
  getGroupRecords(e, n, r) {
    return this.getRequest(`/groups/${e}/records`, Object.assign(Object.assign({}, r), n))
  }
  getGroupHiscores(e, n, r) {
    return this.getRequest(
      `/groups/${e}/hiscores`,
      Object.assign(Object.assign({}, r), { metric: n })
    )
  }
  getGroupNameChanges(e, n) {
    return this.getRequest(`/groups/${e}/name-changes`, Object.assign({}, n))
  }
  getGroupStatistics(e) {
    return this.getRequest(`/groups/${e}/statistics`)
  }
  getGroupActivity(e, n) {
    return this.getRequest(`/groups/${e}/activity`, Object.assign({}, n))
  }
  getMembersCSV(e) {
    return this.getText(`/groups/${e}/csv`)
  }
}
class DH extends Zs {
  searchPlayers(e, n) {
    return this.getRequest('/players/search', Object.assign({ username: e }, n))
  }
  updatePlayer(e) {
    return this.postRequest(`/players/${e}`)
  }
  assertPlayerType(e) {
    return this.postRequest(`/players/${e}/assert-type`)
  }
  getPlayerDetails(e) {
    return this.getRequest(`/players/${e}`)
  }
  getPlayerDetailsById(e) {
    return this.getRequest(`/players/id/${e}`)
  }
  getPlayerAchievements(e) {
    return this.getRequest(`/players/${e}/achievements`)
  }
  getPlayerAchievementProgress(e) {
    return this.getRequest(`/players/${e}/achievements/progress`)
  }
  getPlayerCompetitions(e, n, r) {
    return this.getRequest(`/players/${e}/competitions`, Object.assign(Object.assign({}, n), r))
  }
  getPlayerCompetitionStandings(e, n) {
    return this.getRequest(`/players/${e}/competitions/standings`, n)
  }
  getPlayerGroups(e, n) {
    return this.getRequest(`/players/${e}/groups`, n)
  }
  getPlayerGains(e, n) {
    return this.getRequest(`/players/${e}/gained`, n)
  }
  getPlayerGainsAsArray(e, n) {
    return this.getRequest(
      `/players/${e}/gained`,
      Object.assign(Object.assign({}, n), { formatting: 'array' })
    )
  }
  getPlayerRecords(e, n) {
    return this.getRequest(`/players/${e}/records`, n)
  }
  getPlayerSnapshots(e, n, r) {
    return this.getRequest(`/players/${e}/snapshots`, Object.assign(Object.assign({}, n), r))
  }
  getPlayerSnapshotTimeline(e, n, r) {
    return this.getRequest(
      `/players/${e}/snapshots/timeline`,
      Object.assign(Object.assign({}, r), { metric: n })
    )
  }
  getPlayerNames(e) {
    return this.getRequest(`/players/${e}/names`)
  }
  getPlayerArchives(e) {
    return this.getRequest(`/players/${e}/archives`)
  }
}
class LH extends Zs {
  getRecordLeaderboard(e) {
    return this.getRequest('/records/leaderboard', e)
  }
}
const ut = {
    OVERALL: 'overall',
    ATTACK: 'attack',
    DEFENCE: 'defence',
    STRENGTH: 'strength',
    HITPOINTS: 'hitpoints',
    RANGED: 'ranged',
    PRAYER: 'prayer',
    MAGIC: 'magic',
    COOKING: 'cooking',
    WOODCUTTING: 'woodcutting',
    FLETCHING: 'fletching',
    FISHING: 'fishing',
    FIREMAKING: 'firemaking',
    CRAFTING: 'crafting',
    SMITHING: 'smithing',
    MINING: 'mining',
    HERBLORE: 'herblore',
    AGILITY: 'agility',
    THIEVING: 'thieving',
    SLAYER: 'slayer',
    FARMING: 'farming',
    RUNECRAFTING: 'runecrafting',
    HUNTER: 'hunter',
    CONSTRUCTION: 'construction'
  },
  cn = {
    LEAGUE_POINTS: 'league_points',
    BOUNTY_HUNTER_HUNTER: 'bounty_hunter_hunter',
    BOUNTY_HUNTER_ROGUE: 'bounty_hunter_rogue',
    CLUE_SCROLLS_ALL: 'clue_scrolls_all',
    CLUE_SCROLLS_BEGINNER: 'clue_scrolls_beginner',
    CLUE_SCROLLS_EASY: 'clue_scrolls_easy',
    CLUE_SCROLLS_MEDIUM: 'clue_scrolls_medium',
    CLUE_SCROLLS_HARD: 'clue_scrolls_hard',
    CLUE_SCROLLS_ELITE: 'clue_scrolls_elite',
    CLUE_SCROLLS_MASTER: 'clue_scrolls_master',
    LAST_MAN_STANDING: 'last_man_standing',
    PVP_ARENA: 'pvp_arena',
    SOUL_WARS_ZEAL: 'soul_wars_zeal',
    GUARDIANS_OF_THE_RIFT: 'guardians_of_the_rift',
    COLOSSEUM_GLORY: 'colosseum_glory'
  },
  le = {
    ABYSSAL_SIRE: 'abyssal_sire',
    ALCHEMICAL_HYDRA: 'alchemical_hydra',
    ARTIO: 'artio',
    BARROWS_CHESTS: 'barrows_chests',
    BRYOPHYTA: 'bryophyta',
    CALLISTO: 'callisto',
    CALVARION: 'calvarion',
    CERBERUS: 'cerberus',
    CHAMBERS_OF_XERIC: 'chambers_of_xeric',
    CHAMBERS_OF_XERIC_CM: 'chambers_of_xeric_challenge_mode',
    CHAOS_ELEMENTAL: 'chaos_elemental',
    CHAOS_FANATIC: 'chaos_fanatic',
    COMMANDER_ZILYANA: 'commander_zilyana',
    CORPOREAL_BEAST: 'corporeal_beast',
    CRAZY_ARCHAEOLOGIST: 'crazy_archaeologist',
    DAGANNOTH_PRIME: 'dagannoth_prime',
    DAGANNOTH_REX: 'dagannoth_rex',
    DAGANNOTH_SUPREME: 'dagannoth_supreme',
    DERANGED_ARCHAEOLOGIST: 'deranged_archaeologist',
    DUKE_SUCELLUS: 'duke_sucellus',
    GENERAL_GRAARDOR: 'general_graardor',
    GIANT_MOLE: 'giant_mole',
    GROTESQUE_GUARDIANS: 'grotesque_guardians',
    HESPORI: 'hespori',
    KALPHITE_QUEEN: 'kalphite_queen',
    KING_BLACK_DRAGON: 'king_black_dragon',
    KRAKEN: 'kraken',
    KREEARRA: 'kreearra',
    KRIL_TSUTSAROTH: 'kril_tsutsaroth',
    LUNAR_CHESTS: 'lunar_chests',
    MIMIC: 'mimic',
    NEX: 'nex',
    NIGHTMARE: 'nightmare',
    PHOSANIS_NIGHTMARE: 'phosanis_nightmare',
    OBOR: 'obor',
    PHANTOM_MUSPAH: 'phantom_muspah',
    SARACHNIS: 'sarachnis',
    SCORPIA: 'scorpia',
    SCURRIUS: 'scurrius',
    SKOTIZO: 'skotizo',
    SOL_HEREDIT: 'sol_heredit',
    SPINDEL: 'spindel',
    TEMPOROSS: 'tempoross',
    THE_GAUNTLET: 'the_gauntlet',
    THE_CORRUPTED_GAUNTLET: 'the_corrupted_gauntlet',
    THE_LEVIATHAN: 'the_leviathan',
    THE_WHISPERER: 'the_whisperer',
    THEATRE_OF_BLOOD: 'theatre_of_blood',
    THEATRE_OF_BLOOD_HARD_MODE: 'theatre_of_blood_hard_mode',
    THERMONUCLEAR_SMOKE_DEVIL: 'thermonuclear_smoke_devil',
    TOMBS_OF_AMASCUT: 'tombs_of_amascut',
    TOMBS_OF_AMASCUT_EXPERT: 'tombs_of_amascut_expert',
    TZKAL_ZUK: 'tzkal_zuk',
    TZTOK_JAD: 'tztok_jad',
    VARDORVIS: 'vardorvis',
    VENENATIS: 'venenatis',
    VETION: 'vetion',
    VORKATH: 'vorkath',
    WINTERTODT: 'wintertodt',
    ZALCANO: 'zalcano',
    ZULRAH: 'zulrah'
  },
  Lf = { EHP: 'ehp', EHB: 'ehb' },
  P_ = Object.assign(Object.assign(Object.assign(Object.assign({}, ut), cn), le), Lf),
  b = {
    ACHIEVER: 'achiever',
    ADAMANT: 'adamant',
    ADEPT: 'adept',
    ADMINISTRATOR: 'administrator',
    ADMIRAL: 'admiral',
    ADVENTURER: 'adventurer',
    AIR: 'air',
    ANCHOR: 'anchor',
    APOTHECARY: 'apothecary',
    ARCHER: 'archer',
    ARMADYLEAN: 'armadylean',
    ARTILLERY: 'artillery',
    ARTISAN: 'artisan',
    ASGARNIAN: 'asgarnian',
    ASSASSIN: 'assassin',
    ASSISTANT: 'assistant',
    ASTRAL: 'astral',
    ATHLETE: 'athlete',
    ATTACKER: 'attacker',
    BANDIT: 'bandit',
    BANDOSIAN: 'bandosian',
    BARBARIAN: 'barbarian',
    BATTLEMAGE: 'battlemage',
    BEAST: 'beast',
    BERSERKER: 'berserker',
    BLISTERWOOD: 'blisterwood',
    BLOOD: 'blood',
    BLUE: 'blue',
    BOB: 'bob',
    BODY: 'body',
    BRASSICAN: 'brassican',
    BRAWLER: 'brawler',
    BRIGADIER: 'brigadier',
    BRIGAND: 'brigand',
    BRONZE: 'bronze',
    BRUISER: 'bruiser',
    BULWARK: 'bulwark',
    BURGLAR: 'burglar',
    BURNT: 'burnt',
    CADET: 'cadet',
    CAPTAIN: 'captain',
    CARRY: 'carry',
    CHAMPION: 'champion',
    CHAOS: 'chaos',
    CLERIC: 'cleric',
    COLLECTOR: 'collector',
    COLONEL: 'colonel',
    COMMANDER: 'commander',
    COMPETITOR: 'competitor',
    COMPLETIONIST: 'completionist',
    CONSTRUCTOR: 'constructor',
    COOK: 'cook',
    COORDINATOR: 'coordinator',
    CORPORAL: 'corporal',
    COSMIC: 'cosmic',
    COUNCILLOR: 'councillor',
    CRAFTER: 'crafter',
    CREW: 'crew',
    CRUSADER: 'crusader',
    CUTPURSE: 'cutpurse',
    DEATH: 'death',
    DEFENDER: 'defender',
    DEFILER: 'defiler',
    DEPUTY_OWNER: 'deputy_owner',
    DESTROYER: 'destroyer',
    DIAMOND: 'diamond',
    DISEASED: 'diseased',
    DOCTOR: 'doctor',
    DOGSBODY: 'dogsbody',
    DRAGON: 'dragon',
    DRAGONSTONE: 'dragonstone',
    DRUID: 'druid',
    DUELLIST: 'duellist',
    EARTH: 'earth',
    ELITE: 'elite',
    EMERALD: 'emerald',
    ENFORCER: 'enforcer',
    EPIC: 'epic',
    EXECUTIVE: 'executive',
    EXPERT: 'expert',
    EXPLORER: 'explorer',
    FARMER: 'farmer',
    FEEDER: 'feeder',
    FIGHTER: 'fighter',
    FIRE: 'fire',
    FIREMAKER: 'firemaker',
    FIRESTARTER: 'firestarter',
    FISHER: 'fisher',
    FLETCHER: 'fletcher',
    FORAGER: 'forager',
    FREMENNIK: 'fremennik',
    GAMER: 'gamer',
    GATHERER: 'gatherer',
    GENERAL: 'general',
    GNOME_CHILD: 'gnome_child',
    GNOME_ELDER: 'gnome_elder',
    GOBLIN: 'goblin',
    GOLD: 'gold',
    GOON: 'goon',
    GREEN: 'green',
    GREY: 'grey',
    GUARDIAN: 'guardian',
    GUTHIXIAN: 'guthixian',
    HARPOON: 'harpoon',
    HEALER: 'healer',
    HELLCAT: 'hellcat',
    HELPER: 'helper',
    HERBOLOGIST: 'herbologist',
    HERO: 'hero',
    HOLY: 'holy',
    HOARDER: 'hoarder',
    HUNTER: 'hunter',
    IGNITOR: 'ignitor',
    ILLUSIONIST: 'illusionist',
    IMP: 'imp',
    INFANTRY: 'infantry',
    INQUISITOR: 'inquisitor',
    IRON: 'iron',
    JADE: 'jade',
    JUSTICIAR: 'justiciar',
    KANDARIN: 'kandarin',
    KARAMJAN: 'karamjan',
    KHARIDIAN: 'kharidian',
    KITTEN: 'kitten',
    KNIGHT: 'knight',
    LABOURER: 'labourer',
    LAW: 'law',
    LEADER: 'leader',
    LEARNER: 'learner',
    LEGACY: 'legacy',
    LEGEND: 'legend',
    LEGIONNAIRE: 'legionnaire',
    LIEUTENANT: 'lieutenant',
    LOOTER: 'looter',
    LUMBERJACK: 'lumberjack',
    MAGIC: 'magic',
    MAGICIAN: 'magician',
    MAJOR: 'major',
    MAPLE: 'maple',
    MARSHAL: 'marshal',
    MASTER: 'master',
    MAXED: 'maxed',
    MEDIATOR: 'mediator',
    MEDIC: 'medic',
    MENTOR: 'mentor',
    MEMBER: 'member',
    MERCHANT: 'merchant',
    MIND: 'mind',
    MINER: 'miner',
    MINION: 'minion',
    MISTHALINIAN: 'misthalinian',
    MITHRIL: 'mithril',
    MODERATOR: 'moderator',
    MONARCH: 'monarch',
    MORYTANIAN: 'morytanian',
    MYSTIC: 'mystic',
    MYTH: 'myth',
    NATURAL: 'natural',
    NATURE: 'nature',
    NECROMANCER: 'necromancer',
    NINJA: 'ninja',
    NOBLE: 'noble',
    NOVICE: 'novice',
    NURSE: 'nurse',
    OAK: 'oak',
    OFFICER: 'officer',
    ONYX: 'onyx',
    OPAL: 'opal',
    ORACLE: 'oracle',
    ORANGE: 'orange',
    OWNER: 'owner',
    PAGE: 'page',
    PALADIN: 'paladin',
    PAWN: 'pawn',
    PILGRIM: 'pilgrim',
    PINE: 'pine',
    PINK: 'pink',
    PREFECT: 'prefect',
    PRIEST: 'priest',
    PRIVATE: 'private',
    PRODIGY: 'prodigy',
    PROSELYTE: 'proselyte',
    PROSPECTOR: 'prospector',
    PROTECTOR: 'protector',
    PURE: 'pure',
    PURPLE: 'purple',
    PYROMANCER: 'pyromancer',
    QUESTER: 'quester',
    RACER: 'racer',
    RAIDER: 'raider',
    RANGER: 'ranger',
    RECORD_CHASER: 'record_chaser',
    RECRUIT: 'recruit',
    RECRUITER: 'recruiter',
    RED_TOPAZ: 'red_topaz',
    RED: 'red',
    ROGUE: 'rogue',
    RUBY: 'ruby',
    RUNE: 'rune',
    RUNECRAFTER: 'runecrafter',
    SAGE: 'sage',
    SAPPHIRE: 'sapphire',
    SARADOMINIST: 'saradominist',
    SAVIOUR: 'saviour',
    SCAVENGER: 'scavenger',
    SCHOLAR: 'scholar',
    SCOURGE: 'scourge',
    SCOUT: 'scout',
    SCRIBE: 'scribe',
    SEER: 'seer',
    SENATOR: 'senator',
    SENTRY: 'sentry',
    SERENIST: 'serenist',
    SERGEANT: 'sergeant',
    SHAMAN: 'shaman',
    SHERIFF: 'sheriff',
    SHORT_GREEN_GUY: 'short_green_guy',
    SKILLER: 'skiller',
    SKULLED: 'skulled',
    SLAYER: 'slayer',
    SMITER: 'smiter',
    SMITH: 'smith',
    SMUGGLER: 'smuggler',
    SNIPER: 'sniper',
    SOUL: 'soul',
    SPECIALIST: 'specialist',
    SPEED_RUNNER: 'speed_runner',
    SPELLCASTER: 'spellcaster',
    SQUIRE: 'squire',
    STAFF: 'staff',
    STEEL: 'steel',
    STRIDER: 'strider',
    STRIKER: 'striker',
    SUMMONER: 'summoner',
    SUPERIOR: 'superior',
    SUPERVISOR: 'supervisor',
    TEACHER: 'teacher',
    TEMPLAR: 'templar',
    THERAPIST: 'therapist',
    THIEF: 'thief',
    TIRANNIAN: 'tirannian',
    TRIALIST: 'trialist',
    TRICKSTER: 'trickster',
    TZKAL: 'tzkal',
    TZTOK: 'tztok',
    UNHOLY: 'unholy',
    VAGRANT: 'vagrant',
    VANGUARD: 'vanguard',
    WALKER: 'walker',
    WANDERER: 'wanderer',
    WARDEN: 'warden',
    WARLOCK: 'warlock',
    WARRIOR: 'warrior',
    WATER: 'water',
    WILD: 'wild',
    WILLOW: 'willow',
    WILY: 'wily',
    WINTUMBER: 'wintumber',
    WITCH: 'witch',
    WIZARD: 'wizard',
    WORKER: 'worker',
    WRATH: 'wrath',
    XERICIAN: 'xerician',
    YELLOW: 'yellow',
    YEW: 'yew',
    ZAMORAKIAN: 'zamorakian',
    ZAROSIAN: 'zarosian',
    ZEALOT: 'zealot',
    ZENYTE: 'zenyte'
  }
var Xa
;(function (t) {
  ;(t.UPCOMING = 'upcoming'), (t.ONGOING = 'ongoing'), (t.FINISHED = 'finished')
})(Xa || (Xa = {}))
var Bw
;(function (t) {
  ;(t.TEAM = 'team'), (t.TEAMS = 'teams'), (t.PARTICIPANTS = 'participants')
})(Bw || (Bw = {}))
Xa.UPCOMING + '', Xa.ONGOING + '', Xa.FINISHED + ''
Object.values(Xa)
function Eh(t, e) {
  const n = {}
  return (
    Object.keys(t).forEach((r) => {
      const i = r
      n[i] = e(t[i], i, t)
    }),
    n
  )
}
const VH = [b.ADMINISTRATOR, b.OWNER, b.LEADER, b.DEPUTY_OWNER, b.MODERATOR]
Eh(
  {
    [b.ACHIEVER]: { name: 'Achiever' },
    [b.ADAMANT]: { name: 'Adamant' },
    [b.ADEPT]: { name: 'Adept' },
    [b.ADMINISTRATOR]: { name: 'Administrator' },
    [b.ADMIRAL]: { name: 'Admiral' },
    [b.ADVENTURER]: { name: 'Adventurer' },
    [b.AIR]: { name: 'Air' },
    [b.ANCHOR]: { name: 'Anchor' },
    [b.APOTHECARY]: { name: 'Apothecary' },
    [b.ARCHER]: { name: 'Archer' },
    [b.ARMADYLEAN]: { name: 'Armadylean' },
    [b.ARTILLERY]: { name: 'Artillery' },
    [b.ARTISAN]: { name: 'Artisan' },
    [b.ASGARNIAN]: { name: 'Asgarnian' },
    [b.ASSASSIN]: { name: 'Assassin' },
    [b.ASSISTANT]: { name: 'Assistant' },
    [b.ASTRAL]: { name: 'Astral' },
    [b.ATHLETE]: { name: 'Athlete' },
    [b.ATTACKER]: { name: 'Attacker' },
    [b.BANDIT]: { name: 'Bandit' },
    [b.BANDOSIAN]: { name: 'Bandosian' },
    [b.BARBARIAN]: { name: 'Barbarian' },
    [b.BATTLEMAGE]: { name: 'Battlemage' },
    [b.BEAST]: { name: 'Beast' },
    [b.BERSERKER]: { name: 'Berserker' },
    [b.BLISTERWOOD]: { name: 'Blisterwood' },
    [b.BLOOD]: { name: 'Blood' },
    [b.BLUE]: { name: 'Blue' },
    [b.BOB]: { name: 'Bob' },
    [b.BODY]: { name: 'Body' },
    [b.BRASSICAN]: { name: 'Brassican' },
    [b.BRAWLER]: { name: 'Brawler' },
    [b.BRIGADIER]: { name: 'Brigadier' },
    [b.BRIGAND]: { name: 'Brigand' },
    [b.BRONZE]: { name: 'Bronze' },
    [b.BRUISER]: { name: 'Bruiser' },
    [b.BULWARK]: { name: 'Bulwark' },
    [b.BURGLAR]: { name: 'Burglar' },
    [b.BURNT]: { name: 'Burnt' },
    [b.CADET]: { name: 'Cadet' },
    [b.CAPTAIN]: { name: 'Captain' },
    [b.CARRY]: { name: 'Carry' },
    [b.CHAMPION]: { name: 'Champion' },
    [b.CHAOS]: { name: 'Chaos' },
    [b.CLERIC]: { name: 'Cleric' },
    [b.COLLECTOR]: { name: 'Collector' },
    [b.COLONEL]: { name: 'Colonel' },
    [b.COMMANDER]: { name: 'Commander' },
    [b.COMPETITOR]: { name: 'Competitor' },
    [b.COMPLETIONIST]: { name: 'Completionist' },
    [b.CONSTRUCTOR]: { name: 'Constructor' },
    [b.COOK]: { name: 'Cook' },
    [b.COORDINATOR]: { name: 'Coordinator' },
    [b.CORPORAL]: { name: 'Corporal' },
    [b.COSMIC]: { name: 'Cosmic' },
    [b.COUNCILLOR]: { name: 'Councillor' },
    [b.CRAFTER]: { name: 'Crafter' },
    [b.CREW]: { name: 'Crew' },
    [b.CRUSADER]: { name: 'Crusader' },
    [b.CUTPURSE]: { name: 'Cutpurse' },
    [b.DEATH]: { name: 'Death' },
    [b.DEFENDER]: { name: 'Defender' },
    [b.DEFILER]: { name: 'Defiler' },
    [b.DEPUTY_OWNER]: { name: 'Deputy Owner' },
    [b.DESTROYER]: { name: 'Destroyer' },
    [b.DIAMOND]: { name: 'Diamond' },
    [b.DISEASED]: { name: 'Diseased' },
    [b.DOCTOR]: { name: 'Doctor' },
    [b.DOGSBODY]: { name: 'Dogsbody' },
    [b.DRAGON]: { name: 'Dragon' },
    [b.DRAGONSTONE]: { name: 'Dragonstone' },
    [b.DRUID]: { name: 'Druid' },
    [b.DUELLIST]: { name: 'Duellist' },
    [b.EARTH]: { name: 'Earth' },
    [b.ELITE]: { name: 'Elite' },
    [b.EMERALD]: { name: 'Emerald' },
    [b.ENFORCER]: { name: 'Enforcer' },
    [b.EPIC]: { name: 'Epic' },
    [b.EXECUTIVE]: { name: 'Executive' },
    [b.EXPERT]: { name: 'Expert' },
    [b.EXPLORER]: { name: 'Explorer' },
    [b.FARMER]: { name: 'Farmer' },
    [b.FEEDER]: { name: 'Feeder' },
    [b.FIGHTER]: { name: 'Fighter' },
    [b.FIRE]: { name: 'Fire' },
    [b.FIREMAKER]: { name: 'Firemaker' },
    [b.FIRESTARTER]: { name: 'Firestarter' },
    [b.FISHER]: { name: 'Fisher' },
    [b.FLETCHER]: { name: 'Fletcher' },
    [b.FORAGER]: { name: 'Forager' },
    [b.FREMENNIK]: { name: 'Fremennik' },
    [b.GAMER]: { name: 'Gamer' },
    [b.GATHERER]: { name: 'Gatherer' },
    [b.GENERAL]: { name: 'General' },
    [b.GNOME_CHILD]: { name: 'Gnome Child' },
    [b.GNOME_ELDER]: { name: 'Gnome Elder' },
    [b.GOBLIN]: { name: 'Goblin' },
    [b.GOLD]: { name: 'Gold' },
    [b.GOON]: { name: 'Goon' },
    [b.GREEN]: { name: 'Green' },
    [b.GREY]: { name: 'Grey' },
    [b.GUARDIAN]: { name: 'Guardian' },
    [b.GUTHIXIAN]: { name: 'Guthixian' },
    [b.HARPOON]: { name: 'Harpoon' },
    [b.HEALER]: { name: 'Healer' },
    [b.HELLCAT]: { name: 'Hellcat' },
    [b.HELPER]: { name: 'Helper' },
    [b.HERBOLOGIST]: { name: 'Herbologist' },
    [b.HERO]: { name: 'Hero' },
    [b.HOLY]: { name: 'Holy' },
    [b.HOARDER]: { name: 'Hoarder' },
    [b.HUNTER]: { name: 'Hunter' },
    [b.IGNITOR]: { name: 'Ignitor' },
    [b.ILLUSIONIST]: { name: 'Illusionist' },
    [b.IMP]: { name: 'Imp' },
    [b.INFANTRY]: { name: 'Infantry' },
    [b.INQUISITOR]: { name: 'Inquisitor' },
    [b.IRON]: { name: 'Iron' },
    [b.JADE]: { name: 'Jade' },
    [b.JUSTICIAR]: { name: 'Justiciar' },
    [b.KANDARIN]: { name: 'Kandarin' },
    [b.KARAMJAN]: { name: 'Karamjan' },
    [b.KHARIDIAN]: { name: 'Kharidian' },
    [b.KITTEN]: { name: 'Kitten' },
    [b.KNIGHT]: { name: 'Knight' },
    [b.LABOURER]: { name: 'Labourer' },
    [b.LAW]: { name: 'Law' },
    [b.LEADER]: { name: 'Leader' },
    [b.LEARNER]: { name: 'Learner' },
    [b.LEGACY]: { name: 'Legacy' },
    [b.LEGEND]: { name: 'Legend' },
    [b.LEGIONNAIRE]: { name: 'Legionnaire' },
    [b.LIEUTENANT]: { name: 'Lieutenant' },
    [b.LOOTER]: { name: 'Looter' },
    [b.LUMBERJACK]: { name: 'Lumberjack' },
    [b.MAGIC]: { name: 'Magic' },
    [b.MAGICIAN]: { name: 'Magician' },
    [b.MAJOR]: { name: 'Major' },
    [b.MAPLE]: { name: 'Maple' },
    [b.MARSHAL]: { name: 'Marshal' },
    [b.MASTER]: { name: 'Master' },
    [b.MAXED]: { name: 'Maxed' },
    [b.MEDIATOR]: { name: 'Mediator' },
    [b.MEDIC]: { name: 'Medic' },
    [b.MENTOR]: { name: 'Mentor' },
    [b.MEMBER]: { name: 'Member' },
    [b.MERCHANT]: { name: 'Merchant' },
    [b.MIND]: { name: 'Mind' },
    [b.MINER]: { name: 'Miner' },
    [b.MINION]: { name: 'Minion' },
    [b.MISTHALINIAN]: { name: 'Misthalinian' },
    [b.MITHRIL]: { name: 'Mithril' },
    [b.MODERATOR]: { name: 'Moderator' },
    [b.MONARCH]: { name: 'Monarch' },
    [b.MORYTANIAN]: { name: 'Morytanian' },
    [b.MYSTIC]: { name: 'Mystic' },
    [b.MYTH]: { name: 'Myth' },
    [b.NATURAL]: { name: 'Natural' },
    [b.NATURE]: { name: 'Nature' },
    [b.NECROMANCER]: { name: 'Necromancer' },
    [b.NINJA]: { name: 'Ninja' },
    [b.NOBLE]: { name: 'Noble' },
    [b.NOVICE]: { name: 'Novice' },
    [b.NURSE]: { name: 'Nurse' },
    [b.OAK]: { name: 'Oak' },
    [b.OFFICER]: { name: 'Officer' },
    [b.ONYX]: { name: 'Onyx' },
    [b.OPAL]: { name: 'Opal' },
    [b.ORACLE]: { name: 'Oracle' },
    [b.ORANGE]: { name: 'Orange' },
    [b.OWNER]: { name: 'Owner' },
    [b.PAGE]: { name: 'Page' },
    [b.PALADIN]: { name: 'Paladin' },
    [b.PAWN]: { name: 'Pawn' },
    [b.PILGRIM]: { name: 'Pilgrim' },
    [b.PINE]: { name: 'Pine' },
    [b.PINK]: { name: 'Pink' },
    [b.PREFECT]: { name: 'Prefect' },
    [b.PRIEST]: { name: 'Priest' },
    [b.PRIVATE]: { name: 'Private' },
    [b.PRODIGY]: { name: 'Prodigy' },
    [b.PROSELYTE]: { name: 'Proselyte' },
    [b.PROSPECTOR]: { name: 'Prospector' },
    [b.PROTECTOR]: { name: 'Protector' },
    [b.PURE]: { name: 'Pure' },
    [b.PURPLE]: { name: 'Purple' },
    [b.PYROMANCER]: { name: 'Pyromancer' },
    [b.QUESTER]: { name: 'Quester' },
    [b.RACER]: { name: 'Racer' },
    [b.RAIDER]: { name: 'Raider' },
    [b.RANGER]: { name: 'Ranger' },
    [b.RECORD_CHASER]: { name: 'Record-Chaser' },
    [b.RECRUIT]: { name: 'Recruit' },
    [b.RECRUITER]: { name: 'Recruiter' },
    [b.RED_TOPAZ]: { name: 'Red Topaz' },
    [b.RED]: { name: 'Red' },
    [b.ROGUE]: { name: 'Rogue' },
    [b.RUBY]: { name: 'Ruby' },
    [b.RUNE]: { name: 'Rune' },
    [b.RUNECRAFTER]: { name: 'Runecrafter' },
    [b.SAGE]: { name: 'Sage' },
    [b.SAPPHIRE]: { name: 'Sapphire' },
    [b.SARADOMINIST]: { name: 'Saradominist' },
    [b.SAVIOUR]: { name: 'Saviour' },
    [b.SCAVENGER]: { name: 'Scavenger' },
    [b.SCHOLAR]: { name: 'Scholar' },
    [b.SCOURGE]: { name: 'Scourge' },
    [b.SCOUT]: { name: 'Scout' },
    [b.SCRIBE]: { name: 'Scribe' },
    [b.SEER]: { name: 'Seer' },
    [b.SENATOR]: { name: 'Senator' },
    [b.SENTRY]: { name: 'Sentry' },
    [b.SERENIST]: { name: 'Serenist' },
    [b.SERGEANT]: { name: 'Sergeant' },
    [b.SHAMAN]: { name: 'Shaman' },
    [b.SHERIFF]: { name: 'Sheriff' },
    [b.SHORT_GREEN_GUY]: { name: 'Short Green Guy' },
    [b.SKILLER]: { name: 'Skiller' },
    [b.SKULLED]: { name: 'Skulled' },
    [b.SLAYER]: { name: 'Slayer' },
    [b.SMITER]: { name: 'Smiter' },
    [b.SMITH]: { name: 'Smith' },
    [b.SMUGGLER]: { name: 'Smuggler' },
    [b.SNIPER]: { name: 'Sniper' },
    [b.SOUL]: { name: 'Soul' },
    [b.SPECIALIST]: { name: 'Specialist' },
    [b.SPEED_RUNNER]: { name: 'Speed-Runner' },
    [b.SPELLCASTER]: { name: 'Spellcaster' },
    [b.SQUIRE]: { name: 'Squire' },
    [b.STAFF]: { name: 'Staff' },
    [b.STEEL]: { name: 'Steel' },
    [b.STRIDER]: { name: 'Strider' },
    [b.STRIKER]: { name: 'Striker' },
    [b.SUMMONER]: { name: 'Summoner' },
    [b.SUPERIOR]: { name: 'Superior' },
    [b.SUPERVISOR]: { name: 'Supervisor' },
    [b.TEACHER]: { name: 'Teacher' },
    [b.TEMPLAR]: { name: 'Templar' },
    [b.THERAPIST]: { name: 'Therapist' },
    [b.THIEF]: { name: 'Thief' },
    [b.TIRANNIAN]: { name: 'Tirannian' },
    [b.TRIALIST]: { name: 'Trialist' },
    [b.TRICKSTER]: { name: 'Trickster' },
    [b.TZKAL]: { name: 'TzKal' },
    [b.TZTOK]: { name: 'TzTok' },
    [b.UNHOLY]: { name: 'Unholy' },
    [b.VAGRANT]: { name: 'Vagrant' },
    [b.VANGUARD]: { name: 'Vanguard' },
    [b.WALKER]: { name: 'Walker' },
    [b.WANDERER]: { name: 'Wanderer' },
    [b.WARDEN]: { name: 'Warden' },
    [b.WARLOCK]: { name: 'Warlock' },
    [b.WARRIOR]: { name: 'Warrior' },
    [b.WATER]: { name: 'Water' },
    [b.WILD]: { name: 'Wild' },
    [b.WILLOW]: { name: 'Willow' },
    [b.WILY]: { name: 'Wily' },
    [b.WINTUMBER]: { name: 'Wintumber' },
    [b.WITCH]: { name: 'Witch' },
    [b.WIZARD]: { name: 'Wizard' },
    [b.WORKER]: { name: 'Worker' },
    [b.WRATH]: { name: 'Wrath' },
    [b.XERICIAN]: { name: 'Xerician' },
    [b.YELLOW]: { name: 'Yellow' },
    [b.YEW]: { name: 'Yew' },
    [b.ZAMORAKIAN]: { name: 'Zamorakian' },
    [b.ZAROSIAN]: { name: 'Zarosian' },
    [b.ZEALOT]: { name: 'Zealot' },
    [b.ZENYTE]: { name: 'Zenyte' }
  },
  (t, e) => Object.assign(Object.assign({}, t), { isPriveleged: VH.includes(e) })
)
var Tl
;(function (t) {
  ;(t.SKILL = 'skill'), (t.BOSS = 'boss'), (t.ACTIVITY = 'activity'), (t.COMPUTED = 'computed')
})(Tl || (Tl = {}))
var wl
;(function (t) {
  ;(t.EXPERIENCE = 'experience'), (t.KILLS = 'kills'), (t.SCORE = 'score'), (t.VALUE = 'value')
})(wl || (wl = {}))
const FH = Eh(
    {
      [ut.OVERALL]: { name: 'Overall' },
      [ut.ATTACK]: { name: 'Attack', isCombat: !0 },
      [ut.DEFENCE]: { name: 'Defence', isCombat: !0 },
      [ut.STRENGTH]: { name: 'Strength', isCombat: !0 },
      [ut.HITPOINTS]: { name: 'Hitpoints', isCombat: !0 },
      [ut.RANGED]: { name: 'Ranged', isCombat: !0 },
      [ut.PRAYER]: { name: 'Prayer', isCombat: !0 },
      [ut.MAGIC]: { name: 'Magic', isCombat: !0 },
      [ut.COOKING]: { name: 'Cooking' },
      [ut.WOODCUTTING]: { name: 'Woodcutting' },
      [ut.FLETCHING]: { name: 'Fletching', isMembers: !0 },
      [ut.FISHING]: { name: 'Fishing' },
      [ut.FIREMAKING]: { name: 'Firemaking' },
      [ut.CRAFTING]: { name: 'Crafting' },
      [ut.SMITHING]: { name: 'Smithing' },
      [ut.MINING]: { name: 'Mining' },
      [ut.HERBLORE]: { name: 'Herblore', isMembers: !0 },
      [ut.AGILITY]: { name: 'Agility', isMembers: !0 },
      [ut.THIEVING]: { name: 'Thieving', isMembers: !0 },
      [ut.SLAYER]: { name: 'Slayer', isMembers: !0 },
      [ut.FARMING]: { name: 'Farming', isMembers: !0 },
      [ut.RUNECRAFTING]: { name: 'Runecrafting' },
      [ut.HUNTER]: { name: 'Hunter', isMembers: !0 },
      [ut.CONSTRUCTION]: { name: 'Construction', isMembers: !0 }
    },
    (t) =>
      Object.assign(Object.assign({}, t), {
        type: Tl.SKILL,
        measure: wl.EXPERIENCE,
        isCombat: 'isCombat' in t ? t.isCombat : !1,
        isMembers: 'isMembers' in t ? t.isMembers : !1
      })
  ),
  BH = Eh(
    {
      [le.ABYSSAL_SIRE]: { name: 'Abyssal Sire' },
      [le.ALCHEMICAL_HYDRA]: { name: 'Alchemical Hydra' },
      [le.ARTIO]: { name: 'Artio' },
      [le.BARROWS_CHESTS]: { name: 'Barrows Chests' },
      [le.BRYOPHYTA]: { name: 'Bryophyta', isMembers: !1 },
      [le.CALLISTO]: { name: 'Callisto' },
      [le.CALVARION]: { name: "Calvar'ion" },
      [le.CERBERUS]: { name: 'Cerberus' },
      [le.CHAMBERS_OF_XERIC]: { name: 'Chambers Of Xeric' },
      [le.CHAMBERS_OF_XERIC_CM]: { name: 'Chambers Of Xeric (CM)' },
      [le.CHAOS_ELEMENTAL]: { name: 'Chaos Elemental' },
      [le.CHAOS_FANATIC]: { name: 'Chaos Fanatic' },
      [le.COMMANDER_ZILYANA]: { name: 'Commander Zilyana' },
      [le.CORPOREAL_BEAST]: { name: 'Corporeal Beast' },
      [le.CRAZY_ARCHAEOLOGIST]: { name: 'Crazy Archaeologist' },
      [le.DAGANNOTH_PRIME]: { name: 'Dagannoth Prime' },
      [le.DAGANNOTH_REX]: { name: 'Dagannoth Rex' },
      [le.DAGANNOTH_SUPREME]: { name: 'Dagannoth Supreme' },
      [le.DERANGED_ARCHAEOLOGIST]: { name: 'Deranged Archaeologist' },
      [le.DUKE_SUCELLUS]: { name: 'Duke Sucellus' },
      [le.GENERAL_GRAARDOR]: { name: 'General Graardor' },
      [le.GIANT_MOLE]: { name: 'Giant Mole' },
      [le.GROTESQUE_GUARDIANS]: { name: 'Grotesque Guardians' },
      [le.HESPORI]: { name: 'Hespori' },
      [le.KALPHITE_QUEEN]: { name: 'Kalphite Queen' },
      [le.KING_BLACK_DRAGON]: { name: 'King Black Dragon' },
      [le.KRAKEN]: { name: 'Kraken' },
      [le.KREEARRA]: { name: "Kree'Arra" },
      [le.KRIL_TSUTSAROTH]: { name: "K'ril Tsutsaroth" },
      [le.LUNAR_CHESTS]: { name: 'Lunar Chests' },
      [le.MIMIC]: { name: 'Mimic', minimumValue: 1 },
      [le.NEX]: { name: 'Nex' },
      [le.NIGHTMARE]: { name: 'Nightmare' },
      [le.PHOSANIS_NIGHTMARE]: { name: "Phosani's Nightmare" },
      [le.OBOR]: { name: 'Obor', isMembers: !1 },
      [le.PHANTOM_MUSPAH]: { name: 'Phantom Muspah' },
      [le.SARACHNIS]: { name: 'Sarachnis' },
      [le.SCORPIA]: { name: 'Scorpia' },
      [le.SCURRIUS]: { name: 'Scurrius' },
      [le.SKOTIZO]: { name: 'Skotizo' },
      [le.SOL_HEREDIT]: { name: 'Sol Heredit', minimumValue: 1 },
      [le.SPINDEL]: { name: 'Spindel' },
      [le.TEMPOROSS]: { name: 'Tempoross' },
      [le.THE_GAUNTLET]: { name: 'The Gauntlet' },
      [le.THE_CORRUPTED_GAUNTLET]: { name: 'The Corrupted Gauntlet' },
      [le.THE_LEVIATHAN]: { name: 'The Leviathan' },
      [le.THE_WHISPERER]: { name: 'The Whisperer' },
      [le.THEATRE_OF_BLOOD]: { name: 'Theatre Of Blood' },
      [le.THEATRE_OF_BLOOD_HARD_MODE]: { name: 'Theatre Of Blood (HM)' },
      [le.THERMONUCLEAR_SMOKE_DEVIL]: { name: 'Thermonuclear Smoke Devil' },
      [le.TOMBS_OF_AMASCUT]: { name: 'Tombs of Amascut' },
      [le.TOMBS_OF_AMASCUT_EXPERT]: { name: 'Tombs of Amascut (Expert Mode)' },
      [le.TZKAL_ZUK]: { name: 'TzKal-Zuk', minimumValue: 1 },
      [le.TZTOK_JAD]: { name: 'TzTok-Jad' },
      [le.VARDORVIS]: { name: 'Vardorvis' },
      [le.VENENATIS]: { name: 'Venenatis' },
      [le.VETION]: { name: "Vet'ion" },
      [le.VORKATH]: { name: 'Vorkath' },
      [le.WINTERTODT]: { name: 'Wintertodt' },
      [le.ZALCANO]: { name: 'Zalcano' },
      [le.ZULRAH]: { name: 'Zulrah' }
    },
    (t) =>
      Object.assign(Object.assign({}, t), {
        type: Tl.BOSS,
        measure: wl.KILLS,
        isMembers: 'isMembers' in t ? t.isMembers : !0,
        minimumValue: 'minimumValue' in t ? t.minimumValue : 5
      })
  ),
  UH = Eh(
    {
      [cn.LEAGUE_POINTS]: { name: 'League Points', minimumValue: 100 },
      [cn.BOUNTY_HUNTER_HUNTER]: { name: 'Bounty Hunter (Hunter)', minimumValue: 2 },
      [cn.BOUNTY_HUNTER_ROGUE]: { name: 'Bounty Hunter (Rogue)', minimumValue: 2 },
      [cn.CLUE_SCROLLS_ALL]: { name: 'Clue Scrolls (All)' },
      [cn.CLUE_SCROLLS_BEGINNER]: { name: 'Clue Scrolls (Beginner)' },
      [cn.CLUE_SCROLLS_EASY]: { name: 'Clue Scrolls (Easy)' },
      [cn.CLUE_SCROLLS_MEDIUM]: { name: 'Clue Scrolls (Medium)' },
      [cn.CLUE_SCROLLS_HARD]: { name: 'Clue Scrolls (Hard)' },
      [cn.CLUE_SCROLLS_ELITE]: { name: 'Clue Scrolls (Elite)' },
      [cn.CLUE_SCROLLS_MASTER]: { name: 'Clue Scrolls (Master)' },
      [cn.LAST_MAN_STANDING]: { name: 'Last Man Standing', minimumValue: 500 },
      [cn.PVP_ARENA]: { name: 'PvP Arena', minimumValue: 2525 },
      [cn.SOUL_WARS_ZEAL]: { name: 'Soul Wars Zeal', minimumValue: 200 },
      [cn.GUARDIANS_OF_THE_RIFT]: { name: 'Guardians of the Rift', minimumValue: 2 },
      [cn.COLOSSEUM_GLORY]: { name: 'Colosseum Glory', minimumValue: 300 }
    },
    (t) =>
      Object.assign(Object.assign({}, t), {
        type: Tl.ACTIVITY,
        measure: wl.SCORE,
        minimumValue: 'minimumValue' in t ? t.minimumValue : 1
      })
  ),
  $H = Eh({ [Lf.EHP]: { name: 'EHP' }, [Lf.EHB]: { name: 'EHB' } }, (t) =>
    Object.assign(Object.assign({}, t), { type: Tl.COMPUTED, measure: wl.VALUE })
  ),
  D1 = Object.assign(Object.assign(Object.assign(Object.assign({}, FH), BH), UH), $H),
  HH = Object.values(P_),
  Th = Object.values(ut),
  HO = Object.values(le),
  zH = Object.values(cn)
Object.values(Lf)
Th.filter((t) => t !== ut.OVERALL)
HO.filter((t) => !D1[t].isMembers)
Th.filter((t) => D1[t].isMembers)
Th.filter((t) => D1[t].isCombat)
;[...Th, ...HO, ...zH]
var Uw
;(function (t) {
  ;(t.MAIN = 'main'),
    (t.IRONMAN = 'ironman'),
    (t.ULTIMATE = 'ultimate'),
    (t.LVL3 = 'lvl3'),
    (t.F2P = 'f2p'),
    (t.F2P_LVL3 = 'f2p_lvl3'),
    (t.F2P_IRONMAN = 'f2p_ironman'),
    (t.F2P_LVL3_IRONMAN = 'f2p_lvl3_ironman')
})(Uw || (Uw = {}))
var $w
;(function (t) {
  ;(t[(t.TEMPLE_OSRS = 0)] = 'TEMPLE_OSRS'), (t[(t.CRYSTAL_MATH_LABS = 1)] = 'CRYSTAL_MATH_LABS')
})($w || ($w = {}))
var Hw
;(function (t) {
  ;(t[(t.HISCORES = 0)] = 'HISCORES'), (t[(t.CRYSTAL_MATH_LABS = 1)] = 'CRYSTAL_MATH_LABS')
})(Hw || (Hw = {}))
class jH extends Zs {
  getEfficiencyLeaderboards(e, n) {
    return this.getRequest('/efficiency/leaderboard', Object.assign(Object.assign({}, e), n))
  }
  getEHPRates(e) {
    return this.getRequest('/efficiency/rates', { metric: P_.EHP, type: e })
  }
  getEHBRates(e) {
    return this.getRequest('/efficiency/rates', { metric: P_.EHB, type: e })
  }
}
class WH extends Zs {
  searchNameChanges(e, n) {
    return this.getRequest('/names', Object.assign(Object.assign({}, e), n))
  }
  submitNameChange(e, n) {
    return this.postRequest('/names', { oldName: e, newName: n })
  }
}
class GH extends Zs {
  searchCompetitions(e, n) {
    return this.getRequest('/competitions', Object.assign(Object.assign({}, e), n))
  }
  getCompetitionDetails(e, n) {
    return this.getRequest(`/competitions/${e}`, { metric: n })
  }
  getCompetitionDetailsCSV(e, n) {
    return this.getText(`/competitions/${e}/csv`, Object.assign({ metric: n.previewMetric }, n))
  }
  getCompetitionTopHistory(e, n) {
    return this.getRequest(`/competitions/${e}/top-history`, { metric: n })
  }
  createCompetition(e) {
    return this.postRequest('/competitions', e)
  }
  editCompetition(e, n, r) {
    return this.putRequest(
      `/competitions/${e}`,
      Object.assign(Object.assign({}, n), { verificationCode: r })
    )
  }
  deleteCompetition(e, n) {
    return this.deleteRequest(`/competitions/${e}`, { verificationCode: n })
  }
  addParticipants(e, n, r) {
    return this.postRequest(`/competitions/${e}/participants`, {
      verificationCode: r,
      participants: n
    })
  }
  removeParticipants(e, n, r) {
    return this.deleteRequest(`/competitions/${e}/participants`, {
      verificationCode: r,
      participants: n
    })
  }
  addTeams(e, n, r) {
    return this.postRequest(`/competitions/${e}/teams`, { verificationCode: r, teams: n })
  }
  removeTeams(e, n, r) {
    return this.deleteRequest(`/competitions/${e}/teams`, { verificationCode: r, teamNames: n })
  }
  updateAll(e, n) {
    return this.postRequest(`/competitions/${e}/update-all`, { verificationCode: n })
  }
}
class qH extends Zs {
  constructor(e) {
    const n = (e == null ? void 0 : e.baseAPIUrl) || Vw.baseAPIUrl,
      r = { 'x-user-agent': (e == null ? void 0 : e.userAgent) || Vw.defaultUserAgent }
    e != null && e.apiKey && (r['x-api-key'] = e.apiKey),
      super(r, n),
      (this.deltas = new PH(r, n)),
      (this.groups = new xH(r, n)),
      (this.players = new DH(r, n)),
      (this.records = new LH(r, n)),
      (this.efficiency = new jH(r, n)),
      (this.nameChanges = new WH(r, n)),
      (this.competitions = new GH(r, n))
  }
}
const zO = XA({
    apiKey: 'AIzaSyAnOiG77O1ukT9C2x8u1VbMLw7For9C_3w',
    authDomain: 'bingo-50cec.firebaseapp.com',
    databaseURL: 'https://bingo-50cec-default-rtdb.europe-west1.firebasedatabase.app',
    projectId: 'bingo-50cec',
    storageBucket: 'bingo-50cec.appspot.com',
    messagingSenderId: '866066986693',
    appId: '1:866066986693:web:de513df8434d232b0562ac',
    measurementId: 'G-8F3EECYHQ0'
  }),
  rr = q8(zO),
  KH = (t) => (yp('data-v-7386bc23'), (t = t()), _p(), t),
  YH = KH(() => C('h1', null, 'Hello World', -1)),
  JH = { key: 0 },
  QH = { key: 2 },
  XH = Wr({
    __name: 'newBoard.vapor',
    async setup(t) {
      let e, n
      const r = (([e, n] = qd(() => p5())), (e = await e), n(), e),
        i = Ue(!1),
        s = Ue(40963),
        o = Ue(),
        a = new qH(),
        l = Ue({}),
        c = Ue({
          weekday: 'short',
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          hour: 'numeric',
          minute: 'numeric'
        }),
        u = Ue({}),
        h = async () => {
          !s.value ||
            s.value <= 0 ||
            isNaN(s.value) ||
            (await a.competitions
              .getCompetitionDetails(s.value)
              .then(async (p) => {
                if (p != null && p.message) throw new Error('Error creating bingo: ' + p.message)
                if ((p == null ? void 0 : p.metric) != 'overall')
                  throw new Error('Error creating bingo: Metric should be set to `Overall`')
                if ((p == null ? void 0 : p.type) != 'team')
                  throw new Error('Error creating bingo: Type should be set to `Team`')
                if (!(p != null && p.participations))
                  throw new Error('Error creating bingo: No participants found')
                if (new Date() > p.endsAt)
                  throw new Error('Error creating bingo: Competition has already ended')
                const m = _r(rr, 'Boards', s.value.toString())
                if ((await I1(m)).exists())
                  throw new Error('Error creating bingo: Board already exists')
                ;(u.value = { name: p.title, start: p.startsAt, end: p.endsAt }),
                  (l.value = d(p)),
                  (i.value = !0)
              })
              .catch((p) => {
                o.value = p.message
              }))
        },
        d = (p) => {
          var _
          const m = Ue(),
            g = Ue({})
          return (
            (m.value = p.participations),
            (_ = m.value) == null ||
              _.map((v) => {
                g.value[v.teamName] = { teamName: v.teamName, players: [], stats: null }
              }),
            m.value.map((v) => {
              delete v.player.ehb,
                delete v.player.exp,
                delete v.player.ehp,
                (g.value[v.teamName].players = [
                  ...g.value[v.teamName].players,
                  (g.value[v.teamName].players[v.player.username] = { ...v.player })
                ])
            }),
            g.value
          )
        },
        f = async () => {
          const p = _r(rr, 'Boards', s.value.toString())
          r &&
            (await pw(p, { ownerID: r.uid }).then(() => {
              const m = _r(rr, 'Users', r.uid)
              for (let g in l.value) {
                const _ = _r(mc(rr, 'Boards', p.id, 'Groups')),
                  v = l.value[g]
                pw(_r(rr, _.path), {
                  teamName: v.teamName,
                  teamId: _.id,
                  players: l.value[g].players,
                  stats: null
                })
              }
              I_(p, { name: u.value.name, start: u.value.start, end: u.value.end }),
                I_(m, { boards: rU(p.id) })
            })),
            (i.value = !1)
        }
      return (p, m) => {
        var g, _
        return (
          de(),
          De('div', null, [
            YH,
            o.value ? (de(), De('p', JH, It(o.value), 1)) : ft('', !0),
            Sn(
              C(
                'input',
                {
                  type: 'number',
                  'onUpdate:modelValue': m[0] || (m[0] = (v) => (s.value = v)),
                  placeholder: '12345 WOM Team competition code',
                  min: '0',
                  onFocusin:
                    m[1] ||
                    (m[1] = () => {
                      o.value = ''
                    })
                },
                null,
                544
              ),
              [[ki, s.value]]
            ),
            C('button', { onClick: m[2] || (m[2] = (v) => h()) }, 'Create new Bingo'),
            i.value
              ? (de(),
                De('button', { key: 1, onClick: m[3] || (m[3] = (v) => f()) }, 'finish setup'))
              : ft('', !0),
            l.value !== null && i.value
              ? (de(),
                De('div', QH, [
                  C('h1', null, It(u.value.name), 1),
                  u.value.start
                    ? (de(),
                      De(
                        pt,
                        { key: 0 },
                        [
                          C(
                            'p',
                            null,
                            ' Starts: ' + It(u.value.start.toLocaleDateString(void 0, c.value)),
                            1
                          ),
                          C(
                            'code',
                            null,
                            '<t:' +
                              It(((g = u.value.start) == null ? void 0 : g.valueOf()) / 1e3) +
                              ':F>',
                            1
                          )
                        ],
                        64
                      ))
                    : ft('', !0),
                  u.value.end
                    ? (de(),
                      De(
                        pt,
                        { key: 1 },
                        [
                          C(
                            'p',
                            null,
                            ' Ends: ' + It(u.value.end.toLocaleDateString(void 0, c.value)),
                            1
                          ),
                          C(
                            'code',
                            null,
                            '<t:' +
                              It(((_ = u.value.end) == null ? void 0 : _.valueOf()) / 1e3) +
                              ':F>',
                            1
                          )
                        ],
                        64
                      ))
                    : ft('', !0),
                  (de(!0),
                  De(
                    pt,
                    null,
                    Fs(
                      l.value,
                      (v) => (
                        de(),
                        De('div', { key: v.teamName }, [
                          C('h2', null, It(v.teamName), 1),
                          (de(!0),
                          De(
                            pt,
                            null,
                            Fs(
                              v.players,
                              (T) => (
                                de(),
                                De('div', { key: T.username }, [C('div', null, It(T.username), 1)])
                              )
                            ),
                            128
                          ))
                        ])
                      )
                    ),
                    128
                  ))
                ]))
              : ft('', !0)
          ])
        )
      }
    }
  }),
  ZH = ga(XH, [['__scopeId', 'data-v-7386bc23']]),
  ez = { key: 0 },
  tz = C('h1', null, 'Log in', -1),
  nz = C('p', null, 'you need to be signed in to edit, create and moderate a board', -1),
  rz = C('h1', null, 'User details', -1),
  iz = C('h2', null, 'Boards', -1),
  sz = ['onClick'],
  oz = ['onClick'],
  az = Wr({
    __name: 'loginView.vapor',
    async setup(t) {
      let e, n
      const r = M1(),
        i = new Mi(),
        s = zU(),
        o = DC(),
        a = Ue()
      if (o.value) {
        const { data: d, promise: f } = bO(_r(rr, 'Users', o.value.uid))
        ;([e, n] = qd(() =>
          f.value.then(() => {
            var p
            a.value = (p = d.value) == null ? void 0 : p.boards
          })
        )),
          await e,
          n()
      }
      const l = x1(),
        c = () => (o.value ? 'User details' : 'log in')
      l.value = c() + ' - Bingo Bongo'
      const u = () => {
          BL(s, i)
            .then(() => {
              console.log(o), r.push({ name: 'Home' })
            })
            .catch((d) => {
              const f = d.message
              console.error(f)
            })
        },
        h = () => {
          _L(s).then(() => r.push({ name: 'Home' }))
        }
      return (d, f) =>
        Xe(o)
          ? (de(),
            De(
              pt,
              { key: 1 },
              [
                C('div', null, [
                  rz,
                  C('button', { class: 'btn', onClick: ht(h, ['prevent']) }, 'Log out')
                ]),
                C('div', null, [
                  iz,
                  C('ul', null, [
                    (de(!0),
                    De(
                      pt,
                      null,
                      Fs(
                        a.value,
                        (p) => (
                          de(),
                          De('li', null, [
                            (de(),
                            De('label', { key: p }, [
                              dt(It(p) + ' ', 1),
                              C(
                                'a',
                                {
                                  icon: '',
                                  class: 'btn',
                                  onClick: ht(
                                    (m) =>
                                      Xe(r).push({ name: 'editBoard', params: { boardUUID: p } }),
                                    ['prevent']
                                  )
                                },
                                'edit',
                                8,
                                sz
                              )
                            ])),
                            C(
                              'a',
                              {
                                icon: '',
                                class: 'btn',
                                onClick: ht(
                                  (m) =>
                                    Xe(r).push({
                                      name: 'viewBingoBoard',
                                      params: { boardUUID: p }
                                    }),
                                  ['prevent']
                                )
                              },
                              'visibility',
                              8,
                              oz
                            )
                          ])
                        )
                      ),
                      256
                    ))
                  ])
                ])
              ],
              64
            ))
          : (de(),
            De('div', ez, [
              tz,
              nz,
              Xe(o)
                ? ft('', !0)
                : (de(),
                  De(
                    'button',
                    { key: 0, class: 'btn', onClick: ht(u, ['prevent']) },
                    'Log in with Google'
                  ))
            ]))
    }
  })
/**!
 * Sortable 1.15.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */ function zw(t, e) {
  var n = Object.keys(t)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Ei(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? zw(Object(n), !0).forEach(function (r) {
          lz(t, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : zw(Object(n)).forEach(function (r) {
          Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
        })
  }
  return t
}
function Md(t) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (Md = function (e) {
          return typeof e
        })
      : (Md = function (e) {
          return e &&
            typeof Symbol == 'function' &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        }),
    Md(t)
  )
}
function lz(t, e, n) {
  return (
    e in t
      ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (t[e] = n),
    t
  )
}
function Gi() {
  return (
    (Gi =
      Object.assign ||
      function (t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = arguments[e]
          for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
      }),
    Gi.apply(this, arguments)
  )
}
function cz(t, e) {
  if (t == null) return {}
  var n = {},
    r = Object.keys(t),
    i,
    s
  for (s = 0; s < r.length; s++) (i = r[s]), !(e.indexOf(i) >= 0) && (n[i] = t[i])
  return n
}
function uz(t, e) {
  if (t == null) return {}
  var n = cz(t, e),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(t)
    for (i = 0; i < s.length; i++)
      (r = s[i]),
        !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
  }
  return n
}
var hz = '1.15.2'
function $i(t) {
  if (typeof window < 'u' && window.navigator) return !!navigator.userAgent.match(t)
}
var Xi = $i(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i),
  wh = $i(/Edge/i),
  jw = $i(/firefox/i),
  zc = $i(/safari/i) && !$i(/chrome/i) && !$i(/android/i),
  jO = $i(/iP(ad|od|hone)/i),
  WO = $i(/chrome/i) && $i(/android/i),
  GO = { capture: !1, passive: !1 }
function Ze(t, e, n) {
  t.addEventListener(e, n, !Xi && GO)
}
function Ye(t, e, n) {
  t.removeEventListener(e, n, !Xi && GO)
}
function Vf(t, e) {
  if (e) {
    if ((e[0] === '>' && (e = e.substring(1)), t))
      try {
        if (t.matches) return t.matches(e)
        if (t.msMatchesSelector) return t.msMatchesSelector(e)
        if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e)
      } catch {
        return !1
      }
    return !1
  }
}
function dz(t) {
  return t.host && t !== document && t.host.nodeType ? t.host : t.parentNode
}
function Or(t, e, n, r) {
  if (t) {
    n = n || document
    do {
      if (
        (e != null && (e[0] === '>' ? t.parentNode === n && Vf(t, e) : Vf(t, e))) ||
        (r && t === n)
      )
        return t
      if (t === n) break
    } while ((t = dz(t)))
  }
  return null
}
var Ww = /\s+/g
function Zn(t, e, n) {
  if (t && e)
    if (t.classList) t.classList[n ? 'add' : 'remove'](e)
    else {
      var r = (' ' + t.className + ' ').replace(Ww, ' ').replace(' ' + e + ' ', ' ')
      t.className = (r + (n ? ' ' + e : '')).replace(Ww, ' ')
    }
}
function we(t, e, n) {
  var r = t && t.style
  if (r) {
    if (n === void 0)
      return (
        document.defaultView && document.defaultView.getComputedStyle
          ? (n = document.defaultView.getComputedStyle(t, ''))
          : t.currentStyle && (n = t.currentStyle),
        e === void 0 ? n : n[e]
      )
    !(e in r) && e.indexOf('webkit') === -1 && (e = '-webkit-' + e),
      (r[e] = n + (typeof n == 'string' ? '' : 'px'))
  }
}
function Za(t, e) {
  var n = ''
  if (typeof t == 'string') n = t
  else
    do {
      var r = we(t, 'transform')
      r && r !== 'none' && (n = r + ' ' + n)
    } while (!e && (t = t.parentNode))
  var i = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix
  return i && new i(n)
}
function qO(t, e, n) {
  if (t) {
    var r = t.getElementsByTagName(e),
      i = 0,
      s = r.length
    if (n) for (; i < s; i++) n(r[i], i)
    return r
  }
  return []
}
function fi() {
  var t = document.scrollingElement
  return t || document.documentElement
}
function Ft(t, e, n, r, i) {
  if (!(!t.getBoundingClientRect && t !== window)) {
    var s, o, a, l, c, u, h
    if (
      (t !== window && t.parentNode && t !== fi()
        ? ((s = t.getBoundingClientRect()),
          (o = s.top),
          (a = s.left),
          (l = s.bottom),
          (c = s.right),
          (u = s.height),
          (h = s.width))
        : ((o = 0),
          (a = 0),
          (l = window.innerHeight),
          (c = window.innerWidth),
          (u = window.innerHeight),
          (h = window.innerWidth)),
      (e || n) && t !== window && ((i = i || t.parentNode), !Xi))
    )
      do
        if (
          i &&
          i.getBoundingClientRect &&
          (we(i, 'transform') !== 'none' || (n && we(i, 'position') !== 'static'))
        ) {
          var d = i.getBoundingClientRect()
          ;(o -= d.top + parseInt(we(i, 'border-top-width'))),
            (a -= d.left + parseInt(we(i, 'border-left-width'))),
            (l = o + s.height),
            (c = a + s.width)
          break
        }
      while ((i = i.parentNode))
    if (r && t !== window) {
      var f = Za(i || t),
        p = f && f.a,
        m = f && f.d
      f && ((o /= m), (a /= p), (h /= p), (u /= m), (l = o + u), (c = a + h))
    }
    return { top: o, left: a, bottom: l, right: c, width: h, height: u }
  }
}
function Gw(t, e, n) {
  for (var r = ws(t, !0), i = Ft(t)[e]; r; ) {
    var s = Ft(r)[n],
      o = void 0
    if ((n === 'top' || n === 'left' ? (o = i >= s) : (o = i <= s), !o)) return r
    if (r === fi()) break
    r = ws(r, !1)
  }
  return !1
}
function Sl(t, e, n, r) {
  for (var i = 0, s = 0, o = t.children; s < o.length; ) {
    if (
      o[s].style.display !== 'none' &&
      o[s] !== Se.ghost &&
      (r || o[s] !== Se.dragged) &&
      Or(o[s], n.draggable, t, !1)
    ) {
      if (i === e) return o[s]
      i++
    }
    s++
  }
  return null
}
function L1(t, e) {
  for (
    var n = t.lastElementChild;
    n && (n === Se.ghost || we(n, 'display') === 'none' || (e && !Vf(n, e)));

  )
    n = n.previousElementSibling
  return n || null
}
function gr(t, e) {
  var n = 0
  if (!t || !t.parentNode) return -1
  for (; (t = t.previousElementSibling); )
    t.nodeName.toUpperCase() !== 'TEMPLATE' && t !== Se.clone && (!e || Vf(t, e)) && n++
  return n
}
function qw(t) {
  var e = 0,
    n = 0,
    r = fi()
  if (t)
    do {
      var i = Za(t),
        s = i.a,
        o = i.d
      ;(e += t.scrollLeft * s), (n += t.scrollTop * o)
    } while (t !== r && (t = t.parentNode))
  return [e, n]
}
function fz(t, e) {
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      for (var r in e) if (e.hasOwnProperty(r) && e[r] === t[n][r]) return Number(n)
    }
  return -1
}
function ws(t, e) {
  if (!t || !t.getBoundingClientRect) return fi()
  var n = t,
    r = !1
  do
    if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) {
      var i = we(n)
      if (
        (n.clientWidth < n.scrollWidth && (i.overflowX == 'auto' || i.overflowX == 'scroll')) ||
        (n.clientHeight < n.scrollHeight && (i.overflowY == 'auto' || i.overflowY == 'scroll'))
      ) {
        if (!n.getBoundingClientRect || n === document.body) return fi()
        if (r || e) return n
        r = !0
      }
    }
  while ((n = n.parentNode))
  return fi()
}
function pz(t, e) {
  if (t && e) for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
  return t
}
function Ig(t, e) {
  return (
    Math.round(t.top) === Math.round(e.top) &&
    Math.round(t.left) === Math.round(e.left) &&
    Math.round(t.height) === Math.round(e.height) &&
    Math.round(t.width) === Math.round(e.width)
  )
}
var jc
function KO(t, e) {
  return function () {
    if (!jc) {
      var n = arguments,
        r = this
      n.length === 1 ? t.call(r, n[0]) : t.apply(r, n),
        (jc = setTimeout(function () {
          jc = void 0
        }, e))
    }
  }
}
function mz() {
  clearTimeout(jc), (jc = void 0)
}
function YO(t, e, n) {
  ;(t.scrollLeft += e), (t.scrollTop += n)
}
function JO(t) {
  var e = window.Polymer,
    n = window.jQuery || window.Zepto
  return e && e.dom ? e.dom(t).cloneNode(!0) : n ? n(t).clone(!0)[0] : t.cloneNode(!0)
}
function QO(t, e, n) {
  var r = {}
  return (
    Array.from(t.children).forEach(function (i) {
      var s, o, a, l
      if (!(!Or(i, e.draggable, t, !1) || i.animated || i === n)) {
        var c = Ft(i)
        ;(r.left = Math.min((s = r.left) !== null && s !== void 0 ? s : 1 / 0, c.left)),
          (r.top = Math.min((o = r.top) !== null && o !== void 0 ? o : 1 / 0, c.top)),
          (r.right = Math.max((a = r.right) !== null && a !== void 0 ? a : -1 / 0, c.right)),
          (r.bottom = Math.max((l = r.bottom) !== null && l !== void 0 ? l : -1 / 0, c.bottom))
      }
    }),
    (r.width = r.right - r.left),
    (r.height = r.bottom - r.top),
    (r.x = r.left),
    (r.y = r.top),
    r
  )
}
var ir = 'Sortable' + new Date().getTime()
function gz() {
  var t = [],
    e
  return {
    captureAnimationState: function () {
      if (((t = []), !!this.options.animation)) {
        var r = [].slice.call(this.el.children)
        r.forEach(function (i) {
          if (!(we(i, 'display') === 'none' || i === Se.ghost)) {
            t.push({ target: i, rect: Ft(i) })
            var s = Ei({}, t[t.length - 1].rect)
            if (i.thisAnimationDuration) {
              var o = Za(i, !0)
              o && ((s.top -= o.f), (s.left -= o.e))
            }
            i.fromRect = s
          }
        })
      }
    },
    addAnimationState: function (r) {
      t.push(r)
    },
    removeAnimationState: function (r) {
      t.splice(fz(t, { target: r }), 1)
    },
    animateAll: function (r) {
      var i = this
      if (!this.options.animation) {
        clearTimeout(e), typeof r == 'function' && r()
        return
      }
      var s = !1,
        o = 0
      t.forEach(function (a) {
        var l = 0,
          c = a.target,
          u = c.fromRect,
          h = Ft(c),
          d = c.prevFromRect,
          f = c.prevToRect,
          p = a.rect,
          m = Za(c, !0)
        m && ((h.top -= m.f), (h.left -= m.e)),
          (c.toRect = h),
          c.thisAnimationDuration &&
            Ig(d, h) &&
            !Ig(u, h) &&
            (p.top - h.top) / (p.left - h.left) === (u.top - h.top) / (u.left - h.left) &&
            (l = _z(p, d, f, i.options)),
          Ig(h, u) ||
            ((c.prevFromRect = u),
            (c.prevToRect = h),
            l || (l = i.options.animation),
            i.animate(c, p, h, l)),
          l &&
            ((s = !0),
            (o = Math.max(o, l)),
            clearTimeout(c.animationResetTimer),
            (c.animationResetTimer = setTimeout(function () {
              ;(c.animationTime = 0),
                (c.prevFromRect = null),
                (c.fromRect = null),
                (c.prevToRect = null),
                (c.thisAnimationDuration = null)
            }, l)),
            (c.thisAnimationDuration = l))
      }),
        clearTimeout(e),
        s
          ? (e = setTimeout(function () {
              typeof r == 'function' && r()
            }, o))
          : typeof r == 'function' && r(),
        (t = [])
    },
    animate: function (r, i, s, o) {
      if (o) {
        we(r, 'transition', ''), we(r, 'transform', '')
        var a = Za(this.el),
          l = a && a.a,
          c = a && a.d,
          u = (i.left - s.left) / (l || 1),
          h = (i.top - s.top) / (c || 1)
        ;(r.animatingX = !!u),
          (r.animatingY = !!h),
          we(r, 'transform', 'translate3d(' + u + 'px,' + h + 'px,0)'),
          (this.forRepaintDummy = yz(r)),
          we(
            r,
            'transition',
            'transform ' + o + 'ms' + (this.options.easing ? ' ' + this.options.easing : '')
          ),
          we(r, 'transform', 'translate3d(0,0,0)'),
          typeof r.animated == 'number' && clearTimeout(r.animated),
          (r.animated = setTimeout(function () {
            we(r, 'transition', ''),
              we(r, 'transform', ''),
              (r.animated = !1),
              (r.animatingX = !1),
              (r.animatingY = !1)
          }, o))
      }
    }
  }
}
function yz(t) {
  return t.offsetWidth
}
function _z(t, e, n, r) {
  return (
    (Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) /
      Math.sqrt(Math.pow(e.top - n.top, 2) + Math.pow(e.left - n.left, 2))) *
    r.animation
  )
}
var ba = [],
  Ag = { initializeByDefault: !0 },
  Sh = {
    mount: function (e) {
      for (var n in Ag) Ag.hasOwnProperty(n) && !(n in e) && (e[n] = Ag[n])
      ba.forEach(function (r) {
        if (r.pluginName === e.pluginName)
          throw 'Sortable: Cannot mount plugin '.concat(e.pluginName, ' more than once')
      }),
        ba.push(e)
    },
    pluginEvent: function (e, n, r) {
      var i = this
      ;(this.eventCanceled = !1),
        (r.cancel = function () {
          i.eventCanceled = !0
        })
      var s = e + 'Global'
      ba.forEach(function (o) {
        n[o.pluginName] &&
          (n[o.pluginName][s] && n[o.pluginName][s](Ei({ sortable: n }, r)),
          n.options[o.pluginName] &&
            n[o.pluginName][e] &&
            n[o.pluginName][e](Ei({ sortable: n }, r)))
      })
    },
    initializePlugins: function (e, n, r, i) {
      ba.forEach(function (a) {
        var l = a.pluginName
        if (!(!e.options[l] && !a.initializeByDefault)) {
          var c = new a(e, n, e.options)
          ;(c.sortable = e), (c.options = e.options), (e[l] = c), Gi(r, c.defaults)
        }
      })
      for (var s in e.options)
        if (e.options.hasOwnProperty(s)) {
          var o = this.modifyOption(e, s, e.options[s])
          typeof o < 'u' && (e.options[s] = o)
        }
    },
    getEventProperties: function (e, n) {
      var r = {}
      return (
        ba.forEach(function (i) {
          typeof i.eventProperties == 'function' &&
            Gi(r, i.eventProperties.call(n[i.pluginName], e))
        }),
        r
      )
    },
    modifyOption: function (e, n, r) {
      var i
      return (
        ba.forEach(function (s) {
          e[s.pluginName] &&
            s.optionListeners &&
            typeof s.optionListeners[n] == 'function' &&
            (i = s.optionListeners[n].call(e[s.pluginName], r))
        }),
        i
      )
    }
  }
function vz(t) {
  var e = t.sortable,
    n = t.rootEl,
    r = t.name,
    i = t.targetEl,
    s = t.cloneEl,
    o = t.toEl,
    a = t.fromEl,
    l = t.oldIndex,
    c = t.newIndex,
    u = t.oldDraggableIndex,
    h = t.newDraggableIndex,
    d = t.originalEvent,
    f = t.putSortable,
    p = t.extraEventProperties
  if (((e = e || (n && n[ir])), !!e)) {
    var m,
      g = e.options,
      _ = 'on' + r.charAt(0).toUpperCase() + r.substr(1)
    window.CustomEvent && !Xi && !wh
      ? (m = new CustomEvent(r, { bubbles: !0, cancelable: !0 }))
      : ((m = document.createEvent('Event')), m.initEvent(r, !0, !0)),
      (m.to = o || n),
      (m.from = a || n),
      (m.item = i || n),
      (m.clone = s),
      (m.oldIndex = l),
      (m.newIndex = c),
      (m.oldDraggableIndex = u),
      (m.newDraggableIndex = h),
      (m.originalEvent = d),
      (m.pullMode = f ? f.lastPutMode : void 0)
    var v = Ei(Ei({}, p), Sh.getEventProperties(r, e))
    for (var T in v) m[T] = v[T]
    n && n.dispatchEvent(m), g[_] && g[_].call(e, m)
  }
}
var bz = ['evt'],
  jn = function (e, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      i = r.evt,
      s = uz(r, bz)
    Sh.pluginEvent.bind(Se)(
      e,
      n,
      Ei(
        {
          dragEl: Q,
          parentEl: kt,
          ghostEl: Oe,
          rootEl: St,
          nextEl: fo,
          lastDownEl: Pd,
          cloneEl: Ct,
          cloneHidden: bs,
          dragStarted: yc,
          putSortable: un,
          activeSortable: Se.active,
          originalEvent: i,
          oldIndex: xa,
          oldDraggableIndex: Wc,
          newIndex: er,
          newDraggableIndex: ps,
          hideGhostForTarget: tN,
          unhideGhostForTarget: nN,
          cloneNowHidden: function () {
            bs = !0
          },
          cloneNowShown: function () {
            bs = !1
          },
          dispatchSortableEvent: function (a) {
            Vn({ sortable: n, name: a, originalEvent: i })
          }
        },
        s
      )
    )
  }
function Vn(t) {
  vz(
    Ei(
      {
        putSortable: un,
        cloneEl: Ct,
        targetEl: Q,
        rootEl: St,
        oldIndex: xa,
        oldDraggableIndex: Wc,
        newIndex: er,
        newDraggableIndex: ps
      },
      t
    )
  )
}
var Q,
  kt,
  Oe,
  St,
  fo,
  Pd,
  Ct,
  bs,
  xa,
  er,
  Wc,
  ps,
  td,
  un,
  Ra = !1,
  Ff = !1,
  Bf = [],
  lo,
  kr,
  Cg,
  Rg,
  Kw,
  Yw,
  yc,
  Ea,
  Gc,
  qc = !1,
  nd = !1,
  xd,
  wn,
  kg = [],
  x_ = !1,
  Uf = [],
  ym = typeof document < 'u',
  rd = jO,
  Jw = wh || Xi ? 'cssFloat' : 'float',
  Ez = ym && !WO && !jO && 'draggable' in document.createElement('div'),
  XO = (function () {
    if (ym) {
      if (Xi) return !1
      var t = document.createElement('x')
      return (t.style.cssText = 'pointer-events:auto'), t.style.pointerEvents === 'auto'
    }
  })(),
  ZO = function (e, n) {
    var r = we(e),
      i =
        parseInt(r.width) -
        parseInt(r.paddingLeft) -
        parseInt(r.paddingRight) -
        parseInt(r.borderLeftWidth) -
        parseInt(r.borderRightWidth),
      s = Sl(e, 0, n),
      o = Sl(e, 1, n),
      a = s && we(s),
      l = o && we(o),
      c = a && parseInt(a.marginLeft) + parseInt(a.marginRight) + Ft(s).width,
      u = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + Ft(o).width
    if (r.display === 'flex')
      return r.flexDirection === 'column' || r.flexDirection === 'column-reverse'
        ? 'vertical'
        : 'horizontal'
    if (r.display === 'grid')
      return r.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal'
    if (s && a.float && a.float !== 'none') {
      var h = a.float === 'left' ? 'left' : 'right'
      return o && (l.clear === 'both' || l.clear === h) ? 'vertical' : 'horizontal'
    }
    return s &&
      (a.display === 'block' ||
        a.display === 'flex' ||
        a.display === 'table' ||
        a.display === 'grid' ||
        (c >= i && r[Jw] === 'none') ||
        (o && r[Jw] === 'none' && c + u > i))
      ? 'vertical'
      : 'horizontal'
  },
  Tz = function (e, n, r) {
    var i = r ? e.left : e.top,
      s = r ? e.right : e.bottom,
      o = r ? e.width : e.height,
      a = r ? n.left : n.top,
      l = r ? n.right : n.bottom,
      c = r ? n.width : n.height
    return i === a || s === l || i + o / 2 === a + c / 2
  },
  wz = function (e, n) {
    var r
    return (
      Bf.some(function (i) {
        var s = i[ir].options.emptyInsertThreshold
        if (!(!s || L1(i))) {
          var o = Ft(i),
            a = e >= o.left - s && e <= o.right + s,
            l = n >= o.top - s && n <= o.bottom + s
          if (a && l) return (r = i)
        }
      }),
      r
    )
  },
  eN = function (e) {
    function n(s, o) {
      return function (a, l, c, u) {
        var h =
          a.options.group.name &&
          l.options.group.name &&
          a.options.group.name === l.options.group.name
        if (s == null && (o || h)) return !0
        if (s == null || s === !1) return !1
        if (o && s === 'clone') return s
        if (typeof s == 'function') return n(s(a, l, c, u), o)(a, l, c, u)
        var d = (o ? a : l).options.group.name
        return s === !0 || (typeof s == 'string' && s === d) || (s.join && s.indexOf(d) > -1)
      }
    }
    var r = {},
      i = e.group
    ;(!i || Md(i) != 'object') && (i = { name: i }),
      (r.name = i.name),
      (r.checkPull = n(i.pull, !0)),
      (r.checkPut = n(i.put)),
      (r.revertClone = i.revertClone),
      (e.group = r)
  },
  tN = function () {
    !XO && Oe && we(Oe, 'display', 'none')
  },
  nN = function () {
    !XO && Oe && we(Oe, 'display', '')
  }
ym &&
  !WO &&
  document.addEventListener(
    'click',
    function (t) {
      if (Ff)
        return (
          t.preventDefault(),
          t.stopPropagation && t.stopPropagation(),
          t.stopImmediatePropagation && t.stopImmediatePropagation(),
          (Ff = !1),
          !1
        )
    },
    !0
  )
var co = function (e) {
    if (Q) {
      e = e.touches ? e.touches[0] : e
      var n = wz(e.clientX, e.clientY)
      if (n) {
        var r = {}
        for (var i in e) e.hasOwnProperty(i) && (r[i] = e[i])
        ;(r.target = r.rootEl = n),
          (r.preventDefault = void 0),
          (r.stopPropagation = void 0),
          n[ir]._onDragOver(r)
      }
    }
  },
  Sz = function (e) {
    Q && Q.parentNode[ir]._isOutsideThisEl(e.target)
  }
function Se(t, e) {
  if (!(t && t.nodeType && t.nodeType === 1))
    throw 'Sortable: `el` must be an HTMLElement, not '.concat({}.toString.call(t))
  ;(this.el = t), (this.options = e = Gi({}, e)), (t[ir] = this)
  var n = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(t.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    invertSwap: !1,
    invertedSwapThreshold: null,
    removeCloneOnHide: !0,
    direction: function () {
      return ZO(t, this.options)
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function (o, a) {
      o.setData('Text', a.textContent)
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold:
      (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: { x: 0, y: 0 },
    supportPointer: Se.supportPointer !== !1 && 'PointerEvent' in window && !zc,
    emptyInsertThreshold: 5
  }
  Sh.initializePlugins(this, t, n)
  for (var r in n) !(r in e) && (e[r] = n[r])
  eN(e)
  for (var i in this)
    i.charAt(0) === '_' && typeof this[i] == 'function' && (this[i] = this[i].bind(this))
  ;(this.nativeDraggable = e.forceFallback ? !1 : Ez),
    this.nativeDraggable && (this.options.touchStartThreshold = 1),
    e.supportPointer
      ? Ze(t, 'pointerdown', this._onTapStart)
      : (Ze(t, 'mousedown', this._onTapStart), Ze(t, 'touchstart', this._onTapStart)),
    this.nativeDraggable && (Ze(t, 'dragover', this), Ze(t, 'dragenter', this)),
    Bf.push(this.el),
    e.store && e.store.get && this.sort(e.store.get(this) || []),
    Gi(this, gz())
}
Se.prototype = {
  constructor: Se,
  _isOutsideThisEl: function (e) {
    !this.el.contains(e) && e !== this.el && (Ea = null)
  },
  _getDirection: function (e, n) {
    return typeof this.options.direction == 'function'
      ? this.options.direction.call(this, e, n, Q)
      : this.options.direction
  },
  _onTapStart: function (e) {
    if (e.cancelable) {
      var n = this,
        r = this.el,
        i = this.options,
        s = i.preventOnFilter,
        o = e.type,
        a = (e.touches && e.touches[0]) || (e.pointerType && e.pointerType === 'touch' && e),
        l = (a || e).target,
        c =
          (e.target.shadowRoot &&
            ((e.path && e.path[0]) || (e.composedPath && e.composedPath()[0]))) ||
          l,
        u = i.filter
      if (
        (Mz(r),
        !Q &&
          !((/mousedown|pointerdown/.test(o) && e.button !== 0) || i.disabled) &&
          !c.isContentEditable &&
          !(!this.nativeDraggable && zc && l && l.tagName.toUpperCase() === 'SELECT') &&
          ((l = Or(l, i.draggable, r, !1)), !(l && l.animated) && Pd !== l))
      ) {
        if (((xa = gr(l)), (Wc = gr(l, i.draggable)), typeof u == 'function')) {
          if (u.call(this, e, l, this)) {
            Vn({ sortable: n, rootEl: c, name: 'filter', targetEl: l, toEl: r, fromEl: r }),
              jn('filter', n, { evt: e }),
              s && e.cancelable && e.preventDefault()
            return
          }
        } else if (
          u &&
          ((u = u.split(',').some(function (h) {
            if (((h = Or(c, h.trim(), r, !1)), h))
              return (
                Vn({ sortable: n, rootEl: h, name: 'filter', targetEl: l, fromEl: r, toEl: r }),
                jn('filter', n, { evt: e }),
                !0
              )
          })),
          u)
        ) {
          s && e.cancelable && e.preventDefault()
          return
        }
        ;(i.handle && !Or(c, i.handle, r, !1)) || this._prepareDragStart(e, a, l)
      }
    }
  },
  _prepareDragStart: function (e, n, r) {
    var i = this,
      s = i.el,
      o = i.options,
      a = s.ownerDocument,
      l
    if (r && !Q && r.parentNode === s) {
      var c = Ft(r)
      if (
        ((St = s),
        (Q = r),
        (kt = Q.parentNode),
        (fo = Q.nextSibling),
        (Pd = r),
        (td = o.group),
        (Se.dragged = Q),
        (lo = { target: Q, clientX: (n || e).clientX, clientY: (n || e).clientY }),
        (Kw = lo.clientX - c.left),
        (Yw = lo.clientY - c.top),
        (this._lastX = (n || e).clientX),
        (this._lastY = (n || e).clientY),
        (Q.style['will-change'] = 'all'),
        (l = function () {
          if ((jn('delayEnded', i, { evt: e }), Se.eventCanceled)) {
            i._onDrop()
            return
          }
          i._disableDelayedDragEvents(),
            !jw && i.nativeDraggable && (Q.draggable = !0),
            i._triggerDragStart(e, n),
            Vn({ sortable: i, name: 'choose', originalEvent: e }),
            Zn(Q, o.chosenClass, !0)
        }),
        o.ignore.split(',').forEach(function (u) {
          qO(Q, u.trim(), Og)
        }),
        Ze(a, 'dragover', co),
        Ze(a, 'mousemove', co),
        Ze(a, 'touchmove', co),
        Ze(a, 'mouseup', i._onDrop),
        Ze(a, 'touchend', i._onDrop),
        Ze(a, 'touchcancel', i._onDrop),
        jw && this.nativeDraggable && ((this.options.touchStartThreshold = 4), (Q.draggable = !0)),
        jn('delayStart', this, { evt: e }),
        o.delay && (!o.delayOnTouchOnly || n) && (!this.nativeDraggable || !(wh || Xi)))
      ) {
        if (Se.eventCanceled) {
          this._onDrop()
          return
        }
        Ze(a, 'mouseup', i._disableDelayedDrag),
          Ze(a, 'touchend', i._disableDelayedDrag),
          Ze(a, 'touchcancel', i._disableDelayedDrag),
          Ze(a, 'mousemove', i._delayedDragTouchMoveHandler),
          Ze(a, 'touchmove', i._delayedDragTouchMoveHandler),
          o.supportPointer && Ze(a, 'pointermove', i._delayedDragTouchMoveHandler),
          (i._dragStartTimer = setTimeout(l, o.delay))
      } else l()
    }
  },
  _delayedDragTouchMoveHandler: function (e) {
    var n = e.touches ? e.touches[0] : e
    Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) >=
      Math.floor(
        this.options.touchStartThreshold / ((this.nativeDraggable && window.devicePixelRatio) || 1)
      ) && this._disableDelayedDrag()
  },
  _disableDelayedDrag: function () {
    Q && Og(Q), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents()
  },
  _disableDelayedDragEvents: function () {
    var e = this.el.ownerDocument
    Ye(e, 'mouseup', this._disableDelayedDrag),
      Ye(e, 'touchend', this._disableDelayedDrag),
      Ye(e, 'touchcancel', this._disableDelayedDrag),
      Ye(e, 'mousemove', this._delayedDragTouchMoveHandler),
      Ye(e, 'touchmove', this._delayedDragTouchMoveHandler),
      Ye(e, 'pointermove', this._delayedDragTouchMoveHandler)
  },
  _triggerDragStart: function (e, n) {
    ;(n = n || (e.pointerType == 'touch' && e)),
      !this.nativeDraggable || n
        ? this.options.supportPointer
          ? Ze(document, 'pointermove', this._onTouchMove)
          : n
          ? Ze(document, 'touchmove', this._onTouchMove)
          : Ze(document, 'mousemove', this._onTouchMove)
        : (Ze(Q, 'dragend', this), Ze(St, 'dragstart', this._onDragStart))
    try {
      document.selection
        ? Dd(function () {
            document.selection.empty()
          })
        : window.getSelection().removeAllRanges()
    } catch {}
  },
  _dragStarted: function (e, n) {
    if (((Ra = !1), St && Q)) {
      jn('dragStarted', this, { evt: n }), this.nativeDraggable && Ze(document, 'dragover', Sz)
      var r = this.options
      !e && Zn(Q, r.dragClass, !1),
        Zn(Q, r.ghostClass, !0),
        (Se.active = this),
        e && this._appendGhost(),
        Vn({ sortable: this, name: 'start', originalEvent: n })
    } else this._nulling()
  },
  _emulateDragOver: function () {
    if (kr) {
      ;(this._lastX = kr.clientX), (this._lastY = kr.clientY), tN()
      for (
        var e = document.elementFromPoint(kr.clientX, kr.clientY), n = e;
        e && e.shadowRoot && ((e = e.shadowRoot.elementFromPoint(kr.clientX, kr.clientY)), e !== n);

      )
        n = e
      if ((Q.parentNode[ir]._isOutsideThisEl(e), n))
        do {
          if (n[ir]) {
            var r = void 0
            if (
              ((r = n[ir]._onDragOver({
                clientX: kr.clientX,
                clientY: kr.clientY,
                target: e,
                rootEl: n
              })),
              r && !this.options.dragoverBubble)
            )
              break
          }
          e = n
        } while ((n = n.parentNode))
      nN()
    }
  },
  _onTouchMove: function (e) {
    if (lo) {
      var n = this.options,
        r = n.fallbackTolerance,
        i = n.fallbackOffset,
        s = e.touches ? e.touches[0] : e,
        o = Oe && Za(Oe, !0),
        a = Oe && o && o.a,
        l = Oe && o && o.d,
        c = rd && wn && qw(wn),
        u = (s.clientX - lo.clientX + i.x) / (a || 1) + (c ? c[0] - kg[0] : 0) / (a || 1),
        h = (s.clientY - lo.clientY + i.y) / (l || 1) + (c ? c[1] - kg[1] : 0) / (l || 1)
      if (!Se.active && !Ra) {
        if (r && Math.max(Math.abs(s.clientX - this._lastX), Math.abs(s.clientY - this._lastY)) < r)
          return
        this._onDragStart(e, !0)
      }
      if (Oe) {
        o
          ? ((o.e += u - (Cg || 0)), (o.f += h - (Rg || 0)))
          : (o = { a: 1, b: 0, c: 0, d: 1, e: u, f: h })
        var d = 'matrix('
          .concat(o.a, ',')
          .concat(o.b, ',')
          .concat(o.c, ',')
          .concat(o.d, ',')
          .concat(o.e, ',')
          .concat(o.f, ')')
        we(Oe, 'webkitTransform', d),
          we(Oe, 'mozTransform', d),
          we(Oe, 'msTransform', d),
          we(Oe, 'transform', d),
          (Cg = u),
          (Rg = h),
          (kr = s)
      }
      e.cancelable && e.preventDefault()
    }
  },
  _appendGhost: function () {
    if (!Oe) {
      var e = this.options.fallbackOnBody ? document.body : St,
        n = Ft(Q, !0, rd, !0, e),
        r = this.options
      if (rd) {
        for (
          wn = e;
          we(wn, 'position') === 'static' && we(wn, 'transform') === 'none' && wn !== document;

        )
          wn = wn.parentNode
        wn !== document.body && wn !== document.documentElement
          ? (wn === document && (wn = fi()), (n.top += wn.scrollTop), (n.left += wn.scrollLeft))
          : (wn = fi()),
          (kg = qw(wn))
      }
      ;(Oe = Q.cloneNode(!0)),
        Zn(Oe, r.ghostClass, !1),
        Zn(Oe, r.fallbackClass, !0),
        Zn(Oe, r.dragClass, !0),
        we(Oe, 'transition', ''),
        we(Oe, 'transform', ''),
        we(Oe, 'box-sizing', 'border-box'),
        we(Oe, 'margin', 0),
        we(Oe, 'top', n.top),
        we(Oe, 'left', n.left),
        we(Oe, 'width', n.width),
        we(Oe, 'height', n.height),
        we(Oe, 'opacity', '0.8'),
        we(Oe, 'position', rd ? 'absolute' : 'fixed'),
        we(Oe, 'zIndex', '100000'),
        we(Oe, 'pointerEvents', 'none'),
        (Se.ghost = Oe),
        e.appendChild(Oe),
        we(
          Oe,
          'transform-origin',
          (Kw / parseInt(Oe.style.width)) * 100 +
            '% ' +
            (Yw / parseInt(Oe.style.height)) * 100 +
            '%'
        )
    }
  },
  _onDragStart: function (e, n) {
    var r = this,
      i = e.dataTransfer,
      s = r.options
    if ((jn('dragStart', this, { evt: e }), Se.eventCanceled)) {
      this._onDrop()
      return
    }
    jn('setupClone', this),
      Se.eventCanceled ||
        ((Ct = JO(Q)),
        Ct.removeAttribute('id'),
        (Ct.draggable = !1),
        (Ct.style['will-change'] = ''),
        this._hideClone(),
        Zn(Ct, this.options.chosenClass, !1),
        (Se.clone = Ct)),
      (r.cloneId = Dd(function () {
        jn('clone', r),
          !Se.eventCanceled &&
            (r.options.removeCloneOnHide || St.insertBefore(Ct, Q),
            r._hideClone(),
            Vn({ sortable: r, name: 'clone' }))
      })),
      !n && Zn(Q, s.dragClass, !0),
      n
        ? ((Ff = !0), (r._loopId = setInterval(r._emulateDragOver, 50)))
        : (Ye(document, 'mouseup', r._onDrop),
          Ye(document, 'touchend', r._onDrop),
          Ye(document, 'touchcancel', r._onDrop),
          i && ((i.effectAllowed = 'move'), s.setData && s.setData.call(r, i, Q)),
          Ze(document, 'drop', r),
          we(Q, 'transform', 'translateZ(0)')),
      (Ra = !0),
      (r._dragStartId = Dd(r._dragStarted.bind(r, n, e))),
      Ze(document, 'selectstart', r),
      (yc = !0),
      zc && we(document.body, 'user-select', 'none')
  },
  _onDragOver: function (e) {
    var n = this.el,
      r = e.target,
      i,
      s,
      o,
      a = this.options,
      l = a.group,
      c = Se.active,
      u = td === l,
      h = a.sort,
      d = un || c,
      f,
      p = this,
      m = !1
    if (x_) return
    function g(D, se) {
      jn(
        D,
        p,
        Ei(
          {
            evt: e,
            isOwner: u,
            axis: f ? 'vertical' : 'horizontal',
            revert: o,
            dragRect: i,
            targetRect: s,
            canSort: h,
            fromSortable: d,
            target: r,
            completed: v,
            onMove: function (Ie, xe) {
              return id(St, n, Q, i, Ie, Ft(Ie), e, xe)
            },
            changed: T
          },
          se
        )
      )
    }
    function _() {
      g('dragOverAnimationCapture'), p.captureAnimationState(), p !== d && d.captureAnimationState()
    }
    function v(D) {
      return (
        g('dragOverCompleted', { insertion: D }),
        D &&
          (u ? c._hideClone() : c._showClone(p),
          p !== d &&
            (Zn(Q, un ? un.options.ghostClass : c.options.ghostClass, !1), Zn(Q, a.ghostClass, !0)),
          un !== p && p !== Se.active ? (un = p) : p === Se.active && un && (un = null),
          d === p && (p._ignoreWhileAnimating = r),
          p.animateAll(function () {
            g('dragOverAnimationComplete'), (p._ignoreWhileAnimating = null)
          }),
          p !== d && (d.animateAll(), (d._ignoreWhileAnimating = null))),
        ((r === Q && !Q.animated) || (r === n && !r.animated)) && (Ea = null),
        !a.dragoverBubble &&
          !e.rootEl &&
          r !== document &&
          (Q.parentNode[ir]._isOutsideThisEl(e.target), !D && co(e)),
        !a.dragoverBubble && e.stopPropagation && e.stopPropagation(),
        (m = !0)
      )
    }
    function T() {
      ;(er = gr(Q)),
        (ps = gr(Q, a.draggable)),
        Vn({
          sortable: p,
          name: 'change',
          toEl: n,
          newIndex: er,
          newDraggableIndex: ps,
          originalEvent: e
        })
    }
    if (
      (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(),
      (r = Or(r, a.draggable, n, !0)),
      g('dragOver'),
      Se.eventCanceled)
    )
      return m
    if (
      Q.contains(e.target) ||
      (r.animated && r.animatingX && r.animatingY) ||
      p._ignoreWhileAnimating === r
    )
      return v(!1)
    if (
      ((Ff = !1),
      c &&
        !a.disabled &&
        (u
          ? h || (o = kt !== St)
          : un === this ||
            ((this.lastPutMode = td.checkPull(this, c, Q, e)) && l.checkPut(this, c, Q, e))))
    ) {
      if (
        ((f = this._getDirection(e, r) === 'vertical'),
        (i = Ft(Q)),
        g('dragOverValid'),
        Se.eventCanceled)
      )
        return m
      if (o)
        return (
          (kt = St),
          _(),
          this._hideClone(),
          g('revert'),
          Se.eventCanceled || (fo ? St.insertBefore(Q, fo) : St.appendChild(Q)),
          v(!0)
        )
      var S = L1(n, a.draggable)
      if (!S || (Rz(e, f, this) && !S.animated)) {
        if (S === Q) return v(!1)
        if (
          (S && n === e.target && (r = S), r && (s = Ft(r)), id(St, n, Q, i, r, s, e, !!r) !== !1)
        )
          return (
            _(),
            S && S.nextSibling ? n.insertBefore(Q, S.nextSibling) : n.appendChild(Q),
            (kt = n),
            T(),
            v(!0)
          )
      } else if (S && Cz(e, f, this)) {
        var I = Sl(n, 0, a, !0)
        if (I === Q) return v(!1)
        if (((r = I), (s = Ft(r)), id(St, n, Q, i, r, s, e, !1) !== !1))
          return _(), n.insertBefore(Q, I), (kt = n), T(), v(!0)
      } else if (r.parentNode === n) {
        s = Ft(r)
        var w = 0,
          O,
          P = Q.parentNode !== n,
          k = !Tz((Q.animated && Q.toRect) || i, (r.animated && r.toRect) || s, f),
          U = f ? 'top' : 'left',
          F = Gw(r, 'top', 'top') || Gw(Q, 'top', 'top'),
          $ = F ? F.scrollTop : void 0
        Ea !== r && ((O = s[U]), (qc = !1), (nd = (!k && a.invertSwap) || P)),
          (w = kz(
            e,
            r,
            s,
            f,
            k ? 1 : a.swapThreshold,
            a.invertedSwapThreshold == null ? a.swapThreshold : a.invertedSwapThreshold,
            nd,
            Ea === r
          ))
        var pe
        if (w !== 0) {
          var q = gr(Q)
          do (q -= w), (pe = kt.children[q])
          while (pe && (we(pe, 'display') === 'none' || pe === Oe))
        }
        if (w === 0 || pe === r) return v(!1)
        ;(Ea = r), (Gc = w)
        var z = r.nextElementSibling,
          N = !1
        N = w === 1
        var B = id(St, n, Q, i, r, s, e, N)
        if (B !== !1)
          return (
            (B === 1 || B === -1) && (N = B === 1),
            (x_ = !0),
            setTimeout(Az, 30),
            _(),
            N && !z ? n.appendChild(Q) : r.parentNode.insertBefore(Q, N ? z : r),
            F && YO(F, 0, $ - F.scrollTop),
            (kt = Q.parentNode),
            O !== void 0 && !nd && (xd = Math.abs(O - Ft(r)[U])),
            T(),
            v(!0)
          )
      }
      if (n.contains(Q)) return v(!1)
    }
    return !1
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function () {
    Ye(document, 'mousemove', this._onTouchMove),
      Ye(document, 'touchmove', this._onTouchMove),
      Ye(document, 'pointermove', this._onTouchMove),
      Ye(document, 'dragover', co),
      Ye(document, 'mousemove', co),
      Ye(document, 'touchmove', co)
  },
  _offUpEvents: function () {
    var e = this.el.ownerDocument
    Ye(e, 'mouseup', this._onDrop),
      Ye(e, 'touchend', this._onDrop),
      Ye(e, 'pointerup', this._onDrop),
      Ye(e, 'touchcancel', this._onDrop),
      Ye(document, 'selectstart', this)
  },
  _onDrop: function (e) {
    var n = this.el,
      r = this.options
    if (
      ((er = gr(Q)),
      (ps = gr(Q, r.draggable)),
      jn('drop', this, { evt: e }),
      (kt = Q && Q.parentNode),
      (er = gr(Q)),
      (ps = gr(Q, r.draggable)),
      Se.eventCanceled)
    ) {
      this._nulling()
      return
    }
    ;(Ra = !1),
      (nd = !1),
      (qc = !1),
      clearInterval(this._loopId),
      clearTimeout(this._dragStartTimer),
      D_(this.cloneId),
      D_(this._dragStartId),
      this.nativeDraggable && (Ye(document, 'drop', this), Ye(n, 'dragstart', this._onDragStart)),
      this._offMoveEvents(),
      this._offUpEvents(),
      zc && we(document.body, 'user-select', ''),
      we(Q, 'transform', ''),
      e &&
        (yc && (e.cancelable && e.preventDefault(), !r.dropBubble && e.stopPropagation()),
        Oe && Oe.parentNode && Oe.parentNode.removeChild(Oe),
        (St === kt || (un && un.lastPutMode !== 'clone')) &&
          Ct &&
          Ct.parentNode &&
          Ct.parentNode.removeChild(Ct),
        Q &&
          (this.nativeDraggable && Ye(Q, 'dragend', this),
          Og(Q),
          (Q.style['will-change'] = ''),
          yc && !Ra && Zn(Q, un ? un.options.ghostClass : this.options.ghostClass, !1),
          Zn(Q, this.options.chosenClass, !1),
          Vn({
            sortable: this,
            name: 'unchoose',
            toEl: kt,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: e
          }),
          St !== kt
            ? (er >= 0 &&
                (Vn({ rootEl: kt, name: 'add', toEl: kt, fromEl: St, originalEvent: e }),
                Vn({ sortable: this, name: 'remove', toEl: kt, originalEvent: e }),
                Vn({ rootEl: kt, name: 'sort', toEl: kt, fromEl: St, originalEvent: e }),
                Vn({ sortable: this, name: 'sort', toEl: kt, originalEvent: e })),
              un && un.save())
            : er !== xa &&
              er >= 0 &&
              (Vn({ sortable: this, name: 'update', toEl: kt, originalEvent: e }),
              Vn({ sortable: this, name: 'sort', toEl: kt, originalEvent: e })),
          Se.active &&
            ((er == null || er === -1) && ((er = xa), (ps = Wc)),
            Vn({ sortable: this, name: 'end', toEl: kt, originalEvent: e }),
            this.save()))),
      this._nulling()
  },
  _nulling: function () {
    jn('nulling', this),
      (St =
        Q =
        kt =
        Oe =
        fo =
        Ct =
        Pd =
        bs =
        lo =
        kr =
        yc =
        er =
        ps =
        xa =
        Wc =
        Ea =
        Gc =
        un =
        td =
        Se.dragged =
        Se.ghost =
        Se.clone =
        Se.active =
          null),
      Uf.forEach(function (e) {
        e.checked = !0
      }),
      (Uf.length = Cg = Rg = 0)
  },
  handleEvent: function (e) {
    switch (e.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(e)
        break
      case 'dragenter':
      case 'dragover':
        Q && (this._onDragOver(e), Iz(e))
        break
      case 'selectstart':
        e.preventDefault()
        break
    }
  },
  toArray: function () {
    for (var e = [], n, r = this.el.children, i = 0, s = r.length, o = this.options; i < s; i++)
      (n = r[i]), Or(n, o.draggable, this.el, !1) && e.push(n.getAttribute(o.dataIdAttr) || Nz(n))
    return e
  },
  sort: function (e, n) {
    var r = {},
      i = this.el
    this.toArray().forEach(function (s, o) {
      var a = i.children[o]
      Or(a, this.options.draggable, i, !1) && (r[s] = a)
    }, this),
      n && this.captureAnimationState(),
      e.forEach(function (s) {
        r[s] && (i.removeChild(r[s]), i.appendChild(r[s]))
      }),
      n && this.animateAll()
  },
  save: function () {
    var e = this.options.store
    e && e.set && e.set(this)
  },
  closest: function (e, n) {
    return Or(e, n || this.options.draggable, this.el, !1)
  },
  option: function (e, n) {
    var r = this.options
    if (n === void 0) return r[e]
    var i = Sh.modifyOption(this, e, n)
    typeof i < 'u' ? (r[e] = i) : (r[e] = n), e === 'group' && eN(r)
  },
  destroy: function () {
    jn('destroy', this)
    var e = this.el
    ;(e[ir] = null),
      Ye(e, 'mousedown', this._onTapStart),
      Ye(e, 'touchstart', this._onTapStart),
      Ye(e, 'pointerdown', this._onTapStart),
      this.nativeDraggable && (Ye(e, 'dragover', this), Ye(e, 'dragenter', this)),
      Array.prototype.forEach.call(e.querySelectorAll('[draggable]'), function (n) {
        n.removeAttribute('draggable')
      }),
      this._onDrop(),
      this._disableDelayedDragEvents(),
      Bf.splice(Bf.indexOf(this.el), 1),
      (this.el = e = null)
  },
  _hideClone: function () {
    if (!bs) {
      if ((jn('hideClone', this), Se.eventCanceled)) return
      we(Ct, 'display', 'none'),
        this.options.removeCloneOnHide && Ct.parentNode && Ct.parentNode.removeChild(Ct),
        (bs = !0)
    }
  },
  _showClone: function (e) {
    if (e.lastPutMode !== 'clone') {
      this._hideClone()
      return
    }
    if (bs) {
      if ((jn('showClone', this), Se.eventCanceled)) return
      Q.parentNode == St && !this.options.group.revertClone
        ? St.insertBefore(Ct, Q)
        : fo
        ? St.insertBefore(Ct, fo)
        : St.appendChild(Ct),
        this.options.group.revertClone && this.animate(Q, Ct),
        we(Ct, 'display', ''),
        (bs = !1)
    }
  }
}
function Iz(t) {
  t.dataTransfer && (t.dataTransfer.dropEffect = 'move'), t.cancelable && t.preventDefault()
}
function id(t, e, n, r, i, s, o, a) {
  var l,
    c = t[ir],
    u = c.options.onMove,
    h
  return (
    window.CustomEvent && !Xi && !wh
      ? (l = new CustomEvent('move', { bubbles: !0, cancelable: !0 }))
      : ((l = document.createEvent('Event')), l.initEvent('move', !0, !0)),
    (l.to = e),
    (l.from = t),
    (l.dragged = n),
    (l.draggedRect = r),
    (l.related = i || e),
    (l.relatedRect = s || Ft(e)),
    (l.willInsertAfter = a),
    (l.originalEvent = o),
    t.dispatchEvent(l),
    u && (h = u.call(c, l, o)),
    h
  )
}
function Og(t) {
  t.draggable = !1
}
function Az() {
  x_ = !1
}
function Cz(t, e, n) {
  var r = Ft(Sl(n.el, 0, n.options, !0)),
    i = QO(n.el, n.options, Oe),
    s = 10
  return e
    ? t.clientX < i.left - s || (t.clientY < r.top && t.clientX < r.right)
    : t.clientY < i.top - s || (t.clientY < r.bottom && t.clientX < r.left)
}
function Rz(t, e, n) {
  var r = Ft(L1(n.el, n.options.draggable)),
    i = QO(n.el, n.options, Oe),
    s = 10
  return e
    ? t.clientX > i.right + s || (t.clientY > r.bottom && t.clientX > r.left)
    : t.clientY > i.bottom + s || (t.clientX > r.right && t.clientY > r.top)
}
function kz(t, e, n, r, i, s, o, a) {
  var l = r ? t.clientY : t.clientX,
    c = r ? n.height : n.width,
    u = r ? n.top : n.left,
    h = r ? n.bottom : n.right,
    d = !1
  if (!o) {
    if (a && xd < c * i) {
      if ((!qc && (Gc === 1 ? l > u + (c * s) / 2 : l < h - (c * s) / 2) && (qc = !0), qc)) d = !0
      else if (Gc === 1 ? l < u + xd : l > h - xd) return -Gc
    } else if (l > u + (c * (1 - i)) / 2 && l < h - (c * (1 - i)) / 2) return Oz(e)
  }
  return (
    (d = d || o), d && (l < u + (c * s) / 2 || l > h - (c * s) / 2) ? (l > u + c / 2 ? 1 : -1) : 0
  )
}
function Oz(t) {
  return gr(Q) < gr(t) ? 1 : -1
}
function Nz(t) {
  for (var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, r = 0; n--; )
    r += e.charCodeAt(n)
  return r.toString(36)
}
function Mz(t) {
  Uf.length = 0
  for (var e = t.getElementsByTagName('input'), n = e.length; n--; ) {
    var r = e[n]
    r.checked && Uf.push(r)
  }
}
function Dd(t) {
  return setTimeout(t, 0)
}
function D_(t) {
  return clearTimeout(t)
}
ym &&
  Ze(document, 'touchmove', function (t) {
    ;(Se.active || Ra) && t.cancelable && t.preventDefault()
  })
Se.utils = {
  on: Ze,
  off: Ye,
  css: we,
  find: qO,
  is: function (e, n) {
    return !!Or(e, n, e, !1)
  },
  extend: pz,
  throttle: KO,
  closest: Or,
  toggleClass: Zn,
  clone: JO,
  index: gr,
  nextTick: Dd,
  cancelNextTick: D_,
  detectDirection: ZO,
  getChild: Sl
}
Se.get = function (t) {
  return t[ir]
}
Se.mount = function () {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
  e[0].constructor === Array && (e = e[0]),
    e.forEach(function (r) {
      if (!r.prototype || !r.prototype.constructor)
        throw 'Sortable: Mounted plugin must be a constructor function, not '.concat(
          {}.toString.call(r)
        )
      r.utils && (Se.utils = Ei(Ei({}, Se.utils), r.utils)), Sh.mount(r)
    })
}
Se.create = function (t, e) {
  return new Se(t, e)
}
Se.version = hz
var Lt = [],
  _c,
  L_,
  V_ = !1,
  Ng,
  Mg,
  $f,
  vc
function Pz() {
  function t() {
    this.defaults = {
      scroll: !0,
      forceAutoScrollFallback: !1,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    }
    for (var e in this)
      e.charAt(0) === '_' && typeof this[e] == 'function' && (this[e] = this[e].bind(this))
  }
  return (
    (t.prototype = {
      dragStarted: function (n) {
        var r = n.originalEvent
        this.sortable.nativeDraggable
          ? Ze(document, 'dragover', this._handleAutoScroll)
          : this.options.supportPointer
          ? Ze(document, 'pointermove', this._handleFallbackAutoScroll)
          : r.touches
          ? Ze(document, 'touchmove', this._handleFallbackAutoScroll)
          : Ze(document, 'mousemove', this._handleFallbackAutoScroll)
      },
      dragOverCompleted: function (n) {
        var r = n.originalEvent
        !this.options.dragOverBubble && !r.rootEl && this._handleAutoScroll(r)
      },
      drop: function () {
        this.sortable.nativeDraggable
          ? Ye(document, 'dragover', this._handleAutoScroll)
          : (Ye(document, 'pointermove', this._handleFallbackAutoScroll),
            Ye(document, 'touchmove', this._handleFallbackAutoScroll),
            Ye(document, 'mousemove', this._handleFallbackAutoScroll)),
          Qw(),
          Ld(),
          mz()
      },
      nulling: function () {
        ;($f = L_ = _c = V_ = vc = Ng = Mg = null), (Lt.length = 0)
      },
      _handleFallbackAutoScroll: function (n) {
        this._handleAutoScroll(n, !0)
      },
      _handleAutoScroll: function (n, r) {
        var i = this,
          s = (n.touches ? n.touches[0] : n).clientX,
          o = (n.touches ? n.touches[0] : n).clientY,
          a = document.elementFromPoint(s, o)
        if ((($f = n), r || this.options.forceAutoScrollFallback || wh || Xi || zc)) {
          Pg(n, this.options, a, r)
          var l = ws(a, !0)
          V_ &&
            (!vc || s !== Ng || o !== Mg) &&
            (vc && Qw(),
            (vc = setInterval(function () {
              var c = ws(document.elementFromPoint(s, o), !0)
              c !== l && ((l = c), Ld()), Pg(n, i.options, c, r)
            }, 10)),
            (Ng = s),
            (Mg = o))
        } else {
          if (!this.options.bubbleScroll || ws(a, !0) === fi()) {
            Ld()
            return
          }
          Pg(n, this.options, ws(a, !1), !1)
        }
      }
    }),
    Gi(t, { pluginName: 'scroll', initializeByDefault: !0 })
  )
}
function Ld() {
  Lt.forEach(function (t) {
    clearInterval(t.pid)
  }),
    (Lt = [])
}
function Qw() {
  clearInterval(vc)
}
var Pg = KO(function (t, e, n, r) {
    if (e.scroll) {
      var i = (t.touches ? t.touches[0] : t).clientX,
        s = (t.touches ? t.touches[0] : t).clientY,
        o = e.scrollSensitivity,
        a = e.scrollSpeed,
        l = fi(),
        c = !1,
        u
      L_ !== n && ((L_ = n), Ld(), (_c = e.scroll), (u = e.scrollFn), _c === !0 && (_c = ws(n, !0)))
      var h = 0,
        d = _c
      do {
        var f = d,
          p = Ft(f),
          m = p.top,
          g = p.bottom,
          _ = p.left,
          v = p.right,
          T = p.width,
          S = p.height,
          I = void 0,
          w = void 0,
          O = f.scrollWidth,
          P = f.scrollHeight,
          k = we(f),
          U = f.scrollLeft,
          F = f.scrollTop
        f === l
          ? ((I =
              T < O &&
              (k.overflowX === 'auto' || k.overflowX === 'scroll' || k.overflowX === 'visible')),
            (w =
              S < P &&
              (k.overflowY === 'auto' || k.overflowY === 'scroll' || k.overflowY === 'visible')))
          : ((I = T < O && (k.overflowX === 'auto' || k.overflowX === 'scroll')),
            (w = S < P && (k.overflowY === 'auto' || k.overflowY === 'scroll')))
        var $ = I && (Math.abs(v - i) <= o && U + T < O) - (Math.abs(_ - i) <= o && !!U),
          pe = w && (Math.abs(g - s) <= o && F + S < P) - (Math.abs(m - s) <= o && !!F)
        if (!Lt[h]) for (var q = 0; q <= h; q++) Lt[q] || (Lt[q] = {})
        ;(Lt[h].vx != $ || Lt[h].vy != pe || Lt[h].el !== f) &&
          ((Lt[h].el = f),
          (Lt[h].vx = $),
          (Lt[h].vy = pe),
          clearInterval(Lt[h].pid),
          ($ != 0 || pe != 0) &&
            ((c = !0),
            (Lt[h].pid = setInterval(
              function () {
                r && this.layer === 0 && Se.active._onTouchMove($f)
                var z = Lt[this.layer].vy ? Lt[this.layer].vy * a : 0,
                  N = Lt[this.layer].vx ? Lt[this.layer].vx * a : 0
                ;(typeof u == 'function' &&
                  u.call(Se.dragged.parentNode[ir], N, z, t, $f, Lt[this.layer].el) !==
                    'continue') ||
                  YO(Lt[this.layer].el, N, z)
              }.bind({ layer: h }),
              24
            )))),
          h++
      } while (e.bubbleScroll && d !== l && (d = ws(d, !1)))
      V_ = c
    }
  }, 30),
  rN = function (e) {
    var n = e.originalEvent,
      r = e.putSortable,
      i = e.dragEl,
      s = e.activeSortable,
      o = e.dispatchSortableEvent,
      a = e.hideGhostForTarget,
      l = e.unhideGhostForTarget
    if (n) {
      var c = r || s
      a()
      var u = n.changedTouches && n.changedTouches.length ? n.changedTouches[0] : n,
        h = document.elementFromPoint(u.clientX, u.clientY)
      l(), c && !c.el.contains(h) && (o('spill'), this.onSpill({ dragEl: i, putSortable: r }))
    }
  }
function V1() {}
V1.prototype = {
  startIndex: null,
  dragStart: function (e) {
    var n = e.oldDraggableIndex
    this.startIndex = n
  },
  onSpill: function (e) {
    var n = e.dragEl,
      r = e.putSortable
    this.sortable.captureAnimationState(), r && r.captureAnimationState()
    var i = Sl(this.sortable.el, this.startIndex, this.options)
    i ? this.sortable.el.insertBefore(n, i) : this.sortable.el.appendChild(n),
      this.sortable.animateAll(),
      r && r.animateAll()
  },
  drop: rN
}
Gi(V1, { pluginName: 'revertOnSpill' })
function F1() {}
F1.prototype = {
  onSpill: function (e) {
    var n = e.dragEl,
      r = e.putSortable,
      i = r || this.sortable
    i.captureAnimationState(), n.parentNode && n.parentNode.removeChild(n), i.animateAll()
  },
  drop: rN
}
Gi(F1, { pluginName: 'removeOnSpill' })
Se.mount(new Pz())
Se.mount(F1, V1)
function xz(t, e, n = {}) {
  let r
  const { document: i = LO, ...s } = n,
    o = {
      onUpdate: (u) => {
        iN(e, u.oldIndex, u.newIndex)
      }
    },
    a = () => {
      const u = typeof t == 'string' ? (i == null ? void 0 : i.querySelector(t)) : DO(t)
      !u || r !== void 0 || (r = new Se(u, { ...o, ...s }))
    },
    l = () => {
      r == null || r.destroy(), (r = void 0)
    },
    c = (u, h) => {
      if (h !== void 0) r == null || r.option(u, h)
      else return r == null ? void 0 : r.option(u)
    }
  return oH(a), MO(l), { stop: l, start: a, option: c }
}
function iN(t, e, n) {
  const r = rn(t),
    i = r ? [...ku(t)] : ku(t)
  if (n >= 0 && n < i.length) {
    const s = i.splice(e, 1)[0]
    Pl(() => {
      i.splice(n, 0, s), r && (t.value = i)
    })
  }
}
function Dz() {
  let t = [
      'Bal',
      'Bar',
      'Dal',
      'Dar',
      'Den',
      'Dok',
      'Jar',
      'Jik',
      'Lar',
      'Rak',
      'Ral',
      'Ril',
      'Sig',
      'Tal',
      'Thor',
      'Ton'
    ],
    e = [
      'dar',
      'dor',
      'dur',
      'kal',
      'kar',
      'kir',
      'kur',
      'lah',
      'lak',
      'lim',
      'lor',
      'rak',
      'tin',
      'ton',
      'tor',
      'vald'
    ],
    n = ['Rockcrusher', 'Spinewielder', 'Skullbearer', 'Dräpare']
  return (
    t[Math.floor(Math.random() * t.length)] +
    e[Math.floor(Math.random() * e.length)] +
    ' ' +
    n[Math.floor(Math.random() * n.length)]
  )
}
function xg(t = 4) {
  let e = t,
    n = '',
    r = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  for (let i = 0; i < e; i++) n += r.charAt(Math.floor(Math.random() * r.length))
  return n
}
function hn(t) {
  this.content = t
}
hn.prototype = {
  constructor: hn,
  find: function (t) {
    for (var e = 0; e < this.content.length; e += 2) if (this.content[e] === t) return e
    return -1
  },
  get: function (t) {
    var e = this.find(t)
    return e == -1 ? void 0 : this.content[e + 1]
  },
  update: function (t, e, n) {
    var r = n && n != t ? this.remove(n) : this,
      i = r.find(t),
      s = r.content.slice()
    return i == -1 ? s.push(n || t, e) : ((s[i + 1] = e), n && (s[i] = n)), new hn(s)
  },
  remove: function (t) {
    var e = this.find(t)
    if (e == -1) return this
    var n = this.content.slice()
    return n.splice(e, 2), new hn(n)
  },
  addToStart: function (t, e) {
    return new hn([t, e].concat(this.remove(t).content))
  },
  addToEnd: function (t, e) {
    var n = this.remove(t).content.slice()
    return n.push(t, e), new hn(n)
  },
  addBefore: function (t, e, n) {
    var r = this.remove(e),
      i = r.content.slice(),
      s = r.find(t)
    return i.splice(s == -1 ? i.length : s, 0, e, n), new hn(i)
  },
  forEach: function (t) {
    for (var e = 0; e < this.content.length; e += 2) t(this.content[e], this.content[e + 1])
  },
  prepend: function (t) {
    return (t = hn.from(t)), t.size ? new hn(t.content.concat(this.subtract(t).content)) : this
  },
  append: function (t) {
    return (t = hn.from(t)), t.size ? new hn(this.subtract(t).content.concat(t.content)) : this
  },
  subtract: function (t) {
    var e = this
    t = hn.from(t)
    for (var n = 0; n < t.content.length; n += 2) e = e.remove(t.content[n])
    return e
  },
  toObject: function () {
    var t = {}
    return (
      this.forEach(function (e, n) {
        t[e] = n
      }),
      t
    )
  },
  get size() {
    return this.content.length >> 1
  }
}
hn.from = function (t) {
  if (t instanceof hn) return t
  var e = []
  if (t) for (var n in t) e.push(n, t[n])
  return new hn(e)
}
function sN(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount) return t.childCount == e.childCount ? null : n
    let i = t.child(r),
      s = e.child(r)
    if (i == s) {
      n += i.nodeSize
      continue
    }
    if (!i.sameMarkup(s)) return n
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++) n++
      return n
    }
    if (i.content.size || s.content.size) {
      let o = sN(i.content, s.content, n + 1)
      if (o != null) return o
    }
    n += i.nodeSize
  }
}
function oN(t, e, n, r) {
  for (let i = t.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0) return i == s ? null : { a: n, b: r }
    let o = t.child(--i),
      a = e.child(--s),
      l = o.nodeSize
    if (o == a) {
      ;(n -= l), (r -= l)
      continue
    }
    if (!o.sameMarkup(a)) return { a: n, b: r }
    if (o.isText && o.text != a.text) {
      let c = 0,
        u = Math.min(o.text.length, a.text.length)
      for (; c < u && o.text[o.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, n--, r--
      return { a: n, b: r }
    }
    if (o.content.size || a.content.size) {
      let c = oN(o.content, a.content, n - 1, r - 1)
      if (c) return c
    }
    ;(n -= l), (r -= l)
  }
}
class H {
  constructor(e, n) {
    if (((this.content = e), (this.size = n || 0), n == null))
      for (let r = 0; r < e.length; r++) this.size += e[r].nodeSize
  }
  nodesBetween(e, n, r, i = 0, s) {
    for (let o = 0, a = 0; a < n; o++) {
      let l = this.content[o],
        c = a + l.nodeSize
      if (c > e && r(l, i + a, s || null, o) !== !1 && l.content.size) {
        let u = a + 1
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), r, i + u)
      }
      a = c
    }
  }
  descendants(e) {
    this.nodesBetween(0, this.size, e)
  }
  textBetween(e, n, r, i) {
    let s = '',
      o = !0
    return (
      this.nodesBetween(
        e,
        n,
        (a, l) => {
          let c = a.isText
            ? a.text.slice(Math.max(e, l) - l, n - l)
            : a.isLeaf
            ? i
              ? typeof i == 'function'
                ? i(a)
                : i
              : a.type.spec.leafText
              ? a.type.spec.leafText(a)
              : ''
            : ''
          a.isBlock && ((a.isLeaf && c) || a.isTextblock) && r && (o ? (o = !1) : (s += r)),
            (s += c)
        },
        0
      ),
      s
    )
  }
  append(e) {
    if (!e.size) return this
    if (!this.size) return e
    let n = this.lastChild,
      r = e.firstChild,
      i = this.content.slice(),
      s = 0
    for (
      n.isText && n.sameMarkup(r) && ((i[i.length - 1] = n.withText(n.text + r.text)), (s = 1));
      s < e.content.length;
      s++
    )
      i.push(e.content[s])
    return new H(i, this.size + e.size)
  }
  cut(e, n = this.size) {
    if (e == 0 && n == this.size) return this
    let r = [],
      i = 0
    if (n > e)
      for (let s = 0, o = 0; o < n; s++) {
        let a = this.content[s],
          l = o + a.nodeSize
        l > e &&
          ((o < e || l > n) &&
            (a.isText
              ? (a = a.cut(Math.max(0, e - o), Math.min(a.text.length, n - o)))
              : (a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, n - o - 1)))),
          r.push(a),
          (i += a.nodeSize)),
          (o = l)
      }
    return new H(r, i)
  }
  cutByIndex(e, n) {
    return e == n
      ? H.empty
      : e == 0 && n == this.content.length
      ? this
      : new H(this.content.slice(e, n))
  }
  replaceChild(e, n) {
    let r = this.content[e]
    if (r == n) return this
    let i = this.content.slice(),
      s = this.size + n.nodeSize - r.nodeSize
    return (i[e] = n), new H(i, s)
  }
  addToStart(e) {
    return new H([e].concat(this.content), this.size + e.nodeSize)
  }
  addToEnd(e) {
    return new H(this.content.concat(e), this.size + e.nodeSize)
  }
  eq(e) {
    if (this.content.length != e.content.length) return !1
    for (let n = 0; n < this.content.length; n++) if (!this.content[n].eq(e.content[n])) return !1
    return !0
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null
  }
  get childCount() {
    return this.content.length
  }
  child(e) {
    let n = this.content[e]
    if (!n) throw new RangeError('Index ' + e + ' out of range for ' + this)
    return n
  }
  maybeChild(e) {
    return this.content[e] || null
  }
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n]
      e(i, r, n), (r += i.nodeSize)
    }
  }
  findDiffStart(e, n = 0) {
    return sN(this, e, n)
  }
  findDiffEnd(e, n = this.size, r = e.size) {
    return oN(this, e, n, r)
  }
  findIndex(e, n = -1) {
    if (e == 0) return sd(0, e)
    if (e == this.size) return sd(this.content.length, e)
    if (e > this.size || e < 0) throw new RangeError(`Position ${e} outside of fragment (${this})`)
    for (let r = 0, i = 0; ; r++) {
      let s = this.child(r),
        o = i + s.nodeSize
      if (o >= e) return o == e || n > 0 ? sd(r + 1, o) : sd(r, i)
      i = o
    }
  }
  toString() {
    return '<' + this.toStringInner() + '>'
  }
  toStringInner() {
    return this.content.join(', ')
  }
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null
  }
  static fromJSON(e, n) {
    if (!n) return H.empty
    if (!Array.isArray(n)) throw new RangeError('Invalid input for Fragment.fromJSON')
    return new H(n.map(e.nodeFromJSON))
  }
  static fromArray(e) {
    if (!e.length) return H.empty
    let n,
      r = 0
    for (let i = 0; i < e.length; i++) {
      let s = e[i]
      ;(r += s.nodeSize),
        i && s.isText && e[i - 1].sameMarkup(s)
          ? (n || (n = e.slice(0, i)),
            (n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)))
          : n && n.push(s)
    }
    return new H(n || e, r)
  }
  static from(e) {
    if (!e) return H.empty
    if (e instanceof H) return e
    if (Array.isArray(e)) return this.fromArray(e)
    if (e.attrs) return new H([e], e.nodeSize)
    throw new RangeError(
      'Can not convert ' +
        e +
        ' to a Fragment' +
        (e.nodesBetween ? ' (looks like multiple versions of prosemirror-model were loaded)' : '')
    )
  }
}
H.empty = new H([], 0)
const Dg = { index: 0, offset: 0 }
function sd(t, e) {
  return (Dg.index = t), (Dg.offset = e), Dg
}
function Hf(t, e) {
  if (t === e) return !0
  if (!(t && typeof t == 'object') || !(e && typeof e == 'object')) return !1
  let n = Array.isArray(t)
  if (Array.isArray(e) != n) return !1
  if (n) {
    if (t.length != e.length) return !1
    for (let r = 0; r < t.length; r++) if (!Hf(t[r], e[r])) return !1
  } else {
    for (let r in t) if (!(r in e) || !Hf(t[r], e[r])) return !1
    for (let r in e) if (!(r in t)) return !1
  }
  return !0
}
let at = class F_ {
  constructor(e, n) {
    ;(this.type = e), (this.attrs = n)
  }
  addToSet(e) {
    let n,
      r = !1
    for (let i = 0; i < e.length; i++) {
      let s = e[i]
      if (this.eq(s)) return e
      if (this.type.excludes(s.type)) n || (n = e.slice(0, i))
      else {
        if (s.type.excludes(this.type)) return e
        !r && s.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), (r = !0)),
          n && n.push(s)
      }
    }
    return n || (n = e.slice()), r || n.push(this), n
  }
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n])) return e.slice(0, n).concat(e.slice(n + 1))
    return e
  }
  isInSet(e) {
    for (let n = 0; n < e.length; n++) if (this.eq(e[n])) return !0
    return !1
  }
  eq(e) {
    return this == e || (this.type == e.type && Hf(this.attrs, e.attrs))
  }
  toJSON() {
    let e = { type: this.type.name }
    for (let n in this.attrs) {
      e.attrs = this.attrs
      break
    }
    return e
  }
  static fromJSON(e, n) {
    if (!n) throw new RangeError('Invalid input for Mark.fromJSON')
    let r = e.marks[n.type]
    if (!r) throw new RangeError(`There is no mark type ${n.type} in this schema`)
    return r.create(n.attrs)
  }
  static sameSet(e, n) {
    if (e == n) return !0
    if (e.length != n.length) return !1
    for (let r = 0; r < e.length; r++) if (!e[r].eq(n[r])) return !1
    return !0
  }
  static setFrom(e) {
    if (!e || (Array.isArray(e) && e.length == 0)) return F_.none
    if (e instanceof F_) return [e]
    let n = e.slice()
    return n.sort((r, i) => r.type.rank - i.type.rank), n
  }
}
at.none = []
class zf extends Error {}
class ie {
  constructor(e, n, r) {
    ;(this.content = e), (this.openStart = n), (this.openEnd = r)
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd
  }
  insertAt(e, n) {
    let r = lN(this.content, e + this.openStart, n)
    return r && new ie(r, this.openStart, this.openEnd)
  }
  removeBetween(e, n) {
    return new ie(
      aN(this.content, e + this.openStart, n + this.openStart),
      this.openStart,
      this.openEnd
    )
  }
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd
  }
  toString() {
    return this.content + '(' + this.openStart + ',' + this.openEnd + ')'
  }
  toJSON() {
    if (!this.content.size) return null
    let e = { content: this.content.toJSON() }
    return (
      this.openStart > 0 && (e.openStart = this.openStart),
      this.openEnd > 0 && (e.openEnd = this.openEnd),
      e
    )
  }
  static fromJSON(e, n) {
    if (!n) return ie.empty
    let r = n.openStart || 0,
      i = n.openEnd || 0
    if (typeof r != 'number' || typeof i != 'number')
      throw new RangeError('Invalid input for Slice.fromJSON')
    return new ie(H.fromJSON(e, n.content), r, i)
  }
  static maxOpen(e, n = !0) {
    let r = 0,
      i = 0
    for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)
      r++
    for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild) i++
    return new ie(e, r, i)
  }
}
ie.empty = new ie(H.empty, 0, 0)
function aN(t, e, n) {
  let { index: r, offset: i } = t.findIndex(e),
    s = t.maybeChild(r),
    { index: o, offset: a } = t.findIndex(n)
  if (i == e || s.isText) {
    if (a != n && !t.child(o).isText) throw new RangeError('Removing non-flat range')
    return t.cut(0, e).append(t.cut(n))
  }
  if (r != o) throw new RangeError('Removing non-flat range')
  return t.replaceChild(r, s.copy(aN(s.content, e - i - 1, n - i - 1)))
}
function lN(t, e, n, r) {
  let { index: i, offset: s } = t.findIndex(e),
    o = t.maybeChild(i)
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, n) ? null : t.cut(0, e).append(n).append(t.cut(e))
  let a = lN(o.content, e - s - 1, n)
  return a && t.replaceChild(i, o.copy(a))
}
function Lz(t, e, n) {
  if (n.openStart > t.depth) throw new zf('Inserted content deeper than insertion position')
  if (t.depth - n.openStart != e.depth - n.openEnd) throw new zf('Inconsistent open depths')
  return cN(t, e, n, 0)
}
function cN(t, e, n, r) {
  let i = t.index(r),
    s = t.node(r)
  if (i == e.index(r) && r < t.depth - n.openStart) {
    let o = cN(t, e, n, r + 1)
    return s.copy(s.content.replaceChild(i, o))
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let o = t.parent,
        a = o.content
      return Uo(o, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)))
    } else {
      let { start: o, end: a } = Vz(n, t)
      return Uo(s, hN(t, o, a, e, r))
    }
  else return Uo(s, jf(t, e, r))
}
function uN(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new zf('Cannot join ' + e.type.name + ' onto ' + t.type.name)
}
function B_(t, e, n) {
  let r = t.node(n)
  return uN(r, e.node(n)), r
}
function Bo(t, e) {
  let n = e.length - 1
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? (e[n] = t.withText(e[n].text + t.text)) : e.push(t)
}
function Kc(t, e, n, r) {
  let i = (e || t).node(n),
    s = 0,
    o = e ? e.index(n) : i.childCount
  t && ((s = t.index(n)), t.depth > n ? s++ : t.textOffset && (Bo(t.nodeAfter, r), s++))
  for (let a = s; a < o; a++) Bo(i.child(a), r)
  e && e.depth == n && e.textOffset && Bo(e.nodeBefore, r)
}
function Uo(t, e) {
  return t.type.checkContent(e), t.copy(e)
}
function hN(t, e, n, r, i) {
  let s = t.depth > i && B_(t, e, i + 1),
    o = r.depth > i && B_(n, r, i + 1),
    a = []
  return (
    Kc(null, t, i, a),
    s && o && e.index(i) == n.index(i)
      ? (uN(s, o), Bo(Uo(s, hN(t, e, n, r, i + 1)), a))
      : (s && Bo(Uo(s, jf(t, e, i + 1)), a), Kc(e, n, i, a), o && Bo(Uo(o, jf(n, r, i + 1)), a)),
    Kc(r, null, i, a),
    new H(a)
  )
}
function jf(t, e, n) {
  let r = []
  if ((Kc(null, t, n, r), t.depth > n)) {
    let i = B_(t, e, n + 1)
    Bo(Uo(i, jf(t, e, n + 1)), r)
  }
  return Kc(e, null, n, r), new H(r)
}
function Vz(t, e) {
  let n = e.depth - t.openStart,
    i = e.node(n).copy(t.content)
  for (let s = n - 1; s >= 0; s--) i = e.node(s).copy(H.from(i))
  return {
    start: i.resolveNoCache(t.openStart + n),
    end: i.resolveNoCache(i.content.size - t.openEnd - n)
  }
}
class Ou {
  constructor(e, n, r) {
    ;(this.pos = e), (this.path = n), (this.parentOffset = r), (this.depth = n.length / 3 - 1)
  }
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e
  }
  get parent() {
    return this.node(this.depth)
  }
  get doc() {
    return this.node(0)
  }
  node(e) {
    return this.path[this.resolveDepth(e) * 3]
  }
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1]
  }
  indexAfter(e) {
    return (e = this.resolveDepth(e)), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
  }
  start(e) {
    return (e = this.resolveDepth(e)), e == 0 ? 0 : this.path[e * 3 - 1] + 1
  }
  end(e) {
    return (e = this.resolveDepth(e)), this.start(e) + this.node(e).content.size
  }
  before(e) {
    if (((e = this.resolveDepth(e)), !e))
      throw new RangeError('There is no position before the top-level node')
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1]
  }
  after(e) {
    if (((e = this.resolveDepth(e)), !e))
      throw new RangeError('There is no position after the top-level node')
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize
  }
  get textOffset() {
    return this.pos - this.path[this.path.length - 1]
  }
  get nodeAfter() {
    let e = this.parent,
      n = this.index(this.depth)
    if (n == e.childCount) return null
    let r = this.pos - this.path[this.path.length - 1],
      i = e.child(n)
    return r ? e.child(n).cut(r) : i
  }
  get nodeBefore() {
    let e = this.index(this.depth),
      n = this.pos - this.path[this.path.length - 1]
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1)
  }
  posAtIndex(e, n) {
    n = this.resolveDepth(n)
    let r = this.path[n * 3],
      i = n == 0 ? 0 : this.path[n * 3 - 1] + 1
    for (let s = 0; s < e; s++) i += r.child(s).nodeSize
    return i
  }
  marks() {
    let e = this.parent,
      n = this.index()
    if (e.content.size == 0) return at.none
    if (this.textOffset) return e.child(n).marks
    let r = e.maybeChild(n - 1),
      i = e.maybeChild(n)
    if (!r) {
      let a = r
      ;(r = i), (i = a)
    }
    let s = r.marks
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 &&
        (!i || !s[o].isInSet(i.marks)) &&
        (s = s[o--].removeFromSet(s))
    return s
  }
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index())
    if (!n || !n.isInline) return null
    let r = n.marks,
      i = e.parent.maybeChild(e.index())
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 &&
        (!i || !r[s].isInSet(i.marks)) &&
        (r = r[s--].removeFromSet(r))
    return r
  }
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--) if (this.start(n) <= e && this.end(n) >= e) return n
    return 0
  }
  blockRange(e = this, n) {
    if (e.pos < this.pos) return e.blockRange(this)
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r)))) return new Wf(this, e, r)
    return null
  }
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset
  }
  max(e) {
    return e.pos > this.pos ? e : this
  }
  min(e) {
    return e.pos < this.pos ? e : this
  }
  toString() {
    let e = ''
    for (let n = 1; n <= this.depth; n++)
      e += (e ? '/' : '') + this.node(n).type.name + '_' + this.index(n - 1)
    return e + ':' + this.parentOffset
  }
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size)) throw new RangeError('Position ' + n + ' out of range')
    let r = [],
      i = 0,
      s = n
    for (let o = e; ; ) {
      let { index: a, offset: l } = o.content.findIndex(s),
        c = s - l
      if ((r.push(o, a, i + l), !c || ((o = o.child(a)), o.isText))) break
      ;(s = c - 1), (i += l + 1)
    }
    return new Ou(n, r, s)
  }
  static resolveCached(e, n) {
    for (let i = 0; i < Lg.length; i++) {
      let s = Lg[i]
      if (s.pos == n && s.doc == e) return s
    }
    let r = (Lg[Vg] = Ou.resolve(e, n))
    return (Vg = (Vg + 1) % Fz), r
  }
}
let Lg = [],
  Vg = 0,
  Fz = 12
class Wf {
  constructor(e, n, r) {
    ;(this.$from = e), (this.$to = n), (this.depth = r)
  }
  get start() {
    return this.$from.before(this.depth + 1)
  }
  get end() {
    return this.$to.after(this.depth + 1)
  }
  get parent() {
    return this.$from.node(this.depth)
  }
  get startIndex() {
    return this.$from.index(this.depth)
  }
  get endIndex() {
    return this.$to.indexAfter(this.depth)
  }
}
const Bz = Object.create(null)
let $o = class U_ {
  constructor(e, n, r, i = at.none) {
    ;(this.type = e), (this.attrs = n), (this.marks = i), (this.content = r || H.empty)
  }
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size
  }
  get childCount() {
    return this.content.childCount
  }
  child(e) {
    return this.content.child(e)
  }
  maybeChild(e) {
    return this.content.maybeChild(e)
  }
  forEach(e) {
    this.content.forEach(e)
  }
  nodesBetween(e, n, r, i = 0) {
    this.content.nodesBetween(e, n, r, i, this)
  }
  descendants(e) {
    this.nodesBetween(0, this.content.size, e)
  }
  get textContent() {
    return this.isLeaf && this.type.spec.leafText
      ? this.type.spec.leafText(this)
      : this.textBetween(0, this.content.size, '')
  }
  textBetween(e, n, r, i) {
    return this.content.textBetween(e, n, r, i)
  }
  get firstChild() {
    return this.content.firstChild
  }
  get lastChild() {
    return this.content.lastChild
  }
  eq(e) {
    return this == e || (this.sameMarkup(e) && this.content.eq(e.content))
  }
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks)
  }
  hasMarkup(e, n, r) {
    return (
      this.type == e &&
      Hf(this.attrs, n || e.defaultAttrs || Bz) &&
      at.sameSet(this.marks, r || at.none)
    )
  }
  copy(e = null) {
    return e == this.content ? this : new U_(this.type, this.attrs, e, this.marks)
  }
  mark(e) {
    return e == this.marks ? this : new U_(this.type, this.attrs, this.content, e)
  }
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n))
  }
  slice(e, n = this.content.size, r = !1) {
    if (e == n) return ie.empty
    let i = this.resolve(e),
      s = this.resolve(n),
      o = r ? 0 : i.sharedDepth(n),
      a = i.start(o),
      c = i.node(o).content.cut(i.pos - a, s.pos - a)
    return new ie(c, i.depth - o, s.depth - o)
  }
  replace(e, n, r) {
    return Lz(this.resolve(e), this.resolve(n), r)
  }
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(e)
      if (((n = n.maybeChild(r)), !n)) return null
      if (i == e || n.isText) return n
      e -= i + 1
    }
  }
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e)
    return { node: this.content.maybeChild(n), index: n, offset: r }
  }
  childBefore(e) {
    if (e == 0) return { node: null, index: 0, offset: 0 }
    let { index: n, offset: r } = this.content.findIndex(e)
    if (r < e) return { node: this.content.child(n), index: n, offset: r }
    let i = this.content.child(n - 1)
    return { node: i, index: n - 1, offset: r - i.nodeSize }
  }
  resolve(e) {
    return Ou.resolveCached(this, e)
  }
  resolveNoCache(e) {
    return Ou.resolve(this, e)
  }
  rangeHasMark(e, n, r) {
    let i = !1
    return n > e && this.nodesBetween(e, n, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i
  }
  get isBlock() {
    return this.type.isBlock
  }
  get isTextblock() {
    return this.type.isTextblock
  }
  get inlineContent() {
    return this.type.inlineContent
  }
  get isInline() {
    return this.type.isInline
  }
  get isText() {
    return this.type.isText
  }
  get isLeaf() {
    return this.type.isLeaf
  }
  get isAtom() {
    return this.type.isAtom
  }
  toString() {
    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)
    let e = this.type.name
    return this.content.size && (e += '(' + this.content.toStringInner() + ')'), dN(this.marks, e)
  }
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e)
    if (!n) throw new Error('Called contentMatchAt on a node with invalid content')
    return n
  }
  canReplace(e, n, r = H.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s),
      a = o && o.matchFragment(this.content, n)
    if (!a || !a.validEnd) return !1
    for (let l = i; l < s; l++) if (!this.type.allowsMarks(r.child(l).marks)) return !1
    return !0
  }
  canReplaceWith(e, n, r, i) {
    if (i && !this.type.allowsMarks(i)) return !1
    let s = this.contentMatchAt(e).matchType(r),
      o = s && s.matchFragment(this.content, n)
    return o ? o.validEnd : !1
  }
  canAppend(e) {
    return e.content.size
      ? this.canReplace(this.childCount, this.childCount, e.content)
      : this.type.compatibleContent(e.type)
  }
  check() {
    this.type.checkContent(this.content)
    let e = at.none
    for (let n = 0; n < this.marks.length; n++) e = this.marks[n].addToSet(e)
    if (!at.sameSet(e, this.marks))
      throw new RangeError(
        `Invalid collection of marks for node ${this.type.name}: ${this.marks.map(
          (n) => n.type.name
        )}`
      )
    this.content.forEach((n) => n.check())
  }
  toJSON() {
    let e = { type: this.type.name }
    for (let n in this.attrs) {
      e.attrs = this.attrs
      break
    }
    return (
      this.content.size && (e.content = this.content.toJSON()),
      this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())),
      e
    )
  }
  static fromJSON(e, n) {
    if (!n) throw new RangeError('Invalid input for Node.fromJSON')
    let r = null
    if (n.marks) {
      if (!Array.isArray(n.marks)) throw new RangeError('Invalid mark data for Node.fromJSON')
      r = n.marks.map(e.markFromJSON)
    }
    if (n.type == 'text') {
      if (typeof n.text != 'string') throw new RangeError('Invalid text node in JSON')
      return e.text(n.text, r)
    }
    let i = H.fromJSON(e, n.content)
    return e.nodeType(n.type).create(n.attrs, i, r)
  }
}
$o.prototype.text = void 0
class Gf extends $o {
  constructor(e, n, r, i) {
    if ((super(e, n, null, i), !r)) throw new RangeError('Empty text nodes are not allowed')
    this.text = r
  }
  toString() {
    return this.type.spec.toDebugString
      ? this.type.spec.toDebugString(this)
      : dN(this.marks, JSON.stringify(this.text))
  }
  get textContent() {
    return this.text
  }
  textBetween(e, n) {
    return this.text.slice(e, n)
  }
  get nodeSize() {
    return this.text.length
  }
  mark(e) {
    return e == this.marks ? this : new Gf(this.type, this.attrs, this.text, e)
  }
  withText(e) {
    return e == this.text ? this : new Gf(this.type, this.attrs, e, this.marks)
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n))
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text
  }
  toJSON() {
    let e = super.toJSON()
    return (e.text = this.text), e
  }
}
function dN(t, e) {
  for (let n = t.length - 1; n >= 0; n--) e = t[n].type.name + '(' + e + ')'
  return e
}
class ta {
  constructor(e) {
    ;(this.validEnd = e), (this.next = []), (this.wrapCache = [])
  }
  static parse(e, n) {
    let r = new Uz(e, n)
    if (r.next == null) return ta.empty
    let i = fN(r)
    r.next && r.err('Unexpected trailing text')
    let s = qz(Gz(i))
    return Kz(s, r), s
  }
  matchType(e) {
    for (let n = 0; n < this.next.length; n++) if (this.next[n].type == e) return this.next[n].next
    return null
  }
  matchFragment(e, n = 0, r = e.childCount) {
    let i = this
    for (let s = n; i && s < r; s++) i = i.matchType(e.child(s).type)
    return i
  }
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline
  }
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e]
      if (!(n.isText || n.hasRequiredAttrs())) return n
    }
    return null
  }
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++) if (this.next[n].type == e.next[r].type) return !0
    return !1
  }
  fillBefore(e, n = !1, r = 0) {
    let i = [this]
    function s(o, a) {
      let l = o.matchFragment(e, r)
      if (l && (!n || l.validEnd)) return H.from(a.map((c) => c.createAndFill()))
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: h } = o.next[c]
        if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h)
          let d = s(h, a.concat(u))
          if (d) return d
        }
      }
      return null
    }
    return s(this, [])
  }
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e) return this.wrapCache[r + 1]
    let n = this.computeWrapping(e)
    return this.wrapCache.push(e, n), n
  }
  computeWrapping(e) {
    let n = Object.create(null),
      r = [{ match: this, type: null, via: null }]
    for (; r.length; ) {
      let i = r.shift(),
        s = i.match
      if (s.matchType(e)) {
        let o = []
        for (let a = i; a.type; a = a.via) o.push(a.type)
        return o.reverse()
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: a, next: l } = s.next[o]
        !a.isLeaf &&
          !a.hasRequiredAttrs() &&
          !(a.name in n) &&
          (!i.type || l.validEnd) &&
          (r.push({ match: a.contentMatch, type: a, via: i }), (n[a.name] = !0))
      }
    }
    return null
  }
  get edgeCount() {
    return this.next.length
  }
  edge(e) {
    if (e >= this.next.length) throw new RangeError(`There's no ${e}th edge in this content match`)
    return this.next[e]
  }
  toString() {
    let e = []
    function n(r) {
      e.push(r)
      for (let i = 0; i < r.next.length; i++) e.indexOf(r.next[i].next) == -1 && n(r.next[i].next)
    }
    return (
      n(this),
      e.map((r, i) => {
        let s = i + (r.validEnd ? '*' : ' ') + ' '
        for (let o = 0; o < r.next.length; o++)
          s += (o ? ', ' : '') + r.next[o].type.name + '->' + e.indexOf(r.next[o].next)
        return s
      }).join(`
`)
    )
  }
}
ta.empty = new ta(!0)
class Uz {
  constructor(e, n) {
    ;(this.string = e),
      (this.nodeTypes = n),
      (this.inline = null),
      (this.pos = 0),
      (this.tokens = e.split(/\s*(?=\b|\W|$)/)),
      this.tokens[this.tokens.length - 1] == '' && this.tokens.pop(),
      this.tokens[0] == '' && this.tokens.shift()
  }
  get next() {
    return this.tokens[this.pos]
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0)
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')")
  }
}
function fN(t) {
  let e = []
  do e.push($z(t))
  while (t.eat('|'))
  return e.length == 1 ? e[0] : { type: 'choice', exprs: e }
}
function $z(t) {
  let e = []
  do e.push(Hz(t))
  while (t.next && t.next != ')' && t.next != '|')
  return e.length == 1 ? e[0] : { type: 'seq', exprs: e }
}
function Hz(t) {
  let e = Wz(t)
  for (;;)
    if (t.eat('+')) e = { type: 'plus', expr: e }
    else if (t.eat('*')) e = { type: 'star', expr: e }
    else if (t.eat('?')) e = { type: 'opt', expr: e }
    else if (t.eat('{')) e = zz(t, e)
    else break
  return e
}
function Xw(t) {
  ;/\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'")
  let e = Number(t.next)
  return t.pos++, e
}
function zz(t, e) {
  let n = Xw(t),
    r = n
  return (
    t.eat(',') && (t.next != '}' ? (r = Xw(t)) : (r = -1)),
    t.eat('}') || t.err('Unclosed braced range'),
    { type: 'range', min: n, max: r, expr: e }
  )
}
function jz(t, e) {
  let n = t.nodeTypes,
    r = n[e]
  if (r) return [r]
  let i = []
  for (let s in n) {
    let o = n[s]
    o.groups.indexOf(e) > -1 && i.push(o)
  }
  return i.length == 0 && t.err("No node type or group '" + e + "' found"), i
}
function Wz(t) {
  if (t.eat('(')) {
    let e = fN(t)
    return t.eat(')') || t.err('Missing closing paren'), e
  } else if (/\W/.test(t.next)) t.err("Unexpected token '" + t.next + "'")
  else {
    let e = jz(t, t.next).map(
      (n) => (
        t.inline == null
          ? (t.inline = n.isInline)
          : t.inline != n.isInline && t.err('Mixing inline and block content'),
        { type: 'name', value: n }
      )
    )
    return t.pos++, e.length == 1 ? e[0] : { type: 'choice', exprs: e }
  }
}
function Gz(t) {
  let e = [[]]
  return i(s(t, 0), n()), e
  function n() {
    return e.push([]) - 1
  }
  function r(o, a, l) {
    let c = { term: l, to: a }
    return e[o].push(c), c
  }
  function i(o, a) {
    o.forEach((l) => (l.to = a))
  }
  function s(o, a) {
    if (o.type == 'choice') return o.exprs.reduce((l, c) => l.concat(s(c, a)), [])
    if (o.type == 'seq')
      for (let l = 0; ; l++) {
        let c = s(o.exprs[l], a)
        if (l == o.exprs.length - 1) return c
        i(c, (a = n()))
      }
    else if (o.type == 'star') {
      let l = n()
      return r(a, l), i(s(o.expr, l), l), [r(l)]
    } else if (o.type == 'plus') {
      let l = n()
      return i(s(o.expr, a), l), i(s(o.expr, l), l), [r(l)]
    } else {
      if (o.type == 'opt') return [r(a)].concat(s(o.expr, a))
      if (o.type == 'range') {
        let l = a
        for (let c = 0; c < o.min; c++) {
          let u = n()
          i(s(o.expr, l), u), (l = u)
        }
        if (o.max == -1) i(s(o.expr, l), l)
        else
          for (let c = o.min; c < o.max; c++) {
            let u = n()
            r(l, u), i(s(o.expr, l), u), (l = u)
          }
        return [r(l)]
      } else {
        if (o.type == 'name') return [r(a, void 0, o.value)]
        throw new Error('Unknown expr type')
      }
    }
  }
}
function pN(t, e) {
  return e - t
}
function Zw(t, e) {
  let n = []
  return r(e), n.sort(pN)
  function r(i) {
    let s = t[i]
    if (s.length == 1 && !s[0].term) return r(s[0].to)
    n.push(i)
    for (let o = 0; o < s.length; o++) {
      let { term: a, to: l } = s[o]
      !a && n.indexOf(l) == -1 && r(l)
    }
  }
}
function qz(t) {
  let e = Object.create(null)
  return n(Zw(t, 0))
  function n(r) {
    let i = []
    r.forEach((o) => {
      t[o].forEach(({ term: a, to: l }) => {
        if (!a) return
        let c
        for (let u = 0; u < i.length; u++) i[u][0] == a && (c = i[u][1])
        Zw(t, l).forEach((u) => {
          c || i.push([a, (c = [])]), c.indexOf(u) == -1 && c.push(u)
        })
      })
    })
    let s = (e[r.join(',')] = new ta(r.indexOf(t.length - 1) > -1))
    for (let o = 0; o < i.length; o++) {
      let a = i[o][1].sort(pN)
      s.next.push({ type: i[o][0], next: e[a.join(',')] || n(a) })
    }
    return s
  }
}
function Kz(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let i = r[n],
      s = !i.validEnd,
      o = []
    for (let a = 0; a < i.next.length; a++) {
      let { type: l, next: c } = i.next[a]
      o.push(l.name),
        s && !(l.isText || l.hasRequiredAttrs()) && (s = !1),
        r.indexOf(c) == -1 && r.push(c)
    }
    s &&
      e.err(
        'Only non-generatable nodes (' +
          o.join(', ') +
          ') in a required position (see https://prosemirror.net/docs/guide/#generatable)'
      )
  }
}
function mN(t) {
  let e = Object.create(null)
  for (let n in t) {
    let r = t[n]
    if (!r.hasDefault) return null
    e[n] = r.default
  }
  return e
}
function gN(t, e) {
  let n = Object.create(null)
  for (let r in t) {
    let i = e && e[r]
    if (i === void 0) {
      let s = t[r]
      if (s.hasDefault) i = s.default
      else throw new RangeError('No value supplied for attribute ' + r)
    }
    n[r] = i
  }
  return n
}
function yN(t) {
  let e = Object.create(null)
  if (t) for (let n in t) e[n] = new Yz(t[n])
  return e
}
let eS = class _N {
  constructor(e, n, r) {
    ;(this.name = e),
      (this.schema = n),
      (this.spec = r),
      (this.markSet = null),
      (this.groups = r.group ? r.group.split(' ') : []),
      (this.attrs = yN(r.attrs)),
      (this.defaultAttrs = mN(this.attrs)),
      (this.contentMatch = null),
      (this.inlineContent = null),
      (this.isBlock = !(r.inline || e == 'text')),
      (this.isText = e == 'text')
  }
  get isInline() {
    return !this.isBlock
  }
  get isTextblock() {
    return this.isBlock && this.inlineContent
  }
  get isLeaf() {
    return this.contentMatch == ta.empty
  }
  get isAtom() {
    return this.isLeaf || !!this.spec.atom
  }
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? 'pre' : 'normal')
  }
  hasRequiredAttrs() {
    for (let e in this.attrs) if (this.attrs[e].isRequired) return !0
    return !1
  }
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch)
  }
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : gN(this.attrs, e)
  }
  create(e = null, n, r) {
    if (this.isText) throw new Error("NodeType.create can't construct text nodes")
    return new $o(this, this.computeAttrs(e), H.from(n), at.setFrom(r))
  }
  createChecked(e = null, n, r) {
    return (
      (n = H.from(n)), this.checkContent(n), new $o(this, this.computeAttrs(e), n, at.setFrom(r))
    )
  }
  createAndFill(e = null, n, r) {
    if (((e = this.computeAttrs(e)), (n = H.from(n)), n.size)) {
      let o = this.contentMatch.fillBefore(n)
      if (!o) return null
      n = o.append(n)
    }
    let i = this.contentMatch.matchFragment(n),
      s = i && i.fillBefore(H.empty, !0)
    return s ? new $o(this, e, n.append(s), at.setFrom(r)) : null
  }
  validContent(e) {
    let n = this.contentMatch.matchFragment(e)
    if (!n || !n.validEnd) return !1
    for (let r = 0; r < e.childCount; r++) if (!this.allowsMarks(e.child(r).marks)) return !1
    return !0
  }
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`)
  }
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1
  }
  allowsMarks(e) {
    if (this.markSet == null) return !0
    for (let n = 0; n < e.length; n++) if (!this.allowsMarkType(e[n].type)) return !1
    return !0
  }
  allowedMarks(e) {
    if (this.markSet == null) return e
    let n
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r))
    return n ? (n.length ? n : at.none) : e
  }
  static compile(e, n) {
    let r = Object.create(null)
    e.forEach((s, o) => (r[s] = new _N(s, n, o)))
    let i = n.spec.topNode || 'doc'
    if (!r[i]) throw new RangeError("Schema is missing its top node type ('" + i + "')")
    if (!r.text) throw new RangeError("Every schema needs a 'text' type")
    for (let s in r.text.attrs)
      throw new RangeError('The text node type should not have attributes')
    return r
  }
}
class Yz {
  constructor(e) {
    ;(this.hasDefault = Object.prototype.hasOwnProperty.call(e, 'default')),
      (this.default = e.default)
  }
  get isRequired() {
    return !this.hasDefault
  }
}
class _m {
  constructor(e, n, r, i) {
    ;(this.name = e),
      (this.rank = n),
      (this.schema = r),
      (this.spec = i),
      (this.attrs = yN(i.attrs)),
      (this.excluded = null)
    let s = mN(this.attrs)
    this.instance = s ? new at(this, s) : null
  }
  create(e = null) {
    return !e && this.instance ? this.instance : new at(this, gN(this.attrs, e))
  }
  static compile(e, n) {
    let r = Object.create(null),
      i = 0
    return e.forEach((s, o) => (r[s] = new _m(s, i++, n, o))), r
  }
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && ((e = e.slice(0, n).concat(e.slice(n + 1))), n--)
    return e
  }
  isInSet(e) {
    for (let n = 0; n < e.length; n++) if (e[n].type == this) return e[n]
  }
  excludes(e) {
    return this.excluded.indexOf(e) > -1
  }
}
class Jz {
  constructor(e) {
    this.cached = Object.create(null)
    let n = (this.spec = {})
    for (let i in e) n[i] = e[i]
    ;(n.nodes = hn.from(e.nodes)),
      (n.marks = hn.from(e.marks || {})),
      (this.nodes = eS.compile(this.spec.nodes, this)),
      (this.marks = _m.compile(this.spec.marks, this))
    let r = Object.create(null)
    for (let i in this.nodes) {
      if (i in this.marks) throw new RangeError(i + ' can not be both a node and a mark')
      let s = this.nodes[i],
        o = s.spec.content || '',
        a = s.spec.marks
      ;(s.contentMatch = r[o] || (r[o] = ta.parse(o, this.nodes))),
        (s.inlineContent = s.contentMatch.inlineContent),
        (s.markSet =
          a == '_' ? null : a ? tS(this, a.split(' ')) : a == '' || !s.inlineContent ? [] : null)
    }
    for (let i in this.marks) {
      let s = this.marks[i],
        o = s.spec.excludes
      s.excluded = o == null ? [s] : o == '' ? [] : tS(this, o.split(' '))
    }
    ;(this.nodeFromJSON = this.nodeFromJSON.bind(this)),
      (this.markFromJSON = this.markFromJSON.bind(this)),
      (this.topNodeType = this.nodes[this.spec.topNode || 'doc']),
      (this.cached.wrappings = Object.create(null))
  }
  node(e, n = null, r, i) {
    if (typeof e == 'string') e = this.nodeType(e)
    else if (e instanceof eS) {
      if (e.schema != this)
        throw new RangeError('Node type from different schema used (' + e.name + ')')
    } else throw new RangeError('Invalid node type: ' + e)
    return e.createChecked(n, r, i)
  }
  text(e, n) {
    let r = this.nodes.text
    return new Gf(r, r.defaultAttrs, e, at.setFrom(n))
  }
  mark(e, n) {
    return typeof e == 'string' && (e = this.marks[e]), e.create(n)
  }
  nodeFromJSON(e) {
    return $o.fromJSON(this, e)
  }
  markFromJSON(e) {
    return at.fromJSON(this, e)
  }
  nodeType(e) {
    let n = this.nodes[e]
    if (!n) throw new RangeError('Unknown node type: ' + e)
    return n
  }
}
function tS(t, e) {
  let n = []
  for (let r = 0; r < e.length; r++) {
    let i = e[r],
      s = t.marks[i],
      o = s
    if (s) n.push(s)
    else
      for (let a in t.marks) {
        let l = t.marks[a]
        ;(i == '_' || (l.spec.group && l.spec.group.split(' ').indexOf(i) > -1)) && n.push((o = l))
      }
    if (!o) throw new SyntaxError("Unknown mark type: '" + e[r] + "'")
  }
  return n
}
function Qz(t) {
  return t.tag != null
}
function Xz(t) {
  return t.style != null
}
class Il {
  constructor(e, n) {
    ;(this.schema = e),
      (this.rules = n),
      (this.tags = []),
      (this.styles = []),
      n.forEach((r) => {
        Qz(r) ? this.tags.push(r) : Xz(r) && this.styles.push(r)
      }),
      (this.normalizeLists = !this.tags.some((r) => {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return !1
        let i = e.nodes[r.node]
        return i.contentMatch.matchType(i)
      }))
  }
  parse(e, n = {}) {
    let r = new rS(this, n, !1)
    return r.addAll(e, n.from, n.to), r.finish()
  }
  parseSlice(e, n = {}) {
    let r = new rS(this, n, !0)
    return r.addAll(e, n.from, n.to), ie.maxOpen(r.finish())
  }
  matchTag(e, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i]
      if (
        tj(e, s.tag) &&
        (s.namespace === void 0 || e.namespaceURI == s.namespace) &&
        (!s.context || n.matchesContext(s.context))
      ) {
        if (s.getAttrs) {
          let o = s.getAttrs(e)
          if (o === !1) continue
          s.attrs = o || void 0
        }
        return s
      }
    }
  }
  matchStyle(e, n, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s],
        a = o.style
      if (
        !(
          a.indexOf(e) != 0 ||
          (o.context && !r.matchesContext(o.context)) ||
          (a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))
        )
      ) {
        if (o.getAttrs) {
          let l = o.getAttrs(n)
          if (l === !1) continue
          o.attrs = l || void 0
        }
        return o
      }
    }
  }
  static schemaRules(e) {
    let n = []
    function r(i) {
      let s = i.priority == null ? 50 : i.priority,
        o = 0
      for (; o < n.length; o++) {
        let a = n[o]
        if ((a.priority == null ? 50 : a.priority) < s) break
      }
      n.splice(o, 0, i)
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM
      s &&
        s.forEach((o) => {
          r((o = iS(o))), o.mark || o.ignore || o.clearMark || (o.mark = i)
        })
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM
      s &&
        s.forEach((o) => {
          r((o = iS(o))), o.node || o.ignore || o.mark || (o.node = i)
        })
    }
    return n
  }
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Il(e, Il.schemaRules(e)))
  }
}
const vN = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
  },
  Zz = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 },
  bN = { ol: !0, ul: !0 },
  qf = 1,
  Kf = 2,
  Yc = 4
function nS(t, e, n) {
  return e != null
    ? (e ? qf : 0) | (e === 'full' ? Kf : 0)
    : t && t.whitespace == 'pre'
    ? qf | Kf
    : n & ~Yc
}
class od {
  constructor(e, n, r, i, s, o, a) {
    ;(this.type = e),
      (this.attrs = n),
      (this.marks = r),
      (this.pendingMarks = i),
      (this.solid = s),
      (this.options = a),
      (this.content = []),
      (this.activeMarks = at.none),
      (this.stashMarks = []),
      (this.match = o || (a & Yc ? null : e.contentMatch))
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type) return []
      let n = this.type.contentMatch.fillBefore(H.from(e))
      if (n) this.match = this.type.contentMatch.matchFragment(n)
      else {
        let r = this.type.contentMatch,
          i
        return (i = r.findWrapping(e.type)) ? ((this.match = r), i) : null
      }
    }
    return this.match.findWrapping(e.type)
  }
  finish(e) {
    if (!(this.options & qf)) {
      let r = this.content[this.content.length - 1],
        i
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r
        r.text.length == i[0].length
          ? this.content.pop()
          : (this.content[this.content.length - 1] = s.withText(
              s.text.slice(0, s.text.length - i[0].length)
            ))
      }
    }
    let n = H.from(this.content)
    return (
      !e && this.match && (n = n.append(this.match.fillBefore(H.empty, !0))),
      this.type ? this.type.create(this.attrs, n, this.marks) : n
    )
  }
  popFromStashMark(e) {
    for (let n = this.stashMarks.length - 1; n >= 0; n--)
      if (e.eq(this.stashMarks[n])) return this.stashMarks.splice(n, 1)[0]
  }
  applyPending(e) {
    for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
      let i = r[n]
      ;(this.type ? this.type.allowsMarkType(i.type) : rj(i.type, e)) &&
        !i.isInSet(this.activeMarks) &&
        ((this.activeMarks = i.addToSet(this.activeMarks)),
        (this.pendingMarks = i.removeFromSet(this.pendingMarks)))
    }
  }
  inlineContext(e) {
    return this.type
      ? this.type.inlineContent
      : this.content.length
      ? this.content[0].isInline
      : e.parentNode && !vN.hasOwnProperty(e.parentNode.nodeName.toLowerCase())
  }
}
class rS {
  constructor(e, n, r) {
    ;(this.parser = e), (this.options = n), (this.isOpen = r), (this.open = 0)
    let i = n.topNode,
      s,
      o = nS(null, n.preserveWhitespace, 0) | (r ? Yc : 0)
    i
      ? (s = new od(i.type, i.attrs, at.none, at.none, !0, n.topMatch || i.type.contentMatch, o))
      : r
      ? (s = new od(null, null, at.none, at.none, !0, null, o))
      : (s = new od(e.schema.topNodeType, null, at.none, at.none, !0, null, o)),
      (this.nodes = [s]),
      (this.find = n.findPositions),
      (this.needsBlock = !1)
  }
  get top() {
    return this.nodes[this.open]
  }
  addDOM(e) {
    e.nodeType == 3 ? this.addTextNode(e) : e.nodeType == 1 && this.addElement(e)
  }
  withStyleRules(e, n) {
    let r = e.getAttribute('style')
    if (!r) return n()
    let i = this.readStyles(nj(r))
    if (!i) return
    let [s, o] = i,
      a = this.top
    for (let l = 0; l < o.length; l++) this.removePendingMark(o[l], a)
    for (let l = 0; l < s.length; l++) this.addPendingMark(s[l])
    n()
    for (let l = 0; l < s.length; l++) this.removePendingMark(s[l], a)
    for (let l = 0; l < o.length; l++) this.addPendingMark(o[l])
  }
  addTextNode(e) {
    let n = e.nodeValue,
      r = this.top
    if (r.options & Kf || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
      if (r.options & qf)
        r.options & Kf
          ? (n = n.replace(
              /\r\n?/g,
              `
`
            ))
          : (n = n.replace(/\r?\n|\r/g, ' '))
      else if (
        ((n = n.replace(/[ \t\r\n\u000c]+/g, ' ')),
        /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1)
      ) {
        let i = r.content[r.content.length - 1],
          s = e.previousSibling
        ;(!i || (s && s.nodeName == 'BR') || (i.isText && /[ \t\r\n\u000c]$/.test(i.text))) &&
          (n = n.slice(1))
      }
      n && this.insertNode(this.parser.schema.text(n)), this.findInText(e)
    } else this.findInside(e)
  }
  addElement(e, n) {
    let r = e.nodeName.toLowerCase(),
      i
    bN.hasOwnProperty(r) && this.parser.normalizeLists && ej(e)
    let s =
      (this.options.ruleFromNode && this.options.ruleFromNode(e)) ||
      (i = this.parser.matchTag(e, this, n))
    if (s ? s.ignore : Zz.hasOwnProperty(r)) this.findInside(e), this.ignoreFallback(e)
    else if (!s || s.skip || s.closeParent) {
      s && s.closeParent
        ? (this.open = Math.max(0, this.open - 1))
        : s && s.skip.nodeType && (e = s.skip)
      let o,
        a = this.top,
        l = this.needsBlock
      if (vN.hasOwnProperty(r))
        a.content.length && a.content[0].isInline && this.open && (this.open--, (a = this.top)),
          (o = !0),
          a.type || (this.needsBlock = !0)
      else if (!e.firstChild) {
        this.leafFallback(e)
        return
      }
      s && s.skip ? this.addAll(e) : this.withStyleRules(e, () => this.addAll(e)),
        o && this.sync(a),
        (this.needsBlock = l)
    } else
      this.withStyleRules(e, () => {
        this.addElementByRule(e, s, s.consuming === !1 ? i : void 0)
      })
  }
  leafFallback(e) {
    e.nodeName == 'BR' &&
      this.top.type &&
      this.top.type.inlineContent &&
      this.addTextNode(
        e.ownerDocument.createTextNode(`
`)
      )
  }
  ignoreFallback(e) {
    e.nodeName == 'BR' &&
      (!this.top.type || !this.top.type.inlineContent) &&
      this.findPlace(this.parser.schema.text('-'))
  }
  readStyles(e) {
    let n = at.none,
      r = at.none
    for (let i = 0; i < e.length; i += 2)
      for (let s = void 0; ; ) {
        let o = this.parser.matchStyle(e[i], e[i + 1], this, s)
        if (!o) break
        if (o.ignore) return null
        if (
          (o.clearMark
            ? this.top.pendingMarks.concat(this.top.activeMarks).forEach((a) => {
                o.clearMark(a) && (r = a.addToSet(r))
              })
            : (n = this.parser.schema.marks[o.mark].create(o.attrs).addToSet(n)),
          o.consuming === !1)
        )
          s = o
        else break
      }
    return [n, r]
  }
  addElementByRule(e, n, r) {
    let i, s, o
    n.node
      ? ((s = this.parser.schema.nodes[n.node]),
        s.isLeaf
          ? this.insertNode(s.create(n.attrs)) || this.leafFallback(e)
          : (i = this.enter(s, n.attrs || null, n.preserveWhitespace)))
      : ((o = this.parser.schema.marks[n.mark].create(n.attrs)), this.addPendingMark(o))
    let a = this.top
    if (s && s.isLeaf) this.findInside(e)
    else if (r) this.addElement(e, r)
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l))
    else {
      let l = e
      typeof n.contentElement == 'string'
        ? (l = e.querySelector(n.contentElement))
        : typeof n.contentElement == 'function'
        ? (l = n.contentElement(e))
        : n.contentElement && (l = n.contentElement),
        this.findAround(e, l, !0),
        this.addAll(l)
    }
    i && this.sync(a) && this.open--, o && this.removePendingMark(o, a)
  }
  addAll(e, n, r) {
    let i = n || 0
    for (
      let s = n ? e.childNodes[n] : e.firstChild, o = r == null ? null : e.childNodes[r];
      s != o;
      s = s.nextSibling, ++i
    )
      this.findAtPoint(e, i), this.addDOM(s)
    this.findAtPoint(e, i)
  }
  findPlace(e) {
    let n, r
    for (let i = this.open; i >= 0; i--) {
      let s = this.nodes[i],
        o = s.findWrapping(e)
      if ((o && (!n || n.length > o.length) && ((n = o), (r = s), !o.length)) || s.solid) break
    }
    if (!n) return !1
    this.sync(r)
    for (let i = 0; i < n.length; i++) this.enterInner(n[i], null, !1)
    return !0
  }
  insertNode(e) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let n = this.textblockFromContext()
      n && this.enterInner(n)
    }
    if (this.findPlace(e)) {
      this.closeExtra()
      let n = this.top
      n.applyPending(e.type), n.match && (n.match = n.match.matchType(e.type))
      let r = n.activeMarks
      for (let i = 0; i < e.marks.length; i++)
        (!n.type || n.type.allowsMarkType(e.marks[i].type)) && (r = e.marks[i].addToSet(r))
      return n.content.push(e.mark(r)), !0
    }
    return !1
  }
  enter(e, n, r) {
    let i = this.findPlace(e.create(n))
    return i && this.enterInner(e, n, !0, r), i
  }
  enterInner(e, n = null, r = !1, i) {
    this.closeExtra()
    let s = this.top
    s.applyPending(e), (s.match = s.match && s.match.matchType(e))
    let o = nS(e, i, s.options)
    s.options & Yc && s.content.length == 0 && (o |= Yc),
      this.nodes.push(new od(e, n, s.activeMarks, s.pendingMarks, r, null, o)),
      this.open++
  }
  closeExtra(e = !1) {
    let n = this.nodes.length - 1
    if (n > this.open) {
      for (; n > this.open; n--) this.nodes[n - 1].content.push(this.nodes[n].finish(e))
      this.nodes.length = this.open + 1
    }
  }
  finish() {
    return (
      (this.open = 0),
      this.closeExtra(this.isOpen),
      this.nodes[0].finish(this.isOpen || this.options.topOpen)
    )
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) if (this.nodes[n] == e) return (this.open = n), !0
    return !1
  }
  get currentPos() {
    this.closeExtra()
    let e = 0
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content
      for (let i = r.length - 1; i >= 0; i--) e += r[i].nodeSize
      n && e++
    }
    return e
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos)
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null &&
          e.nodeType == 1 &&
          e.contains(this.find[n].node) &&
          (this.find[n].pos = this.currentPos)
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null &&
          e.nodeType == 1 &&
          e.contains(this.find[i].node) &&
          n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) &&
          (this.find[i].pos = this.currentPos)
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e &&
          (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset))
  }
  matchesContext(e) {
    if (e.indexOf('|') > -1) return e.split(/\s*\|\s*/).some(this.matchesContext, this)
    let n = e.split('/'),
      r = this.options.context,
      i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
      s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1),
      o = (a, l) => {
        for (; a >= 0; a--) {
          let c = n[a]
          if (c == '') {
            if (a == n.length - 1 || a == 0) continue
            for (; l >= s; l--) if (o(a - 1, l)) return !0
            return !1
          } else {
            let u =
              l > 0 || (l == 0 && i) ? this.nodes[l].type : r && l >= s ? r.node(l - s).type : null
            if (!u || (u.name != c && u.groups.indexOf(c) == -1)) return !1
            l--
          }
        }
        return !0
      }
    return o(n.length - 1, this.open)
  }
  textblockFromContext() {
    let e = this.options.context
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType
        if (r && r.isTextblock && r.defaultAttrs) return r
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n]
      if (r.isTextblock && r.defaultAttrs) return r
    }
  }
  addPendingMark(e) {
    let n = ij(e, this.top.pendingMarks)
    n && this.top.stashMarks.push(n), (this.top.pendingMarks = e.addToSet(this.top.pendingMarks))
  }
  removePendingMark(e, n) {
    for (let r = this.open; r >= 0; r--) {
      let i = this.nodes[r]
      if (i.pendingMarks.lastIndexOf(e) > -1) i.pendingMarks = e.removeFromSet(i.pendingMarks)
      else {
        i.activeMarks = e.removeFromSet(i.activeMarks)
        let o = i.popFromStashMark(e)
        o && i.type && i.type.allowsMarkType(o.type) && (i.activeMarks = o.addToSet(i.activeMarks))
      }
      if (i == n) break
    }
  }
}
function ej(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null
    r && bN.hasOwnProperty(r) && n
      ? (n.appendChild(e), (e = n))
      : r == 'li'
      ? (n = e)
      : r && (n = null)
  }
}
function tj(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(
    t,
    e
  )
}
function nj(t) {
  let e = /\s*([\w-]+)\s*:\s*([^;]+)/g,
    n,
    r = []
  for (; (n = e.exec(t)); ) r.push(n[1], n[2].trim())
  return r
}
function iS(t) {
  let e = {}
  for (let n in t) e[n] = t[n]
  return e
}
function rj(t, e) {
  let n = e.schema.nodes
  for (let r in n) {
    let i = n[r]
    if (!i.allowsMarkType(t)) continue
    let s = [],
      o = (a) => {
        s.push(a)
        for (let l = 0; l < a.edgeCount; l++) {
          let { type: c, next: u } = a.edge(l)
          if (c == e || (s.indexOf(u) < 0 && o(u))) return !0
        }
      }
    if (o(i.contentMatch)) return !0
  }
}
function ij(t, e) {
  for (let n = 0; n < e.length; n++) if (t.eq(e[n])) return e[n]
}
class si {
  constructor(e, n) {
    ;(this.nodes = e), (this.marks = n)
  }
  serializeFragment(e, n = {}, r) {
    r || (r = Fg(n).createDocumentFragment())
    let i = r,
      s = []
    return (
      e.forEach((o) => {
        if (s.length || o.marks.length) {
          let a = 0,
            l = 0
          for (; a < s.length && l < o.marks.length; ) {
            let c = o.marks[l]
            if (!this.marks[c.type.name]) {
              l++
              continue
            }
            if (!c.eq(s[a][0]) || c.type.spec.spanning === !1) break
            a++, l++
          }
          for (; a < s.length; ) i = s.pop()[1]
          for (; l < o.marks.length; ) {
            let c = o.marks[l++],
              u = this.serializeMark(c, o.isInline, n)
            u && (s.push([c, i]), i.appendChild(u.dom), (i = u.contentDOM || u.dom))
          }
        }
        i.appendChild(this.serializeNodeInner(o, n))
      }),
      r
    )
  }
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: i } = si.renderSpec(Fg(n), this.nodes[e.type.name](e))
    if (i) {
      if (e.isLeaf) throw new RangeError('Content hole not allowed in a leaf node spec')
      this.serializeFragment(e.content, n, i)
    }
    return r
  }
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n)
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, n)
      s && ((s.contentDOM || s.dom).appendChild(r), (r = s.dom))
    }
    return r
  }
  serializeMark(e, n, r = {}) {
    let i = this.marks[e.type.name]
    return i && si.renderSpec(Fg(r), i(e, n))
  }
  static renderSpec(e, n, r = null) {
    if (typeof n == 'string') return { dom: e.createTextNode(n) }
    if (n.nodeType != null) return { dom: n }
    if (n.dom && n.dom.nodeType != null) return n
    let i = n[0],
      s = i.indexOf(' ')
    s > 0 && ((r = i.slice(0, s)), (i = i.slice(s + 1)))
    let o,
      a = r ? e.createElementNS(r, i) : e.createElement(i),
      l = n[1],
      c = 1
    if (l && typeof l == 'object' && l.nodeType == null && !Array.isArray(l)) {
      c = 2
      for (let u in l)
        if (l[u] != null) {
          let h = u.indexOf(' ')
          h > 0 ? a.setAttributeNS(u.slice(0, h), u.slice(h + 1), l[u]) : a.setAttribute(u, l[u])
        }
    }
    for (let u = c; u < n.length; u++) {
      let h = n[u]
      if (h === 0) {
        if (u < n.length - 1 || u > c)
          throw new RangeError('Content hole must be the only child of its parent node')
        return { dom: a, contentDOM: a }
      } else {
        let { dom: d, contentDOM: f } = si.renderSpec(e, h, r)
        if ((a.appendChild(d), f)) {
          if (o) throw new RangeError('Multiple content holes')
          o = f
        }
      }
    }
    return { dom: a, contentDOM: o }
  }
  static fromSchema(e) {
    return (
      e.cached.domSerializer ||
      (e.cached.domSerializer = new si(this.nodesFromSchema(e), this.marksFromSchema(e)))
    )
  }
  static nodesFromSchema(e) {
    let n = sS(e.nodes)
    return n.text || (n.text = (r) => r.text), n
  }
  static marksFromSchema(e) {
    return sS(e.marks)
  }
}
function sS(t) {
  let e = {}
  for (let n in t) {
    let r = t[n].spec.toDOM
    r && (e[n] = r)
  }
  return e
}
function Fg(t) {
  return t.document || window.document
}
const EN = 65535,
  TN = Math.pow(2, 16)
function sj(t, e) {
  return t + e * TN
}
function oS(t) {
  return t & EN
}
function oj(t) {
  return (t - (t & EN)) / TN
}
const wN = 1,
  SN = 2,
  Vd = 4,
  IN = 8
class $_ {
  constructor(e, n, r) {
    ;(this.pos = e), (this.delInfo = n), (this.recover = r)
  }
  get deleted() {
    return (this.delInfo & IN) > 0
  }
  get deletedBefore() {
    return (this.delInfo & (wN | Vd)) > 0
  }
  get deletedAfter() {
    return (this.delInfo & (SN | Vd)) > 0
  }
  get deletedAcross() {
    return (this.delInfo & Vd) > 0
  }
}
class sr {
  constructor(e, n = !1) {
    if (((this.ranges = e), (this.inverted = n), !e.length && sr.empty)) return sr.empty
  }
  recover(e) {
    let n = 0,
      r = oS(e)
    if (!this.inverted)
      for (let i = 0; i < r; i++) n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]
    return this.ranges[r * 3] + n + oj(e)
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1)
  }
  map(e, n = 1) {
    return this._map(e, n, !0)
  }
  _map(e, n, r) {
    let i = 0,
      s = this.inverted ? 2 : 1,
      o = this.inverted ? 1 : 2
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0)
      if (l > e) break
      let c = this.ranges[a + s],
        u = this.ranges[a + o],
        h = l + c
      if (e <= h) {
        let d = c ? (e == l ? -1 : e == h ? 1 : n) : n,
          f = l + i + (d < 0 ? 0 : u)
        if (r) return f
        let p = e == (n < 0 ? l : h) ? null : sj(a / 3, e - l),
          m = e == l ? SN : e == h ? wN : Vd
        return (n < 0 ? e != l : e != h) && (m |= IN), new $_(f, m, p)
      }
      i += u - c
    }
    return r ? e + i : new $_(e + i, 0, null)
  }
  touches(e, n) {
    let r = 0,
      i = oS(n),
      s = this.inverted ? 2 : 1,
      o = this.inverted ? 1 : 2
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0)
      if (l > e) break
      let c = this.ranges[a + s],
        u = l + c
      if (e <= u && a == i * 3) return !0
      r += this.ranges[a + o] - c
    }
    return !1
  }
  forEach(e) {
    let n = this.inverted ? 2 : 1,
      r = this.inverted ? 1 : 2
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i],
        a = o - (this.inverted ? s : 0),
        l = o + (this.inverted ? 0 : s),
        c = this.ranges[i + n],
        u = this.ranges[i + r]
      e(a, a + c, l, l + u), (s += u - c)
    }
  }
  invert() {
    return new sr(this.ranges, !this.inverted)
  }
  toString() {
    return (this.inverted ? '-' : '') + JSON.stringify(this.ranges)
  }
  static offset(e) {
    return e == 0 ? sr.empty : new sr(e < 0 ? [0, -e, 0] : [0, 0, e])
  }
}
sr.empty = new sr([])
class el {
  constructor(e = [], n, r = 0, i = e.length) {
    ;(this.maps = e), (this.mirror = n), (this.from = r), (this.to = i)
  }
  slice(e = 0, n = this.maps.length) {
    return new el(this.maps, this.mirror, e, n)
  }
  copy() {
    return new el(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)
  }
  appendMap(e, n) {
    ;(this.to = this.maps.push(e)), n != null && this.setMirror(this.maps.length - 1, n)
  }
  appendMapping(e) {
    for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
      let i = e.getMirror(n)
      this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0)
    }
  }
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e) return this.mirror[n + (n % 2 ? -1 : 1)]
    }
  }
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n)
  }
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this.maps.length + e.maps.length; n >= 0; n--) {
      let i = e.getMirror(n)
      this.appendMap(e.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0)
    }
  }
  invert() {
    let e = new el()
    return e.appendMappingInverted(this), e
  }
  map(e, n = 1) {
    if (this.mirror) return this._map(e, n, !0)
    for (let r = this.from; r < this.to; r++) e = this.maps[r].map(e, n)
    return e
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1)
  }
  _map(e, n, r) {
    let i = 0
    for (let s = this.from; s < this.to; s++) {
      let o = this.maps[s],
        a = o.mapResult(e, n)
      if (a.recover != null) {
        let l = this.getMirror(s)
        if (l != null && l > s && l < this.to) {
          ;(s = l), (e = this.maps[l].recover(a.recover))
          continue
        }
      }
      ;(i |= a.delInfo), (e = a.pos)
    }
    return r ? e : new $_(e, i, null)
  }
}
const Bg = Object.create(null)
class Dn {
  getMap() {
    return sr.empty
  }
  merge(e) {
    return null
  }
  static fromJSON(e, n) {
    if (!n || !n.stepType) throw new RangeError('Invalid input for Step.fromJSON')
    let r = Bg[n.stepType]
    if (!r) throw new RangeError(`No step type ${n.stepType} defined`)
    return r.fromJSON(e, n)
  }
  static jsonID(e, n) {
    if (e in Bg) throw new RangeError('Duplicate use of step JSON ID ' + e)
    return (Bg[e] = n), (n.prototype.jsonID = e), n
  }
}
class Ut {
  constructor(e, n) {
    ;(this.doc = e), (this.failed = n)
  }
  static ok(e) {
    return new Ut(e, null)
  }
  static fail(e) {
    return new Ut(null, e)
  }
  static fromReplace(e, n, r, i) {
    try {
      return Ut.ok(e.replace(n, r, i))
    } catch (s) {
      if (s instanceof zf) return Ut.fail(s.message)
      throw s
    }
  }
}
function B1(t, e, n) {
  let r = []
  for (let i = 0; i < t.childCount; i++) {
    let s = t.child(i)
    s.content.size && (s = s.copy(B1(s.content, e, s))), s.isInline && (s = e(s, n, i)), r.push(s)
  }
  return H.fromArray(r)
}
class Ss extends Dn {
  constructor(e, n, r) {
    super(), (this.from = e), (this.to = n), (this.mark = r)
  }
  apply(e) {
    let n = e.slice(this.from, this.to),
      r = e.resolve(this.from),
      i = r.node(r.sharedDepth(this.to)),
      s = new ie(
        B1(
          n.content,
          (o, a) =>
            !o.isAtom || !a.type.allowsMarkType(this.mark.type)
              ? o
              : o.mark(this.mark.addToSet(o.marks)),
          i
        ),
        n.openStart,
        n.openEnd
      )
    return Ut.fromReplace(e, this.from, this.to, s)
  }
  invert() {
    return new oi(this.from, this.to, this.mark)
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1)
    return (n.deleted && r.deleted) || n.pos >= r.pos ? null : new Ss(n.pos, r.pos, this.mark)
  }
  merge(e) {
    return e instanceof Ss && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from
      ? new Ss(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark)
      : null
  }
  toJSON() {
    return { stepType: 'addMark', mark: this.mark.toJSON(), from: this.from, to: this.to }
  }
  static fromJSON(e, n) {
    if (typeof n.from != 'number' || typeof n.to != 'number')
      throw new RangeError('Invalid input for AddMarkStep.fromJSON')
    return new Ss(n.from, n.to, e.markFromJSON(n.mark))
  }
}
Dn.jsonID('addMark', Ss)
class oi extends Dn {
  constructor(e, n, r) {
    super(), (this.from = e), (this.to = n), (this.mark = r)
  }
  apply(e) {
    let n = e.slice(this.from, this.to),
      r = new ie(
        B1(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e),
        n.openStart,
        n.openEnd
      )
    return Ut.fromReplace(e, this.from, this.to, r)
  }
  invert() {
    return new Ss(this.from, this.to, this.mark)
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1)
    return (n.deleted && r.deleted) || n.pos >= r.pos ? null : new oi(n.pos, r.pos, this.mark)
  }
  merge(e) {
    return e instanceof oi && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from
      ? new oi(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark)
      : null
  }
  toJSON() {
    return { stepType: 'removeMark', mark: this.mark.toJSON(), from: this.from, to: this.to }
  }
  static fromJSON(e, n) {
    if (typeof n.from != 'number' || typeof n.to != 'number')
      throw new RangeError('Invalid input for RemoveMarkStep.fromJSON')
    return new oi(n.from, n.to, e.markFromJSON(n.mark))
  }
}
Dn.jsonID('removeMark', oi)
class Is extends Dn {
  constructor(e, n) {
    super(), (this.pos = e), (this.mark = n)
  }
  apply(e) {
    let n = e.nodeAt(this.pos)
    if (!n) return Ut.fail("No node at mark step's position")
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks))
    return Ut.fromReplace(e, this.pos, this.pos + 1, new ie(H.from(r), 0, n.isLeaf ? 0 : 1))
  }
  invert(e) {
    let n = e.nodeAt(this.pos)
    if (n) {
      let r = this.mark.addToSet(n.marks)
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r)) return new Is(this.pos, n.marks[i])
        return new Is(this.pos, this.mark)
      }
    }
    return new Al(this.pos, this.mark)
  }
  map(e) {
    let n = e.mapResult(this.pos, 1)
    return n.deletedAfter ? null : new Is(n.pos, this.mark)
  }
  toJSON() {
    return { stepType: 'addNodeMark', pos: this.pos, mark: this.mark.toJSON() }
  }
  static fromJSON(e, n) {
    if (typeof n.pos != 'number') throw new RangeError('Invalid input for AddNodeMarkStep.fromJSON')
    return new Is(n.pos, e.markFromJSON(n.mark))
  }
}
Dn.jsonID('addNodeMark', Is)
class Al extends Dn {
  constructor(e, n) {
    super(), (this.pos = e), (this.mark = n)
  }
  apply(e) {
    let n = e.nodeAt(this.pos)
    if (!n) return Ut.fail("No node at mark step's position")
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks))
    return Ut.fromReplace(e, this.pos, this.pos + 1, new ie(H.from(r), 0, n.isLeaf ? 0 : 1))
  }
  invert(e) {
    let n = e.nodeAt(this.pos)
    return !n || !this.mark.isInSet(n.marks) ? this : new Is(this.pos, this.mark)
  }
  map(e) {
    let n = e.mapResult(this.pos, 1)
    return n.deletedAfter ? null : new Al(n.pos, this.mark)
  }
  toJSON() {
    return { stepType: 'removeNodeMark', pos: this.pos, mark: this.mark.toJSON() }
  }
  static fromJSON(e, n) {
    if (typeof n.pos != 'number')
      throw new RangeError('Invalid input for RemoveNodeMarkStep.fromJSON')
    return new Al(n.pos, e.markFromJSON(n.mark))
  }
}
Dn.jsonID('removeNodeMark', Al)
class Zt extends Dn {
  constructor(e, n, r, i = !1) {
    super(), (this.from = e), (this.to = n), (this.slice = r), (this.structure = i)
  }
  apply(e) {
    return this.structure && H_(e, this.from, this.to)
      ? Ut.fail('Structure replace would overwrite content')
      : Ut.fromReplace(e, this.from, this.to, this.slice)
  }
  getMap() {
    return new sr([this.from, this.to - this.from, this.slice.size])
  }
  invert(e) {
    return new Zt(this.from, this.from + this.slice.size, e.slice(this.from, this.to))
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1)
    return n.deletedAcross && r.deletedAcross
      ? null
      : new Zt(n.pos, Math.max(n.pos, r.pos), this.slice)
  }
  merge(e) {
    if (!(e instanceof Zt) || e.structure || this.structure) return null
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n =
        this.slice.size + e.slice.size == 0
          ? ie.empty
          : new ie(
              this.slice.content.append(e.slice.content),
              this.slice.openStart,
              e.slice.openEnd
            )
      return new Zt(this.from, this.to + (e.to - e.from), n, this.structure)
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n =
        this.slice.size + e.slice.size == 0
          ? ie.empty
          : new ie(
              e.slice.content.append(this.slice.content),
              e.slice.openStart,
              this.slice.openEnd
            )
      return new Zt(e.from, this.to, n, this.structure)
    } else return null
  }
  toJSON() {
    let e = { stepType: 'replace', from: this.from, to: this.to }
    return (
      this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e
    )
  }
  static fromJSON(e, n) {
    if (typeof n.from != 'number' || typeof n.to != 'number')
      throw new RangeError('Invalid input for ReplaceStep.fromJSON')
    return new Zt(n.from, n.to, ie.fromJSON(e, n.slice), !!n.structure)
  }
}
Dn.jsonID('replace', Zt)
class tn extends Dn {
  constructor(e, n, r, i, s, o, a = !1) {
    super(),
      (this.from = e),
      (this.to = n),
      (this.gapFrom = r),
      (this.gapTo = i),
      (this.slice = s),
      (this.insert = o),
      (this.structure = a)
  }
  apply(e) {
    if (this.structure && (H_(e, this.from, this.gapFrom) || H_(e, this.gapTo, this.to)))
      return Ut.fail('Structure gap-replace would overwrite content')
    let n = e.slice(this.gapFrom, this.gapTo)
    if (n.openStart || n.openEnd) return Ut.fail('Gap is not a flat range')
    let r = this.slice.insertAt(this.insert, n.content)
    return r ? Ut.fromReplace(e, this.from, this.to, r) : Ut.fail('Content does not fit in gap')
  }
  getMap() {
    return new sr([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ])
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom
    return new tn(
      this.from,
      this.from + this.slice.size + n,
      this.from + this.insert,
      this.from + this.insert + n,
      e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
      this.gapFrom - this.from,
      this.structure
    )
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1),
      i = e.map(this.gapFrom, -1),
      s = e.map(this.gapTo, 1)
    return (n.deletedAcross && r.deletedAcross) || i < n.pos || s > r.pos
      ? null
      : new tn(n.pos, r.pos, i, s, this.slice, this.insert, this.structure)
  }
  toJSON() {
    let e = {
      stepType: 'replaceAround',
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    }
    return (
      this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e
    )
  }
  static fromJSON(e, n) {
    if (
      typeof n.from != 'number' ||
      typeof n.to != 'number' ||
      typeof n.gapFrom != 'number' ||
      typeof n.gapTo != 'number' ||
      typeof n.insert != 'number'
    )
      throw new RangeError('Invalid input for ReplaceAroundStep.fromJSON')
    return new tn(
      n.from,
      n.to,
      n.gapFrom,
      n.gapTo,
      ie.fromJSON(e, n.slice),
      n.insert,
      !!n.structure
    )
  }
}
Dn.jsonID('replaceAround', tn)
function H_(t, e, n) {
  let r = t.resolve(e),
    i = n - e,
    s = r.depth
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; ) s--, i--
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s))
    for (; i > 0; ) {
      if (!o || o.isLeaf) return !0
      ;(o = o.firstChild), i--
    }
  }
  return !1
}
function aj(t, e, n, r) {
  let i = [],
    s = [],
    o,
    a
  t.doc.nodesBetween(e, n, (l, c, u) => {
    if (!l.isInline) return
    let h = l.marks
    if (!r.isInSet(h) && u.type.allowsMarkType(r.type)) {
      let d = Math.max(c, e),
        f = Math.min(c + l.nodeSize, n),
        p = r.addToSet(h)
      for (let m = 0; m < h.length; m++)
        h[m].isInSet(p) ||
          (o && o.to == d && o.mark.eq(h[m]) ? (o.to = f) : i.push((o = new oi(d, f, h[m]))))
      a && a.to == d ? (a.to = f) : s.push((a = new Ss(d, f, r)))
    }
  }),
    i.forEach((l) => t.step(l)),
    s.forEach((l) => t.step(l))
}
function lj(t, e, n, r) {
  let i = [],
    s = 0
  t.doc.nodesBetween(e, n, (o, a) => {
    if (!o.isInline) return
    s++
    let l = null
    if (r instanceof _m) {
      let c = o.marks,
        u
      for (; (u = r.isInSet(c)); ) (l || (l = [])).push(u), (c = u.removeFromSet(c))
    } else r ? r.isInSet(o.marks) && (l = [r]) : (l = o.marks)
    if (l && l.length) {
      let c = Math.min(a + o.nodeSize, n)
      for (let u = 0; u < l.length; u++) {
        let h = l[u],
          d
        for (let f = 0; f < i.length; f++) {
          let p = i[f]
          p.step == s - 1 && h.eq(i[f].style) && (d = p)
        }
        d ? ((d.to = c), (d.step = s)) : i.push({ style: h, from: Math.max(a, e), to: c, step: s })
      }
    }
  }),
    i.forEach((o) => t.step(new oi(o.from, o.to, o.style)))
}
function cj(t, e, n, r = n.contentMatch) {
  let i = t.doc.nodeAt(e),
    s = [],
    o = e + 1
  for (let a = 0; a < i.childCount; a++) {
    let l = i.child(a),
      c = o + l.nodeSize,
      u = r.matchType(l.type)
    if (!u) s.push(new Zt(o, c, ie.empty))
    else {
      r = u
      for (let h = 0; h < l.marks.length; h++)
        n.allowsMarkType(l.marks[h].type) || t.step(new oi(o, c, l.marks[h]))
      if (l.isText && !n.spec.code) {
        let h,
          d = /\r?\n|\r/g,
          f
        for (; (h = d.exec(l.text)); )
          f || (f = new ie(H.from(n.schema.text(' ', n.allowedMarks(l.marks))), 0, 0)),
            s.push(new Zt(o + h.index, o + h.index + h[0].length, f))
      }
    }
    o = c
  }
  if (!r.validEnd) {
    let a = r.fillBefore(H.empty, !0)
    t.replace(o, o, new ie(a, 0, 0))
  }
  for (let a = s.length - 1; a >= 0; a--) t.step(s[a])
}
function uj(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n))
}
function ql(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex)
  for (let r = t.depth; ; --r) {
    let i = t.$from.node(r),
      s = t.$from.index(r),
      o = t.$to.indexAfter(r)
    if (r < t.depth && i.canReplace(s, o, n)) return r
    if (r == 0 || i.type.spec.isolating || !uj(i, s, o)) break
  }
  return null
}
function hj(t, e, n) {
  let { $from: r, $to: i, depth: s } = e,
    o = r.before(s + 1),
    a = i.after(s + 1),
    l = o,
    c = a,
    u = H.empty,
    h = 0
  for (let p = s, m = !1; p > n; p--)
    m || r.index(p) > 0 ? ((m = !0), (u = H.from(r.node(p).copy(u))), h++) : l--
  let d = H.empty,
    f = 0
  for (let p = s, m = !1; p > n; p--)
    m || i.after(p + 1) < i.end(p) ? ((m = !0), (d = H.from(i.node(p).copy(d))), f++) : c++
  t.step(new tn(l, c, o, a, new ie(u.append(d), h, f), u.size - h, !0))
}
function U1(t, e, n = null, r = t) {
  let i = dj(t, e),
    s = i && fj(r, e)
  return s ? i.map(aS).concat({ type: e, attrs: n }).concat(s.map(aS)) : null
}
function aS(t) {
  return { type: t, attrs: null }
}
function dj(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t,
    s = n.contentMatchAt(r).findWrapping(e)
  if (!s) return null
  let o = s.length ? s[0] : e
  return n.canReplaceWith(r, i, o) ? s : null
}
function fj(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t,
    s = n.child(r),
    o = e.contentMatch.findWrapping(s.type)
  if (!o) return null
  let l = (o.length ? o[o.length - 1] : e).contentMatch
  for (let c = r; l && c < i; c++) l = l.matchType(n.child(c).type)
  return !l || !l.validEnd ? null : o
}
function pj(t, e, n) {
  let r = H.empty
  for (let o = n.length - 1; o >= 0; o--) {
    if (r.size) {
      let a = n[o].type.contentMatch.matchFragment(r)
      if (!a || !a.validEnd)
        throw new RangeError(
          'Wrapper type given to Transform.wrap does not form valid content of its parent wrapper'
        )
    }
    r = H.from(n[o].type.create(n[o].attrs, r))
  }
  let i = e.start,
    s = e.end
  t.step(new tn(i, s, i, s, new ie(r, 0, 0), n.length, !0))
}
function mj(t, e, n, r, i) {
  if (!r.isTextblock) throw new RangeError('Type given to setBlockType should be a textblock')
  let s = t.steps.length
  t.doc.nodesBetween(e, n, (o, a) => {
    if (o.isTextblock && !o.hasMarkup(r, i) && gj(t.doc, t.mapping.slice(s).map(a), r)) {
      t.clearIncompatible(t.mapping.slice(s).map(a, 1), r)
      let l = t.mapping.slice(s),
        c = l.map(a, 1),
        u = l.map(a + o.nodeSize, 1)
      return (
        t.step(new tn(c, u, c + 1, u - 1, new ie(H.from(r.create(i, null, o.marks)), 0, 0), 1, !0)),
        !1
      )
    }
  })
}
function gj(t, e, n) {
  let r = t.resolve(e),
    i = r.index()
  return r.parent.canReplaceWith(i, i + 1, n)
}
function yj(t, e, n, r, i) {
  let s = t.doc.nodeAt(e)
  if (!s) throw new RangeError('No node at given position')
  n || (n = s.type)
  let o = n.create(r, null, i || s.marks)
  if (s.isLeaf) return t.replaceWith(e, e + s.nodeSize, o)
  if (!n.validContent(s.content)) throw new RangeError('Invalid content for node type ' + n.name)
  t.step(new tn(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new ie(H.from(o), 0, 0), 1, !0))
}
function tl(t, e, n = 1, r) {
  let i = t.resolve(e),
    s = i.depth - n,
    o = (r && r[r.length - 1]) || i.parent
  if (
    s < 0 ||
    i.parent.type.spec.isolating ||
    !i.parent.canReplace(i.index(), i.parent.childCount) ||
    !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount))
  )
    return !1
  for (let c = i.depth - 1, u = n - 2; c > s; c--, u--) {
    let h = i.node(c),
      d = i.index(c)
    if (h.type.spec.isolating) return !1
    let f = h.content.cutByIndex(d, h.childCount),
      p = r && r[u + 1]
    p && (f = f.replaceChild(0, p.type.create(p.attrs)))
    let m = (r && r[u]) || h
    if (!h.canReplace(d + 1, h.childCount) || !m.type.validContent(f)) return !1
  }
  let a = i.indexAfter(s),
    l = r && r[0]
  return i.node(s).canReplaceWith(a, a, l ? l.type : i.node(s + 1).type)
}
function _j(t, e, n = 1, r) {
  let i = t.doc.resolve(e),
    s = H.empty,
    o = H.empty
  for (let a = i.depth, l = i.depth - n, c = n - 1; a > l; a--, c--) {
    s = H.from(i.node(a).copy(s))
    let u = r && r[c]
    o = H.from(u ? u.type.create(u.attrs, o) : i.node(a).copy(o))
  }
  t.step(new Zt(e, e, new ie(s.append(o), n, n), !0))
}
function eo(t, e) {
  let n = t.resolve(e),
    r = n.index()
  return AN(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1)
}
function AN(t, e) {
  return !!(t && e && !t.isLeaf && t.canAppend(e))
}
function vm(t, e, n = -1) {
  let r = t.resolve(e)
  for (let i = r.depth; ; i--) {
    let s,
      o,
      a = r.index(i)
    if (
      (i == r.depth
        ? ((s = r.nodeBefore), (o = r.nodeAfter))
        : n > 0
        ? ((s = r.node(i + 1)), a++, (o = r.node(i).maybeChild(a)))
        : ((s = r.node(i).maybeChild(a - 1)), (o = r.node(i + 1))),
      s && !s.isTextblock && AN(s, o) && r.node(i).canReplace(a, a + 1))
    )
      return e
    if (i == 0) break
    e = n < 0 ? r.before(i) : r.after(i)
  }
}
function vj(t, e, n) {
  let r = new Zt(e - n, e + n, ie.empty, !0)
  t.step(r)
}
function bj(t, e, n) {
  let r = t.resolve(e)
  if (r.parent.canReplaceWith(r.index(), r.index(), n)) return e
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i)
      if (r.node(i).canReplaceWith(s, s, n)) return r.before(i + 1)
      if (s > 0) return null
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i)
      if (r.node(i).canReplaceWith(s, s, n)) return r.after(i + 1)
      if (s < r.node(i).childCount) return null
    }
  return null
}
function CN(t, e, n) {
  let r = t.resolve(e)
  if (!n.content.size) return e
  let i = n.content
  for (let s = 0; s < n.openStart; s++) i = i.firstChild.content
  for (let s = 1; s <= (n.openStart == 0 && n.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let a = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1,
        l = r.index(o) + (a > 0 ? 1 : 0),
        c = r.node(o),
        u = !1
      if (s == 1) u = c.canReplace(l, l, i)
      else {
        let h = c.contentMatchAt(l).findWrapping(i.firstChild.type)
        u = h && c.canReplaceWith(l, l, h[0])
      }
      if (u) return a == 0 ? r.pos : a < 0 ? r.before(o + 1) : r.after(o + 1)
    }
  return null
}
function bm(t, e, n = e, r = ie.empty) {
  if (e == n && !r.size) return null
  let i = t.resolve(e),
    s = t.resolve(n)
  return RN(i, s, r) ? new Zt(e, n, r) : new Ej(i, s, r).fit()
}
function RN(t, e, n) {
  return (
    !n.openStart &&
    !n.openEnd &&
    t.start() == e.start() &&
    t.parent.canReplace(t.index(), e.index(), n.content)
  )
}
class Ej {
  constructor(e, n, r) {
    ;(this.$from = e),
      (this.$to = n),
      (this.unplaced = r),
      (this.frontier = []),
      (this.placed = H.empty)
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i)
      this.frontier.push({ type: s.type, match: s.contentMatchAt(e.indexAfter(i)) })
    }
    for (let i = e.depth; i > 0; i--) this.placed = H.from(e.node(i).copy(this.placed))
  }
  get depth() {
    return this.frontier.length - 1
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable()
      c ? this.placeNodes(c) : this.openMore() || this.dropNode()
    }
    let e = this.mustMoveInline(),
      n = this.placed.size - this.depth - this.$from.depth,
      r = this.$from,
      i = this.close(e < 0 ? this.$to : r.doc.resolve(e))
    if (!i) return null
    let s = this.placed,
      o = r.depth,
      a = i.depth
    for (; o && a && s.childCount == 1; ) (s = s.firstChild.content), o--, a--
    let l = new ie(s, o, a)
    return e > -1
      ? new tn(r.pos, e, this.$to.pos, this.$to.end(), l, n)
      : l.size || r.pos != this.$to.pos
      ? new Zt(r.pos, i.pos, l)
      : null
  }
  findFittable() {
    let e = this.unplaced.openStart
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = n.firstChild
      if ((n.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r)) {
        e = r
        break
      }
      n = s.content
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i,
          s = null
        r
          ? ((s = Ug(this.unplaced.content, r - 1).firstChild), (i = s.content))
          : (i = this.unplaced.content)
        let o = i.firstChild
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a],
            u,
            h = null
          if (
            n == 1 &&
            (o
              ? c.matchType(o.type) || (h = c.fillBefore(H.from(o), !1))
              : s && l.compatibleContent(s.type))
          )
            return { sliceDepth: r, frontierDepth: a, parent: s, inject: h }
          if (n == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, wrap: u }
          if (s && c.matchType(s.type)) break
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced,
      i = Ug(e, n)
    return !i.childCount || i.firstChild.isLeaf
      ? !1
      : ((this.unplaced = new ie(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0))), !0)
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced,
      i = Ug(e, n)
    if (i.childCount <= 1 && n > 0) {
      let s = e.size - n <= n + i.size
      this.unplaced = new ie(bc(e, n - 1, 1), n - 1, s ? n - 1 : r)
    } else this.unplaced = new ie(bc(e, n, 1), n, r)
  }
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: s }) {
    for (; this.depth > n; ) this.closeFrontierNode()
    if (s) for (let m = 0; m < s.length; m++) this.openFrontierNode(s[m])
    let o = this.unplaced,
      a = r ? r.content : o.content,
      l = o.openStart - e,
      c = 0,
      u = [],
      { match: h, type: d } = this.frontier[n]
    if (i) {
      for (let m = 0; m < i.childCount; m++) u.push(i.child(m))
      h = h.matchFragment(i)
    }
    let f = a.size + e - (o.content.size - o.openEnd)
    for (; c < a.childCount; ) {
      let m = a.child(c),
        g = h.matchType(m.type)
      if (!g) break
      c++,
        (c > 1 || l == 0 || m.content.size) &&
          ((h = g),
          u.push(kN(m.mark(d.allowedMarks(m.marks)), c == 1 ? l : 0, c == a.childCount ? f : -1)))
    }
    let p = c == a.childCount
    p || (f = -1),
      (this.placed = Ec(this.placed, n, H.from(u))),
      (this.frontier[n].match = h),
      p &&
        f < 0 &&
        r &&
        r.type == this.frontier[this.depth].type &&
        this.frontier.length > 1 &&
        this.closeFrontierNode()
    for (let m = 0, g = a; m < f; m++) {
      let _ = g.lastChild
      this.frontier.push({ type: _.type, match: _.contentMatchAt(_.childCount) }), (g = _.content)
    }
    this.unplaced = p
      ? e == 0
        ? ie.empty
        : new ie(bc(o.content, e - 1, 1), e - 1, f < 0 ? o.openEnd : e - 1)
      : new ie(bc(o.content, e, c), o.openStart, o.openEnd)
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock) return -1
    let e = this.frontier[this.depth],
      n
    if (
      !e.type.isTextblock ||
      !$g(this.$to, this.$to.depth, e.type, e.match, !1) ||
      (this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
    )
      return -1
    let { depth: r } = this.$to,
      i = this.$to.after(r)
    for (; r > 1 && i == this.$to.end(--r); ) ++i
    return i
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: r, type: i } = this.frontier[n],
        s = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)),
        o = $g(e, n, i, r, s)
      if (o) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: l, type: c } = this.frontier[a],
            u = $g(e, a, c, l, !0)
          if (!u || u.childCount) continue e
        }
        return { depth: n, fit: o, move: s ? e.doc.resolve(e.after(n + 1)) : e }
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e)
    if (!n) return null
    for (; this.depth > n.depth; ) this.closeFrontierNode()
    n.fit.childCount && (this.placed = Ec(this.placed, n.depth, n.fit)), (e = n.move)
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let i = e.node(r),
        s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r))
      this.openFrontierNode(i.type, i.attrs, s)
    }
    return e
  }
  openFrontierNode(e, n = null, r) {
    let i = this.frontier[this.depth]
    ;(i.match = i.match.matchType(e)),
      (this.placed = Ec(this.placed, this.depth, H.from(e.create(n, r)))),
      this.frontier.push({ type: e, match: e.contentMatch })
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(H.empty, !0)
    n.childCount && (this.placed = Ec(this.placed, this.frontier.length, n))
  }
}
function bc(t, e, n) {
  return e == 0
    ? t.cutByIndex(n, t.childCount)
    : t.replaceChild(0, t.firstChild.copy(bc(t.firstChild.content, e - 1, n)))
}
function Ec(t, e, n) {
  return e == 0
    ? t.append(n)
    : t.replaceChild(t.childCount - 1, t.lastChild.copy(Ec(t.lastChild.content, e - 1, n)))
}
function Ug(t, e) {
  for (let n = 0; n < e; n++) t = t.firstChild.content
  return t
}
function kN(t, e, n) {
  if (e <= 0) return t
  let r = t.content
  return (
    e > 1 && (r = r.replaceChild(0, kN(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))),
    e > 0 &&
      ((r = t.type.contentMatch.fillBefore(r).append(r)),
      n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(H.empty, !0)))),
    t.copy(r)
  )
}
function $g(t, e, n, r, i) {
  let s = t.node(e),
    o = i ? t.indexAfter(e) : t.index(e)
  if (o == s.childCount && !n.compatibleContent(s.type)) return null
  let a = r.fillBefore(s.content, !0, o)
  return a && !Tj(n, s.content, o) ? a : null
}
function Tj(t, e, n) {
  for (let r = n; r < e.childCount; r++) if (!t.allowsMarks(e.child(r).marks)) return !0
  return !1
}
function wj(t) {
  return t.spec.defining || t.spec.definingForContent
}
function Sj(t, e, n, r) {
  if (!r.size) return t.deleteRange(e, n)
  let i = t.doc.resolve(e),
    s = t.doc.resolve(n)
  if (RN(i, s, r)) return t.step(new Zt(e, n, r))
  let o = NN(i, t.doc.resolve(n))
  o[o.length - 1] == 0 && o.pop()
  let a = -(i.depth + 1)
  o.unshift(a)
  for (let d = i.depth, f = i.pos - 1; d > 0; d--, f--) {
    let p = i.node(d).type.spec
    if (p.defining || p.definingAsContext || p.isolating) break
    o.indexOf(d) > -1 ? (a = d) : i.before(d) == f && o.splice(1, 0, -d)
  }
  let l = o.indexOf(a),
    c = [],
    u = r.openStart
  for (let d = r.content, f = 0; ; f++) {
    let p = d.firstChild
    if ((c.push(p), f == r.openStart)) break
    d = p.content
  }
  for (let d = u - 1; d >= 0; d--) {
    let f = c[d],
      p = wj(f.type)
    if (p && !f.sameMarkup(i.node(Math.abs(a) - 1))) u = d
    else if (p || !f.type.isTextblock) break
  }
  for (let d = r.openStart; d >= 0; d--) {
    let f = (d + u + 1) % (r.openStart + 1),
      p = c[f]
    if (p)
      for (let m = 0; m < o.length; m++) {
        let g = o[(m + l) % o.length],
          _ = !0
        g < 0 && ((_ = !1), (g = -g))
        let v = i.node(g - 1),
          T = i.index(g - 1)
        if (v.canReplaceWith(T, T, p.type, p.marks))
          return t.replace(
            i.before(g),
            _ ? s.after(g) : n,
            new ie(ON(r.content, 0, r.openStart, f), f, r.openEnd)
          )
      }
  }
  let h = t.steps.length
  for (let d = o.length - 1; d >= 0 && (t.replace(e, n, r), !(t.steps.length > h)); d--) {
    let f = o[d]
    f < 0 || ((e = i.before(f)), (n = s.after(f)))
  }
}
function ON(t, e, n, r, i) {
  if (e < n) {
    let s = t.firstChild
    t = t.replaceChild(0, s.copy(ON(s.content, e + 1, n, r, s)))
  }
  if (e > r) {
    let s = i.contentMatchAt(0),
      o = s.fillBefore(t).append(t)
    t = o.append(s.matchFragment(o).fillBefore(H.empty, !0))
  }
  return t
}
function Ij(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let i = bj(t.doc, e, r.type)
    i != null && (e = n = i)
  }
  t.replaceRange(e, n, new ie(H.from(r), 0, 0))
}
function Aj(t, e, n) {
  let r = t.doc.resolve(e),
    i = t.doc.resolve(n),
    s = NN(r, i)
  for (let o = 0; o < s.length; o++) {
    let a = s[o],
      l = o == s.length - 1
    if ((l && a == 0) || r.node(a).type.contentMatch.validEnd) return t.delete(r.start(a), i.end(a))
    if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return t.delete(r.before(a), i.after(a))
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && n > r.end(o) && i.end(o) - n != i.depth - o)
      return t.delete(r.before(o), n)
  t.delete(e, n)
}
function NN(t, e) {
  let n = [],
    r = Math.min(t.depth, e.depth)
  for (let i = r; i >= 0; i--) {
    let s = t.start(i)
    if (
      s < t.pos - (t.depth - i) ||
      e.end(i) > e.pos + (e.depth - i) ||
      t.node(i).type.spec.isolating ||
      e.node(i).type.spec.isolating
    )
      break
    ;(s == e.start(i) ||
      (i == t.depth &&
        i == e.depth &&
        t.parent.inlineContent &&
        e.parent.inlineContent &&
        i &&
        e.start(i - 1) == s - 1)) &&
      n.push(i)
  }
  return n
}
class nl extends Dn {
  constructor(e, n, r) {
    super(), (this.pos = e), (this.attr = n), (this.value = r)
  }
  apply(e) {
    let n = e.nodeAt(this.pos)
    if (!n) return Ut.fail("No node at attribute step's position")
    let r = Object.create(null)
    for (let s in n.attrs) r[s] = n.attrs[s]
    r[this.attr] = this.value
    let i = n.type.create(r, null, n.marks)
    return Ut.fromReplace(e, this.pos, this.pos + 1, new ie(H.from(i), 0, n.isLeaf ? 0 : 1))
  }
  getMap() {
    return sr.empty
  }
  invert(e) {
    return new nl(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr])
  }
  map(e) {
    let n = e.mapResult(this.pos, 1)
    return n.deletedAfter ? null : new nl(n.pos, this.attr, this.value)
  }
  toJSON() {
    return { stepType: 'attr', pos: this.pos, attr: this.attr, value: this.value }
  }
  static fromJSON(e, n) {
    if (typeof n.pos != 'number' || typeof n.attr != 'string')
      throw new RangeError('Invalid input for AttrStep.fromJSON')
    return new nl(n.pos, n.attr, n.value)
  }
}
Dn.jsonID('attr', nl)
class Nu extends Dn {
  constructor(e, n) {
    super(), (this.attr = e), (this.value = n)
  }
  apply(e) {
    let n = Object.create(null)
    for (let i in e.attrs) n[i] = e.attrs[i]
    n[this.attr] = this.value
    let r = e.type.create(n, e.content, e.marks)
    return Ut.ok(r)
  }
  getMap() {
    return sr.empty
  }
  invert(e) {
    return new Nu(this.attr, e.attrs[this.attr])
  }
  map(e) {
    return this
  }
  toJSON() {
    return { stepType: 'docAttr', attr: this.attr, value: this.value }
  }
  static fromJSON(e, n) {
    if (typeof n.attr != 'string') throw new RangeError('Invalid input for DocAttrStep.fromJSON')
    return new Nu(n.attr, n.value)
  }
}
Dn.jsonID('docAttr', Nu)
let Cl = class extends Error {}
Cl = function t(e) {
  let n = Error.call(this, e)
  return (n.__proto__ = t.prototype), n
}
Cl.prototype = Object.create(Error.prototype)
Cl.prototype.constructor = Cl
Cl.prototype.name = 'TransformError'
class Cj {
  constructor(e) {
    ;(this.doc = e), (this.steps = []), (this.docs = []), (this.mapping = new el())
  }
  get before() {
    return this.docs.length ? this.docs[0] : this.doc
  }
  step(e) {
    let n = this.maybeStep(e)
    if (n.failed) throw new Cl(n.failed)
    return this
  }
  maybeStep(e) {
    let n = e.apply(this.doc)
    return n.failed || this.addStep(e, n.doc), n
  }
  get docChanged() {
    return this.steps.length > 0
  }
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), (this.doc = n)
  }
  replace(e, n = e, r = ie.empty) {
    let i = bm(this.doc, e, n, r)
    return i && this.step(i), this
  }
  replaceWith(e, n, r) {
    return this.replace(e, n, new ie(H.from(r), 0, 0))
  }
  delete(e, n) {
    return this.replace(e, n, ie.empty)
  }
  insert(e, n) {
    return this.replaceWith(e, e, n)
  }
  replaceRange(e, n, r) {
    return Sj(this, e, n, r), this
  }
  replaceRangeWith(e, n, r) {
    return Ij(this, e, n, r), this
  }
  deleteRange(e, n) {
    return Aj(this, e, n), this
  }
  lift(e, n) {
    return hj(this, e, n), this
  }
  join(e, n = 1) {
    return vj(this, e, n), this
  }
  wrap(e, n) {
    return pj(this, e, n), this
  }
  setBlockType(e, n = e, r, i = null) {
    return mj(this, e, n, r, i), this
  }
  setNodeMarkup(e, n, r = null, i) {
    return yj(this, e, n, r, i), this
  }
  setNodeAttribute(e, n, r) {
    return this.step(new nl(e, n, r)), this
  }
  setDocAttribute(e, n) {
    return this.step(new Nu(e, n)), this
  }
  addNodeMark(e, n) {
    return this.step(new Is(e, n)), this
  }
  removeNodeMark(e, n) {
    if (!(n instanceof at)) {
      let r = this.doc.nodeAt(e)
      if (!r) throw new RangeError('No node at position ' + e)
      if (((n = n.isInSet(r.marks)), !n)) return this
    }
    return this.step(new Al(e, n)), this
  }
  split(e, n = 1, r) {
    return _j(this, e, n, r), this
  }
  addMark(e, n, r) {
    return aj(this, e, n, r), this
  }
  removeMark(e, n, r) {
    return lj(this, e, n, r), this
  }
  clearIncompatible(e, n, r) {
    return cj(this, e, n, r), this
  }
}
const Hg = Object.create(null)
class Fe {
  constructor(e, n, r) {
    ;(this.$anchor = e), (this.$head = n), (this.ranges = r || [new Rj(e.min(n), e.max(n))])
  }
  get anchor() {
    return this.$anchor.pos
  }
  get head() {
    return this.$head.pos
  }
  get from() {
    return this.$from.pos
  }
  get to() {
    return this.$to.pos
  }
  get $from() {
    return this.ranges[0].$from
  }
  get $to() {
    return this.ranges[0].$to
  }
  get empty() {
    let e = this.ranges
    for (let n = 0; n < e.length; n++) if (e[n].$from.pos != e[n].$to.pos) return !1
    return !0
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, !0)
  }
  replace(e, n = ie.empty) {
    let r = n.content.lastChild,
      i = null
    for (let a = 0; a < n.openEnd; a++) (i = r), (r = r.lastChild)
    let s = e.steps.length,
      o = this.ranges
    for (let a = 0; a < o.length; a++) {
      let { $from: l, $to: c } = o[a],
        u = e.mapping.slice(s)
      e.replaceRange(u.map(l.pos), u.map(c.pos), a ? ie.empty : n),
        a == 0 && uS(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1)
    }
  }
  replaceWith(e, n) {
    let r = e.steps.length,
      i = this.ranges
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: a } = i[s],
        l = e.mapping.slice(r),
        c = l.map(o.pos),
        u = l.map(a.pos)
      s ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, n), uS(e, r, n.isInline ? -1 : 1))
    }
  }
  static findFrom(e, n, r = !1) {
    let i = e.parent.inlineContent ? new Me(e) : ka(e.node(0), e.parent, e.pos, e.index(), n, r)
    if (i) return i
    for (let s = e.depth - 1; s >= 0; s--) {
      let o =
        n < 0
          ? ka(e.node(0), e.node(s), e.before(s + 1), e.index(s), n, r)
          : ka(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, n, r)
      if (o) return o
    }
    return null
  }
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new Br(e.node(0))
  }
  static atStart(e) {
    return ka(e, e, 0, 0, 1) || new Br(e)
  }
  static atEnd(e) {
    return ka(e, e, e.content.size, e.childCount, -1) || new Br(e)
  }
  static fromJSON(e, n) {
    if (!n || !n.type) throw new RangeError('Invalid input for Selection.fromJSON')
    let r = Hg[n.type]
    if (!r) throw new RangeError(`No selection type ${n.type} defined`)
    return r.fromJSON(e, n)
  }
  static jsonID(e, n) {
    if (e in Hg) throw new RangeError('Duplicate use of selection JSON ID ' + e)
    return (Hg[e] = n), (n.prototype.jsonID = e), n
  }
  getBookmark() {
    return Me.between(this.$anchor, this.$head).getBookmark()
  }
}
Fe.prototype.visible = !0
class Rj {
  constructor(e, n) {
    ;(this.$from = e), (this.$to = n)
  }
}
let lS = !1
function cS(t) {
  !lS &&
    !t.parent.inlineContent &&
    ((lS = !0),
    console.warn(
      'TextSelection endpoint not pointing into a node with inline content (' +
        t.parent.type.name +
        ')'
    ))
}
class Me extends Fe {
  constructor(e, n = e) {
    cS(e), cS(n), super(e, n)
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head))
    if (!r.parent.inlineContent) return Fe.near(r)
    let i = e.resolve(n.map(this.anchor))
    return new Me(i.parent.inlineContent ? i : r, r)
  }
  replace(e, n = ie.empty) {
    if ((super.replace(e, n), n == ie.empty)) {
      let r = this.$from.marksAcross(this.$to)
      r && e.ensureMarks(r)
    }
  }
  eq(e) {
    return e instanceof Me && e.anchor == this.anchor && e.head == this.head
  }
  getBookmark() {
    return new Em(this.anchor, this.head)
  }
  toJSON() {
    return { type: 'text', anchor: this.anchor, head: this.head }
  }
  static fromJSON(e, n) {
    if (typeof n.anchor != 'number' || typeof n.head != 'number')
      throw new RangeError('Invalid input for TextSelection.fromJSON')
    return new Me(e.resolve(n.anchor), e.resolve(n.head))
  }
  static create(e, n, r = n) {
    let i = e.resolve(n)
    return new this(i, r == n ? i : e.resolve(r))
  }
  static between(e, n, r) {
    let i = e.pos - n.pos
    if (((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent)) {
      let s = Fe.findFrom(n, r, !0) || Fe.findFrom(n, -r, !0)
      if (s) n = s.$head
      else return Fe.near(n, r)
    }
    return (
      e.parent.inlineContent ||
        (i == 0
          ? (e = n)
          : ((e = (Fe.findFrom(e, -r, !0) || Fe.findFrom(e, r, !0)).$anchor),
            e.pos < n.pos != i < 0 && (e = n))),
      new Me(e, n)
    )
  }
}
Fe.jsonID('text', Me)
class Em {
  constructor(e, n) {
    ;(this.anchor = e), (this.head = n)
  }
  map(e) {
    return new Em(e.map(this.anchor), e.map(this.head))
  }
  resolve(e) {
    return Me.between(e.resolve(this.anchor), e.resolve(this.head))
  }
}
class Ee extends Fe {
  constructor(e) {
    let n = e.nodeAfter,
      r = e.node(0).resolve(e.pos + n.nodeSize)
    super(e, r), (this.node = n)
  }
  map(e, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor),
      s = e.resolve(i)
    return r ? Fe.near(s) : new Ee(s)
  }
  content() {
    return new ie(H.from(this.node), 0, 0)
  }
  eq(e) {
    return e instanceof Ee && e.anchor == this.anchor
  }
  toJSON() {
    return { type: 'node', anchor: this.anchor }
  }
  getBookmark() {
    return new $1(this.anchor)
  }
  static fromJSON(e, n) {
    if (typeof n.anchor != 'number')
      throw new RangeError('Invalid input for NodeSelection.fromJSON')
    return new Ee(e.resolve(n.anchor))
  }
  static create(e, n) {
    return new Ee(e.resolve(n))
  }
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1
  }
}
Ee.prototype.visible = !1
Fe.jsonID('node', Ee)
class $1 {
  constructor(e) {
    this.anchor = e
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor)
    return n ? new Em(r, r) : new $1(r)
  }
  resolve(e) {
    let n = e.resolve(this.anchor),
      r = n.nodeAfter
    return r && Ee.isSelectable(r) ? new Ee(n) : Fe.near(n)
  }
}
class Br extends Fe {
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size))
  }
  replace(e, n = ie.empty) {
    if (n == ie.empty) {
      e.delete(0, e.doc.content.size)
      let r = Fe.atStart(e.doc)
      r.eq(e.selection) || e.setSelection(r)
    } else super.replace(e, n)
  }
  toJSON() {
    return { type: 'all' }
  }
  static fromJSON(e) {
    return new Br(e)
  }
  map(e) {
    return new Br(e)
  }
  eq(e) {
    return e instanceof Br
  }
  getBookmark() {
    return kj
  }
}
Fe.jsonID('all', Br)
const kj = {
  map() {
    return this
  },
  resolve(t) {
    return new Br(t)
  }
}
function ka(t, e, n, r, i, s = !1) {
  if (e.inlineContent) return Me.create(t, n)
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let a = e.child(o)
    if (a.isAtom) {
      if (!s && Ee.isSelectable(a)) return Ee.create(t, n - (i < 0 ? a.nodeSize : 0))
    } else {
      let l = ka(t, a, n + i, i < 0 ? a.childCount : 0, i, s)
      if (l) return l
    }
    n += a.nodeSize * i
  }
  return null
}
function uS(t, e, n) {
  let r = t.steps.length - 1
  if (r < e) return
  let i = t.steps[r]
  if (!(i instanceof Zt || i instanceof tn)) return
  let s = t.mapping.maps[r],
    o
  s.forEach((a, l, c, u) => {
    o == null && (o = u)
  }),
    t.setSelection(Fe.near(t.doc.resolve(o), n))
}
const hS = 1,
  ad = 2,
  dS = 4
class Oj extends Cj {
  constructor(e) {
    super(e.doc),
      (this.curSelectionFor = 0),
      (this.updated = 0),
      (this.meta = Object.create(null)),
      (this.time = Date.now()),
      (this.curSelection = e.selection),
      (this.storedMarks = e.storedMarks)
  }
  get selection() {
    return (
      this.curSelectionFor < this.steps.length &&
        ((this.curSelection = this.curSelection.map(
          this.doc,
          this.mapping.slice(this.curSelectionFor)
        )),
        (this.curSelectionFor = this.steps.length)),
      this.curSelection
    )
  }
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError('Selection passed to setSelection must point at the current document')
    return (
      (this.curSelection = e),
      (this.curSelectionFor = this.steps.length),
      (this.updated = (this.updated | hS) & ~ad),
      (this.storedMarks = null),
      this
    )
  }
  get selectionSet() {
    return (this.updated & hS) > 0
  }
  setStoredMarks(e) {
    return (this.storedMarks = e), (this.updated |= ad), this
  }
  ensureMarks(e) {
    return (
      at.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e),
      this
    )
  }
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()))
  }
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()))
  }
  get storedMarksSet() {
    return (this.updated & ad) > 0
  }
  addStep(e, n) {
    super.addStep(e, n), (this.updated = this.updated & ~ad), (this.storedMarks = null)
  }
  setTime(e) {
    return (this.time = e), this
  }
  replaceSelection(e) {
    return this.selection.replace(this, e), this
  }
  replaceSelectionWith(e, n = !0) {
    let r = this.selection
    return (
      n &&
        (e = e.mark(
          this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || at.none)
        )),
      r.replaceWith(this, e),
      this
    )
  }
  deleteSelection() {
    return this.selection.replace(this), this
  }
  insertText(e, n, r) {
    let i = this.doc.type.schema
    if (n == null) return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection()
    {
      if ((r == null && (r = n), (r = r ?? n), !e)) return this.deleteRange(n, r)
      let s = this.storedMarks
      if (!s) {
        let o = this.doc.resolve(n)
        s = r == n ? o.marks() : o.marksAcross(this.doc.resolve(r))
      }
      return (
        this.replaceRangeWith(n, r, i.text(e, s)),
        this.selection.empty || this.setSelection(Fe.near(this.selection.$to)),
        this
      )
    }
  }
  setMeta(e, n) {
    return (this.meta[typeof e == 'string' ? e : e.key] = n), this
  }
  getMeta(e) {
    return this.meta[typeof e == 'string' ? e : e.key]
  }
  get isGeneric() {
    for (let e in this.meta) return !1
    return !0
  }
  scrollIntoView() {
    return (this.updated |= dS), this
  }
  get scrolledIntoView() {
    return (this.updated & dS) > 0
  }
}
function fS(t, e) {
  return !e || !t ? t : t.bind(e)
}
class Tc {
  constructor(e, n, r) {
    ;(this.name = e), (this.init = fS(n.init, r)), (this.apply = fS(n.apply, r))
  }
}
const Nj = [
  new Tc('doc', {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill()
    },
    apply(t) {
      return t.doc
    }
  }),
  new Tc('selection', {
    init(t, e) {
      return t.selection || Fe.atStart(e.doc)
    },
    apply(t) {
      return t.selection
    }
  }),
  new Tc('storedMarks', {
    init(t) {
      return t.storedMarks || null
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null
    }
  }),
  new Tc('scrollToSelection', {
    init() {
      return 0
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e
    }
  })
]
class zg {
  constructor(e, n) {
    ;(this.schema = e),
      (this.plugins = []),
      (this.pluginsByKey = Object.create(null)),
      (this.fields = Nj.slice()),
      n &&
        n.forEach((r) => {
          if (this.pluginsByKey[r.key])
            throw new RangeError('Adding different instances of a keyed plugin (' + r.key + ')')
          this.plugins.push(r),
            (this.pluginsByKey[r.key] = r),
            r.spec.state && this.fields.push(new Tc(r.key, r.spec.state, r))
        })
  }
}
class Da {
  constructor(e) {
    this.config = e
  }
  get schema() {
    return this.config.schema
  }
  get plugins() {
    return this.config.plugins
  }
  apply(e) {
    return this.applyTransaction(e).state
  }
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r]
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this)) return !1
      }
    return !0
  }
  applyTransaction(e) {
    if (!this.filterTransaction(e)) return { state: this, transactions: [] }
    let n = [e],
      r = this.applyInner(e),
      i = null
    for (;;) {
      let s = !1
      for (let o = 0; o < this.config.plugins.length; o++) {
        let a = this.config.plugins[o]
        if (a.spec.appendTransaction) {
          let l = i ? i[o].n : 0,
            c = i ? i[o].state : this,
            u = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, r)
          if (u && r.filterTransaction(u, o)) {
            if ((u.setMeta('appendedTransaction', e), !i)) {
              i = []
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < o ? { state: r, n: n.length } : { state: this, n: 0 })
            }
            n.push(u), (r = r.applyInner(u)), (s = !0)
          }
          i && (i[o] = { state: r, n: n.length })
        }
      }
      if (!s) return { state: r, transactions: n }
    }
  }
  applyInner(e) {
    if (!e.before.eq(this.doc)) throw new RangeError('Applying a mismatched transaction')
    let n = new Da(this.config),
      r = this.config.fields
    for (let i = 0; i < r.length; i++) {
      let s = r[i]
      n[s.name] = s.apply(e, this[s.name], this, n)
    }
    return n
  }
  get tr() {
    return new Oj(this)
  }
  static create(e) {
    let n = new zg(e.doc ? e.doc.type.schema : e.schema, e.plugins),
      r = new Da(n)
    for (let i = 0; i < n.fields.length; i++) r[n.fields[i].name] = n.fields[i].init(e, r)
    return r
  }
  reconfigure(e) {
    let n = new zg(this.schema, e.plugins),
      r = n.fields,
      i = new Da(n)
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i)
    }
    return i
  }
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }
    if (
      (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
      e && typeof e == 'object')
    )
      for (let r in e) {
        if (r == 'doc' || r == 'selection')
          throw new RangeError('The JSON fields `doc` and `selection` are reserved')
        let i = e[r],
          s = i.spec.state
        s && s.toJSON && (n[r] = s.toJSON.call(i, this[i.key]))
      }
    return n
  }
  static fromJSON(e, n, r) {
    if (!n) throw new RangeError('Invalid input for EditorState.fromJSON')
    if (!e.schema) throw new RangeError("Required config field 'schema' missing")
    let i = new zg(e.schema, e.plugins),
      s = new Da(i)
    return (
      i.fields.forEach((o) => {
        if (o.name == 'doc') s.doc = $o.fromJSON(e.schema, n.doc)
        else if (o.name == 'selection') s.selection = Fe.fromJSON(s.doc, n.selection)
        else if (o.name == 'storedMarks')
          n.storedMarks && (s.storedMarks = n.storedMarks.map(e.schema.markFromJSON))
        else {
          if (r)
            for (let a in r) {
              let l = r[a],
                c = l.spec.state
              if (
                l.key == o.name &&
                c &&
                c.fromJSON &&
                Object.prototype.hasOwnProperty.call(n, a)
              ) {
                s[o.name] = c.fromJSON.call(l, e, n[a], s)
                return
              }
            }
          s[o.name] = o.init(e, s)
        }
      }),
      s
    )
  }
}
function MN(t, e, n) {
  for (let r in t) {
    let i = t[r]
    i instanceof Function ? (i = i.bind(e)) : r == 'handleDOMEvents' && (i = MN(i, e, {})),
      (n[r] = i)
  }
  return n
}
class Cr {
  constructor(e) {
    ;(this.spec = e),
      (this.props = {}),
      e.props && MN(e.props, this, this.props),
      (this.key = e.key ? e.key.key : PN('plugin'))
  }
  getState(e) {
    return e[this.key]
  }
}
const jg = Object.create(null)
function PN(t) {
  return t in jg ? t + '$' + ++jg[t] : ((jg[t] = 0), t + '$')
}
class to {
  constructor(e = 'key') {
    this.key = PN(e)
  }
  get(e) {
    return e.config.pluginsByKey[this.key]
  }
  getState(e) {
    return e[this.key]
  }
}
const mn = function (t) {
    for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e
  },
  Mu = function (t) {
    let e = t.assignedSlot || t.parentNode
    return e && e.nodeType == 11 ? e.host : e
  }
let z_ = null
const Ni = function (t, e, n) {
    let r = z_ || (z_ = document.createRange())
    return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r
  },
  Mj = function () {
    z_ = null
  },
  na = function (t, e, n, r) {
    return n && (pS(t, e, n, r, -1) || pS(t, e, n, r, 1))
  },
  Pj = /^(img|br|input|textarea|hr)$/i
function pS(t, e, n, r, i) {
  for (;;) {
    if (t == n && e == r) return !0
    if (e == (i < 0 ? 0 : Zr(t))) {
      let s = t.parentNode
      if (!s || s.nodeType != 1 || Ih(t) || Pj.test(t.nodeName) || t.contentEditable == 'false')
        return !1
      ;(e = mn(t) + (i < 0 ? 0 : 1)), (t = s)
    } else if (t.nodeType == 1) {
      if (((t = t.childNodes[e + (i < 0 ? -1 : 0)]), t.contentEditable == 'false')) return !1
      e = i < 0 ? Zr(t) : 0
    } else return !1
  }
}
function Zr(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function xj(t, e) {
  for (;;) {
    if (t.nodeType == 3 && e) return t
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == 'false') return null
      ;(t = t.childNodes[e - 1]), (e = Zr(t))
    } else if (t.parentNode && !Ih(t)) (e = mn(t)), (t = t.parentNode)
    else return null
  }
}
function Dj(t, e) {
  for (;;) {
    if (t.nodeType == 3 && e < t.nodeValue.length) return t
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == 'false') return null
      ;(t = t.childNodes[e]), (e = 0)
    } else if (t.parentNode && !Ih(t)) (e = mn(t) + 1), (t = t.parentNode)
    else return null
  }
}
function Lj(t, e, n) {
  for (let r = e == 0, i = e == Zr(t); r || i; ) {
    if (t == n) return !0
    let s = mn(t)
    if (((t = t.parentNode), !t)) return !1
    ;(r = r && s == 0), (i = i && s == Zr(t))
  }
}
function Ih(t) {
  let e
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode);
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t)
}
const Tm = function (t) {
  return t.focusNode && na(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
}
function yo(t, e) {
  let n = document.createEvent('Event')
  return n.initEvent('keydown', !0, !0), (n.keyCode = t), (n.key = n.code = e), n
}
function Vj(t) {
  let e = t.activeElement
  for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement
  return e
}
function Fj(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let r = t.caretPositionFromPoint(e, n)
      if (r) return { node: r.offsetNode, offset: r.offset }
    } catch {}
  if (t.caretRangeFromPoint) {
    let r = t.caretRangeFromPoint(e, n)
    if (r) return { node: r.startContainer, offset: r.startOffset }
  }
}
const Ti = typeof navigator < 'u' ? navigator : null,
  mS = typeof document < 'u' ? document : null,
  no = (Ti && Ti.userAgent) || '',
  j_ = /Edge\/(\d+)/.exec(no),
  xN = /MSIE \d/.exec(no),
  W_ = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(no),
  Jn = !!(xN || W_ || j_),
  Ps = xN ? document.documentMode : W_ ? +W_[1] : j_ ? +j_[1] : 0,
  jr = !Jn && /gecko\/(\d+)/i.test(no)
jr && +(/Firefox\/(\d+)/.exec(no) || [0, 0])[1]
const G_ = !Jn && /Chrome\/(\d+)/.exec(no),
  Bn = !!G_,
  Bj = G_ ? +G_[1] : 0,
  $n = !Jn && !!Ti && /Apple Computer/.test(Ti.vendor),
  Rl = $n && (/Mobile\/\w+/.test(no) || (!!Ti && Ti.maxTouchPoints > 2)),
  yr = Rl || (Ti ? /Mac/.test(Ti.platform) : !1),
  Uj = Ti ? /Win/.test(Ti.platform) : !1,
  Mr = /Android \d/.test(no),
  Ah = !!mS && 'webkitFontSmoothing' in mS.documentElement.style,
  $j = Ah ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0
function Hj(t) {
  let e = t.defaultView && t.defaultView.visualViewport
  return e
    ? { left: 0, right: e.width, top: 0, bottom: e.height }
    : {
        left: 0,
        right: t.documentElement.clientWidth,
        top: 0,
        bottom: t.documentElement.clientHeight
      }
}
function Ri(t, e) {
  return typeof t == 'number' ? t : t[e]
}
function zj(t) {
  let e = t.getBoundingClientRect(),
    n = e.width / t.offsetWidth || 1,
    r = e.height / t.offsetHeight || 1
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  }
}
function gS(t, e, n) {
  let r = t.someProp('scrollThreshold') || 0,
    i = t.someProp('scrollMargin') || 5,
    s = t.dom.ownerDocument
  for (let o = n || t.dom; o; o = Mu(o)) {
    if (o.nodeType != 1) continue
    let a = o,
      l = a == s.body,
      c = l ? Hj(s) : zj(a),
      u = 0,
      h = 0
    if (
      (e.top < c.top + Ri(r, 'top')
        ? (h = -(c.top - e.top + Ri(i, 'top')))
        : e.bottom > c.bottom - Ri(r, 'bottom') &&
          (h =
            e.bottom - e.top > c.bottom - c.top
              ? e.top + Ri(i, 'top') - c.top
              : e.bottom - c.bottom + Ri(i, 'bottom')),
      e.left < c.left + Ri(r, 'left')
        ? (u = -(c.left - e.left + Ri(i, 'left')))
        : e.right > c.right - Ri(r, 'right') && (u = e.right - c.right + Ri(i, 'right')),
      u || h)
    )
      if (l) s.defaultView.scrollBy(u, h)
      else {
        let d = a.scrollLeft,
          f = a.scrollTop
        h && (a.scrollTop += h), u && (a.scrollLeft += u)
        let p = a.scrollLeft - d,
          m = a.scrollTop - f
        e = { left: e.left - p, top: e.top - m, right: e.right - p, bottom: e.bottom - m }
      }
    if (l || /^(fixed|sticky)$/.test(getComputedStyle(o).position)) break
  }
}
function jj(t) {
  let e = t.dom.getBoundingClientRect(),
    n = Math.max(0, e.top),
    r,
    i
  for (let s = (e.left + e.right) / 2, o = n + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let a = t.root.elementFromPoint(s, o)
    if (!a || a == t.dom || !t.dom.contains(a)) continue
    let l = a.getBoundingClientRect()
    if (l.top >= n - 20) {
      ;(r = a), (i = l.top)
      break
    }
  }
  return { refDOM: r, refTop: i, stack: DN(t.dom) }
}
function DN(t) {
  let e = [],
    n = t.ownerDocument
  for (
    let r = t;
    r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n);
    r = Mu(r)
  );
  return e
}
function Wj({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0
  LN(n, r == 0 ? 0 : r - e)
}
function LN(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: i, left: s } = t[n]
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s)
  }
}
let Ta = null
function Gj(t) {
  if (t.setActive) return t.setActive()
  if (Ta) return t.focus(Ta)
  let e = DN(t)
  t.focus(
    Ta == null
      ? {
          get preventScroll() {
            return (Ta = { preventScroll: !0 }), !0
          }
        }
      : void 0
  ),
    Ta || ((Ta = !1), LN(e, 0))
}
function VN(t, e) {
  let n,
    r = 2e8,
    i,
    s = 0,
    o = e.top,
    a = e.top,
    l,
    c
  for (let u = t.firstChild, h = 0; u; u = u.nextSibling, h++) {
    let d
    if (u.nodeType == 1) d = u.getClientRects()
    else if (u.nodeType == 3) d = Ni(u).getClientRects()
    else continue
    for (let f = 0; f < d.length; f++) {
      let p = d[f]
      if (p.top <= o && p.bottom >= a) {
        ;(o = Math.max(p.bottom, o)), (a = Math.min(p.top, a))
        let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0
        if (m < r) {
          ;(n = u),
            (r = m),
            (i =
              m && n.nodeType == 3 ? { left: p.right < e.left ? p.right : p.left, top: e.top } : e),
            u.nodeType == 1 && m && (s = h + (e.left >= (p.left + p.right) / 2 ? 1 : 0))
          continue
        }
      } else
        p.top > e.top &&
          !l &&
          p.left <= e.left &&
          p.right >= e.left &&
          ((l = u), (c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top }))
      !n &&
        ((e.left >= p.right && e.top >= p.top) || (e.left >= p.left && e.top >= p.bottom)) &&
        (s = h + 1)
    }
  }
  return (
    !n && l && ((n = l), (i = c), (r = 0)),
    n && n.nodeType == 3
      ? qj(n, i)
      : !n || (r && n.nodeType == 1)
      ? { node: t, offset: s }
      : VN(n, i)
  )
}
function qj(t, e) {
  let n = t.nodeValue.length,
    r = document.createRange()
  for (let i = 0; i < n; i++) {
    r.setEnd(t, i + 1), r.setStart(t, i)
    let s = ls(r, 1)
    if (s.top != s.bottom && H1(e, s))
      return { node: t, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) }
  }
  return { node: t, offset: 0 }
}
function H1(t, e) {
  return (
    t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1
  )
}
function Kj(t, e) {
  let n = t.parentNode
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t
}
function Yj(t, e, n) {
  let { node: r, offset: i } = VN(e, n),
    s = -1
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect()
    s = o.left != o.right && n.left > (o.left + o.right) / 2 ? 1 : -1
  }
  return t.docView.posFromDOM(r, i, s)
}
function Jj(t, e, n, r) {
  let i = -1
  for (let s = e, o = !1; s != t.dom; ) {
    let a = t.docView.nearestDesc(s, !0)
    if (!a) return null
    if (a.dom.nodeType == 1 && ((a.node.isBlock && a.parent && !o) || !a.contentDOM)) {
      let l = a.dom.getBoundingClientRect()
      if (
        (a.node.isBlock &&
          a.parent &&
          !o &&
          ((o = !0),
          l.left > r.left || l.top > r.top
            ? (i = a.posBefore)
            : (l.right < r.left || l.bottom < r.top) && (i = a.posAfter)),
        !a.contentDOM && i < 0 && !a.node.isText)
      )
        return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2)
          ? a.posBefore
          : a.posAfter
    }
    s = a.dom.parentNode
  }
  return i > -1 ? i : t.docView.posFromDOM(e, n, -1)
}
function FN(t, e, n) {
  let r = t.childNodes.length
  if (r && n.top < n.bottom)
    for (
      let i = Math.max(
          0,
          Math.min(r - 1, Math.floor((r * (e.top - n.top)) / (n.bottom - n.top)) - 2)
        ),
        s = i;
      ;

    ) {
      let o = t.childNodes[s]
      if (o.nodeType == 1) {
        let a = o.getClientRects()
        for (let l = 0; l < a.length; l++) {
          let c = a[l]
          if (H1(e, c)) return FN(o, e, c)
        }
      }
      if ((s = (s + 1) % r) == i) break
    }
  return t
}
function Qj(t, e) {
  let n = t.dom.ownerDocument,
    r,
    i = 0,
    s = Fj(n, e.left, e.top)
  s && ({ node: r, offset: i } = s)
  let o = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top),
    a
  if (!o || !t.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = t.dom.getBoundingClientRect()
    if (!H1(e, c) || ((o = FN(t.dom, e, c)), !o)) return null
  }
  if ($n) for (let c = o; r && c; c = Mu(c)) c.draggable && (r = void 0)
  if (((o = Kj(o, e)), r)) {
    if (
      jr &&
      r.nodeType == 1 &&
      ((i = Math.min(i, r.childNodes.length)), i < r.childNodes.length)
    ) {
      let u = r.childNodes[i],
        h
      u.nodeName == 'IMG' &&
        (h = u.getBoundingClientRect()).right <= e.left &&
        h.bottom > e.top &&
        i++
    }
    let c
    Ah &&
      i &&
      r.nodeType == 1 &&
      (c = r.childNodes[i - 1]).nodeType == 1 &&
      c.contentEditable == 'false' &&
      c.getBoundingClientRect().top >= e.top &&
      i--,
      r == t.dom &&
      i == r.childNodes.length - 1 &&
      r.lastChild.nodeType == 1 &&
      e.top > r.lastChild.getBoundingClientRect().bottom
        ? (a = t.state.doc.content.size)
        : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != 'BR') &&
          (a = Jj(t, r, i, e))
  }
  a == null && (a = Yj(t, o, e))
  let l = t.docView.nearestDesc(o, !0)
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 }
}
function yS(t) {
  return t.top < t.bottom || t.left < t.right
}
function ls(t, e) {
  let n = t.getClientRects()
  if (n.length) {
    let r = n[e < 0 ? 0 : n.length - 1]
    if (yS(r)) return r
  }
  return Array.prototype.find.call(n, yS) || t.getBoundingClientRect()
}
const Xj = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
function BN(t, e, n) {
  let { node: r, offset: i, atom: s } = t.docView.domFromPos(e, n < 0 ? -1 : 1),
    o = Ah || jr
  if (r.nodeType == 3)
    if (o && (Xj.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let l = ls(Ni(r, i, i), n)
      if (jr && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let c = ls(Ni(r, i - 1, i - 1), -1)
        if (c.top == l.top) {
          let u = ls(Ni(r, i, i + 1), -1)
          if (u.top != l.top) return ac(u, u.left < c.left)
        }
      }
      return l
    } else {
      let l = i,
        c = i,
        u = n < 0 ? 1 : -1
      return (
        n < 0 && !i
          ? (c++, (u = -1))
          : n >= 0 && i == r.nodeValue.length
          ? (l--, (u = 1))
          : n < 0
          ? l--
          : c++,
        ac(ls(Ni(r, l, c), u), u < 0)
      )
    }
  if (!t.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (n < 0 || i == Zr(r))) {
      let l = r.childNodes[i - 1]
      if (l.nodeType == 1) return Wg(l.getBoundingClientRect(), !1)
    }
    if (s == null && i < Zr(r)) {
      let l = r.childNodes[i]
      if (l.nodeType == 1) return Wg(l.getBoundingClientRect(), !0)
    }
    return Wg(r.getBoundingClientRect(), n >= 0)
  }
  if (s == null && i && (n < 0 || i == Zr(r))) {
    let l = r.childNodes[i - 1],
      c =
        l.nodeType == 3
          ? Ni(l, Zr(l) - (o ? 0 : 1))
          : l.nodeType == 1 && (l.nodeName != 'BR' || !l.nextSibling)
          ? l
          : null
    if (c) return ac(ls(c, 1), !1)
  }
  if (s == null && i < Zr(r)) {
    let l = r.childNodes[i]
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; ) l = l.nextSibling
    let c = l ? (l.nodeType == 3 ? Ni(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null) : null
    if (c) return ac(ls(c, -1), !0)
  }
  return ac(ls(r.nodeType == 3 ? Ni(r) : r, -n), n >= 0)
}
function ac(t, e) {
  if (t.width == 0) return t
  let n = e ? t.left : t.right
  return { top: t.top, bottom: t.bottom, left: n, right: n }
}
function Wg(t, e) {
  if (t.height == 0) return t
  let n = e ? t.top : t.bottom
  return { top: n, bottom: n, left: t.left, right: t.right }
}
function UN(t, e, n) {
  let r = t.state,
    i = t.root.activeElement
  r != e && t.updateState(e), i != t.dom && t.focus()
  try {
    return n()
  } finally {
    r != e && t.updateState(r), i != t.dom && i && i.focus()
  }
}
function Zj(t, e, n) {
  let r = e.selection,
    i = n == 'up' ? r.$from : r.$to
  return UN(t, e, () => {
    let { node: s } = t.docView.domFromPos(i.pos, n == 'up' ? -1 : 1)
    for (;;) {
      let a = t.docView.nearestDesc(s, !0)
      if (!a) break
      if (a.node.isBlock) {
        s = a.contentDOM || a.dom
        break
      }
      s = a.dom.parentNode
    }
    let o = BN(t, i.pos, 1)
    for (let a = s.firstChild; a; a = a.nextSibling) {
      let l
      if (a.nodeType == 1) l = a.getClientRects()
      else if (a.nodeType == 3) l = Ni(a, 0, a.nodeValue.length).getClientRects()
      else continue
      for (let c = 0; c < l.length; c++) {
        let u = l[c]
        if (
          u.bottom > u.top + 1 &&
          (n == 'up'
            ? o.top - u.top > (u.bottom - o.top) * 2
            : u.bottom - o.bottom > (o.bottom - u.top) * 2)
        )
          return !1
      }
    }
    return !0
  })
}
const eW = /[\u0590-\u08ac]/
function tW(t, e, n) {
  let { $head: r } = e.selection
  if (!r.parent.isTextblock) return !1
  let i = r.parentOffset,
    s = !i,
    o = i == r.parent.content.size,
    a = t.domSelection()
  return !eW.test(r.parent.textContent) || !a.modify
    ? n == 'left' || n == 'backward'
      ? s
      : o
    : UN(t, e, () => {
        let {
            focusNode: l,
            focusOffset: c,
            anchorNode: u,
            anchorOffset: h
          } = t.domSelectionRange(),
          d = a.caretBidiLevel
        a.modify('move', n, 'character')
        let f = r.depth ? t.docView.domAfterPos(r.before()) : t.dom,
          { focusNode: p, focusOffset: m } = t.domSelectionRange(),
          g = (p && !f.contains(p.nodeType == 1 ? p : p.parentNode)) || (l == p && c == m)
        try {
          a.collapse(u, h), l && (l != u || c != h) && a.extend && a.extend(l, c)
        } catch {}
        return d != null && (a.caretBidiLevel = d), g
      })
}
let _S = null,
  vS = null,
  bS = !1
function nW(t, e, n) {
  return _S == e && vS == n
    ? bS
    : ((_S = e), (vS = n), (bS = n == 'up' || n == 'down' ? Zj(t, e, n) : tW(t, e, n)))
}
const Ir = 0,
  ES = 1,
  Ao = 2,
  wi = 3
class Ch {
  constructor(e, n, r, i) {
    ;(this.parent = e),
      (this.children = n),
      (this.dom = r),
      (this.contentDOM = i),
      (this.dirty = Ir),
      (r.pmViewDesc = this)
  }
  matchesWidget(e) {
    return !1
  }
  matchesMark(e) {
    return !1
  }
  matchesNode(e, n, r) {
    return !1
  }
  matchesHack(e) {
    return !1
  }
  parseRule() {
    return null
  }
  stopEvent(e) {
    return !1
  }
  get size() {
    let e = 0
    for (let n = 0; n < this.children.length; n++) e += this.children[n].size
    return e
  }
  get border() {
    return 0
  }
  destroy() {
    ;(this.parent = void 0), this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0)
    for (let e = 0; e < this.children.length; e++) this.children[e].destroy()
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n]
      if (i == e) return r
      r += i.size
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this)
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
  }
  get posAfter() {
    return this.posBefore + this.size
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border
  }
  localPosFromDOM(e, n, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let s, o
        if (e == this.contentDOM) s = e.childNodes[n - 1]
        else {
          for (; e.parentNode != this.contentDOM; ) e = e.parentNode
          s = e.previousSibling
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); ) s = s.previousSibling
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart
      } else {
        let s, o
        if (e == this.contentDOM) s = e.childNodes[n]
        else {
          for (; e.parentNode != this.contentDOM; ) e = e.parentNode
          s = e.nextSibling
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); ) s = s.nextSibling
        return s ? this.posBeforeChild(o) : this.posAtEnd
      }
    let i
    if (e == this.dom && this.contentDOM) i = n > mn(this.contentDOM)
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1
            break
          }
          if (s.previousSibling) break
        }
      if (i == null && n == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0
            break
          }
          if (s.nextSibling) break
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i),
        o
      if (s && (!n || s.node))
        if (
          r &&
          (o = s.nodeDOM) &&
          !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e)
        )
          r = !1
        else return s
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc
    for (let r = n; r; r = r.parent) if (r == this) return n
  }
  posFromDOM(e, n, r) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i)
      if (s) return s.localPosFromDOM(e, n, r)
    }
    return -1
  }
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n],
        s = r + i.size
      if (r == e && s != r) {
        for (; !i.border && i.children.length; ) i = i.children[0]
        return i
      }
      if (e < s) return i.descAt(e - r - i.border)
      r = s
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 }
    let r = 0,
      i = 0
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r],
        a = s + o.size
      if (a > e || o instanceof HN) {
        i = e - s
        break
      }
      s = a
    }
    if (i) return this.children[r].domFromPos(i - this.children[r].border, n)
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof $N && s.side >= 0; r--);
    if (n <= 0) {
      let s,
        o = !0
      for (
        ;
        (s = r ? this.children[r - 1] : null), !(!s || s.dom.parentNode == this.contentDOM);
        r--, o = !1
      );
      return s && n && o && !s.border && !s.domAtom
        ? s.domFromPos(s.size, n)
        : { node: this.contentDOM, offset: s ? mn(s.dom) + 1 : 0 }
    } else {
      let s,
        o = !0
      for (
        ;
        (s = r < this.children.length ? this.children[r] : null),
          !(!s || s.dom.parentNode == this.contentDOM);
        r++, o = !1
      );
      return s && o && !s.border && !s.domAtom
        ? s.domFromPos(0, n)
        : { node: this.contentDOM, offset: s ? mn(s.dom) : this.contentDOM.childNodes.length }
    }
  }
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return {
        node: this.contentDOM,
        from: e,
        to: n,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length
      }
    let i = -1,
      s = -1
    for (let o = r, a = 0; ; a++) {
      let l = this.children[a],
        c = o + l.size
      if (i == -1 && e <= c) {
        let u = o + l.border
        if (
          e >= u &&
          n <= c - l.border &&
          l.node &&
          l.contentDOM &&
          this.contentDOM.contains(l.contentDOM)
        )
          return l.parseRange(e, n, u)
        e = o
        for (let h = a; h > 0; h--) {
          let d = this.children[h - 1]
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(1)) {
            i = mn(d.dom) + 1
            break
          }
          e -= d.size
        }
        i == -1 && (i = 0)
      }
      if (i > -1 && (c > n || a == this.children.length - 1)) {
        n = c
        for (let u = a + 1; u < this.children.length; u++) {
          let h = this.children[u]
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            s = mn(h.dom)
            break
          }
          n += h.size
        }
        s == -1 && (s = this.contentDOM.childNodes.length)
        break
      }
      o = c
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: i, toOffset: s }
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length) return !1
    let n = this.children[e < 0 ? 0 : this.children.length - 1]
    return n.size == 0 || n.emptyChildAt(e)
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0)
    if (n.nodeType != 1 || r == n.childNodes.length) throw new RangeError('No node after pos ' + e)
    return n.childNodes[r]
  }
  setSelection(e, n, r, i = !1) {
    let s = Math.min(e, n),
      o = Math.max(e, n)
    for (let d = 0, f = 0; d < this.children.length; d++) {
      let p = this.children[d],
        m = f + p.size
      if (s > f && o < m) return p.setSelection(e - f - p.border, n - f - p.border, r, i)
      f = m
    }
    let a = this.domFromPos(e, e ? -1 : 1),
      l = n == e ? a : this.domFromPos(n, n ? -1 : 1),
      c = r.getSelection(),
      u = !1
    if ((jr || $n) && e == n) {
      let { node: d, offset: f } = a
      if (d.nodeType == 3) {
        if (
          ((u = !!(
            f &&
            d.nodeValue[f - 1] ==
              `
`
          )),
          u && f == d.nodeValue.length)
        )
          for (let p = d, m; p; p = p.parentNode) {
            if ((m = p.nextSibling)) {
              m.nodeName == 'BR' && (a = l = { node: m.parentNode, offset: mn(m) + 1 })
              break
            }
            let g = p.pmViewDesc
            if (g && g.node && g.node.isBlock) break
          }
      } else {
        let p = d.childNodes[f - 1]
        u = p && (p.nodeName == 'BR' || p.contentEditable == 'false')
      }
    }
    if (jr && c.focusNode && c.focusNode != l.node && c.focusNode.nodeType == 1) {
      let d = c.focusNode.childNodes[c.focusOffset]
      d && d.contentEditable == 'false' && (i = !0)
    }
    if (
      !(i || (u && $n)) &&
      na(a.node, a.offset, c.anchorNode, c.anchorOffset) &&
      na(l.node, l.offset, c.focusNode, c.focusOffset)
    )
      return
    let h = !1
    if ((c.extend || e == n) && !u) {
      c.collapse(a.node, a.offset)
      try {
        e != n && c.extend(l.node, l.offset), (h = !0)
      } catch {}
    }
    if (!h) {
      if (e > n) {
        let f = a
        ;(a = l), (l = f)
      }
      let d = document.createRange()
      d.setEnd(l.node, l.offset), d.setStart(a.node, a.offset), c.removeAllRanges(), c.addRange(d)
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != 'selection'
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
  }
  markDirty(e, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i],
        o = r + s.size
      if (r == o ? e <= o && n >= r : e < o && n > r) {
        let a = r + s.border,
          l = o - s.border
        if (e >= a && n <= l) {
          ;(this.dirty = e == r || n == o ? Ao : ES),
            e == a && n == l && (s.contentLost || s.dom.parentNode != this.contentDOM)
              ? (s.dirty = wi)
              : s.markDirty(e - a, n - a)
          return
        } else
          s.dirty =
            s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length
              ? Ao
              : wi
      }
      r = o
    }
    this.dirty = Ao
  }
  markParentsDirty() {
    let e = 1
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? Ao : ES
      n.dirty < r && (n.dirty = r)
    }
  }
  get domAtom() {
    return !1
  }
  get ignoreForCoords() {
    return !1
  }
  isText(e) {
    return !1
  }
}
class $N extends Ch {
  constructor(e, n, r, i) {
    let s,
      o = n.type.toDOM
    if (
      (typeof o == 'function' &&
        (o = o(r, () => {
          if (!s) return i
          if (s.parent) return s.parent.posBeforeChild(s)
        })),
      !n.type.spec.raw)
    ) {
      if (o.nodeType != 1) {
        let a = document.createElement('span')
        a.appendChild(o), (o = a)
      }
      ;(o.contentEditable = 'false'), o.classList.add('ProseMirror-widget')
    }
    super(e, [], o, null), (this.widget = n), (this.widget = n), (s = this)
  }
  matchesWidget(e) {
    return this.dirty == Ir && e.type.eq(this.widget.type)
  }
  parseRule() {
    return { ignore: !0 }
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent
    return n ? n(e) : !1
  }
  ignoreMutation(e) {
    return e.type != 'selection' || this.widget.spec.ignoreSelection
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy()
  }
  get domAtom() {
    return !0
  }
  get side() {
    return this.widget.type.side
  }
}
class rW extends Ch {
  constructor(e, n, r, i) {
    super(e, [], n, null), (this.textDOM = r), (this.text = i)
  }
  get size() {
    return this.text.length
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e }
  }
  ignoreMutation(e) {
    return e.type === 'characterData' && e.target.nodeValue == e.oldValue
  }
}
class ra extends Ch {
  constructor(e, n, r, i) {
    super(e, [], r, i), (this.mark = n)
  }
  static create(e, n, r, i) {
    let s = i.nodeViews[n.type.name],
      o = s && s(n, i, r)
    return (
      (!o || !o.dom) && (o = si.renderSpec(document, n.type.spec.toDOM(n, r))),
      new ra(e, n, o.dom, o.contentDOM || o.dom)
    )
  }
  parseRule() {
    return this.dirty & wi || this.mark.type.spec.reparseInView
      ? null
      : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM }
  }
  matchesMark(e) {
    return this.dirty != wi && this.mark.eq(e)
  }
  markDirty(e, n) {
    if ((super.markDirty(e, n), this.dirty != Ir)) {
      let r = this.parent
      for (; !r.node; ) r = r.parent
      r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = Ir)
    }
  }
  slice(e, n, r) {
    let i = ra.create(this.parent, this.mark, !0, r),
      s = this.children,
      o = this.size
    n < o && (s = Y_(s, n, o, r)), e > 0 && (s = Y_(s, 0, e, r))
    for (let a = 0; a < s.length; a++) s[a].parent = i
    return (i.children = s), i
  }
}
class xs extends Ch {
  constructor(e, n, r, i, s, o, a, l, c) {
    super(e, [], s, o),
      (this.node = n),
      (this.outerDeco = r),
      (this.innerDeco = i),
      (this.nodeDOM = a)
  }
  static create(e, n, r, i, s, o) {
    let a = s.nodeViews[n.type.name],
      l,
      c =
        a &&
        a(
          n,
          s,
          () => {
            if (!l) return o
            if (l.parent) return l.parent.posBeforeChild(l)
          },
          r,
          i
        ),
      u = c && c.dom,
      h = c && c.contentDOM
    if (n.isText) {
      if (!u) u = document.createTextNode(n.text)
      else if (u.nodeType != 3) throw new RangeError('Text must be rendered as a DOM text node')
    } else u || ({ dom: u, contentDOM: h } = si.renderSpec(document, n.type.spec.toDOM(n)))
    !h &&
      !n.isText &&
      u.nodeName != 'BR' &&
      (u.hasAttribute('contenteditable') || (u.contentEditable = 'false'),
      n.type.spec.draggable && (u.draggable = !0))
    let d = u
    return (
      (u = WN(u, r, n)),
      c
        ? (l = new iW(e, n, r, i, u, h || null, d, c, s, o + 1))
        : n.isText
        ? new wm(e, n, r, i, u, d, s)
        : new xs(e, n, r, i, u, h || null, d, s, o + 1)
    )
  }
  parseRule() {
    if (this.node.type.spec.reparseInView) return null
    let e = { node: this.node.type.name, attrs: this.node.attrs }
    if ((this.node.type.whitespace == 'pre' && (e.preserveWhitespace = 'full'), !this.contentDOM))
      e.getContent = () => this.node.content
    else if (!this.contentLost) e.contentElement = this.contentDOM
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n]
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode
          break
        }
      }
      e.contentElement || (e.getContent = () => H.empty)
    }
    return e
  }
  matchesNode(e, n, r) {
    return this.dirty == Ir && e.eq(this.node) && K_(n, this.outerDeco) && r.eq(this.innerDeco)
  }
  get size() {
    return this.node.nodeSize
  }
  get border() {
    return this.node.isLeaf ? 0 : 1
  }
  updateChildren(e, n) {
    let r = this.node.inlineContent,
      i = n,
      s = e.composing ? this.localCompositionInfo(e, n) : null,
      o = s && s.pos > -1 ? s : null,
      a = s && s.pos < 0,
      l = new oW(this, o && o.node, e)
    cW(
      this.node,
      this.innerDeco,
      (c, u, h) => {
        c.spec.marks
          ? l.syncToMarks(c.spec.marks, r, e)
          : c.type.side >= 0 &&
            !h &&
            l.syncToMarks(u == this.node.childCount ? at.none : this.node.child(u).marks, r, e),
          l.placeWidget(c, e, i)
      },
      (c, u, h, d) => {
        l.syncToMarks(c.marks, r, e)
        let f
        l.findNodeMatch(c, u, h, d) ||
          (a &&
            e.state.selection.from > i &&
            e.state.selection.to < i + c.nodeSize &&
            (f = l.findIndexWithChild(s.node)) > -1 &&
            l.updateNodeAt(c, u, h, f, e)) ||
          l.updateNextNode(c, u, h, e, d, i) ||
          l.addNode(c, u, h, e, i),
          (i += c.nodeSize)
      }
    ),
      l.syncToMarks([], r, e),
      this.node.isTextblock && l.addTextblockHacks(),
      l.destroyRest(),
      (l.changed || this.dirty == Ao) &&
        (o && this.protectLocalComposition(e, o),
        zN(this.contentDOM, this.children, e),
        Rl && uW(this.dom))
  }
  localCompositionInfo(e, n) {
    let { from: r, to: i } = e.state.selection
    if (!(e.state.selection instanceof Me) || r < n || i > n + this.node.content.size) return null
    let s = e.input.compositionNode
    if (!s || !this.dom.contains(s.parentNode)) return null
    if (this.node.inlineContent) {
      let o = s.nodeValue,
        a = hW(this.node.content, o, r - n, i - n)
      return a < 0 ? null : { node: s, pos: a, text: o }
    } else return { node: s, pos: -1, text: '' }
  }
  protectLocalComposition(e, { node: n, pos: r, text: i }) {
    if (this.getDesc(n)) return
    let s = n
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; ) s.parentNode.removeChild(s.previousSibling)
      for (; s.nextSibling; ) s.parentNode.removeChild(s.nextSibling)
      s.pmViewDesc && (s.pmViewDesc = void 0)
    }
    let o = new rW(this, s, n, i)
    e.input.compositionNodes.push(o), (this.children = Y_(this.children, r, r + i.length, e, o))
  }
  update(e, n, r, i) {
    return this.dirty == wi || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, i), !0)
  }
  updateInner(e, n, r, i) {
    this.updateOuterDeco(n),
      (this.node = e),
      (this.innerDeco = r),
      this.contentDOM && this.updateChildren(i, this.posAtStart),
      (this.dirty = Ir)
  }
  updateOuterDeco(e) {
    if (K_(e, this.outerDeco)) return
    let n = this.nodeDOM.nodeType != 1,
      r = this.dom
    ;(this.dom = jN(this.dom, this.nodeDOM, q_(this.outerDeco, this.node, n), q_(e, this.node, n))),
      this.dom != r && ((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
      (this.outerDeco = e)
  }
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add('ProseMirror-selectednode'),
      (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0)
  }
  deselectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove('ProseMirror-selectednode'),
      (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute('draggable')
  }
  get domAtom() {
    return this.node.isAtom
  }
}
function TS(t, e, n, r, i) {
  WN(r, e, t)
  let s = new xs(void 0, t, e, n, r, r, r, i, 0)
  return s.contentDOM && s.updateChildren(i, 0), s
}
class wm extends xs {
  constructor(e, n, r, i, s, o, a) {
    super(e, n, r, i, s, null, o, a, 0)
  }
  parseRule() {
    let e = this.nodeDOM.parentNode
    for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode
    return { skip: e || !0 }
  }
  update(e, n, r, i) {
    return this.dirty == wi || (this.dirty != Ir && !this.inParent()) || !e.sameMarkup(this.node)
      ? !1
      : (this.updateOuterDeco(n),
        (this.dirty != Ir || e.text != this.node.text) &&
          e.text != this.nodeDOM.nodeValue &&
          ((this.nodeDOM.nodeValue = e.text),
          i.trackWrites == this.nodeDOM && (i.trackWrites = null)),
        (this.node = e),
        (this.dirty = Ir),
        !0)
  }
  inParent() {
    let e = this.parent.contentDOM
    for (let n = this.nodeDOM; n; n = n.parentNode) if (n == e) return !0
    return !1
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e }
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM
      ? this.posAtStart + Math.min(n, this.node.text.length)
      : super.localPosFromDOM(e, n, r)
  }
  ignoreMutation(e) {
    return e.type != 'characterData' && e.type != 'selection'
  }
  slice(e, n, r) {
    let i = this.node.cut(e, n),
      s = document.createTextNode(i.text)
    return new wm(this.parent, i, this.outerDeco, this.innerDeco, s, s, r)
  }
  markDirty(e, n) {
    super.markDirty(e, n),
      this.dom != this.nodeDOM &&
        (e == 0 || n == this.nodeDOM.nodeValue.length) &&
        (this.dirty = wi)
  }
  get domAtom() {
    return !1
  }
  isText(e) {
    return this.node.text == e
  }
}
class HN extends Ch {
  parseRule() {
    return { ignore: !0 }
  }
  matchesHack(e) {
    return this.dirty == Ir && this.dom.nodeName == e
  }
  get domAtom() {
    return !0
  }
  get ignoreForCoords() {
    return this.dom.nodeName == 'IMG'
  }
}
class iW extends xs {
  constructor(e, n, r, i, s, o, a, l, c, u) {
    super(e, n, r, i, s, o, a, c, u), (this.spec = l)
  }
  update(e, n, r, i) {
    if (this.dirty == wi) return !1
    if (this.spec.update) {
      let s = this.spec.update(e, n, r)
      return s && this.updateInner(e, n, r, i), s
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, i)
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()
  }
  setSelection(e, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, n, r) : super.setSelection(e, n, r, i)
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy()
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e)
  }
}
function zN(t, e, n) {
  let r = t.firstChild,
    i = !1
  for (let s = 0; s < e.length; s++) {
    let o = e[s],
      a = o.dom
    if (a.parentNode == t) {
      for (; a != r; ) (r = wS(r)), (i = !0)
      r = r.nextSibling
    } else (i = !0), t.insertBefore(a, r)
    if (o instanceof ra) {
      let l = r ? r.previousSibling : t.lastChild
      zN(o.contentDOM, o.children, n), (r = l ? l.nextSibling : t.firstChild)
    }
  }
  for (; r; ) (r = wS(r)), (i = !0)
  i && n.trackWrites == t && (n.trackWrites = null)
}
const Jc = function (t) {
  t && (this.nodeName = t)
}
Jc.prototype = Object.create(null)
const Co = [new Jc()]
function q_(t, e, n) {
  if (t.length == 0) return Co
  let r = n ? Co[0] : new Jc(),
    i = [r]
  for (let s = 0; s < t.length; s++) {
    let o = t[s].type.attrs
    if (o) {
      o.nodeName && i.push((r = new Jc(o.nodeName)))
      for (let a in o) {
        let l = o[a]
        l != null &&
          (n && i.length == 1 && i.push((r = new Jc(e.isInline ? 'span' : 'div'))),
          a == 'class'
            ? (r.class = (r.class ? r.class + ' ' : '') + l)
            : a == 'style'
            ? (r.style = (r.style ? r.style + ';' : '') + l)
            : a != 'nodeName' && (r[a] = l))
      }
    }
  }
  return i
}
function jN(t, e, n, r) {
  if (n == Co && r == Co) return e
  let i = e
  for (let s = 0; s < r.length; s++) {
    let o = r[s],
      a = n[s]
    if (s) {
      let l
      ;(a &&
        a.nodeName == o.nodeName &&
        i != t &&
        (l = i.parentNode) &&
        l.nodeName.toLowerCase() == o.nodeName) ||
        ((l = document.createElement(o.nodeName)),
        (l.pmIsDeco = !0),
        l.appendChild(i),
        (a = Co[0])),
        (i = l)
    }
    sW(i, a || Co[0], o)
  }
  return i
}
function sW(t, e, n) {
  for (let r in e)
    r != 'class' && r != 'style' && r != 'nodeName' && !(r in n) && t.removeAttribute(r)
  for (let r in n)
    r != 'class' && r != 'style' && r != 'nodeName' && n[r] != e[r] && t.setAttribute(r, n[r])
  if (e.class != n.class) {
    let r = e.class ? e.class.split(' ').filter(Boolean) : [],
      i = n.class ? n.class.split(' ').filter(Boolean) : []
    for (let s = 0; s < r.length; s++) i.indexOf(r[s]) == -1 && t.classList.remove(r[s])
    for (let s = 0; s < i.length; s++) r.indexOf(i[s]) == -1 && t.classList.add(i[s])
    t.classList.length == 0 && t.removeAttribute('class')
  }
  if (e.style != n.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
        i
      for (; (i = r.exec(e.style)); ) t.style.removeProperty(i[1])
    }
    n.style && (t.style.cssText += n.style)
  }
}
function WN(t, e, n) {
  return jN(t, t, Co, q_(e, n, t.nodeType != 1))
}
function K_(t, e) {
  if (t.length != e.length) return !1
  for (let n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1
  return !0
}
function wS(t) {
  let e = t.nextSibling
  return t.parentNode.removeChild(t), e
}
class oW {
  constructor(e, n, r) {
    ;(this.lock = n),
      (this.view = r),
      (this.index = 0),
      (this.stack = []),
      (this.changed = !1),
      (this.top = e),
      (this.preMatch = aW(e.node.content, e))
  }
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++) this.top.children[r].destroy()
      this.top.children.splice(e, n - e), (this.changed = !0)
    }
  }
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length)
  }
  syncToMarks(e, n, r) {
    let i = 0,
      s = this.stack.length >> 1,
      o = Math.min(s, e.length)
    for (
      ;
      i < o &&
      (i == s - 1 ? this.top : this.stack[(i + 1) << 1]).matchesMark(e[i]) &&
      e[i].type.spec.spanning !== !1;

    )
      i++
    for (; i < s; )
      this.destroyRest(),
        (this.top.dirty = Ir),
        (this.index = this.stack.pop()),
        (this.top = this.stack.pop()),
        s--
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1)
      let a = -1
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l]
        if (c.matchesMark(e[s]) && !this.isLocked(c.dom)) {
          a = l
          break
        }
      }
      if (a > -1)
        a > this.index && ((this.changed = !0), this.destroyBetween(this.index, a)),
          (this.top = this.top.children[this.index])
      else {
        let l = ra.create(this.top, e[s], n, r)
        this.top.children.splice(this.index, 0, l), (this.top = l), (this.changed = !0)
      }
      ;(this.index = 0), s++
    }
  }
  findNodeMatch(e, n, r, i) {
    let s = -1,
      o
    if (
      i >= this.preMatch.index &&
      (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top &&
      o.matchesNode(e, n, r)
    )
      s = this.top.children.indexOf(o, this.index)
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a]
        if (c.matchesNode(e, n, r) && !this.preMatch.matched.has(c)) {
          s = a
          break
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0)
  }
  updateNodeAt(e, n, r, i, s) {
    let o = this.top.children[i]
    return (
      o.dirty == wi && o.dom == o.contentDOM && (o.dirty = Ao),
      o.update(e, n, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1
    )
  }
  findIndexWithChild(e) {
    for (;;) {
      let n = e.parentNode
      if (!n) return -1
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r) return i
        }
        return -1
      }
      e = n
    }
  }
  updateNextNode(e, n, r, i, s, o) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a]
      if (l instanceof xs) {
        let c = this.preMatch.matched.get(l)
        if (c != null && c != s) return !1
        let u = l.dom,
          h,
          d =
            this.isLocked(u) &&
            !(
              e.isText &&
              l.node &&
              l.node.isText &&
              l.nodeDOM.nodeValue == e.text &&
              l.dirty != wi &&
              K_(n, l.outerDeco)
            )
        if (!d && l.update(e, n, r, i))
          return (
            this.destroyBetween(this.index, a), l.dom != u && (this.changed = !0), this.index++, !0
          )
        if (!d && (h = this.recreateWrapper(l, e, n, r, i, o)))
          return (
            (this.top.children[this.index] = h),
            h.contentDOM && ((h.dirty = Ao), h.updateChildren(i, o + 1), (h.dirty = Ir)),
            (this.changed = !0),
            this.index++,
            !0
          )
        break
      }
    }
    return !1
  }
  recreateWrapper(e, n, r, i, s, o) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content)) return null
    let a = xs.create(this.top, n, r, i, s, o)
    if (a.contentDOM) {
      ;(a.children = e.children), (e.children = [])
      for (let l of a.children) l.parent = a
    }
    return e.destroy(), a
  }
  addNode(e, n, r, i, s) {
    let o = xs.create(this.top, e, n, r, i, s)
    o.contentDOM && o.updateChildren(i, s + 1),
      this.top.children.splice(this.index++, 0, o),
      (this.changed = !0)
  }
  placeWidget(e, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode)) this.index++
    else {
      let s = new $N(this.top, e, n, r)
      this.top.children.splice(this.index++, 0, s), (this.changed = !0)
    }
  }
  addTextblockHacks() {
    let e = this.top.children[this.index - 1],
      n = this.top
    for (; e instanceof ra; ) (n = e), (e = n.children[n.children.length - 1])
    ;(!e ||
      !(e instanceof wm) ||
      /\n$/.test(e.node.text) ||
      (this.view.requiresGeckoHackNode && /\s$/.test(e.node.text))) &&
      (($n || Bn) && e && e.dom.contentEditable == 'false' && this.addHackNode('IMG', n),
      this.addHackNode('BR', this.top))
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++
    else {
      let r = document.createElement(e)
      e == 'IMG' && ((r.className = 'ProseMirror-separator'), (r.alt = '')),
        e == 'BR' && (r.className = 'ProseMirror-trailingBreak')
      let i = new HN(this.top, [], r, null)
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i),
        (this.changed = !0)
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || (e.nodeType == 1 && e.contains(this.lock.parentNode)))
  }
}
function aW(t, e) {
  let n = e,
    r = n.children.length,
    i = t.childCount,
    s = new Map(),
    o = []
  e: for (; i > 0; ) {
    let a
    for (;;)
      if (r) {
        let c = n.children[r - 1]
        if (c instanceof ra) (n = c), (r = c.children.length)
        else {
          ;(a = c), r--
          break
        }
      } else {
        if (n == e) break e
        ;(r = n.parent.children.indexOf(n)), (n = n.parent)
      }
    let l = a.node
    if (l) {
      if (l != t.child(i - 1)) break
      --i, s.set(a, i), o.push(a)
    }
  }
  return { index: i, matched: s, matches: o.reverse() }
}
function lW(t, e) {
  return t.type.side - e.type.side
}
function cW(t, e, n, r) {
  let i = e.locals(t),
    s = 0
  if (i.length == 0) {
    for (let c = 0; c < t.childCount; c++) {
      let u = t.child(c)
      r(u, i, e.forChild(s, u), c), (s += u.nodeSize)
    }
    return
  }
  let o = 0,
    a = [],
    l = null
  for (let c = 0; ; ) {
    let u, h
    for (; o < i.length && i[o].to == s; ) {
      let g = i[o++]
      g.widget && (u ? (h || (h = [u])).push(g) : (u = g))
    }
    if (u)
      if (h) {
        h.sort(lW)
        for (let g = 0; g < h.length; g++) n(h[g], c, !!l)
      } else n(u, c, !!l)
    let d, f
    if (l) (f = -1), (d = l), (l = null)
    else if (c < t.childCount) (f = c), (d = t.child(c++))
    else break
    for (let g = 0; g < a.length; g++) a[g].to <= s && a.splice(g--, 1)
    for (; o < i.length && i[o].from <= s && i[o].to > s; ) a.push(i[o++])
    let p = s + d.nodeSize
    if (d.isText) {
      let g = p
      o < i.length && i[o].from < g && (g = i[o].from)
      for (let _ = 0; _ < a.length; _++) a[_].to < g && (g = a[_].to)
      g < p && ((l = d.cut(g - s)), (d = d.cut(0, g - s)), (p = g), (f = -1))
    } else for (; o < i.length && i[o].to < p; ) o++
    let m = d.isInline && !d.isLeaf ? a.filter((g) => !g.inline) : a.slice()
    r(d, m, e.forChild(s, d), f), (s = p)
  }
}
function uW(t) {
  if (t.nodeName == 'UL' || t.nodeName == 'OL') {
    let e = t.style.cssText
    ;(t.style.cssText = e + '; list-style: square !important'),
      window.getComputedStyle(t).listStyle,
      (t.style.cssText = e)
  }
}
function hW(t, e, n, r) {
  for (let i = 0, s = 0; i < t.childCount && s <= r; ) {
    let o = t.child(i++),
      a = s
    if (((s += o.nodeSize), !o.isText)) continue
    let l = o.text
    for (; i < t.childCount; ) {
      let c = t.child(i++)
      if (((s += c.nodeSize), !c.isText)) break
      l += c.text
    }
    if (s >= n) {
      if (s >= r && l.slice(r - e.length - a, r - a) == e) return r - e.length
      let c = a < r ? l.lastIndexOf(e, r - a - 1) : -1
      if (c >= 0 && c + e.length + a >= n) return a + c
      if (n == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e) return r
    }
  }
  return -1
}
function Y_(t, e, n, r, i) {
  let s = []
  for (let o = 0, a = 0; o < t.length; o++) {
    let l = t[o],
      c = a,
      u = (a += l.size)
    c >= n || u <= e
      ? s.push(l)
      : (c < e && s.push(l.slice(0, e - c, r)),
        i && (s.push(i), (i = void 0)),
        u > n && s.push(l.slice(n - c, l.size, r)))
  }
  return s
}
function z1(t, e = null) {
  let n = t.domSelectionRange(),
    r = t.state.doc
  if (!n.focusNode) return null
  let i = t.docView.nearestDesc(n.focusNode),
    s = i && i.size == 0,
    o = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1)
  if (o < 0) return null
  let a = r.resolve(o),
    l,
    c
  if (Tm(n)) {
    for (l = a; i && !i.node; ) i = i.parent
    let u = i.node
    if (
      i &&
      u.isAtom &&
      Ee.isSelectable(u) &&
      i.parent &&
      !(u.isInline && Lj(n.focusNode, n.focusOffset, i.dom))
    ) {
      let h = i.posBefore
      c = new Ee(o == h ? a : r.resolve(h))
    }
  } else {
    let u = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1)
    if (u < 0) return null
    l = r.resolve(u)
  }
  if (!c) {
    let u = e == 'pointer' || (t.state.selection.head < a.pos && !s) ? 1 : -1
    c = j1(t, l, a, u)
  }
  return c
}
function GN(t) {
  return t.editable
    ? t.hasFocus()
    : KN(t) && document.activeElement && document.activeElement.contains(t.dom)
}
function Hi(t, e = !1) {
  let n = t.state.selection
  if ((qN(t, n), !!GN(t))) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Bn) {
      let r = t.domSelectionRange(),
        i = t.domObserver.currentSelection
      if (
        r.anchorNode &&
        i.anchorNode &&
        na(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)
      ) {
        ;(t.input.mouseDown.delayedSelectionSync = !0), t.domObserver.setCurSelection()
        return
      }
    }
    if ((t.domObserver.disconnectSelection(), t.cursorWrapper)) fW(t)
    else {
      let { anchor: r, head: i } = n,
        s,
        o
      SS &&
        !(n instanceof Me) &&
        (n.$from.parent.inlineContent || (s = IS(t, n.from)),
        !n.empty && !n.$from.parent.inlineContent && (o = IS(t, n.to))),
        t.docView.setSelection(r, i, t.root, e),
        SS && (s && AS(s), o && AS(o)),
        n.visible
          ? t.dom.classList.remove('ProseMirror-hideselection')
          : (t.dom.classList.add('ProseMirror-hideselection'),
            'onselectionchange' in document && dW(t))
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection()
  }
}
const SS = $n || (Bn && Bj < 63)
function IS(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0),
    i = r < n.childNodes.length ? n.childNodes[r] : null,
    s = r ? n.childNodes[r - 1] : null
  if ($n && i && i.contentEditable == 'false') return Gg(i)
  if ((!i || i.contentEditable == 'false') && (!s || s.contentEditable == 'false')) {
    if (i) return Gg(i)
    if (s) return Gg(s)
  }
}
function Gg(t) {
  return (
    (t.contentEditable = 'true'),
    $n && t.draggable && ((t.draggable = !1), (t.wasDraggable = !0)),
    t
  )
}
function AS(t) {
  ;(t.contentEditable = 'false'), t.wasDraggable && ((t.draggable = !0), (t.wasDraggable = null))
}
function dW(t) {
  let e = t.dom.ownerDocument
  e.removeEventListener('selectionchange', t.input.hideSelectionGuard)
  let n = t.domSelectionRange(),
    r = n.anchorNode,
    i = n.anchorOffset
  e.addEventListener(
    'selectionchange',
    (t.input.hideSelectionGuard = () => {
      ;(n.anchorNode != r || n.anchorOffset != i) &&
        (e.removeEventListener('selectionchange', t.input.hideSelectionGuard),
        setTimeout(() => {
          ;(!GN(t) || t.state.selection.visible) &&
            t.dom.classList.remove('ProseMirror-hideselection')
        }, 20))
    })
  )
}
function fW(t) {
  let e = t.domSelection(),
    n = document.createRange(),
    r = t.cursorWrapper.dom,
    i = r.nodeName == 'IMG'
  i ? n.setEnd(r.parentNode, mn(r) + 1) : n.setEnd(r, 0),
    n.collapse(!1),
    e.removeAllRanges(),
    e.addRange(n),
    !i && !t.state.selection.visible && Jn && Ps <= 11 && ((r.disabled = !0), (r.disabled = !1))
}
function qN(t, e) {
  if (e instanceof Ee) {
    let n = t.docView.descAt(e.from)
    n != t.lastSelectedViewDesc && (CS(t), n && n.selectNode(), (t.lastSelectedViewDesc = n))
  } else CS(t)
}
function CS(t) {
  t.lastSelectedViewDesc &&
    (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
    (t.lastSelectedViewDesc = void 0))
}
function j1(t, e, n, r) {
  return t.someProp('createSelectionBetween', (i) => i(t, e, n)) || Me.between(e, n, r)
}
function RS(t) {
  return t.editable && !t.hasFocus() ? !1 : KN(t)
}
function KN(t) {
  let e = t.domSelectionRange()
  if (!e.anchorNode) return !1
  try {
    return (
      t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) &&
      (t.editable ||
        t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode))
    )
  } catch {
    return !1
  }
}
function pW(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0),
    n = t.domSelectionRange()
  return na(e.node, e.offset, n.anchorNode, n.anchorOffset)
}
function J_(t, e) {
  let { $anchor: n, $head: r } = t.selection,
    i = e > 0 ? n.max(r) : n.min(r),
    s = i.parent.inlineContent
      ? i.depth
        ? t.doc.resolve(e > 0 ? i.after() : i.before())
        : null
      : i
  return s && Fe.findFrom(s, e)
}
function ms(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0
}
function kS(t, e, n) {
  let r = t.state.selection
  if (r instanceof Me)
    if (n.indexOf('s') > -1) {
      let { $head: i } = r,
        s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter
      if (!s || s.isText || !s.isLeaf) return !1
      let o = t.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1))
      return ms(t, new Me(r.$anchor, o))
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? 'forward' : 'backward')) {
        let i = J_(t.state, e)
        return i && i instanceof Ee ? ms(t, i) : !1
      } else if (!(yr && n.indexOf('m') > -1)) {
        let i = r.$head,
          s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter,
          o
        if (!s || s.isText) return !1
        let a = e < 0 ? i.pos - s.nodeSize : i.pos
        return s.isAtom || ((o = t.docView.descAt(a)) && !o.contentDOM)
          ? Ee.isSelectable(s)
            ? ms(t, new Ee(e < 0 ? t.state.doc.resolve(i.pos - s.nodeSize) : i))
            : Ah
            ? ms(t, new Me(t.state.doc.resolve(e < 0 ? a : a + s.nodeSize)))
            : !1
          : !1
      }
    } else return !1
  else {
    if (r instanceof Ee && r.node.isInline) return ms(t, new Me(e > 0 ? r.$to : r.$from))
    {
      let i = J_(t.state, e)
      return i ? ms(t, i) : !1
    }
  }
}
function Yf(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function Qc(t, e) {
  let n = t.pmViewDesc
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != 'BR')
}
function wa(t, e) {
  return e < 0 ? mW(t) : gW(t)
}
function mW(t) {
  let e = t.domSelectionRange(),
    n = e.focusNode,
    r = e.focusOffset
  if (!n) return
  let i,
    s,
    o = !1
  for (jr && n.nodeType == 1 && r < Yf(n) && Qc(n.childNodes[r], -1) && (o = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1) break
      {
        let a = n.childNodes[r - 1]
        if (Qc(a, -1)) (i = n), (s = --r)
        else if (a.nodeType == 3) (n = a), (r = n.nodeValue.length)
        else break
      }
    } else {
      if (YN(n)) break
      {
        let a = n.previousSibling
        for (; a && Qc(a, -1); ) (i = n.parentNode), (s = mn(a)), (a = a.previousSibling)
        if (a) (n = a), (r = Yf(n))
        else {
          if (((n = n.parentNode), n == t.dom)) break
          r = 0
        }
      }
    }
  o ? Q_(t, n, r) : i && Q_(t, i, s)
}
function gW(t) {
  let e = t.domSelectionRange(),
    n = e.focusNode,
    r = e.focusOffset
  if (!n) return
  let i = Yf(n),
    s,
    o
  for (;;)
    if (r < i) {
      if (n.nodeType != 1) break
      let a = n.childNodes[r]
      if (Qc(a, 1)) (s = n), (o = ++r)
      else break
    } else {
      if (YN(n)) break
      {
        let a = n.nextSibling
        for (; a && Qc(a, 1); ) (s = a.parentNode), (o = mn(a) + 1), (a = a.nextSibling)
        if (a) (n = a), (r = 0), (i = Yf(n))
        else {
          if (((n = n.parentNode), n == t.dom)) break
          r = i = 0
        }
      }
    }
  s && Q_(t, s, o)
}
function YN(t) {
  let e = t.pmViewDesc
  return e && e.node && e.node.isBlock
}
function yW(t, e) {
  for (; t && e == t.childNodes.length && !Ih(t); ) (e = mn(t) + 1), (t = t.parentNode)
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e]
    if (n.nodeType == 3) return n
    if (n.nodeType == 1 && n.contentEditable == 'false') break
    ;(t = n), (e = 0)
  }
}
function _W(t, e) {
  for (; t && !e && !Ih(t); ) (e = mn(t)), (t = t.parentNode)
  for (; t && e; ) {
    let n = t.childNodes[e - 1]
    if (n.nodeType == 3) return n
    if (n.nodeType == 1 && n.contentEditable == 'false') break
    ;(t = n), (e = t.childNodes.length)
  }
}
function Q_(t, e, n) {
  if (e.nodeType != 3) {
    let s, o
    ;(o = yW(e, n)) ? ((e = o), (n = 0)) : (s = _W(e, n)) && ((e = s), (n = s.nodeValue.length))
  }
  let r = t.domSelection()
  if (Tm(r)) {
    let s = document.createRange()
    s.setEnd(e, n), s.setStart(e, n), r.removeAllRanges(), r.addRange(s)
  } else r.extend && r.extend(e, n)
  t.domObserver.setCurSelection()
  let { state: i } = t
  setTimeout(() => {
    t.state == i && Hi(t)
  }, 50)
}
function OS(t, e) {
  let n = t.state.doc.resolve(e)
  if (!(Bn || Uj) && n.parent.inlineContent) {
    let i = t.coordsAtPos(e)
    if (e > n.start()) {
      let s = t.coordsAtPos(e - 1),
        o = (s.top + s.bottom) / 2
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left < i.left ? 'ltr' : 'rtl'
    }
    if (e < n.end()) {
      let s = t.coordsAtPos(e + 1),
        o = (s.top + s.bottom) / 2
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left > i.left ? 'ltr' : 'rtl'
    }
  }
  return getComputedStyle(t.dom).direction == 'rtl' ? 'rtl' : 'ltr'
}
function NS(t, e, n) {
  let r = t.state.selection
  if ((r instanceof Me && !r.empty) || n.indexOf('s') > -1 || (yr && n.indexOf('m') > -1)) return !1
  let { $from: i, $to: s } = r
  if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? 'up' : 'down')) {
    let o = J_(t.state, e)
    if (o && o instanceof Ee) return ms(t, o)
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s,
      a = r instanceof Br ? Fe.near(o, e) : Fe.findFrom(o, e)
    return a ? ms(t, a) : !1
  }
  return !1
}
function MS(t, e) {
  if (!(t.state.selection instanceof Me)) return !0
  let { $head: n, $anchor: r, empty: i } = t.state.selection
  if (!n.sameParent(r)) return !0
  if (!i) return !1
  if (t.endOfTextblock(e > 0 ? 'forward' : 'backward')) return !0
  let s = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter)
  if (s && !s.isText) {
    let o = t.state.tr
    return (
      e < 0 ? o.delete(n.pos - s.nodeSize, n.pos) : o.delete(n.pos, n.pos + s.nodeSize),
      t.dispatch(o),
      !0
    )
  }
  return !1
}
function PS(t, e, n) {
  t.domObserver.stop(), (e.contentEditable = n), t.domObserver.start()
}
function vW(t) {
  if (!$n || t.state.selection.$head.parentOffset > 0) return !1
  let { focusNode: e, focusOffset: n } = t.domSelectionRange()
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == 'false') {
    let r = e.firstChild
    PS(t, r, 'true'), setTimeout(() => PS(t, r, 'false'), 20)
  }
  return !1
}
function bW(t) {
  let e = ''
  return (
    t.ctrlKey && (e += 'c'),
    t.metaKey && (e += 'm'),
    t.altKey && (e += 'a'),
    t.shiftKey && (e += 's'),
    e
  )
}
function EW(t, e) {
  let n = e.keyCode,
    r = bW(e)
  if (n == 8 || (yr && n == 72 && r == 'c')) return MS(t, -1) || wa(t, -1)
  if ((n == 46 && !e.shiftKey) || (yr && n == 68 && r == 'c')) return MS(t, 1) || wa(t, 1)
  if (n == 13 || n == 27) return !0
  if (n == 37 || (yr && n == 66 && r == 'c')) {
    let i = n == 37 ? (OS(t, t.state.selection.from) == 'ltr' ? -1 : 1) : -1
    return kS(t, i, r) || wa(t, i)
  } else if (n == 39 || (yr && n == 70 && r == 'c')) {
    let i = n == 39 ? (OS(t, t.state.selection.from) == 'ltr' ? 1 : -1) : 1
    return kS(t, i, r) || wa(t, i)
  } else {
    if (n == 38 || (yr && n == 80 && r == 'c')) return NS(t, -1, r) || wa(t, -1)
    if (n == 40 || (yr && n == 78 && r == 'c')) return vW(t) || NS(t, 1, r) || wa(t, 1)
    if (r == (yr ? 'm' : 'c') && (n == 66 || n == 73 || n == 89 || n == 90)) return !0
  }
  return !1
}
function JN(t, e) {
  t.someProp('transformCopied', (f) => {
    e = f(e, t)
  })
  let n = [],
    { content: r, openStart: i, openEnd: s } = e
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--
    let f = r.firstChild
    n.push(f.type.name, f.attrs != f.type.defaultAttrs ? f.attrs : null), (r = f.content)
  }
  let o = t.someProp('clipboardSerializer') || si.fromSchema(t.state.schema),
    a = nM(),
    l = a.createElement('div')
  l.appendChild(o.serializeFragment(r, { document: a }))
  let c = l.firstChild,
    u,
    h = 0
  for (; c && c.nodeType == 1 && (u = tM[c.nodeName.toLowerCase()]); ) {
    for (let f = u.length - 1; f >= 0; f--) {
      let p = a.createElement(u[f])
      for (; l.firstChild; ) p.appendChild(l.firstChild)
      l.appendChild(p), h++
    }
    c = l.firstChild
  }
  c &&
    c.nodeType == 1 &&
    c.setAttribute('data-pm-slice', `${i} ${s}${h ? ` -${h}` : ''} ${JSON.stringify(n)}`)
  let d =
    t.someProp('clipboardTextSerializer', (f) => f(e, t)) ||
    e.content.textBetween(
      0,
      e.content.size,
      `

`
    )
  return { dom: l, text: d }
}
function QN(t, e, n, r, i) {
  let s = i.parent.type.spec.code,
    o,
    a
  if (!n && !e) return null
  let l = e && (r || s || !n)
  if (l) {
    if (
      (t.someProp('transformPastedText', (d) => {
        e = d(e, s || r, t)
      }),
      s)
    )
      return e
        ? new ie(
            H.from(
              t.state.schema.text(
                e.replace(
                  /\r\n?/g,
                  `
`
                )
              )
            ),
            0,
            0
          )
        : ie.empty
    let h = t.someProp('clipboardTextParser', (d) => d(e, i, r, t))
    if (h) a = h
    else {
      let d = i.marks(),
        { schema: f } = t.state,
        p = si.fromSchema(f)
      ;(o = document.createElement('div')),
        e.split(/(?:\r\n?|\n)+/).forEach((m) => {
          let g = o.appendChild(document.createElement('p'))
          m && g.appendChild(p.serializeNode(f.text(m, d)))
        })
    }
  } else
    t.someProp('transformPastedHTML', (h) => {
      n = h(n, t)
    }),
      (o = SW(n)),
      Ah && IW(o)
  let c = o && o.querySelector('[data-pm-slice]'),
    u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute('data-pm-slice') || '')
  if (u && u[3])
    for (let h = +u[3]; h > 0; h--) {
      let d = o.firstChild
      for (; d && d.nodeType != 1; ) d = d.nextSibling
      if (!d) break
      o = d
    }
  if (
    (a ||
      (a = (
        t.someProp('clipboardParser') ||
        t.someProp('domParser') ||
        Il.fromSchema(t.state.schema)
      ).parseSlice(o, {
        preserveWhitespace: !!(l || u),
        context: i,
        ruleFromNode(d) {
          return d.nodeName == 'BR' &&
            !d.nextSibling &&
            d.parentNode &&
            !TW.test(d.parentNode.nodeName)
            ? { ignore: !0 }
            : null
        }
      })),
    u)
  )
    a = AW(xS(a, +u[1], +u[2]), u[4])
  else if (((a = ie.maxOpen(wW(a.content, i), !0)), a.openStart || a.openEnd)) {
    let h = 0,
      d = 0
    for (
      let f = a.content.firstChild;
      h < a.openStart && !f.type.spec.isolating;
      h++, f = f.firstChild
    );
    for (
      let f = a.content.lastChild;
      d < a.openEnd && !f.type.spec.isolating;
      d++, f = f.lastChild
    );
    a = xS(a, h, d)
  }
  return (
    t.someProp('transformPasted', (h) => {
      a = h(a, t)
    }),
    a
  )
}
const TW =
  /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i
function wW(t, e) {
  if (t.childCount < 2) return t
  for (let n = e.depth; n >= 0; n--) {
    let i = e.node(n).contentMatchAt(e.index(n)),
      s,
      o = []
    if (
      (t.forEach((a) => {
        if (!o) return
        let l = i.findWrapping(a.type),
          c
        if (!l) return (o = null)
        if ((c = o.length && s.length && ZN(l, s, a, o[o.length - 1], 0))) o[o.length - 1] = c
        else {
          o.length && (o[o.length - 1] = eM(o[o.length - 1], s.length))
          let u = XN(a, l)
          o.push(u), (i = i.matchType(u.type)), (s = l)
        }
      }),
      o)
    )
      return H.from(o)
  }
  return t
}
function XN(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--) t = e[r].create(null, H.from(t))
  return t
}
function ZN(t, e, n, r, i) {
  if (i < t.length && i < e.length && t[i] == e[i]) {
    let s = ZN(t, e, n, r.lastChild, i + 1)
    if (s) return r.copy(r.content.replaceChild(r.childCount - 1, s))
    if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1]))
      return r.copy(r.content.append(H.from(XN(n, t, i + 1))))
  }
}
function eM(t, e) {
  if (e == 0) return t
  let n = t.content.replaceChild(t.childCount - 1, eM(t.lastChild, e - 1)),
    r = t.contentMatchAt(t.childCount).fillBefore(H.empty, !0)
  return t.copy(n.append(r))
}
function X_(t, e, n, r, i, s) {
  let o = e < 0 ? t.firstChild : t.lastChild,
    a = o.content
  return (
    t.childCount > 1 && (s = 0),
    i < r - 1 && (a = X_(a, e, n, r, i + 1, s)),
    i >= n &&
      (a =
        e < 0
          ? o
              .contentMatchAt(0)
              .fillBefore(a, s <= i)
              .append(a)
          : a.append(o.contentMatchAt(o.childCount).fillBefore(H.empty, !0))),
    t.replaceChild(e < 0 ? 0 : t.childCount - 1, o.copy(a))
  )
}
function xS(t, e, n) {
  return (
    e < t.openStart && (t = new ie(X_(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)),
    n < t.openEnd && (t = new ie(X_(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
    t
  )
}
const tM = {
  thead: ['table'],
  tbody: ['table'],
  tfoot: ['table'],
  caption: ['table'],
  colgroup: ['table'],
  col: ['table', 'colgroup'],
  tr: ['table', 'tbody'],
  td: ['table', 'tbody', 'tr'],
  th: ['table', 'tbody', 'tr']
}
let DS = null
function nM() {
  return DS || (DS = document.implementation.createHTMLDocument('title'))
}
function SW(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t)
  e && (t = t.slice(e[0].length))
  let n = nM().createElement('div'),
    r = /<([a-z][^>\s]+)/i.exec(t),
    i
  if (
    ((i = r && tM[r[1].toLowerCase()]) &&
      (t =
        i.map((s) => '<' + s + '>').join('') +
        t +
        i
          .map((s) => '</' + s + '>')
          .reverse()
          .join('')),
    (n.innerHTML = t),
    i)
  )
    for (let s = 0; s < i.length; s++) n = n.querySelector(i[s]) || n
  return n
}
function IW(t) {
  let e = t.querySelectorAll(Bn ? 'span:not([class]):not([style])' : 'span.Apple-converted-space')
  for (let n = 0; n < e.length; n++) {
    let r = e[n]
    r.childNodes.length == 1 &&
      r.textContent == ' ' &&
      r.parentNode &&
      r.parentNode.replaceChild(t.ownerDocument.createTextNode(' '), r)
  }
}
function AW(t, e) {
  if (!t.size) return t
  let n = t.content.firstChild.type.schema,
    r
  try {
    r = JSON.parse(e)
  } catch {
    return t
  }
  let { content: i, openStart: s, openEnd: o } = t
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[r[a]]
    if (!l || l.hasRequiredAttrs()) break
    ;(i = H.from(l.create(r[a + 1], i))), s++, o++
  }
  return new ie(i, s, o)
}
const Hn = {},
  zn = {},
  CW = { touchstart: !0, touchmove: !0 }
class RW {
  constructor() {
    ;(this.shiftKey = !1),
      (this.mouseDown = null),
      (this.lastKeyCode = null),
      (this.lastKeyCodeTime = 0),
      (this.lastClick = { time: 0, x: 0, y: 0, type: '' }),
      (this.lastSelectionOrigin = null),
      (this.lastSelectionTime = 0),
      (this.lastIOSEnter = 0),
      (this.lastIOSEnterFallbackTimeout = -1),
      (this.lastFocus = 0),
      (this.lastTouch = 0),
      (this.lastAndroidDelete = 0),
      (this.composing = !1),
      (this.compositionNode = null),
      (this.composingTimeout = -1),
      (this.compositionNodes = []),
      (this.compositionEndedAt = -2e8),
      (this.compositionID = 1),
      (this.compositionPendingChanges = 0),
      (this.domChangeCount = 0),
      (this.eventHandlers = Object.create(null)),
      (this.hideSelectionGuard = null)
  }
}
function kW(t) {
  for (let e in Hn) {
    let n = Hn[e]
    t.dom.addEventListener(
      e,
      (t.input.eventHandlers[e] = (r) => {
        NW(t, r) && !W1(t, r) && (t.editable || !(r.type in zn)) && n(t, r)
      }),
      CW[e] ? { passive: !0 } : void 0
    )
  }
  $n && t.dom.addEventListener('input', () => null), Z_(t)
}
function As(t, e) {
  ;(t.input.lastSelectionOrigin = e), (t.input.lastSelectionTime = Date.now())
}
function OW(t) {
  t.domObserver.stop()
  for (let e in t.input.eventHandlers) t.dom.removeEventListener(e, t.input.eventHandlers[e])
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout)
}
function Z_(t) {
  t.someProp('handleDOMEvents', (e) => {
    for (let n in e)
      t.input.eventHandlers[n] ||
        t.dom.addEventListener(n, (t.input.eventHandlers[n] = (r) => W1(t, r)))
  })
}
function W1(t, e) {
  return t.someProp('handleDOMEvents', (n) => {
    let r = n[e.type]
    return r ? r(t, e) || e.defaultPrevented : !1
  })
}
function NW(t, e) {
  if (!e.bubbles) return !0
  if (e.defaultPrevented) return !1
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || (n.pmViewDesc && n.pmViewDesc.stopEvent(e))) return !1
  return !0
}
function MW(t, e) {
  !W1(t, e) && Hn[e.type] && (t.editable || !(e.type in zn)) && Hn[e.type](t, e)
}
zn.keydown = (t, e) => {
  let n = e
  if (
    ((t.input.shiftKey = n.keyCode == 16 || n.shiftKey),
    !iM(t, n) &&
      ((t.input.lastKeyCode = n.keyCode),
      (t.input.lastKeyCodeTime = Date.now()),
      !(Mr && Bn && n.keyCode == 13)))
  )
    if (
      (n.keyCode != 229 && t.domObserver.forceFlush(),
      Rl && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
    ) {
      let r = Date.now()
      ;(t.input.lastIOSEnter = r),
        (t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
          t.input.lastIOSEnter == r &&
            (t.someProp('handleKeyDown', (i) => i(t, yo(13, 'Enter'))), (t.input.lastIOSEnter = 0))
        }, 200))
    } else
      t.someProp('handleKeyDown', (r) => r(t, n)) || EW(t, n) ? n.preventDefault() : As(t, 'key')
}
zn.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1)
}
zn.keypress = (t, e) => {
  let n = e
  if (iM(t, n) || !n.charCode || (n.ctrlKey && !n.altKey) || (yr && n.metaKey)) return
  if (t.someProp('handleKeyPress', (i) => i(t, n))) {
    n.preventDefault()
    return
  }
  let r = t.state.selection
  if (!(r instanceof Me) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode)
    !/[\r\n]/.test(i) &&
      !t.someProp('handleTextInput', (s) => s(t, r.$from.pos, r.$to.pos, i)) &&
      t.dispatch(t.state.tr.insertText(i).scrollIntoView()),
      n.preventDefault()
  }
}
function Sm(t) {
  return { left: t.clientX, top: t.clientY }
}
function PW(t, e) {
  let n = e.x - t.clientX,
    r = e.y - t.clientY
  return n * n + r * r < 100
}
function G1(t, e, n, r, i) {
  if (r == -1) return !1
  let s = t.state.doc.resolve(r)
  for (let o = s.depth + 1; o > 0; o--)
    if (
      t.someProp(e, (a) =>
        o > s.depth
          ? a(t, n, s.nodeAfter, s.before(o), i, !0)
          : a(t, n, s.node(o), s.before(o), i, !1)
      )
    )
      return !0
  return !1
}
function rl(t, e, n) {
  t.focused || t.focus()
  let r = t.state.tr.setSelection(e)
  n == 'pointer' && r.setMeta('pointer', !0), t.dispatch(r)
}
function xW(t, e) {
  if (e == -1) return !1
  let n = t.state.doc.resolve(e),
    r = n.nodeAfter
  return r && r.isAtom && Ee.isSelectable(r) ? (rl(t, new Ee(n), 'pointer'), !0) : !1
}
function DW(t, e) {
  if (e == -1) return !1
  let n = t.state.selection,
    r,
    i
  n instanceof Ee && (r = n.node)
  let s = t.state.doc.resolve(e)
  for (let o = s.depth + 1; o > 0; o--) {
    let a = o > s.depth ? s.nodeAfter : s.node(o)
    if (Ee.isSelectable(a)) {
      r && n.$from.depth > 0 && o >= n.$from.depth && s.before(n.$from.depth + 1) == n.$from.pos
        ? (i = s.before(n.$from.depth))
        : (i = s.before(o))
      break
    }
  }
  return i != null ? (rl(t, Ee.create(t.state.doc, i), 'pointer'), !0) : !1
}
function LW(t, e, n, r, i) {
  return (
    G1(t, 'handleClickOn', e, n, r) ||
    t.someProp('handleClick', (s) => s(t, e, r)) ||
    (i ? DW(t, n) : xW(t, n))
  )
}
function VW(t, e, n, r) {
  return G1(t, 'handleDoubleClickOn', e, n, r) || t.someProp('handleDoubleClick', (i) => i(t, e, r))
}
function FW(t, e, n, r) {
  return (
    G1(t, 'handleTripleClickOn', e, n, r) ||
    t.someProp('handleTripleClick', (i) => i(t, e, r)) ||
    BW(t, n, r)
  )
}
function BW(t, e, n) {
  if (n.button != 0) return !1
  let r = t.state.doc
  if (e == -1) return r.inlineContent ? (rl(t, Me.create(r, 0, r.content.size), 'pointer'), !0) : !1
  let i = r.resolve(e)
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s),
      a = i.before(s)
    if (o.inlineContent) rl(t, Me.create(r, a + 1, a + 1 + o.content.size), 'pointer')
    else if (Ee.isSelectable(o)) rl(t, Ee.create(r, a), 'pointer')
    else continue
    return !0
  }
}
function q1(t) {
  return Jf(t)
}
const rM = yr ? 'metaKey' : 'ctrlKey'
Hn.mousedown = (t, e) => {
  let n = e
  t.input.shiftKey = n.shiftKey
  let r = q1(t),
    i = Date.now(),
    s = 'singleClick'
  i - t.input.lastClick.time < 500 &&
    PW(n, t.input.lastClick) &&
    !n[rM] &&
    (t.input.lastClick.type == 'singleClick'
      ? (s = 'doubleClick')
      : t.input.lastClick.type == 'doubleClick' && (s = 'tripleClick')),
    (t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: s })
  let o = t.posAtCoords(Sm(n))
  o &&
    (s == 'singleClick'
      ? (t.input.mouseDown && t.input.mouseDown.done(), (t.input.mouseDown = new UW(t, o, n, !!r)))
      : (s == 'doubleClick' ? VW : FW)(t, o.pos, o.inside, n)
      ? n.preventDefault()
      : As(t, 'pointer'))
}
class UW {
  constructor(e, n, r, i) {
    ;(this.view = e),
      (this.pos = n),
      (this.event = r),
      (this.flushed = i),
      (this.delayedSelectionSync = !1),
      (this.mightDrag = null),
      (this.startDoc = e.state.doc),
      (this.selectNode = !!r[rM]),
      (this.allowDefault = r.shiftKey)
    let s, o
    if (n.inside > -1) (s = e.state.doc.nodeAt(n.inside)), (o = n.inside)
    else {
      let u = e.state.doc.resolve(n.pos)
      ;(s = u.parent), (o = u.depth ? u.before() : 0)
    }
    const a = i ? null : r.target,
      l = a ? e.docView.nearestDesc(a, !0) : null
    this.target = l ? l.dom : null
    let { selection: c } = e.state
    ;((r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1) ||
      (c instanceof Ee && c.from <= o && c.to > o)) &&
      (this.mightDrag = {
        node: s,
        pos: o,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && jr && !this.target.hasAttribute('contentEditable'))
      }),
      this.target &&
        this.mightDrag &&
        (this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
        (this.view.domObserver.stop(),
        this.mightDrag.addAttr && (this.target.draggable = !0),
        this.mightDrag.setUneditable &&
          setTimeout(() => {
            this.view.input.mouseDown == this &&
              this.target.setAttribute('contentEditable', 'false')
          }, 20),
        this.view.domObserver.start()),
      e.root.addEventListener('mouseup', (this.up = this.up.bind(this))),
      e.root.addEventListener('mousemove', (this.move = this.move.bind(this))),
      As(e, 'pointer')
  }
  done() {
    this.view.root.removeEventListener('mouseup', this.up),
      this.view.root.removeEventListener('mousemove', this.move),
      this.mightDrag &&
        this.target &&
        (this.view.domObserver.stop(),
        this.mightDrag.addAttr && this.target.removeAttribute('draggable'),
        this.mightDrag.setUneditable && this.target.removeAttribute('contentEditable'),
        this.view.domObserver.start()),
      this.delayedSelectionSync && setTimeout(() => Hi(this.view)),
      (this.view.input.mouseDown = null)
  }
  up(e) {
    if ((this.done(), !this.view.dom.contains(e.target))) return
    let n = this.pos
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Sm(e))),
      this.updateAllowDefault(e),
      this.allowDefault || !n
        ? As(this.view, 'pointer')
        : LW(this.view, n.pos, n.inside, e, this.selectNode)
        ? e.preventDefault()
        : e.button == 0 &&
          (this.flushed ||
            ($n && this.mightDrag && !this.mightDrag.node.isAtom) ||
            (Bn &&
              !this.view.state.selection.visible &&
              Math.min(
                Math.abs(n.pos - this.view.state.selection.from),
                Math.abs(n.pos - this.view.state.selection.to)
              ) <= 2))
        ? (rl(this.view, Fe.near(this.view.state.doc.resolve(n.pos)), 'pointer'),
          e.preventDefault())
        : As(this.view, 'pointer')
  }
  move(e) {
    this.updateAllowDefault(e), As(this.view, 'pointer'), e.buttons == 0 && this.done()
  }
  updateAllowDefault(e) {
    !this.allowDefault &&
      (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) &&
      (this.allowDefault = !0)
  }
}
Hn.touchstart = (t) => {
  ;(t.input.lastTouch = Date.now()), q1(t), As(t, 'pointer')
}
Hn.touchmove = (t) => {
  ;(t.input.lastTouch = Date.now()), As(t, 'pointer')
}
Hn.contextmenu = (t) => q1(t)
function iM(t, e) {
  return t.composing
    ? !0
    : $n && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500
    ? ((t.input.compositionEndedAt = -2e8), !0)
    : !1
}
const $W = Mr ? 5e3 : -1
zn.compositionstart = zn.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush()
    let { state: e } = t,
      n = e.selection.$from
    if (
      e.selection.empty &&
      (e.storedMarks ||
        (!n.textOffset &&
          n.parentOffset &&
          n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
    )
      (t.markCursor = t.state.storedMarks || n.marks()), Jf(t, !0), (t.markCursor = null)
    else if (
      (Jf(t),
      jr && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length)
    ) {
      let r = t.domSelectionRange()
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1]
        if (!o) break
        if (o.nodeType == 3) {
          t.domSelection().collapse(o, o.nodeValue.length)
          break
        } else (i = o), (s = -1)
      }
    }
    t.input.composing = !0
  }
  sM(t, $W)
}
zn.compositionend = (t, e) => {
  t.composing &&
    ((t.input.composing = !1),
    (t.input.compositionEndedAt = e.timeStamp),
    (t.input.compositionPendingChanges = t.domObserver.pendingRecords().length
      ? t.input.compositionID
      : 0),
    (t.input.compositionNode = null),
    t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()),
    t.input.compositionID++,
    sM(t, 20))
}
function sM(t, e) {
  clearTimeout(t.input.composingTimeout),
    e > -1 && (t.input.composingTimeout = setTimeout(() => Jf(t), e))
}
function oM(t) {
  for (
    t.composing && ((t.input.composing = !1), (t.input.compositionEndedAt = zW()));
    t.input.compositionNodes.length > 0;

  )
    t.input.compositionNodes.pop().markParentsDirty()
}
function HW(t) {
  let e = t.domSelectionRange()
  if (!e.focusNode) return null
  let n = xj(e.focusNode, e.focusOffset),
    r = Dj(e.focusNode, e.focusOffset)
  if (n && r && n != r) {
    let i = r.pmViewDesc
    if (!i || !i.isText(r.nodeValue)) return r
    if (t.input.compositionNode == r) {
      let s = n.pmViewDesc
      if (!(!s || !s.isText(n.nodeValue))) return r
    }
  }
  return n
}
function zW() {
  let t = document.createEvent('Event')
  return t.initEvent('event', !0, !0), t.timeStamp
}
function Jf(t, e = !1) {
  if (!(Mr && t.domObserver.flushingSoon >= 0)) {
    if ((t.domObserver.forceFlush(), oM(t), e || (t.docView && t.docView.dirty))) {
      let n = z1(t)
      return (
        n && !n.eq(t.state.selection)
          ? t.dispatch(t.state.tr.setSelection(n))
          : t.updateState(t.state),
        !0
      )
    }
    return !1
  }
}
function jW(t, e) {
  if (!t.dom.parentNode) return
  let n = t.dom.parentNode.appendChild(document.createElement('div'))
  n.appendChild(e), (n.style.cssText = 'position: fixed; left: -10000px; top: 10px')
  let r = getSelection(),
    i = document.createRange()
  i.selectNodeContents(e),
    t.dom.blur(),
    r.removeAllRanges(),
    r.addRange(i),
    setTimeout(() => {
      n.parentNode && n.parentNode.removeChild(n), t.focus()
    }, 50)
}
const Pu = (Jn && Ps < 15) || (Rl && $j < 604)
Hn.copy = zn.cut = (t, e) => {
  let n = e,
    r = t.state.selection,
    i = n.type == 'cut'
  if (r.empty) return
  let s = Pu ? null : n.clipboardData,
    o = r.content(),
    { dom: a, text: l } = JN(t, o)
  s
    ? (n.preventDefault(),
      s.clearData(),
      s.setData('text/html', a.innerHTML),
      s.setData('text/plain', l))
    : jW(t, a),
    i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta('uiEvent', 'cut'))
}
function WW(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1
    ? t.content.firstChild
    : null
}
function GW(t, e) {
  if (!t.dom.parentNode) return
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code,
    r = t.dom.parentNode.appendChild(document.createElement(n ? 'textarea' : 'div'))
  n || (r.contentEditable = 'true'),
    (r.style.cssText = 'position: fixed; left: -10000px; top: 10px'),
    r.focus()
  let i = t.input.shiftKey && t.input.lastKeyCode != 45
  setTimeout(() => {
    t.focus(),
      r.parentNode && r.parentNode.removeChild(r),
      n ? xu(t, r.value, null, i, e) : xu(t, r.textContent, r.innerHTML, i, e)
  }, 50)
}
function xu(t, e, n, r, i) {
  let s = QN(t, e, n, r, t.state.selection.$from)
  if (t.someProp('handlePaste', (l) => l(t, i, s || ie.empty))) return !0
  if (!s) return !1
  let o = WW(s),
    a = o ? t.state.tr.replaceSelectionWith(o, r) : t.state.tr.replaceSelection(s)
  return t.dispatch(a.scrollIntoView().setMeta('paste', !0).setMeta('uiEvent', 'paste')), !0
}
function aM(t) {
  let e = t.getData('text/plain') || t.getData('Text')
  if (e) return e
  let n = t.getData('text/uri-list')
  return n ? n.replace(/\r?\n/g, ' ') : ''
}
zn.paste = (t, e) => {
  let n = e
  if (t.composing && !Mr) return
  let r = Pu ? null : n.clipboardData,
    i = t.input.shiftKey && t.input.lastKeyCode != 45
  r && xu(t, aM(r), r.getData('text/html'), i, n) ? n.preventDefault() : GW(t, n)
}
class lM {
  constructor(e, n, r) {
    ;(this.slice = e), (this.move = n), (this.node = r)
  }
}
const cM = yr ? 'altKey' : 'ctrlKey'
Hn.dragstart = (t, e) => {
  let n = e,
    r = t.input.mouseDown
  if ((r && r.done(), !n.dataTransfer)) return
  let i = t.state.selection,
    s = i.empty ? null : t.posAtCoords(Sm(n)),
    o
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof Ee ? i.to - 1 : i.to))) {
    if (r && r.mightDrag) o = Ee.create(t.state.doc, r.mightDrag.pos)
    else if (n.target && n.target.nodeType == 1) {
      let u = t.docView.nearestDesc(n.target, !0)
      u && u.node.type.spec.draggable && u != t.docView && (o = Ee.create(t.state.doc, u.posBefore))
    }
  }
  let a = (o || t.state.selection).content(),
    { dom: l, text: c } = JN(t, a)
  n.dataTransfer.clearData(),
    n.dataTransfer.setData(Pu ? 'Text' : 'text/html', l.innerHTML),
    (n.dataTransfer.effectAllowed = 'copyMove'),
    Pu || n.dataTransfer.setData('text/plain', c),
    (t.dragging = new lM(a, !n[cM], o))
}
Hn.dragend = (t) => {
  let e = t.dragging
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null)
  }, 50)
}
zn.dragover = zn.dragenter = (t, e) => e.preventDefault()
zn.drop = (t, e) => {
  let n = e,
    r = t.dragging
  if (((t.dragging = null), !n.dataTransfer)) return
  let i = t.posAtCoords(Sm(n))
  if (!i) return
  let s = t.state.doc.resolve(i.pos),
    o = r && r.slice
  o
    ? t.someProp('transformPasted', (p) => {
        o = p(o, t)
      })
    : (o = QN(t, aM(n.dataTransfer), Pu ? null : n.dataTransfer.getData('text/html'), !1, s))
  let a = !!(r && !n[cM])
  if (t.someProp('handleDrop', (p) => p(t, n, o || ie.empty, a))) {
    n.preventDefault()
    return
  }
  if (!o) return
  n.preventDefault()
  let l = o ? CN(t.state.doc, s.pos, o) : s.pos
  l == null && (l = s.pos)
  let c = t.state.tr
  if (a) {
    let { node: p } = r
    p ? p.replace(c) : c.deleteSelection()
  }
  let u = c.mapping.map(l),
    h = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1,
    d = c.doc
  if ((h ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(d)))
    return
  let f = c.doc.resolve(u)
  if (
    h &&
    Ee.isSelectable(o.content.firstChild) &&
    f.nodeAfter &&
    f.nodeAfter.sameMarkup(o.content.firstChild)
  )
    c.setSelection(new Ee(f))
  else {
    let p = c.mapping.map(l)
    c.mapping.maps[c.mapping.maps.length - 1].forEach((m, g, _, v) => (p = v)),
      c.setSelection(j1(t, f, c.doc.resolve(p)))
  }
  t.focus(), t.dispatch(c.setMeta('uiEvent', 'drop'))
}
Hn.focus = (t) => {
  ;(t.input.lastFocus = Date.now()),
    t.focused ||
      (t.domObserver.stop(),
      t.dom.classList.add('ProseMirror-focused'),
      t.domObserver.start(),
      (t.focused = !0),
      setTimeout(() => {
        t.docView &&
          t.hasFocus() &&
          !t.domObserver.currentSelection.eq(t.domSelectionRange()) &&
          Hi(t)
      }, 20))
}
Hn.blur = (t, e) => {
  let n = e
  t.focused &&
    (t.domObserver.stop(),
    t.dom.classList.remove('ProseMirror-focused'),
    t.domObserver.start(),
    n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(),
    (t.focused = !1))
}
Hn.beforeinput = (t, e) => {
  if (Bn && Mr && e.inputType == 'deleteContentBackward') {
    t.domObserver.flushSoon()
    let { domChangeCount: r } = t.input
    setTimeout(() => {
      if (
        t.input.domChangeCount != r ||
        (t.dom.blur(), t.focus(), t.someProp('handleKeyDown', (s) => s(t, yo(8, 'Backspace'))))
      )
        return
      let { $cursor: i } = t.state.selection
      i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView())
    }, 50)
  }
}
for (let t in zn) Hn[t] = zn[t]
function Du(t, e) {
  if (t == e) return !0
  for (let n in t) if (t[n] !== e[n]) return !1
  for (let n in e) if (!(n in t)) return !1
  return !0
}
class Qf {
  constructor(e, n) {
    ;(this.toDOM = e), (this.spec = n || Ho), (this.side = this.spec.side || 0)
  }
  map(e, n, r, i) {
    let { pos: s, deleted: o } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1)
    return o ? null : new wr(s - r, s - r, this)
  }
  valid() {
    return !0
  }
  eq(e) {
    return (
      this == e ||
      (e instanceof Qf &&
        ((this.spec.key && this.spec.key == e.spec.key) ||
          (this.toDOM == e.toDOM && Du(this.spec, e.spec))))
    )
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e)
  }
}
class Ds {
  constructor(e, n) {
    ;(this.attrs = e), (this.spec = n || Ho)
  }
  map(e, n, r, i) {
    let s = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r,
      o = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r
    return s >= o ? null : new wr(s, o, this)
  }
  valid(e, n) {
    return n.from < n.to
  }
  eq(e) {
    return this == e || (e instanceof Ds && Du(this.attrs, e.attrs) && Du(this.spec, e.spec))
  }
  static is(e) {
    return e.type instanceof Ds
  }
  destroy() {}
}
class K1 {
  constructor(e, n) {
    ;(this.attrs = e), (this.spec = n || Ho)
  }
  map(e, n, r, i) {
    let s = e.mapResult(n.from + i, 1)
    if (s.deleted) return null
    let o = e.mapResult(n.to + i, -1)
    return o.deleted || o.pos <= s.pos ? null : new wr(s.pos - r, o.pos - r, this)
  }
  valid(e, n) {
    let { index: r, offset: i } = e.content.findIndex(n.from),
      s
    return i == n.from && !(s = e.child(r)).isText && i + s.nodeSize == n.to
  }
  eq(e) {
    return this == e || (e instanceof K1 && Du(this.attrs, e.attrs) && Du(this.spec, e.spec))
  }
  destroy() {}
}
class wr {
  constructor(e, n, r) {
    ;(this.from = e), (this.to = n), (this.type = r)
  }
  copy(e, n) {
    return new wr(e, n, this.type)
  }
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to
  }
  map(e, n, r) {
    return this.type.map(e, this, n, r)
  }
  static widget(e, n, r) {
    return new wr(e, e, new Qf(n, r))
  }
  static inline(e, n, r, i) {
    return new wr(e, n, new Ds(r, i))
  }
  static node(e, n, r, i) {
    return new wr(e, n, new K1(r, i))
  }
  get spec() {
    return this.type.spec
  }
  get inline() {
    return this.type instanceof Ds
  }
  get widget() {
    return this.type instanceof Qf
  }
}
const Oa = [],
  Ho = {}
class zt {
  constructor(e, n) {
    ;(this.local = e.length ? e : Oa), (this.children = n.length ? n : Oa)
  }
  static create(e, n) {
    return n.length ? Xf(n, e, 0, Ho) : In
  }
  find(e, n, r) {
    let i = []
    return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i
  }
  findInner(e, n, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let a = this.local[o]
      a.from <= n && a.to >= e && (!s || s(a.spec)) && r.push(a.copy(a.from + i, a.to + i))
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < n && this.children[o + 1] > e) {
        let a = this.children[o] + 1
        this.children[o + 2].findInner(e - a, n - a, r, i + a, s)
      }
  }
  map(e, n, r) {
    return this == In || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || Ho)
  }
  mapInner(e, n, r, i, s) {
    let o
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, r, i)
      l && l.type.valid(n, l)
        ? (o || (o = [])).push(l)
        : s.onRemove && s.onRemove(this.local[a].spec)
    }
    return this.children.length
      ? qW(this.children, o || [], e, n, r, i, s)
      : o
      ? new zt(o.sort(zo), Oa)
      : In
  }
  add(e, n) {
    return n.length ? (this == In ? zt.create(e, n) : this.addInner(e, n, 0)) : this
  }
  addInner(e, n, r) {
    let i,
      s = 0
    e.forEach((a, l) => {
      let c = l + r,
        u
      if ((u = hM(n, a, c))) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < l; ) s += 3
        i[s] == l
          ? (i[s + 2] = i[s + 2].addInner(a, u, c + 1))
          : i.splice(s, 0, l, l + a.nodeSize, Xf(u, a, c + 1, Ho)),
          (s += 3)
      }
    })
    let o = uM(s ? dM(n) : n, -r)
    for (let a = 0; a < o.length; a++) o[a].type.valid(e, o[a]) || o.splice(a--, 1)
    return new zt(o.length ? this.local.concat(o).sort(zo) : this.local, i || this.children)
  }
  remove(e) {
    return e.length == 0 || this == In ? this : this.removeInner(e, 0)
  }
  removeInner(e, n) {
    let r = this.children,
      i = this.local
    for (let s = 0; s < r.length; s += 3) {
      let o,
        a = r[s] + n,
        l = r[s + 1] + n
      for (let u = 0, h; u < e.length; u++)
        (h = e[u]) && h.from > a && h.to < l && ((e[u] = null), (o || (o = [])).push(h))
      if (!o) continue
      r == this.children && (r = this.children.slice())
      let c = r[s + 2].removeInner(o, a + 1)
      c != In ? (r[s + 2] = c) : (r.splice(s, 3), (s -= 3))
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if ((o = e[s]))
          for (let a = 0; a < i.length; a++)
            i[a].eq(o, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1))
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new zt(i, r) : In
  }
  forChild(e, n) {
    if (this == In) return this
    if (n.isLeaf) return zt.empty
    let r, i
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2])
        break
      }
    let s = e + 1,
      o = s + n.content.size
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a]
      if (l.from < o && l.to > s && l.type instanceof Ds) {
        let c = Math.max(s, l.from) - s,
          u = Math.min(o, l.to) - s
        c < u && (i || (i = [])).push(l.copy(c, u))
      }
    }
    if (i) {
      let a = new zt(i.sort(zo), Oa)
      return r ? new Es([a, r]) : a
    }
    return r || In
  }
  eq(e) {
    if (this == e) return !0
    if (
      !(e instanceof zt) ||
      this.local.length != e.local.length ||
      this.children.length != e.children.length
    )
      return !1
    for (let n = 0; n < this.local.length; n++) if (!this.local[n].eq(e.local[n])) return !1
    for (let n = 0; n < this.children.length; n += 3)
      if (
        this.children[n] != e.children[n] ||
        this.children[n + 1] != e.children[n + 1] ||
        !this.children[n + 2].eq(e.children[n + 2])
      )
        return !1
    return !0
  }
  locals(e) {
    return Y1(this.localsInner(e))
  }
  localsInner(e) {
    if (this == In) return Oa
    if (e.inlineContent || !this.local.some(Ds.is)) return this.local
    let n = []
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Ds || n.push(this.local[r])
    return n
  }
}
zt.empty = new zt([], [])
zt.removeOverlap = Y1
const In = zt.empty
class Es {
  constructor(e) {
    this.members = e
  }
  map(e, n) {
    const r = this.members.map((i) => i.map(e, n, Ho))
    return Es.from(r)
  }
  forChild(e, n) {
    if (n.isLeaf) return zt.empty
    let r = []
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, n)
      s != In && (s instanceof Es ? (r = r.concat(s.members)) : r.push(s))
    }
    return Es.from(r)
  }
  eq(e) {
    if (!(e instanceof Es) || e.members.length != this.members.length) return !1
    for (let n = 0; n < this.members.length; n++) if (!this.members[n].eq(e.members[n])) return !1
    return !0
  }
  locals(e) {
    let n,
      r = !0
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e)
      if (s.length)
        if (!n) n = s
        else {
          r && ((n = n.slice()), (r = !1))
          for (let o = 0; o < s.length; o++) n.push(s[o])
        }
    }
    return n ? Y1(r ? n : n.sort(zo)) : Oa
  }
  static from(e) {
    switch (e.length) {
      case 0:
        return In
      case 1:
        return e[0]
      default:
        return new Es(
          e.every((n) => n instanceof zt)
            ? e
            : e.reduce((n, r) => n.concat(r instanceof zt ? r : r.members), [])
        )
    }
  }
}
function qW(t, e, n, r, i, s, o) {
  let a = t.slice()
  for (let c = 0, u = s; c < n.maps.length; c++) {
    let h = 0
    n.maps[c].forEach((d, f, p, m) => {
      let g = m - p - (f - d)
      for (let _ = 0; _ < a.length; _ += 3) {
        let v = a[_ + 1]
        if (v < 0 || d > v + u - h) continue
        let T = a[_] + u - h
        f >= T ? (a[_ + 1] = d <= T ? -2 : -1) : d >= u && g && ((a[_] += g), (a[_ + 1] += g))
      }
      h += g
    }),
      (u = n.maps[c].map(u, -1))
  }
  let l = !1
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        ;(l = !0), (a[c + 1] = -1)
        continue
      }
      let u = n.map(t[c] + s),
        h = u - i
      if (h < 0 || h >= r.content.size) {
        l = !0
        continue
      }
      let d = n.map(t[c + 1] + s, -1),
        f = d - i,
        { index: p, offset: m } = r.content.findIndex(h),
        g = r.maybeChild(p)
      if (g && m == h && m + g.nodeSize == f) {
        let _ = a[c + 2].mapInner(n, g, u + 1, t[c] + s + 1, o)
        _ != In ? ((a[c] = h), (a[c + 1] = f), (a[c + 2] = _)) : ((a[c + 1] = -2), (l = !0))
      } else l = !0
    }
  if (l) {
    let c = KW(a, t, e, n, i, s, o),
      u = Xf(c, r, 0, o)
    e = u.local
    for (let h = 0; h < a.length; h += 3) a[h + 1] < 0 && (a.splice(h, 3), (h -= 3))
    for (let h = 0, d = 0; h < u.children.length; h += 3) {
      let f = u.children[h]
      for (; d < a.length && a[d] < f; ) d += 3
      a.splice(d, 0, u.children[h], u.children[h + 1], u.children[h + 2])
    }
  }
  return new zt(e.sort(zo), a)
}
function uM(t, e) {
  if (!e || !t.length) return t
  let n = []
  for (let r = 0; r < t.length; r++) {
    let i = t[r]
    n.push(new wr(i.from + e, i.to + e, i.type))
  }
  return n
}
function KW(t, e, n, r, i, s, o) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let h = l.local[u].map(r, i, c)
      h ? n.push(h) : o.onRemove && o.onRemove(l.local[u].spec)
    }
    for (let u = 0; u < l.children.length; u += 3) a(l.children[u + 2], l.children[u] + c + 1)
  }
  for (let l = 0; l < t.length; l += 3) t[l + 1] == -1 && a(t[l + 2], e[l] + s + 1)
  return n
}
function hM(t, e, n) {
  if (e.isLeaf) return null
  let r = n + e.nodeSize,
    i = null
  for (let s = 0, o; s < t.length; s++)
    (o = t[s]) && o.from > n && o.to < r && ((i || (i = [])).push(o), (t[s] = null))
  return i
}
function dM(t) {
  let e = []
  for (let n = 0; n < t.length; n++) t[n] != null && e.push(t[n])
  return e
}
function Xf(t, e, n, r) {
  let i = [],
    s = !1
  e.forEach((a, l) => {
    let c = hM(t, a, l + n)
    if (c) {
      s = !0
      let u = Xf(c, a, n + l + 1, r)
      u != In && i.push(l, l + a.nodeSize, u)
    }
  })
  let o = uM(s ? dM(t) : t, -n).sort(zo)
  for (let a = 0; a < o.length; a++)
    o[a].type.valid(e, o[a]) || (r.onRemove && r.onRemove(o[a].spec), o.splice(a--, 1))
  return o.length || i.length ? new zt(o, i) : In
}
function zo(t, e) {
  return t.from - e.from || t.to - e.to
}
function Y1(t) {
  let e = t
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n]
    if (r.from != r.to)
      for (let i = n + 1; i < e.length; i++) {
        let s = e[i]
        if (s.from == r.from) {
          s.to != r.to &&
            (e == t && (e = t.slice()),
            (e[i] = s.copy(s.from, r.to)),
            LS(e, i + 1, s.copy(r.to, s.to)))
          continue
        } else {
          s.from < r.to &&
            (e == t && (e = t.slice()),
            (e[n] = r.copy(r.from, s.from)),
            LS(e, i, r.copy(s.from, r.to)))
          break
        }
      }
  }
  return e
}
function LS(t, e, n) {
  for (; e < t.length && zo(n, t[e]) > 0; ) e++
  t.splice(e, 0, n)
}
function qg(t) {
  let e = []
  return (
    t.someProp('decorations', (n) => {
      let r = n(t.state)
      r && r != In && e.push(r)
    }),
    t.cursorWrapper && e.push(zt.create(t.state.doc, [t.cursorWrapper.deco])),
    Es.from(e)
  )
}
const YW = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
  },
  JW = Jn && Ps <= 11
class QW {
  constructor() {
    ;(this.anchorNode = null),
      (this.anchorOffset = 0),
      (this.focusNode = null),
      (this.focusOffset = 0)
  }
  set(e) {
    ;(this.anchorNode = e.anchorNode),
      (this.anchorOffset = e.anchorOffset),
      (this.focusNode = e.focusNode),
      (this.focusOffset = e.focusOffset)
  }
  clear() {
    this.anchorNode = this.focusNode = null
  }
  eq(e) {
    return (
      e.anchorNode == this.anchorNode &&
      e.anchorOffset == this.anchorOffset &&
      e.focusNode == this.focusNode &&
      e.focusOffset == this.focusOffset
    )
  }
}
class XW {
  constructor(e, n) {
    ;(this.view = e),
      (this.handleDOMChange = n),
      (this.queue = []),
      (this.flushingSoon = -1),
      (this.observer = null),
      (this.currentSelection = new QW()),
      (this.onCharData = null),
      (this.suppressingSelectionUpdates = !1),
      (this.observer =
        window.MutationObserver &&
        new window.MutationObserver((r) => {
          for (let i = 0; i < r.length; i++) this.queue.push(r[i])
          Jn &&
          Ps <= 11 &&
          r.some(
            (i) =>
              (i.type == 'childList' && i.removedNodes.length) ||
              (i.type == 'characterData' && i.oldValue.length > i.target.nodeValue.length)
          )
            ? this.flushSoon()
            : this.flush()
        })),
      JW &&
        (this.onCharData = (r) => {
          this.queue.push({ target: r.target, type: 'characterData', oldValue: r.prevValue }),
            this.flushSoon()
        }),
      (this.onSelectionChange = this.onSelectionChange.bind(this))
  }
  flushSoon() {
    this.flushingSoon < 0 &&
      (this.flushingSoon = window.setTimeout(() => {
        ;(this.flushingSoon = -1), this.flush()
      }, 20))
  }
  forceFlush() {
    this.flushingSoon > -1 &&
      (window.clearTimeout(this.flushingSoon), (this.flushingSoon = -1), this.flush())
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, YW)),
      this.onCharData &&
        this.view.dom.addEventListener('DOMCharacterDataModified', this.onCharData),
      this.connectSelection()
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords()
      if (e.length) {
        for (let n = 0; n < e.length; n++) this.queue.push(e[n])
        window.setTimeout(() => this.flush(), 20)
      }
      this.observer.disconnect()
    }
    this.onCharData &&
      this.view.dom.removeEventListener('DOMCharacterDataModified', this.onCharData),
      this.disconnectSelection()
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener('selectionchange', this.onSelectionChange)
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener('selectionchange', this.onSelectionChange)
  }
  suppressSelectionUpdates() {
    ;(this.suppressingSelectionUpdates = !0),
      setTimeout(() => (this.suppressingSelectionUpdates = !1), 50)
  }
  onSelectionChange() {
    if (RS(this.view)) {
      if (this.suppressingSelectionUpdates) return Hi(this.view)
      if (Jn && Ps <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange()
        if (e.focusNode && na(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon()
      }
      this.flush()
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange())
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode) return !0
    let n = new Set(),
      r
    for (let s = e.focusNode; s; s = Mu(s)) n.add(s)
    for (let s = e.anchorNode; s; s = Mu(s))
      if (n.has(s)) {
        r = s
        break
      }
    let i = r && this.view.docView.nearestDesc(r)
    if (i && i.ignoreMutation({ type: 'selection', target: r.nodeType == 3 ? r.parentNode : r }))
      return this.setCurSelection(), !0
  }
  pendingRecords() {
    if (this.observer) for (let e of this.observer.takeRecords()) this.queue.push(e)
    return this.queue
  }
  flush() {
    let { view: e } = this
    if (!e.docView || this.flushingSoon > -1) return
    let n = this.pendingRecords()
    n.length && (this.queue = [])
    let r = e.domSelectionRange(),
      i =
        !this.suppressingSelectionUpdates &&
        !this.currentSelection.eq(r) &&
        RS(e) &&
        !this.ignoreSelectionChange(r),
      s = -1,
      o = -1,
      a = !1,
      l = []
    if (e.editable)
      for (let u = 0; u < n.length; u++) {
        let h = this.registerMutation(n[u], l)
        h &&
          ((s = s < 0 ? h.from : Math.min(h.from, s)),
          (o = o < 0 ? h.to : Math.max(h.to, o)),
          h.typeOver && (a = !0))
      }
    if (jr && l.length > 1) {
      let u = l.filter((h) => h.nodeName == 'BR')
      if (u.length == 2) {
        let h = u[0],
          d = u[1]
        h.parentNode && h.parentNode.parentNode == d.parentNode ? d.remove() : h.remove()
      }
    }
    let c = null
    s < 0 &&
    i &&
    e.input.lastFocus > Date.now() - 200 &&
    Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 &&
    Tm(r) &&
    (c = z1(e)) &&
    c.eq(Fe.near(e.state.doc.resolve(0), 1))
      ? ((e.input.lastFocus = 0), Hi(e), this.currentSelection.set(r), e.scrollToSelection())
      : (s > -1 || i) &&
        (s > -1 && (e.docView.markDirty(s, o), ZW(e)),
        this.handleDOMChange(s, o, a, l),
        e.docView && e.docView.dirty
          ? e.updateState(e.state)
          : this.currentSelection.eq(r) || Hi(e),
        this.currentSelection.set(r))
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1) return null
    let r = this.view.docView.nearestDesc(e.target)
    if (
      (e.type == 'attributes' &&
        (r == this.view.docView ||
          e.attributeName == 'contenteditable' ||
          (e.attributeName == 'style' && !e.oldValue && !e.target.getAttribute('style')))) ||
      !r ||
      r.ignoreMutation(e)
    )
      return null
    if (e.type == 'childList') {
      for (let u = 0; u < e.addedNodes.length; u++) n.push(e.addedNodes[u])
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter }
      let i = e.previousSibling,
        s = e.nextSibling
      if (Jn && Ps <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: h, nextSibling: d } = e.addedNodes[u]
          ;(!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h),
            (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (s = d)
        }
      let o = i && i.parentNode == e.target ? mn(i) + 1 : 0,
        a = r.localPosFromDOM(e.target, o, -1),
        l = s && s.parentNode == e.target ? mn(s) : e.target.childNodes.length,
        c = r.localPosFromDOM(e.target, l, 1)
      return { from: a, to: c }
    } else
      return e.type == 'attributes'
        ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
        : { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue }
  }
}
let VS = new WeakMap(),
  FS = !1
function ZW(t) {
  if (
    !VS.has(t) &&
    (VS.set(t, null),
    ['normal', 'nowrap', 'pre-line'].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)
  ) {
    if (((t.requiresGeckoHackNode = jr), FS)) return
    console.warn(
      "ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."
    ),
      (FS = !0)
  }
}
function BS(t, e) {
  let n = e.startContainer,
    r = e.startOffset,
    i = e.endContainer,
    s = e.endOffset,
    o = t.domAtPos(t.state.selection.anchor)
  return (
    na(o.node, o.offset, i, s) && ([n, r, i, s] = [i, s, n, r]),
    { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s }
  )
}
function eG(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0]
    if (i) return BS(t, i)
  }
  let n
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), (n = i.getTargetRanges()[0])
  }
  return (
    t.dom.addEventListener('beforeinput', r, !0),
    document.execCommand('indent'),
    t.dom.removeEventListener('beforeinput', r, !0),
    n ? BS(t, n) : null
  )
}
function tG(t, e, n) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: a } = t.docView.parseRange(e, n),
    l = t.domSelectionRange(),
    c,
    u = l.anchorNode
  if (
    (u &&
      t.dom.contains(u.nodeType == 1 ? u : u.parentNode) &&
      ((c = [{ node: u, offset: l.anchorOffset }]),
      Tm(l) || c.push({ node: l.focusNode, offset: l.focusOffset })),
    Bn && t.input.lastKeyCode === 8)
  )
    for (let g = s; g > i; g--) {
      let _ = r.childNodes[g - 1],
        v = _.pmViewDesc
      if (_.nodeName == 'BR' && !v) {
        s = g
        break
      }
      if (!v || v.size) break
    }
  let h = t.state.doc,
    d = t.someProp('domParser') || Il.fromSchema(t.state.schema),
    f = h.resolve(o),
    p = null,
    m = d.parse(r, {
      topNode: f.parent,
      topMatch: f.parent.contentMatchAt(f.index()),
      topOpen: !0,
      from: i,
      to: s,
      preserveWhitespace: f.parent.type.whitespace == 'pre' ? 'full' : !0,
      findPositions: c,
      ruleFromNode: nG,
      context: f
    })
  if (c && c[0].pos != null) {
    let g = c[0].pos,
      _ = c[1] && c[1].pos
    _ == null && (_ = g), (p = { anchor: g + o, head: _ + o })
  }
  return { doc: m, sel: p, from: o, to: a }
}
function nG(t) {
  let e = t.pmViewDesc
  if (e) return e.parseRule()
  if (t.nodeName == 'BR' && t.parentNode) {
    if ($n && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement('div')
      return n.appendChild(document.createElement('li')), { skip: n }
    } else if (t.parentNode.lastChild == t || ($n && /^(tr|table)$/i.test(t.parentNode.nodeName)))
      return { ignore: !0 }
  } else if (t.nodeName == 'IMG' && t.getAttribute('mark-placeholder')) return { ignore: !0 }
  return null
}
const rG =
  /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i
function iG(t, e, n, r, i) {
  let s = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0)
  if (((t.input.compositionPendingChanges = 0), e < 0)) {
    let k = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null,
      U = z1(t, k)
    if (U && !t.state.selection.eq(U)) {
      if (
        Bn &&
        Mr &&
        t.input.lastKeyCode === 13 &&
        Date.now() - 100 < t.input.lastKeyCodeTime &&
        t.someProp('handleKeyDown', ($) => $(t, yo(13, 'Enter')))
      )
        return
      let F = t.state.tr.setSelection(U)
      k == 'pointer' ? F.setMeta('pointer', !0) : k == 'key' && F.scrollIntoView(),
        s && F.setMeta('composition', s),
        t.dispatch(F)
    }
    return
  }
  let o = t.state.doc.resolve(e),
    a = o.sharedDepth(n)
  ;(e = o.before(a + 1)), (n = t.state.doc.resolve(n).after(a + 1))
  let l = t.state.selection,
    c = tG(t, e, n),
    u = t.state.doc,
    h = u.slice(c.from, c.to),
    d,
    f
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime
    ? ((d = t.state.selection.to), (f = 'end'))
    : ((d = t.state.selection.from), (f = 'start')),
    (t.input.lastKeyCode = null)
  let p = aG(h.content, c.doc.content, c.from, d, f)
  if (
    ((Rl && t.input.lastIOSEnter > Date.now() - 225) || Mr) &&
    i.some((k) => k.nodeType == 1 && !rG.test(k.nodeName)) &&
    (!p || p.endA >= p.endB) &&
    t.someProp('handleKeyDown', (k) => k(t, yo(13, 'Enter')))
  ) {
    t.input.lastIOSEnter = 0
    return
  }
  if (!p)
    if (
      r &&
      l instanceof Me &&
      !l.empty &&
      l.$head.sameParent(l.$anchor) &&
      !t.composing &&
      !(c.sel && c.sel.anchor != c.sel.head)
    )
      p = { start: l.from, endA: l.to, endB: l.to }
    else {
      if (c.sel) {
        let k = US(t, t.state.doc, c.sel)
        if (k && !k.eq(t.state.selection)) {
          let U = t.state.tr.setSelection(k)
          s && U.setMeta('composition', s), t.dispatch(U)
        }
      }
      return
    }
  t.input.domChangeCount++,
    t.state.selection.from < t.state.selection.to &&
      p.start == p.endB &&
      t.state.selection instanceof Me &&
      (p.start > t.state.selection.from &&
      p.start <= t.state.selection.from + 2 &&
      t.state.selection.from >= c.from
        ? (p.start = t.state.selection.from)
        : p.endA < t.state.selection.to &&
          p.endA >= t.state.selection.to - 2 &&
          t.state.selection.to <= c.to &&
          ((p.endB += t.state.selection.to - p.endA), (p.endA = t.state.selection.to))),
    Jn &&
      Ps <= 11 &&
      p.endB == p.start + 1 &&
      p.endA == p.start &&
      p.start > c.from &&
      c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == '  ' &&
      (p.start--, p.endA--, p.endB--)
  let m = c.doc.resolveNoCache(p.start - c.from),
    g = c.doc.resolveNoCache(p.endB - c.from),
    _ = u.resolve(p.start),
    v = m.sameParent(g) && m.parent.inlineContent && _.end() >= p.endA,
    T
  if (
    ((Rl &&
      t.input.lastIOSEnter > Date.now() - 225 &&
      (!v || i.some((k) => k.nodeName == 'DIV' || k.nodeName == 'P'))) ||
      (!v &&
        m.pos < c.doc.content.size &&
        !m.sameParent(g) &&
        (T = Fe.findFrom(c.doc.resolve(m.pos + 1), 1, !0)) &&
        T.head == g.pos)) &&
    t.someProp('handleKeyDown', (k) => k(t, yo(13, 'Enter')))
  ) {
    t.input.lastIOSEnter = 0
    return
  }
  if (
    t.state.selection.anchor > p.start &&
    oG(u, p.start, p.endA, m, g) &&
    t.someProp('handleKeyDown', (k) => k(t, yo(8, 'Backspace')))
  ) {
    Mr && Bn && t.domObserver.suppressSelectionUpdates()
    return
  }
  Bn && Mr && p.endB == p.start && (t.input.lastAndroidDelete = Date.now()),
    Mr &&
      !v &&
      m.start() != g.start() &&
      g.parentOffset == 0 &&
      m.depth == g.depth &&
      c.sel &&
      c.sel.anchor == c.sel.head &&
      c.sel.head == p.endA &&
      ((p.endB -= 2),
      (g = c.doc.resolveNoCache(p.endB - c.from)),
      setTimeout(() => {
        t.someProp('handleKeyDown', function (k) {
          return k(t, yo(13, 'Enter'))
        })
      }, 20))
  let S = p.start,
    I = p.endA,
    w,
    O,
    P
  if (v) {
    if (m.pos == g.pos)
      Jn &&
        Ps <= 11 &&
        m.parentOffset == 0 &&
        (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Hi(t), 20)),
        (w = t.state.tr.delete(S, I)),
        (O = u.resolve(p.start).marksAcross(u.resolve(p.endA)))
    else if (
      p.endA == p.endB &&
      (P = sG(
        m.parent.content.cut(m.parentOffset, g.parentOffset),
        _.parent.content.cut(_.parentOffset, p.endA - _.start())
      ))
    )
      (w = t.state.tr), P.type == 'add' ? w.addMark(S, I, P.mark) : w.removeMark(S, I, P.mark)
    else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let k = m.parent.textBetween(m.parentOffset, g.parentOffset)
      if (t.someProp('handleTextInput', (U) => U(t, S, I, k))) return
      w = t.state.tr.insertText(k, S, I)
    }
  }
  if (
    (w || (w = t.state.tr.replace(S, I, c.doc.slice(p.start - c.from, p.endB - c.from))), c.sel)
  ) {
    let k = US(t, w.doc, c.sel)
    k &&
      !(
        (Bn &&
          Mr &&
          t.composing &&
          k.empty &&
          (p.start != p.endB || t.input.lastAndroidDelete < Date.now() - 100) &&
          (k.head == S || k.head == w.mapping.map(I) - 1)) ||
        (Jn && k.empty && k.head == S)
      ) &&
      w.setSelection(k)
  }
  O && w.ensureMarks(O), s && w.setMeta('composition', s), t.dispatch(w.scrollIntoView())
}
function US(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size
    ? null
    : j1(t, e.resolve(n.anchor), e.resolve(n.head))
}
function sG(t, e) {
  let n = t.firstChild.marks,
    r = e.firstChild.marks,
    i = n,
    s = r,
    o,
    a,
    l
  for (let u = 0; u < r.length; u++) i = r[u].removeFromSet(i)
  for (let u = 0; u < n.length; u++) s = n[u].removeFromSet(s)
  if (i.length == 1 && s.length == 0)
    (a = i[0]), (o = 'add'), (l = (u) => u.mark(a.addToSet(u.marks)))
  else if (i.length == 0 && s.length == 1)
    (a = s[0]), (o = 'remove'), (l = (u) => u.mark(a.removeFromSet(u.marks)))
  else return null
  let c = []
  for (let u = 0; u < e.childCount; u++) c.push(l(e.child(u)))
  if (H.from(c).eq(t)) return { mark: a, type: o }
}
function oG(t, e, n, r, i) {
  if (n - e <= i.pos - r.pos || Kg(r, !0, !1) < i.pos) return !1
  let s = t.resolve(e)
  if (!r.parent.isTextblock) {
    let a = s.nodeAfter
    return a != null && n == e + a.nodeSize
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock) return !1
  let o = t.resolve(Kg(s, !0, !0))
  return !o.parent.isTextblock || o.pos > n || Kg(o, !0, !1) < n
    ? !1
    : r.parent.content.cut(r.parentOffset).eq(o.parent.content)
}
function Kg(t, e, n) {
  let r = t.depth,
    i = e ? t.end() : t.pos
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); ) r--, i++, (e = !1)
  if (n) {
    let s = t.node(r).maybeChild(t.indexAfter(r))
    for (; s && !s.isLeaf; ) (s = s.firstChild), i++
  }
  return i
}
function aG(t, e, n, r, i) {
  let s = t.findDiffStart(e, n)
  if (s == null) return null
  let { a: o, b: a } = t.findDiffEnd(e, n + t.size, n + e.size)
  if (i == 'end') {
    let l = Math.max(0, s - Math.min(o, a))
    r -= o + l - s
  }
  if (o < s && t.size < e.size) {
    let l = r <= s && r >= o ? s - r : 0
    ;(s -= l),
      s && s < e.size && $S(e.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1),
      (a = s + (a - o)),
      (o = s)
  } else if (a < s) {
    let l = r <= s && r >= a ? s - r : 0
    ;(s -= l),
      s && s < t.size && $S(t.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1),
      (o = s + (o - a)),
      (a = s)
  }
  return { start: s, endA: o, endB: a }
}
function $S(t) {
  if (t.length != 2) return !1
  let e = t.charCodeAt(0),
    n = t.charCodeAt(1)
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319
}
class lG {
  constructor(e, n) {
    ;(this._root = null),
      (this.focused = !1),
      (this.trackWrites = null),
      (this.mounted = !1),
      (this.markCursor = null),
      (this.cursorWrapper = null),
      (this.lastSelectedViewDesc = void 0),
      (this.input = new RW()),
      (this.prevDirectPlugins = []),
      (this.pluginViews = []),
      (this.requiresGeckoHackNode = !1),
      (this.dragging = null),
      (this._props = n),
      (this.state = n.state),
      (this.directPlugins = n.plugins || []),
      this.directPlugins.forEach(GS),
      (this.dispatch = this.dispatch.bind(this)),
      (this.dom = (e && e.mount) || document.createElement('div')),
      e &&
        (e.appendChild
          ? e.appendChild(this.dom)
          : typeof e == 'function'
          ? e(this.dom)
          : e.mount && (this.mounted = !0)),
      (this.editable = jS(this)),
      zS(this),
      (this.nodeViews = WS(this)),
      (this.docView = TS(this.state.doc, HS(this), qg(this), this.dom, this)),
      (this.domObserver = new XW(this, (r, i, s, o) => iG(this, r, i, s, o))),
      this.domObserver.start(),
      kW(this),
      this.updatePluginViews()
  }
  get composing() {
    return this.input.composing
  }
  get props() {
    if (this._props.state != this.state) {
      let e = this._props
      this._props = {}
      for (let n in e) this._props[n] = e[n]
      this._props.state = this.state
    }
    return this._props
  }
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Z_(this)
    let n = this._props
    ;(this._props = e),
      e.plugins && (e.plugins.forEach(GS), (this.directPlugins = e.plugins)),
      this.updateStateInner(e.state, n)
  }
  setProps(e) {
    let n = {}
    for (let r in this._props) n[r] = this._props[r]
    n.state = this.state
    for (let r in e) n[r] = e[r]
    this.update(n)
  }
  updateState(e) {
    this.updateStateInner(e, this._props)
  }
  updateStateInner(e, n) {
    var r
    let i = this.state,
      s = !1,
      o = !1
    e.storedMarks && this.composing && (oM(this), (o = !0)), (this.state = e)
    let a = i.plugins != e.plugins || this._props.plugins != n.plugins
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let f = WS(this)
      uG(f, this.nodeViews) && ((this.nodeViews = f), (s = !0))
    }
    ;(a || n.handleDOMEvents != this._props.handleDOMEvents) && Z_(this),
      (this.editable = jS(this)),
      zS(this)
    let l = qg(this),
      c = HS(this),
      u =
        i.plugins != e.plugins && !i.doc.eq(e.doc)
          ? 'reset'
          : e.scrollToSelection > i.scrollToSelection
          ? 'to selection'
          : 'preserve',
      h = s || !this.docView.matchesNode(e.doc, c, l)
    ;(h || !e.selection.eq(i.selection)) && (o = !0)
    let d = u == 'preserve' && o && this.dom.style.overflowAnchor == null && jj(this)
    if (o) {
      this.domObserver.stop()
      let f =
        h &&
        (Jn || Bn) &&
        !this.composing &&
        !i.selection.empty &&
        !e.selection.empty &&
        cG(i.selection, e.selection)
      if (h) {
        let p = Bn ? (this.trackWrites = this.domSelectionRange().focusNode) : null
        this.composing && (this.input.compositionNode = HW(this)),
          (s || !this.docView.update(e.doc, c, l, this)) &&
            (this.docView.updateOuterDeco(c),
            this.docView.destroy(),
            (this.docView = TS(e.doc, c, l, this.dom, this))),
          p && !this.trackWrites && (f = !0)
      }
      f ||
      !(
        this.input.mouseDown &&
        this.domObserver.currentSelection.eq(this.domSelectionRange()) &&
        pW(this)
      )
        ? Hi(this, f)
        : (qN(this, e.selection), this.domObserver.setCurSelection()),
        this.domObserver.start()
    }
    this.updatePluginViews(i),
      !((r = this.dragging) === null || r === void 0) &&
        r.node &&
        !i.doc.eq(e.doc) &&
        this.updateDraggedNode(this.dragging, i),
      u == 'reset'
        ? (this.dom.scrollTop = 0)
        : u == 'to selection'
        ? this.scrollToSelection()
        : d && Wj(d)
  }
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode
    if (!this.someProp('handleScrollToSelection', (n) => n(this)))
      if (this.state.selection instanceof Ee) {
        let n = this.docView.domAfterPos(this.state.selection.from)
        n.nodeType == 1 && gS(this, n.getBoundingClientRect(), e)
      } else gS(this, this.coordsAtPos(this.state.selection.head, 1), e)
  }
  destroyPluginViews() {
    let e
    for (; (e = this.pluginViews.pop()); ) e.destroy && e.destroy()
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      ;(this.prevDirectPlugins = this.directPlugins), this.destroyPluginViews()
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n]
        r.spec.view && this.pluginViews.push(r.spec.view(this))
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n]
        r.spec.view && this.pluginViews.push(r.spec.view(this))
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n]
        r.update && r.update(this, e)
      }
  }
  updateDraggedNode(e, n) {
    let r = e.node,
      i = -1
    if (this.state.doc.nodeAt(r.from) == r.node) i = r.from
    else {
      let s = r.from + (this.state.doc.content.size - n.doc.content.size)
      ;(s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s)
    }
    this.dragging = new lM(e.slice, e.move, i < 0 ? void 0 : Ee.create(this.state.doc, i))
  }
  someProp(e, n) {
    let r = this._props && this._props[e],
      i
    if (r != null && (i = n ? n(r) : r)) return i
    for (let o = 0; o < this.directPlugins.length; o++) {
      let a = this.directPlugins[o].props[e]
      if (a != null && (i = n ? n(a) : a)) return i
    }
    let s = this.state.plugins
    if (s)
      for (let o = 0; o < s.length; o++) {
        let a = s[o].props[e]
        if (a != null && (i = n ? n(a) : a)) return i
      }
  }
  hasFocus() {
    if (Jn) {
      let e = this.root.activeElement
      if (e == this.dom) return !0
      if (!e || !this.dom.contains(e)) return !1
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == 'false') return !1
        e = e.parentElement
      }
      return !0
    }
    return this.root.activeElement == this.dom
  }
  focus() {
    this.domObserver.stop(), this.editable && Gj(this.dom), Hi(this), this.domObserver.start()
  }
  get root() {
    let e = this._root
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
          return (
            n.getSelection ||
              (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()),
            (this._root = n)
          )
    }
    return e || document
  }
  updateRoot() {
    this._root = null
  }
  posAtCoords(e) {
    return Qj(this, e)
  }
  coordsAtPos(e, n = 1) {
    return BN(this, e, n)
  }
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n)
  }
  nodeDOM(e) {
    let n = this.docView.descAt(e)
    return n ? n.nodeDOM : null
  }
  posAtDOM(e, n, r = -1) {
    let i = this.docView.posFromDOM(e, n, r)
    if (i == null) throw new RangeError('DOM position not inside the editor')
    return i
  }
  endOfTextblock(e, n) {
    return nW(this, n || this.state, e)
  }
  pasteHTML(e, n) {
    return xu(this, '', e, !1, n || new ClipboardEvent('paste'))
  }
  pasteText(e, n) {
    return xu(this, e, null, !0, n || new ClipboardEvent('paste'))
  }
  destroy() {
    this.docView &&
      (OW(this),
      this.destroyPluginViews(),
      this.mounted
        ? (this.docView.update(this.state.doc, [], qg(this), this), (this.dom.textContent = ''))
        : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
      this.docView.destroy(),
      (this.docView = null),
      Mj())
  }
  get isDestroyed() {
    return this.docView == null
  }
  dispatchEvent(e) {
    return MW(this, e)
  }
  dispatch(e) {
    let n = this._props.dispatchTransaction
    n ? n.call(this, e) : this.updateState(this.state.apply(e))
  }
  domSelectionRange() {
    let e = this.domSelection()
    return (
      ($n && this.root.nodeType === 11 && Vj(this.dom.ownerDocument) == this.dom && eG(this, e)) ||
      e
    )
  }
  domSelection() {
    return this.root.getSelection()
  }
}
function HS(t) {
  let e = Object.create(null)
  return (
    (e.class = 'ProseMirror'),
    (e.contenteditable = String(t.editable)),
    t.someProp('attributes', (n) => {
      if ((typeof n == 'function' && (n = n(t.state)), n))
        for (let r in n)
          r == 'class'
            ? (e.class += ' ' + n[r])
            : r == 'style'
            ? (e.style = (e.style ? e.style + ';' : '') + n[r])
            : !e[r] && r != 'contenteditable' && r != 'nodeName' && (e[r] = String(n[r]))
    }),
    e.translate || (e.translate = 'no'),
    [wr.node(0, t.state.doc.content.size, e)]
  )
}
function zS(t) {
  if (t.markCursor) {
    let e = document.createElement('img')
    ;(e.className = 'ProseMirror-separator'),
      e.setAttribute('mark-placeholder', 'true'),
      e.setAttribute('alt', ''),
      (t.cursorWrapper = {
        dom: e,
        deco: wr.widget(t.state.selection.head, e, { raw: !0, marks: t.markCursor })
      })
  } else t.cursorWrapper = null
}
function jS(t) {
  return !t.someProp('editable', (e) => e(t.state) === !1)
}
function cG(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head))
  return t.$anchor.start(n) != e.$anchor.start(n)
}
function WS(t) {
  let e = Object.create(null)
  function n(r) {
    for (let i in r) Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i])
  }
  return t.someProp('nodeViews', n), t.someProp('markViews', n), e
}
function uG(t, e) {
  let n = 0,
    r = 0
  for (let i in t) {
    if (t[i] != e[i]) return !0
    n++
  }
  for (let i in e) r++
  return n != r
}
function GS(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError('Plugins passed directly to the view must not have a state component')
}
var Ws = {
    8: 'Backspace',
    9: 'Tab',
    10: 'Enter',
    12: 'NumLock',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    44: 'PrintScreen',
    45: 'Insert',
    46: 'Delete',
    59: ';',
    61: '=',
    91: 'Meta',
    92: 'Meta',
    106: '*',
    107: '+',
    108: ',',
    109: '-',
    110: '.',
    111: '/',
    144: 'NumLock',
    145: 'ScrollLock',
    160: 'Shift',
    161: 'Shift',
    162: 'Control',
    163: 'Control',
    164: 'Alt',
    165: 'Alt',
    173: '-',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: "'"
  },
  Zf = {
    48: ')',
    49: '!',
    50: '@',
    51: '#',
    52: '$',
    53: '%',
    54: '^',
    55: '&',
    56: '*',
    57: '(',
    59: ':',
    61: '+',
    173: '_',
    186: ':',
    187: '+',
    188: '<',
    189: '_',
    190: '>',
    191: '?',
    192: '~',
    219: '{',
    220: '|',
    221: '}',
    222: '"'
  },
  hG = typeof navigator < 'u' && /Mac/.test(navigator.platform),
  dG =
    typeof navigator < 'u' &&
    /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
for (var gn = 0; gn < 10; gn++) Ws[48 + gn] = Ws[96 + gn] = String(gn)
for (var gn = 1; gn <= 24; gn++) Ws[gn + 111] = 'F' + gn
for (var gn = 65; gn <= 90; gn++)
  (Ws[gn] = String.fromCharCode(gn + 32)), (Zf[gn] = String.fromCharCode(gn))
for (var Yg in Ws) Zf.hasOwnProperty(Yg) || (Zf[Yg] = Ws[Yg])
function fG(t) {
  var e =
      (hG && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
      (dG && t.shiftKey && t.key && t.key.length == 1) ||
      t.key == 'Unidentified',
    n = (!e && t.key) || (t.shiftKey ? Zf : Ws)[t.keyCode] || t.key || 'Unidentified'
  return (
    n == 'Esc' && (n = 'Escape'),
    n == 'Del' && (n = 'Delete'),
    n == 'Left' && (n = 'ArrowLeft'),
    n == 'Up' && (n = 'ArrowUp'),
    n == 'Right' && (n = 'ArrowRight'),
    n == 'Down' && (n = 'ArrowDown'),
    n
  )
}
const pG = typeof navigator < 'u' ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1
function mG(t) {
  let e = t.split(/-(?!$)/),
    n = e[e.length - 1]
  n == 'Space' && (n = ' ')
  let r, i, s, o
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a]
    if (/^(cmd|meta|m)$/i.test(l)) o = !0
    else if (/^a(lt)?$/i.test(l)) r = !0
    else if (/^(c|ctrl|control)$/i.test(l)) i = !0
    else if (/^s(hift)?$/i.test(l)) s = !0
    else if (/^mod$/i.test(l)) pG ? (o = !0) : (i = !0)
    else throw new Error('Unrecognized modifier name: ' + l)
  }
  return (
    r && (n = 'Alt-' + n),
    i && (n = 'Ctrl-' + n),
    o && (n = 'Meta-' + n),
    s && (n = 'Shift-' + n),
    n
  )
}
function gG(t) {
  let e = Object.create(null)
  for (let n in t) e[mG(n)] = t[n]
  return e
}
function Jg(t, e, n = !0) {
  return (
    e.altKey && (t = 'Alt-' + t),
    e.ctrlKey && (t = 'Ctrl-' + t),
    e.metaKey && (t = 'Meta-' + t),
    n && e.shiftKey && (t = 'Shift-' + t),
    t
  )
}
function yG(t) {
  return new Cr({ props: { handleKeyDown: fM(t) } })
}
function fM(t) {
  let e = gG(t)
  return function (n, r) {
    let i = fG(r),
      s,
      o = e[Jg(i, r)]
    if (o && o(n.state, n.dispatch, n)) return !0
    if (i.length == 1 && i != ' ') {
      if (r.shiftKey) {
        let a = e[Jg(i, r, !1)]
        if (a && a(n.state, n.dispatch, n)) return !0
      }
      if (
        (r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) &&
        (s = Ws[r.keyCode]) &&
        s != i
      ) {
        let a = e[Jg(s, r)]
        if (a && a(n.state, n.dispatch, n)) return !0
      }
    }
    return !1
  }
}
const _G = (t, e) =>
  t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0)
function pM(t, e) {
  let { $cursor: n } = t.selection
  return !n || (e ? !e.endOfTextblock('backward', t) : n.parentOffset > 0) ? null : n
}
const vG = (t, e, n) => {
    let r = pM(t, n)
    if (!r) return !1
    let i = J1(r)
    if (!i) {
      let o = r.blockRange(),
        a = o && ql(o)
      return a == null ? !1 : (e && e(t.tr.lift(o, a).scrollIntoView()), !0)
    }
    let s = i.nodeBefore
    if (!s.type.spec.isolating && _M(t, i, e)) return !0
    if (r.parent.content.size == 0 && (kl(s, 'end') || Ee.isSelectable(s))) {
      let o = bm(t.doc, r.before(), r.after(), ie.empty)
      if (o && o.slice.size < o.to - o.from) {
        if (e) {
          let a = t.tr.step(o)
          a.setSelection(
            kl(s, 'end')
              ? Fe.findFrom(a.doc.resolve(a.mapping.map(i.pos, -1)), -1)
              : Ee.create(a.doc, i.pos - s.nodeSize)
          ),
            e(a.scrollIntoView())
        }
        return !0
      }
    }
    return s.isAtom && i.depth == r.depth - 1
      ? (e && e(t.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0)
      : !1
  },
  bG = (t, e, n) => {
    let r = pM(t, n)
    if (!r) return !1
    let i = J1(r)
    return i ? mM(t, i, e) : !1
  },
  EG = (t, e, n) => {
    let r = gM(t, n)
    if (!r) return !1
    let i = Q1(r)
    return i ? mM(t, i, e) : !1
  }
function mM(t, e, n) {
  let r = e.nodeBefore,
    i = r,
    s = e.pos - 1
  for (; !i.isTextblock; s--) {
    if (i.type.spec.isolating) return !1
    let u = i.lastChild
    if (!u) return !1
    i = u
  }
  let o = e.nodeAfter,
    a = o,
    l = e.pos + 1
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating) return !1
    let u = a.firstChild
    if (!u) return !1
    a = u
  }
  let c = bm(t.doc, s, l, ie.empty)
  if (!c || c.from != s || (c instanceof Zt && c.slice.size >= l - s)) return !1
  if (n) {
    let u = t.tr.step(c)
    u.setSelection(Me.create(u.doc, s)), n(u.scrollIntoView())
  }
  return !0
}
function kl(t, e, n = !1) {
  for (let r = t; r; r = e == 'start' ? r.firstChild : r.lastChild) {
    if (r.isTextblock) return !0
    if (n && r.childCount != 1) return !1
  }
  return !1
}
const TG = (t, e, n) => {
  let { $head: r, empty: i } = t.selection,
    s = r
  if (!i) return !1
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock('backward', t) : r.parentOffset > 0) return !1
    s = J1(r)
  }
  let o = s && s.nodeBefore
  return !o || !Ee.isSelectable(o)
    ? !1
    : (e && e(t.tr.setSelection(Ee.create(t.doc, s.pos - o.nodeSize)).scrollIntoView()), !0)
}
function J1(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1))
      if (t.node(e).type.spec.isolating) break
    }
  return null
}
function gM(t, e) {
  let { $cursor: n } = t.selection
  return !n || (e ? !e.endOfTextblock('forward', t) : n.parentOffset < n.parent.content.size)
    ? null
    : n
}
const wG = (t, e, n) => {
    let r = gM(t, n)
    if (!r) return !1
    let i = Q1(r)
    if (!i) return !1
    let s = i.nodeAfter
    if (_M(t, i, e)) return !0
    if (r.parent.content.size == 0 && (kl(s, 'start') || Ee.isSelectable(s))) {
      let o = bm(t.doc, r.before(), r.after(), ie.empty)
      if (o && o.slice.size < o.to - o.from) {
        if (e) {
          let a = t.tr.step(o)
          a.setSelection(
            kl(s, 'start')
              ? Fe.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1)
              : Ee.create(a.doc, a.mapping.map(i.pos))
          ),
            e(a.scrollIntoView())
        }
        return !0
      }
    }
    return s.isAtom && i.depth == r.depth - 1
      ? (e && e(t.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0)
      : !1
  },
  SG = (t, e, n) => {
    let { $head: r, empty: i } = t.selection,
      s = r
    if (!i) return !1
    if (r.parent.isTextblock) {
      if (n ? !n.endOfTextblock('forward', t) : r.parentOffset < r.parent.content.size) return !1
      s = Q1(r)
    }
    let o = s && s.nodeAfter
    return !o || !Ee.isSelectable(o)
      ? !1
      : (e && e(t.tr.setSelection(Ee.create(t.doc, s.pos)).scrollIntoView()), !0)
  }
function Q1(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e)
      if (t.index(e) + 1 < n.childCount) return t.doc.resolve(t.after(e + 1))
      if (n.type.spec.isolating) break
    }
  return null
}
const IG = (t, e) => {
    let n = t.selection,
      r = n instanceof Ee,
      i
    if (r) {
      if (n.node.isTextblock || !eo(t.doc, n.from)) return !1
      i = n.from
    } else if (((i = vm(t.doc, n.from, -1)), i == null)) return !1
    if (e) {
      let s = t.tr.join(i)
      r && s.setSelection(Ee.create(s.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)),
        e(s.scrollIntoView())
    }
    return !0
  },
  AG = (t, e) => {
    let n = t.selection,
      r
    if (n instanceof Ee) {
      if (n.node.isTextblock || !eo(t.doc, n.to)) return !1
      r = n.to
    } else if (((r = vm(t.doc, n.to, 1)), r == null)) return !1
    return e && e(t.tr.join(r).scrollIntoView()), !0
  },
  CG = (t, e) => {
    let { $from: n, $to: r } = t.selection,
      i = n.blockRange(r),
      s = i && ql(i)
    return s == null ? !1 : (e && e(t.tr.lift(i, s).scrollIntoView()), !0)
  },
  RG = (t, e) => {
    let { $head: n, $anchor: r } = t.selection
    return !n.parent.type.spec.code || !n.sameParent(r)
      ? !1
      : (e &&
          e(
            t.tr
              .insertText(
                `
`
              )
              .scrollIntoView()
          ),
        !0)
  }
function yM(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e)
    if (n.isTextblock && !n.hasRequiredAttrs()) return n
  }
  return null
}
const kG = (t, e) => {
    let { $head: n, $anchor: r } = t.selection
    if (!n.parent.type.spec.code || !n.sameParent(r)) return !1
    let i = n.node(-1),
      s = n.indexAfter(-1),
      o = yM(i.contentMatchAt(s))
    if (!o || !i.canReplaceWith(s, s, o)) return !1
    if (e) {
      let a = n.after(),
        l = t.tr.replaceWith(a, a, o.createAndFill())
      l.setSelection(Fe.near(l.doc.resolve(a), 1)), e(l.scrollIntoView())
    }
    return !0
  },
  OG = (t, e) => {
    let n = t.selection,
      { $from: r, $to: i } = n
    if (n instanceof Br || r.parent.inlineContent || i.parent.inlineContent) return !1
    let s = yM(i.parent.contentMatchAt(i.indexAfter()))
    if (!s || !s.isTextblock) return !1
    if (e) {
      let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos,
        a = t.tr.insert(o, s.createAndFill())
      a.setSelection(Me.create(a.doc, o + 1)), e(a.scrollIntoView())
    }
    return !0
  },
  NG = (t, e) => {
    let { $cursor: n } = t.selection
    if (!n || n.parent.content.size) return !1
    if (n.depth > 1 && n.after() != n.end(-1)) {
      let s = n.before()
      if (tl(t.doc, s)) return e && e(t.tr.split(s).scrollIntoView()), !0
    }
    let r = n.blockRange(),
      i = r && ql(r)
    return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0)
  },
  MG = (t, e) => {
    let { $from: n, to: r } = t.selection,
      i,
      s = n.sharedDepth(r)
    return s == 0 ? !1 : ((i = n.before(s)), e && e(t.tr.setSelection(Ee.create(t.doc, i))), !0)
  }
function PG(t, e, n) {
  let r = e.nodeBefore,
    i = e.nodeAfter,
    s = e.index()
  return !r || !i || !r.type.compatibleContent(i.type)
    ? !1
    : !r.content.size && e.parent.canReplace(s - 1, s)
    ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0)
    : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || eo(t.doc, e.pos))
    ? !1
    : (n &&
        n(
          t.tr
            .clearIncompatible(e.pos, r.type, r.contentMatchAt(r.childCount))
            .join(e.pos)
            .scrollIntoView()
        ),
      !0)
}
function _M(t, e, n) {
  let r = e.nodeBefore,
    i = e.nodeAfter,
    s,
    o
  if (r.type.spec.isolating || i.type.spec.isolating) return !1
  if (PG(t, e, n)) return !0
  let a = e.parent.canReplace(e.index(), e.index() + 1)
  if (
    a &&
    (s = (o = r.contentMatchAt(r.childCount)).findWrapping(i.type)) &&
    o.matchType(s[0] || i.type).validEnd
  ) {
    if (n) {
      let h = e.pos + i.nodeSize,
        d = H.empty
      for (let m = s.length - 1; m >= 0; m--) d = H.from(s[m].create(null, d))
      d = H.from(r.copy(d))
      let f = t.tr.step(new tn(e.pos - 1, h, e.pos, h, new ie(d, 1, 0), s.length, !0)),
        p = h + 2 * s.length
      eo(f.doc, p) && f.join(p), n(f.scrollIntoView())
    }
    return !0
  }
  let l = Fe.findFrom(e, 1),
    c = l && l.$from.blockRange(l.$to),
    u = c && ql(c)
  if (u != null && u >= e.depth) return n && n(t.tr.lift(c, u).scrollIntoView()), !0
  if (a && kl(i, 'start', !0) && kl(r, 'end')) {
    let h = r,
      d = []
    for (; d.push(h), !h.isTextblock; ) h = h.lastChild
    let f = i,
      p = 1
    for (; !f.isTextblock; f = f.firstChild) p++
    if (h.canReplace(h.childCount, h.childCount, f.content)) {
      if (n) {
        let m = H.empty
        for (let _ = d.length - 1; _ >= 0; _--) m = H.from(d[_].copy(m))
        let g = t.tr.step(
          new tn(
            e.pos - d.length,
            e.pos + i.nodeSize,
            e.pos + p,
            e.pos + i.nodeSize - p,
            new ie(m, d.length, 0),
            0,
            !0
          )
        )
        n(g.scrollIntoView())
      }
      return !0
    }
  }
  return !1
}
function vM(t) {
  return function (e, n) {
    let r = e.selection,
      i = t < 0 ? r.$from : r.$to,
      s = i.depth
    for (; i.node(s).isInline; ) {
      if (!s) return !1
      s--
    }
    return i.node(s).isTextblock
      ? (n && n(e.tr.setSelection(Me.create(e.doc, t < 0 ? i.start(s) : i.end(s)))), !0)
      : !1
  }
}
const xG = vM(-1),
  DG = vM(1)
function LG(t, e = null) {
  return function (n, r) {
    let { $from: i, $to: s } = n.selection,
      o = i.blockRange(s),
      a = o && U1(o, t, e)
    return a ? (r && r(n.tr.wrap(o, a).scrollIntoView()), !0) : !1
  }
}
function qS(t, e = null) {
  return function (n, r) {
    let i = !1
    for (let s = 0; s < n.selection.ranges.length && !i; s++) {
      let {
        $from: { pos: o },
        $to: { pos: a }
      } = n.selection.ranges[s]
      n.doc.nodesBetween(o, a, (l, c) => {
        if (i) return !1
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t) i = !0
          else {
            let u = n.doc.resolve(c),
              h = u.index()
            i = u.parent.canReplaceWith(h, h + 1, t)
          }
      })
    }
    if (!i) return !1
    if (r) {
      let s = n.tr
      for (let o = 0; o < n.selection.ranges.length; o++) {
        let {
          $from: { pos: a },
          $to: { pos: l }
        } = n.selection.ranges[o]
        s.setBlockType(a, l, t, e)
      }
      r(s.scrollIntoView())
    }
    return !0
  }
}
typeof navigator < 'u'
  ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
  : typeof os < 'u' && os.platform && os.platform() == 'darwin'
function VG(t, e = null) {
  return function (n, r) {
    let { $from: i, $to: s } = n.selection,
      o = i.blockRange(s),
      a = !1,
      l = o
    if (!o) return !1
    if (o.depth >= 2 && i.node(o.depth - 1).type.compatibleContent(t) && o.startIndex == 0) {
      if (i.index(o.depth - 1) == 0) return !1
      let u = n.doc.resolve(o.start - 2)
      ;(l = new Wf(u, u, o.depth)),
        o.endIndex < o.parent.childCount && (o = new Wf(i, n.doc.resolve(s.end(o.depth)), o.depth)),
        (a = !0)
    }
    let c = U1(l, t, e, o)
    return c ? (r && r(FG(n.tr, o, c, a, t).scrollIntoView()), !0) : !1
  }
}
function FG(t, e, n, r, i) {
  let s = H.empty
  for (let u = n.length - 1; u >= 0; u--) s = H.from(n[u].type.create(n[u].attrs, s))
  t.step(new tn(e.start - (r ? 2 : 0), e.end, e.start, e.end, new ie(s, 0, 0), n.length, !0))
  let o = 0
  for (let u = 0; u < n.length; u++) n[u].type == i && (o = u + 1)
  let a = n.length - o,
    l = e.start + n.length - (r ? 2 : 0),
    c = e.parent
  for (let u = e.startIndex, h = e.endIndex, d = !0; u < h; u++, d = !1)
    !d && tl(t.doc, l, a) && (t.split(l, a), (l += 2 * a)), (l += c.child(u).nodeSize)
  return t
}
function BG(t) {
  return function (e, n) {
    let { $from: r, $to: i } = e.selection,
      s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == t)
    return s ? (n ? (r.node(s.depth - 1).type == t ? UG(e, n, t, s) : $G(e, n, s)) : !0) : !1
  }
}
function UG(t, e, n, r) {
  let i = t.tr,
    s = r.end,
    o = r.$to.end(r.depth)
  s < o &&
    (i.step(new tn(s - 1, o, s, o, new ie(H.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)),
    (r = new Wf(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth)))
  const a = ql(r)
  if (a == null) return !1
  i.lift(r, a)
  let l = i.mapping.map(s, -1) - 1
  return eo(i.doc, l) && i.join(l), e(i.scrollIntoView()), !0
}
function $G(t, e, n) {
  let r = t.tr,
    i = n.parent
  for (let f = n.end, p = n.endIndex - 1, m = n.startIndex; p > m; p--)
    (f -= i.child(p).nodeSize), r.delete(f - 1, f + 1)
  let s = r.doc.resolve(n.start),
    o = s.nodeAfter
  if (r.mapping.map(n.end) != n.start + s.nodeAfter.nodeSize) return !1
  let a = n.startIndex == 0,
    l = n.endIndex == i.childCount,
    c = s.node(-1),
    u = s.index(-1)
  if (!c.canReplace(u + (a ? 0 : 1), u + 1, o.content.append(l ? H.empty : H.from(i)))) return !1
  let h = s.pos,
    d = h + o.nodeSize
  return (
    r.step(
      new tn(
        h - (a ? 1 : 0),
        d + (l ? 1 : 0),
        h + 1,
        d - 1,
        new ie(
          (a ? H.empty : H.from(i.copy(H.empty))).append(l ? H.empty : H.from(i.copy(H.empty))),
          a ? 0 : 1,
          l ? 0 : 1
        ),
        a ? 0 : 1
      )
    ),
    e(r.scrollIntoView()),
    !0
  )
}
function HG(t) {
  return function (e, n) {
    let { $from: r, $to: i } = e.selection,
      s = r.blockRange(i, (c) => c.childCount > 0 && c.firstChild.type == t)
    if (!s) return !1
    let o = s.startIndex
    if (o == 0) return !1
    let a = s.parent,
      l = a.child(o - 1)
    if (l.type != t) return !1
    if (n) {
      let c = l.lastChild && l.lastChild.type == a.type,
        u = H.from(c ? t.create() : null),
        h = new ie(H.from(t.create(null, H.from(a.type.create(null, u)))), c ? 3 : 1, 0),
        d = s.start,
        f = s.end
      n(e.tr.step(new tn(d - (c ? 3 : 1), f, d, f, h, 1, !0)).scrollIntoView())
    }
    return !0
  }
}
function Im(t) {
  const { state: e, transaction: n } = t
  let { selection: r } = n,
    { doc: i } = n,
    { storedMarks: s } = n
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return s
    },
    get selection() {
      return r
    },
    get doc() {
      return i
    },
    get tr() {
      return (r = n.selection), (i = n.doc), (s = n.storedMarks), n
    }
  }
}
class Am {
  constructor(e) {
    ;(this.editor = e.editor),
      (this.rawCommands = this.editor.extensionManager.commands),
      (this.customState = e.state)
  }
  get hasCustomState() {
    return !!this.customState
  }
  get state() {
    return this.customState || this.editor.state
  }
  get commands() {
    const { rawCommands: e, editor: n, state: r } = this,
      { view: i } = n,
      { tr: s } = r,
      o = this.buildProps(s)
    return Object.fromEntries(
      Object.entries(e).map(([a, l]) => [
        a,
        (...u) => {
          const h = l(...u)(o)
          return !s.getMeta('preventDispatch') && !this.hasCustomState && i.dispatch(s), h
        }
      ])
    )
  }
  get chain() {
    return () => this.createChain()
  }
  get can() {
    return () => this.createCan()
  }
  createChain(e, n = !0) {
    const { rawCommands: r, editor: i, state: s } = this,
      { view: o } = i,
      a = [],
      l = !!e,
      c = e || s.tr,
      u = () => (
        !l && n && !c.getMeta('preventDispatch') && !this.hasCustomState && o.dispatch(c),
        a.every((d) => d === !0)
      ),
      h = {
        ...Object.fromEntries(
          Object.entries(r).map(([d, f]) => [
            d,
            (...m) => {
              const g = this.buildProps(c, n),
                _ = f(...m)(g)
              return a.push(_), h
            }
          ])
        ),
        run: u
      }
    return h
  }
  createCan(e) {
    const { rawCommands: n, state: r } = this,
      i = !1,
      s = e || r.tr,
      o = this.buildProps(s, i)
    return {
      ...Object.fromEntries(
        Object.entries(n).map(([l, c]) => [l, (...u) => c(...u)({ ...o, dispatch: void 0 })])
      ),
      chain: () => this.createChain(s, i)
    }
  }
  buildProps(e, n = !0) {
    const { rawCommands: r, editor: i, state: s } = this,
      { view: o } = i,
      a = {
        tr: e,
        editor: i,
        view: o,
        state: Im({ state: s, transaction: e }),
        dispatch: n ? () => {} : void 0,
        chain: () => this.createChain(e, n),
        can: () => this.createCan(e),
        get commands() {
          return Object.fromEntries(Object.entries(r).map(([l, c]) => [l, (...u) => c(...u)(a)]))
        }
      }
    return a
  }
}
class zG {
  constructor() {
    this.callbacks = {}
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this
  }
  emit(e, ...n) {
    const r = this.callbacks[e]
    return r && r.forEach((i) => i.apply(this, n)), this
  }
  off(e, n) {
    const r = this.callbacks[e]
    return (
      r && (n ? (this.callbacks[e] = r.filter((i) => i !== n)) : delete this.callbacks[e]), this
    )
  }
  removeAllListeners() {
    this.callbacks = {}
  }
}
function ce(t, e, n) {
  return t.config[e] === void 0 && t.parent
    ? ce(t.parent, e, n)
    : typeof t.config[e] == 'function'
    ? t.config[e].bind({ ...n, parent: t.parent ? ce(t.parent, e, n) : null })
    : t.config[e]
}
function Cm(t) {
  const e = t.filter((i) => i.type === 'extension'),
    n = t.filter((i) => i.type === 'node'),
    r = t.filter((i) => i.type === 'mark')
  return { baseExtensions: e, nodeExtensions: n, markExtensions: r }
}
function bM(t) {
  const e = [],
    { nodeExtensions: n, markExtensions: r } = Cm(t),
    i = [...n, ...r],
    s = {
      default: null,
      rendered: !0,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: !0,
      isRequired: !1
    }
  return (
    t.forEach((o) => {
      const a = { name: o.name, options: o.options, storage: o.storage },
        l = ce(o, 'addGlobalAttributes', a)
      if (!l) return
      l().forEach((u) => {
        u.types.forEach((h) => {
          Object.entries(u.attributes).forEach(([d, f]) => {
            e.push({ type: h, name: d, attribute: { ...s, ...f } })
          })
        })
      })
    }),
    i.forEach((o) => {
      const a = { name: o.name, options: o.options, storage: o.storage },
        l = ce(o, 'addAttributes', a)
      if (!l) return
      const c = l()
      Object.entries(c).forEach(([u, h]) => {
        const d = { ...s, ...h }
        typeof (d == null ? void 0 : d.default) == 'function' && (d.default = d.default()),
          d != null &&
            d.isRequired &&
            (d == null ? void 0 : d.default) === void 0 &&
            delete d.default,
          e.push({ type: o.name, name: u, attribute: d })
      })
    }),
    e
  )
}
function an(t, e) {
  if (typeof t == 'string') {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`)
    return e.nodes[t]
  }
  return t
}
function qt(...t) {
  return t
    .filter((e) => !!e)
    .reduce((e, n) => {
      const r = { ...e }
      return (
        Object.entries(n).forEach(([i, s]) => {
          if (!r[i]) {
            r[i] = s
            return
          }
          if (i === 'class') {
            const a = s ? s.split(' ') : [],
              l = r[i] ? r[i].split(' ') : [],
              c = a.filter((u) => !l.includes(u))
            r[i] = [...l, ...c].join(' ')
          } else i === 'style' ? (r[i] = [r[i], s].join('; ')) : (r[i] = s)
        }),
        r
      )
    }, {})
}
function ev(t, e) {
  return e
    .filter((n) => n.attribute.rendered)
    .map((n) =>
      n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : { [n.name]: t.attrs[n.name] }
    )
    .reduce((n, r) => qt(n, r), {})
}
function EM(t) {
  return typeof t == 'function'
}
function Ve(t, e = void 0, ...n) {
  return EM(t) ? (e ? t.bind(e)(...n) : t(...n)) : t
}
function jG(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object
}
function WG(t) {
  return typeof t != 'string'
    ? t
    : t.match(/^[+-]?(?:\d*\.)?\d+$/)
    ? Number(t)
    : t === 'true'
    ? !0
    : t === 'false'
    ? !1
    : t
}
function KS(t, e) {
  return t.style
    ? t
    : {
        ...t,
        getAttrs: (n) => {
          const r = t.getAttrs ? t.getAttrs(n) : t.attrs
          if (r === !1) return !1
          const i = e.reduce((s, o) => {
            const a = o.attribute.parseHTML ? o.attribute.parseHTML(n) : WG(n.getAttribute(o.name))
            return a == null ? s : { ...s, [o.name]: a }
          }, {})
          return { ...r, ...i }
        }
      }
}
function YS(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) => (e === 'attrs' && jG(n) ? !1 : n != null))
  )
}
function GG(t, e) {
  var n
  const r = bM(t),
    { nodeExtensions: i, markExtensions: s } = Cm(t),
    o = (n = i.find((c) => ce(c, 'topNode'))) === null || n === void 0 ? void 0 : n.name,
    a = Object.fromEntries(
      i.map((c) => {
        const u = r.filter((_) => _.type === c.name),
          h = { name: c.name, options: c.options, storage: c.storage, editor: e },
          d = t.reduce((_, v) => {
            const T = ce(v, 'extendNodeSchema', h)
            return { ..._, ...(T ? T(c) : {}) }
          }, {}),
          f = YS({
            ...d,
            content: Ve(ce(c, 'content', h)),
            marks: Ve(ce(c, 'marks', h)),
            group: Ve(ce(c, 'group', h)),
            inline: Ve(ce(c, 'inline', h)),
            atom: Ve(ce(c, 'atom', h)),
            selectable: Ve(ce(c, 'selectable', h)),
            draggable: Ve(ce(c, 'draggable', h)),
            code: Ve(ce(c, 'code', h)),
            defining: Ve(ce(c, 'defining', h)),
            isolating: Ve(ce(c, 'isolating', h)),
            attrs: Object.fromEntries(
              u.map((_) => {
                var v
                return [
                  _.name,
                  {
                    default:
                      (v = _ == null ? void 0 : _.attribute) === null || v === void 0
                        ? void 0
                        : v.default
                  }
                ]
              })
            )
          }),
          p = Ve(ce(c, 'parseHTML', h))
        p && (f.parseDOM = p.map((_) => KS(_, u)))
        const m = ce(c, 'renderHTML', h)
        m && (f.toDOM = (_) => m({ node: _, HTMLAttributes: ev(_, u) }))
        const g = ce(c, 'renderText', h)
        return g && (f.toText = g), [c.name, f]
      })
    ),
    l = Object.fromEntries(
      s.map((c) => {
        const u = r.filter((g) => g.type === c.name),
          h = { name: c.name, options: c.options, storage: c.storage, editor: e },
          d = t.reduce((g, _) => {
            const v = ce(_, 'extendMarkSchema', h)
            return { ...g, ...(v ? v(c) : {}) }
          }, {}),
          f = YS({
            ...d,
            inclusive: Ve(ce(c, 'inclusive', h)),
            excludes: Ve(ce(c, 'excludes', h)),
            group: Ve(ce(c, 'group', h)),
            spanning: Ve(ce(c, 'spanning', h)),
            code: Ve(ce(c, 'code', h)),
            attrs: Object.fromEntries(
              u.map((g) => {
                var _
                return [
                  g.name,
                  {
                    default:
                      (_ = g == null ? void 0 : g.attribute) === null || _ === void 0
                        ? void 0
                        : _.default
                  }
                ]
              })
            )
          }),
          p = Ve(ce(c, 'parseHTML', h))
        p && (f.parseDOM = p.map((g) => KS(g, u)))
        const m = ce(c, 'renderHTML', h)
        return m && (f.toDOM = (g) => m({ mark: g, HTMLAttributes: ev(g, u) })), [c.name, f]
      })
    )
  return new Jz({ topNode: o, nodes: a, marks: l })
}
function Qg(t, e) {
  return e.nodes[t] || e.marks[t] || null
}
function JS(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == 'string' ? n : n.name) === t.name) : e
}
const qG = (t, e = 500) => {
  let n = ''
  const r = t.parentOffset
  return (
    t.parent.nodesBetween(Math.max(0, r - e), r, (i, s, o, a) => {
      var l, c
      const u =
        ((c = (l = i.type.spec).toText) === null || c === void 0
          ? void 0
          : c.call(l, { node: i, pos: s, parent: o, index: a })) ||
        i.textContent ||
        '%leaf%'
      n += u.slice(0, Math.max(0, r - s))
    }),
    n
  )
}
function X1(t) {
  return Object.prototype.toString.call(t) === '[object RegExp]'
}
class Rm {
  constructor(e) {
    ;(this.find = e.find), (this.handler = e.handler)
  }
}
const KG = (t, e) => {
  if (X1(e)) return e.exec(t)
  const n = e(t)
  if (!n) return null
  const r = [n.text]
  return (
    (r.index = n.index),
    (r.input = t),
    (r.data = n.data),
    n.replaceWith &&
      (n.text.includes(n.replaceWith) ||
        console.warn(
          '[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
        ),
      r.push(n.replaceWith)),
    r
  )
}
function Xg(t) {
  var e
  const { editor: n, from: r, to: i, text: s, rules: o, plugin: a } = t,
    { view: l } = n
  if (l.composing) return !1
  const c = l.state.doc.resolve(r)
  if (
    c.parent.type.spec.code ||
    (!((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) &&
      e.marks.find((d) => d.type.spec.code))
  )
    return !1
  let u = !1
  const h = qG(c) + s
  return (
    o.forEach((d) => {
      if (u) return
      const f = KG(h, d.find)
      if (!f) return
      const p = l.state.tr,
        m = Im({ state: l.state, transaction: p }),
        g = { from: r - (f[0].length - s.length), to: i },
        { commands: _, chain: v, can: T } = new Am({ editor: n, state: m })
      d.handler({ state: m, range: g, match: f, commands: _, chain: v, can: T }) === null ||
        !p.steps.length ||
        (p.setMeta(a, { transform: p, from: r, to: i, text: s }), l.dispatch(p), (u = !0))
    }),
    u
  )
}
function YG(t) {
  const { editor: e, rules: n } = t,
    r = new Cr({
      state: {
        init() {
          return null
        },
        apply(i, s) {
          const o = i.getMeta(r)
          return o || (i.selectionSet || i.docChanged ? null : s)
        }
      },
      props: {
        handleTextInput(i, s, o, a) {
          return Xg({ editor: e, from: s, to: o, text: a, rules: n, plugin: r })
        },
        handleDOMEvents: {
          compositionend: (i) => (
            setTimeout(() => {
              const { $cursor: s } = i.state.selection
              s && Xg({ editor: e, from: s.pos, to: s.pos, text: '', rules: n, plugin: r })
            }),
            !1
          )
        },
        handleKeyDown(i, s) {
          if (s.key !== 'Enter') return !1
          const { $cursor: o } = i.state.selection
          return o
            ? Xg({
                editor: e,
                from: o.pos,
                to: o.pos,
                text: `
`,
                rules: n,
                plugin: r
              })
            : !1
        }
      },
      isInputRules: !0
    })
  return r
}
function JG(t) {
  return typeof t == 'number'
}
class QG {
  constructor(e) {
    ;(this.find = e.find), (this.handler = e.handler)
  }
}
const XG = (t, e, n) => {
  if (X1(e)) return [...t.matchAll(e)]
  const r = e(t, n)
  return r
    ? r.map((i) => {
        const s = [i.text]
        return (
          (s.index = i.index),
          (s.input = t),
          (s.data = i.data),
          i.replaceWith &&
            (i.text.includes(i.replaceWith) ||
              console.warn(
                '[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'
              ),
            s.push(i.replaceWith)),
          s
        )
      })
    : []
}
function ZG(t) {
  const { editor: e, state: n, from: r, to: i, rule: s, pasteEvent: o, dropEvent: a } = t,
    { commands: l, chain: c, can: u } = new Am({ editor: e, state: n }),
    h = []
  return (
    n.doc.nodesBetween(r, i, (f, p) => {
      if (!f.isTextblock || f.type.spec.code) return
      const m = Math.max(r, p),
        g = Math.min(i, p + f.content.size),
        _ = f.textBetween(m - p, g - p, void 0, '￼')
      XG(_, s.find, o).forEach((T) => {
        if (T.index === void 0) return
        const S = m + T.index + 1,
          I = S + T[0].length,
          w = { from: n.tr.mapping.map(S), to: n.tr.mapping.map(I) },
          O = s.handler({
            state: n,
            range: w,
            match: T,
            commands: l,
            chain: c,
            can: u,
            pasteEvent: o,
            dropEvent: a
          })
        h.push(O)
      })
    }),
    h.every((f) => f !== null)
  )
}
function eq(t) {
  const { editor: e, rules: n } = t
  let r = null,
    i = !1,
    s = !1,
    o = typeof ClipboardEvent < 'u' ? new ClipboardEvent('paste') : null,
    a = typeof DragEvent < 'u' ? new DragEvent('drop') : null
  return n.map(
    (c) =>
      new Cr({
        view(u) {
          const h = (d) => {
            var f
            r =
              !((f = u.dom.parentElement) === null || f === void 0) && f.contains(d.target)
                ? u.dom.parentElement
                : null
          }
          return (
            window.addEventListener('dragstart', h),
            {
              destroy() {
                window.removeEventListener('dragstart', h)
              }
            }
          )
        },
        props: {
          handleDOMEvents: {
            drop: (u, h) => ((s = r === u.dom.parentElement), (a = h), !1),
            paste: (u, h) => {
              var d
              const f =
                (d = h.clipboardData) === null || d === void 0 ? void 0 : d.getData('text/html')
              return (o = h), (i = !!(f != null && f.includes('data-pm-slice'))), !1
            }
          }
        },
        appendTransaction: (u, h, d) => {
          const f = u[0],
            p = f.getMeta('uiEvent') === 'paste' && !i,
            m = f.getMeta('uiEvent') === 'drop' && !s
          if (!p && !m) return
          const g = h.doc.content.findDiffStart(d.doc.content),
            _ = h.doc.content.findDiffEnd(d.doc.content)
          if (!JG(g) || !_ || g === _.b) return
          const v = d.tr,
            T = Im({ state: d, transaction: v })
          if (
            !(
              !ZG({
                editor: e,
                state: T,
                from: Math.max(g - 1, 0),
                to: _.b - 1,
                rule: c,
                pasteEvent: o,
                dropEvent: a
              }) || !v.steps.length
            )
          )
            return (
              (a = typeof DragEvent < 'u' ? new DragEvent('drop') : null),
              (o = typeof ClipboardEvent < 'u' ? new ClipboardEvent('paste') : null),
              v
            )
        }
      })
  )
}
function tq(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r)
  return [...new Set(e)]
}
class La {
  constructor(e, n) {
    ;(this.splittableMarks = []),
      (this.editor = n),
      (this.extensions = La.resolve(e)),
      (this.schema = GG(this.extensions, n)),
      this.extensions.forEach((r) => {
        var i
        this.editor.extensionStorage[r.name] = r.storage
        const s = {
          name: r.name,
          options: r.options,
          storage: r.storage,
          editor: this.editor,
          type: Qg(r.name, this.schema)
        }
        r.type === 'mark' &&
          (!((i = Ve(ce(r, 'keepOnSplit', s))) !== null && i !== void 0) || i) &&
          this.splittableMarks.push(r.name)
        const o = ce(r, 'onBeforeCreate', s)
        o && this.editor.on('beforeCreate', o)
        const a = ce(r, 'onCreate', s)
        a && this.editor.on('create', a)
        const l = ce(r, 'onUpdate', s)
        l && this.editor.on('update', l)
        const c = ce(r, 'onSelectionUpdate', s)
        c && this.editor.on('selectionUpdate', c)
        const u = ce(r, 'onTransaction', s)
        u && this.editor.on('transaction', u)
        const h = ce(r, 'onFocus', s)
        h && this.editor.on('focus', h)
        const d = ce(r, 'onBlur', s)
        d && this.editor.on('blur', d)
        const f = ce(r, 'onDestroy', s)
        f && this.editor.on('destroy', f)
      })
  }
  static resolve(e) {
    const n = La.sort(La.flatten(e)),
      r = tq(n.map((i) => i.name))
    return (
      r.length &&
        console.warn(
          `[tiptap warn]: Duplicate extension names found: [${r
            .map((i) => `'${i}'`)
            .join(', ')}]. This can lead to issues.`
        ),
      n
    )
  }
  static flatten(e) {
    return e
      .map((n) => {
        const r = { name: n.name, options: n.options, storage: n.storage },
          i = ce(n, 'addExtensions', r)
        return i ? [n, ...this.flatten(i())] : n
      })
      .flat(10)
  }
  static sort(e) {
    return e.sort((r, i) => {
      const s = ce(r, 'priority') || 100,
        o = ce(i, 'priority') || 100
      return s > o ? -1 : s < o ? 1 : 0
    })
  }
  get commands() {
    return this.extensions.reduce((e, n) => {
      const r = {
          name: n.name,
          options: n.options,
          storage: n.storage,
          editor: this.editor,
          type: Qg(n.name, this.schema)
        },
        i = ce(n, 'addCommands', r)
      return i ? { ...e, ...i() } : e
    }, {})
  }
  get plugins() {
    const { editor: e } = this,
      n = La.sort([...this.extensions].reverse()),
      r = [],
      i = [],
      s = n
        .map((o) => {
          const a = {
              name: o.name,
              options: o.options,
              storage: o.storage,
              editor: e,
              type: Qg(o.name, this.schema)
            },
            l = [],
            c = ce(o, 'addKeyboardShortcuts', a)
          let u = {}
          if (
            (o.type === 'mark' &&
              o.config.exitable &&
              (u.ArrowRight = () => Si.handleExit({ editor: e, mark: o })),
            c)
          ) {
            const m = Object.fromEntries(
              Object.entries(c()).map(([g, _]) => [g, () => _({ editor: e })])
            )
            u = { ...u, ...m }
          }
          const h = yG(u)
          l.push(h)
          const d = ce(o, 'addInputRules', a)
          JS(o, e.options.enableInputRules) && d && r.push(...d())
          const f = ce(o, 'addPasteRules', a)
          JS(o, e.options.enablePasteRules) && f && i.push(...f())
          const p = ce(o, 'addProseMirrorPlugins', a)
          if (p) {
            const m = p()
            l.push(...m)
          }
          return l
        })
        .flat()
    return [YG({ editor: e, rules: r }), ...eq({ editor: e, rules: i }), ...s]
  }
  get attributes() {
    return bM(this.extensions)
  }
  get nodeViews() {
    const { editor: e } = this,
      { nodeExtensions: n } = Cm(this.extensions)
    return Object.fromEntries(
      n
        .filter((r) => !!ce(r, 'addNodeView'))
        .map((r) => {
          const i = this.attributes.filter((l) => l.type === r.name),
            s = {
              name: r.name,
              options: r.options,
              storage: r.storage,
              editor: e,
              type: an(r.name, this.schema)
            },
            o = ce(r, 'addNodeView', s)
          if (!o) return []
          const a = (l, c, u, h) => {
            const d = ev(l, i)
            return o()({
              editor: e,
              node: l,
              getPos: u,
              decorations: h,
              HTMLAttributes: d,
              extension: r
            })
          }
          return [r.name, a]
        })
    )
  }
}
function nq(t) {
  return Object.prototype.toString.call(t).slice(8, -1)
}
function Zg(t) {
  return nq(t) !== 'Object'
    ? !1
    : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype
}
function km(t, e) {
  const n = { ...t }
  return (
    Zg(t) &&
      Zg(e) &&
      Object.keys(e).forEach((r) => {
        Zg(e[r])
          ? r in t
            ? (n[r] = km(t[r], e[r]))
            : Object.assign(n, { [r]: e[r] })
          : Object.assign(n, { [r]: e[r] })
      }),
    n
  )
}
class dr {
  constructor(e = {}) {
    ;(this.type = 'extension'),
      (this.name = 'extension'),
      (this.parent = null),
      (this.child = null),
      (this.config = { name: this.name, defaultOptions: {} }),
      (this.config = { ...this.config, ...e }),
      (this.name = this.config.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions && (this.options = Ve(ce(this, 'addOptions', { name: this.name }))),
      (this.storage = Ve(ce(this, 'addStorage', { name: this.name, options: this.options })) || {})
  }
  static create(e = {}) {
    return new dr(e)
  }
  configure(e = {}) {
    const n = this.extend()
    return (
      (n.options = km(this.options, e)),
      (n.storage = Ve(ce(n, 'addStorage', { name: n.name, options: n.options }))),
      n
    )
  }
  extend(e = {}) {
    const n = new dr({ ...this.config, ...e })
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = Ve(ce(n, 'addOptions', { name: n.name }))),
      (n.storage = Ve(ce(n, 'addStorage', { name: n.name, options: n.options }))),
      n
    )
  }
}
function TM(t, e, n) {
  const { from: r, to: i } = e,
    {
      blockSeparator: s = `

`,
      textSerializers: o = {}
    } = n || {}
  let a = '',
    l = !0
  return (
    t.nodesBetween(r, i, (c, u, h, d) => {
      var f
      const p = o == null ? void 0 : o[c.type.name]
      if (p)
        return (
          c.isBlock && !l && ((a += s), (l = !0)),
          h && (a += p({ node: c, pos: u, parent: h, index: d, range: e })),
          !1
        )
      c.isText
        ? ((a +=
            (f = c == null ? void 0 : c.text) === null || f === void 0
              ? void 0
              : f.slice(Math.max(r, u) - u, i - u)),
          (l = !1))
        : c.isBlock && !l && ((a += s), (l = !0))
    }),
    a
  )
}
function wM(t) {
  return Object.fromEntries(
    Object.entries(t.nodes)
      .filter(([, e]) => e.spec.toText)
      .map(([e, n]) => [e, n.spec.toText])
  )
}
const rq = dr.create({
    name: 'clipboardTextSerializer',
    addProseMirrorPlugins() {
      return [
        new Cr({
          key: new to('clipboardTextSerializer'),
          props: {
            clipboardTextSerializer: () => {
              const { editor: t } = this,
                { state: e, schema: n } = t,
                { doc: r, selection: i } = e,
                { ranges: s } = i,
                o = Math.min(...s.map((u) => u.$from.pos)),
                a = Math.max(...s.map((u) => u.$to.pos)),
                l = wM(n)
              return TM(r, { from: o, to: a }, { textSerializers: l })
            }
          }
        })
      ]
    }
  }),
  iq =
    () =>
    ({ editor: t, view: e }) => (
      requestAnimationFrame(() => {
        var n
        t.isDestroyed ||
          (e.dom.blur(),
          (n = window == null ? void 0 : window.getSelection()) === null ||
            n === void 0 ||
            n.removeAllRanges())
      }),
      !0
    ),
  sq =
    (t = !1) =>
    ({ commands: e }) =>
      e.setContent('', t),
  oq =
    () =>
    ({ state: t, tr: e, dispatch: n }) => {
      const { selection: r } = e,
        { ranges: i } = r
      return (
        n &&
          i.forEach(({ $from: s, $to: o }) => {
            t.doc.nodesBetween(s.pos, o.pos, (a, l) => {
              if (a.type.isText) return
              const { doc: c, mapping: u } = e,
                h = c.resolve(u.map(l)),
                d = c.resolve(u.map(l + a.nodeSize)),
                f = h.blockRange(d)
              if (!f) return
              const p = ql(f)
              if (a.type.isTextblock) {
                const { defaultType: m } = h.parent.contentMatchAt(h.index())
                e.setNodeMarkup(f.start, m)
              }
              ;(p || p === 0) && e.lift(f, p)
            })
          }),
        !0
      )
    },
  aq = (t) => (e) => t(e),
  lq =
    () =>
    ({ state: t, dispatch: e }) =>
      OG(t, e),
  cq =
    (t, e) =>
    ({ editor: n, tr: r }) => {
      const { state: i } = n,
        s = i.doc.slice(t.from, t.to)
      r.deleteRange(t.from, t.to)
      const o = r.mapping.map(e)
      return r.insert(o, s.content), r.setSelection(new Me(r.doc.resolve(o - 1))), !0
    },
  uq =
    () =>
    ({ tr: t, dispatch: e }) => {
      const { selection: n } = t,
        r = n.$anchor.node()
      if (r.content.size > 0) return !1
      const i = t.selection.$anchor
      for (let s = i.depth; s > 0; s -= 1)
        if (i.node(s).type === r.type) {
          if (e) {
            const a = i.before(s),
              l = i.after(s)
            t.delete(a, l).scrollIntoView()
          }
          return !0
        }
      return !1
    },
  hq =
    (t) =>
    ({ tr: e, state: n, dispatch: r }) => {
      const i = an(t, n.schema),
        s = e.selection.$anchor
      for (let o = s.depth; o > 0; o -= 1)
        if (s.node(o).type === i) {
          if (r) {
            const l = s.before(o),
              c = s.after(o)
            e.delete(l, c).scrollIntoView()
          }
          return !0
        }
      return !1
    },
  dq =
    (t) =>
    ({ tr: e, dispatch: n }) => {
      const { from: r, to: i } = t
      return n && e.delete(r, i), !0
    },
  fq =
    () =>
    ({ state: t, dispatch: e }) =>
      _G(t, e),
  pq =
    () =>
    ({ commands: t }) =>
      t.keyboardShortcut('Enter'),
  mq =
    () =>
    ({ state: t, dispatch: e }) =>
      kG(t, e)
function ep(t, e, n = { strict: !0 }) {
  const r = Object.keys(e)
  return r.length
    ? r.every((i) => (n.strict ? e[i] === t[i] : X1(e[i]) ? e[i].test(t[i]) : e[i] === t[i]))
    : !0
}
function tv(t, e, n = {}) {
  return t.find((r) => r.type === e && ep(r.attrs, n))
}
function gq(t, e, n = {}) {
  return !!tv(t, e, n)
}
function Z1(t, e, n = {}) {
  if (!t || !e) return
  let r = t.parent.childAfter(t.parentOffset)
  if (
    (t.parentOffset === r.offset && r.offset !== 0 && (r = t.parent.childBefore(t.parentOffset)),
    !r.node)
  )
    return
  const i = tv([...r.node.marks], e, n)
  if (!i) return
  let s = r.index,
    o = t.start() + r.offset,
    a = s + 1,
    l = o + r.node.nodeSize
  for (tv([...r.node.marks], e, n); s > 0 && i.isInSet(t.parent.child(s - 1).marks); )
    (s -= 1), (o -= t.parent.child(s).nodeSize)
  for (; a < t.parent.childCount && gq([...t.parent.child(a).marks], e, n); )
    (l += t.parent.child(a).nodeSize), (a += 1)
  return { from: o, to: l }
}
function ro(t, e) {
  if (typeof t == 'string') {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`)
    return e.marks[t]
  }
  return t
}
const yq =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: i }) => {
      const s = ro(t, r.schema),
        { doc: o, selection: a } = n,
        { $from: l, from: c, to: u } = a
      if (i) {
        const h = Z1(l, s, e)
        if (h && h.from <= c && h.to >= u) {
          const d = Me.create(o, h.from, h.to)
          n.setSelection(d)
        }
      }
      return !0
    },
  _q = (t) => (e) => {
    const n = typeof t == 'function' ? t(e) : t
    for (let r = 0; r < n.length; r += 1) if (n[r](e)) return !0
    return !1
  }
function SM(t) {
  return t instanceof Me
}
function Ro(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n)
}
function IM(t, e = null) {
  if (!e) return null
  const n = Fe.atStart(t),
    r = Fe.atEnd(t)
  if (e === 'start' || e === !0) return n
  if (e === 'end') return r
  const i = n.from,
    s = r.to
  return e === 'all'
    ? Me.create(t, Ro(0, i, s), Ro(t.content.size, i, s))
    : Me.create(t, Ro(e, i, s), Ro(e, i, s))
}
function eb() {
  return (
    ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(
      navigator.platform
    ) ||
    (navigator.userAgent.includes('Mac') && 'ontouchend' in document)
  )
}
const vq =
    (t = null, e = {}) =>
    ({ editor: n, view: r, tr: i, dispatch: s }) => {
      e = { scrollIntoView: !0, ...e }
      const o = () => {
        eb() && r.dom.focus(),
          requestAnimationFrame(() => {
            n.isDestroyed ||
              (r.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView())
          })
      }
      if ((r.hasFocus() && t === null) || t === !1) return !0
      if (s && t === null && !SM(n.state.selection)) return o(), !0
      const a = IM(i.doc, t) || n.state.selection,
        l = n.state.selection.eq(a)
      return (
        s && (l || i.setSelection(a), l && i.storedMarks && i.setStoredMarks(i.storedMarks), o()),
        !0
      )
    },
  bq = (t, e) => (n) => t.every((r, i) => e(r, { ...n, index: i })),
  Eq =
    (t, e) =>
    ({ tr: n, commands: r }) =>
      r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e),
  AM = (t) => {
    const e = t.childNodes
    for (let n = e.length - 1; n >= 0; n -= 1) {
      const r = e[n]
      r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)
        ? t.removeChild(r)
        : r.nodeType === 1 && AM(r)
    }
    return t
  }
function QS(t) {
  const e = `<body>${t}</body>`,
    n = new window.DOMParser().parseFromString(e, 'text/html').body
  return AM(n)
}
function tp(t, e, n) {
  if (((n = { slice: !0, parseOptions: {}, ...n }), typeof t == 'object' && t !== null))
    try {
      return Array.isArray(t) && t.length > 0
        ? H.fromArray(t.map((r) => e.nodeFromJSON(r)))
        : e.nodeFromJSON(t)
    } catch (r) {
      return (
        console.warn('[tiptap warn]: Invalid content.', 'Passed value:', t, 'Error:', r),
        tp('', e, n)
      )
    }
  if (typeof t == 'string') {
    const r = Il.fromSchema(e)
    return n.slice ? r.parseSlice(QS(t), n.parseOptions).content : r.parse(QS(t), n.parseOptions)
  }
  return tp('', e, n)
}
function Tq(t, e, n) {
  const r = t.steps.length - 1
  if (r < e) return
  const i = t.steps[r]
  if (!(i instanceof Zt || i instanceof tn)) return
  const s = t.mapping.maps[r]
  let o = 0
  s.forEach((a, l, c, u) => {
    o === 0 && (o = u)
  }),
    t.setSelection(Fe.near(t.doc.resolve(o), n))
}
const wq = (t) => t.toString().startsWith('<'),
  Sq =
    (t, e, n) =>
    ({ tr: r, dispatch: i, editor: s }) => {
      if (i) {
        n = { parseOptions: {}, updateSelection: !0, ...n }
        const o = tp(e, s.schema, {
          parseOptions: { preserveWhitespace: 'full', ...n.parseOptions }
        })
        if (o.toString() === '<>') return !0
        let { from: a, to: l } =
            typeof t == 'number' ? { from: t, to: t } : { from: t.from, to: t.to },
          c = !0,
          u = !0
        if (
          ((wq(o) ? o : [o]).forEach((d) => {
            d.check(), (c = c ? d.isText && d.marks.length === 0 : !1), (u = u ? d.isBlock : !1)
          }),
          a === l && u)
        ) {
          const { parent: d } = r.doc.resolve(a)
          d.isTextblock && !d.type.spec.code && !d.childCount && ((a -= 1), (l += 1))
        }
        c
          ? Array.isArray(e)
            ? r.insertText(e.map((d) => d.text || '').join(''), a, l)
            : typeof e == 'object' && e && e.text
            ? r.insertText(e.text, a, l)
            : r.insertText(e, a, l)
          : r.replaceWith(a, l, o),
          n.updateSelection && Tq(r, r.steps.length - 1, -1)
      }
      return !0
    },
  Iq =
    () =>
    ({ state: t, dispatch: e }) =>
      IG(t, e),
  Aq =
    () =>
    ({ state: t, dispatch: e }) =>
      AG(t, e),
  Cq =
    () =>
    ({ state: t, dispatch: e }) =>
      vG(t, e),
  Rq =
    () =>
    ({ state: t, dispatch: e }) =>
      wG(t, e),
  kq =
    () =>
    ({ tr: t, state: e, dispatch: n }) => {
      try {
        const r = vm(e.doc, e.selection.$from.pos, -1)
        return r == null ? !1 : (t.join(r, 2), n && n(t), !0)
      } catch {
        return !1
      }
    },
  Oq =
    () =>
    ({ state: t, dispatch: e, tr: n }) => {
      try {
        const r = vm(t.doc, t.selection.$from.pos, 1)
        return r == null ? !1 : (n.join(r, 2), e && e(n), !0)
      } catch {
        return !1
      }
    },
  Nq =
    () =>
    ({ state: t, dispatch: e }) =>
      bG(t, e),
  Mq =
    () =>
    ({ state: t, dispatch: e }) =>
      EG(t, e)
function tb() {
  return typeof navigator < 'u' ? /Mac/.test(navigator.platform) : !1
}
function Pq(t) {
  const e = t.split(/-(?!$)/)
  let n = e[e.length - 1]
  n === 'Space' && (n = ' ')
  let r, i, s, o
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a]
    if (/^(cmd|meta|m)$/i.test(l)) o = !0
    else if (/^a(lt)?$/i.test(l)) r = !0
    else if (/^(c|ctrl|control)$/i.test(l)) i = !0
    else if (/^s(hift)?$/i.test(l)) s = !0
    else if (/^mod$/i.test(l)) eb() || tb() ? (o = !0) : (i = !0)
    else throw new Error(`Unrecognized modifier name: ${l}`)
  }
  return (
    r && (n = `Alt-${n}`),
    i && (n = `Ctrl-${n}`),
    o && (n = `Meta-${n}`),
    s && (n = `Shift-${n}`),
    n
  )
}
const xq =
  (t) =>
  ({ editor: e, view: n, tr: r, dispatch: i }) => {
    const s = Pq(t).split(/-(?!$)/),
      o = s.find((c) => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(c)),
      a = new KeyboardEvent('keydown', {
        key: o === 'Space' ? ' ' : o,
        altKey: s.includes('Alt'),
        ctrlKey: s.includes('Ctrl'),
        metaKey: s.includes('Meta'),
        shiftKey: s.includes('Shift'),
        bubbles: !0,
        cancelable: !0
      }),
      l = e.captureTransaction(() => {
        n.someProp('handleKeyDown', (c) => c(n, a))
      })
    return (
      l == null ||
        l.steps.forEach((c) => {
          const u = c.map(r.mapping)
          u && i && r.maybeStep(u)
        }),
      !0
    )
  }
function Lu(t, e, n = {}) {
  const { from: r, to: i, empty: s } = t.selection,
    o = e ? an(e, t.schema) : null,
    a = []
  t.doc.nodesBetween(r, i, (h, d) => {
    if (h.isText) return
    const f = Math.max(r, d),
      p = Math.min(i, d + h.nodeSize)
    a.push({ node: h, from: f, to: p })
  })
  const l = i - r,
    c = a
      .filter((h) => (o ? o.name === h.node.type.name : !0))
      .filter((h) => ep(h.node.attrs, n, { strict: !1 }))
  return s ? !!c.length : c.reduce((h, d) => h + d.to - d.from, 0) >= l
}
const Dq =
    (t, e = {}) =>
    ({ state: n, dispatch: r }) => {
      const i = an(t, n.schema)
      return Lu(n, i, e) ? CG(n, r) : !1
    },
  Lq =
    () =>
    ({ state: t, dispatch: e }) =>
      NG(t, e),
  Vq =
    (t) =>
    ({ state: e, dispatch: n }) => {
      const r = an(t, e.schema)
      return BG(r)(e, n)
    },
  Fq =
    () =>
    ({ state: t, dispatch: e }) =>
      RG(t, e)
function Om(t, e) {
  return e.nodes[t] ? 'node' : e.marks[t] ? 'mark' : null
}
function XS(t, e) {
  const n = typeof e == 'string' ? [e] : e
  return Object.keys(t).reduce((r, i) => (n.includes(i) || (r[i] = t[i]), r), {})
}
const Bq =
    (t, e) =>
    ({ tr: n, state: r, dispatch: i }) => {
      let s = null,
        o = null
      const a = Om(typeof t == 'string' ? t : t.name, r.schema)
      return a
        ? (a === 'node' && (s = an(t, r.schema)),
          a === 'mark' && (o = ro(t, r.schema)),
          i &&
            n.selection.ranges.forEach((l) => {
              r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
                s && s === c.type && n.setNodeMarkup(u, void 0, XS(c.attrs, e)),
                  o &&
                    c.marks.length &&
                    c.marks.forEach((h) => {
                      o === h.type && n.addMark(u, u + c.nodeSize, o.create(XS(h.attrs, e)))
                    })
              })
            }),
          !0)
        : !1
    },
  Uq =
    () =>
    ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0),
  $q =
    () =>
    ({ tr: t, commands: e }) =>
      e.setTextSelection({ from: 0, to: t.doc.content.size }),
  Hq =
    () =>
    ({ state: t, dispatch: e }) =>
      TG(t, e),
  zq =
    () =>
    ({ state: t, dispatch: e }) =>
      SG(t, e),
  jq =
    () =>
    ({ state: t, dispatch: e }) =>
      MG(t, e),
  Wq =
    () =>
    ({ state: t, dispatch: e }) =>
      DG(t, e),
  Gq =
    () =>
    ({ state: t, dispatch: e }) =>
      xG(t, e)
function CM(t, e, n = {}) {
  return tp(t, e, { slice: !1, parseOptions: n })
}
const qq =
  (t, e = !1, n = {}) =>
  ({ tr: r, editor: i, dispatch: s }) => {
    const { doc: o } = r,
      a = CM(t, i.schema, n)
    return s && r.replaceWith(0, o.content.size, a).setMeta('preventUpdate', !e), !0
  }
function Nm(t, e) {
  const n = ro(e, t.schema),
    { from: r, to: i, empty: s } = t.selection,
    o = []
  s
    ? (t.storedMarks && o.push(...t.storedMarks), o.push(...t.selection.$head.marks()))
    : t.doc.nodesBetween(r, i, (l) => {
        o.push(...l.marks)
      })
  const a = o.find((l) => l.type.name === n.name)
  return a ? { ...a.attrs } : {}
}
function Kq(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e)
    if (n.isTextblock && !n.hasRequiredAttrs()) return n
  }
  return null
}
function Yq(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n)
    if (e(r)) return { pos: n > 0 ? t.before(n) : 0, start: t.start(n), depth: n, node: r }
  }
}
function nb(t) {
  return (e) => Yq(e.$from, t)
}
function Jq(t, e) {
  const n = si.fromSchema(e).serializeFragment(t),
    i = document.implementation.createHTMLDocument().createElement('div')
  return i.appendChild(n), i.innerHTML
}
function Qq(t, e) {
  const n = { from: 0, to: t.content.size }
  return TM(t, n, e)
}
function Xq(t, e) {
  const n = an(e, t.schema),
    { from: r, to: i } = t.selection,
    s = []
  t.doc.nodesBetween(r, i, (a) => {
    s.push(a)
  })
  const o = s.reverse().find((a) => a.type.name === n.name)
  return o ? { ...o.attrs } : {}
}
function Zq(t, e) {
  const n = Om(typeof e == 'string' ? e : e.name, t.schema)
  return n === 'node' ? Xq(t, e) : n === 'mark' ? Nm(t, e) : {}
}
function RM(t, e, n) {
  const r = []
  return (
    t === e
      ? n
          .resolve(t)
          .marks()
          .forEach((i) => {
            const s = n.resolve(t - 1),
              o = Z1(s, i.type)
            o && r.push({ mark: i, ...o })
          })
      : n.nodesBetween(t, e, (i, s) => {
          !i ||
            (i == null ? void 0 : i.nodeSize) === void 0 ||
            r.push(...i.marks.map((o) => ({ from: s, to: s + i.nodeSize, mark: o })))
        }),
    r
  )
}
function Fd(t, e, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const i = t.find((s) => s.type === e && s.name === r)
      return i ? i.attribute.keepOnSplit : !1
    })
  )
}
function nv(t, e, n = {}) {
  const { empty: r, ranges: i } = t.selection,
    s = e ? ro(e, t.schema) : null
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks())
      .filter((h) => (s ? s.name === h.type.name : !0))
      .find((h) => ep(h.attrs, n, { strict: !1 }))
  let o = 0
  const a = []
  if (
    (i.forEach(({ $from: h, $to: d }) => {
      const f = h.pos,
        p = d.pos
      t.doc.nodesBetween(f, p, (m, g) => {
        if (!m.isText && !m.marks.length) return
        const _ = Math.max(f, g),
          v = Math.min(p, g + m.nodeSize),
          T = v - _
        ;(o += T), a.push(...m.marks.map((S) => ({ mark: S, from: _, to: v })))
      })
    }),
    o === 0)
  )
    return !1
  const l = a
      .filter((h) => (s ? s.name === h.mark.type.name : !0))
      .filter((h) => ep(h.mark.attrs, n, { strict: !1 }))
      .reduce((h, d) => h + d.to - d.from, 0),
    c = a
      .filter((h) => (s ? h.mark.type !== s && h.mark.type.excludes(s) : !0))
      .reduce((h, d) => h + d.to - d.from, 0)
  return (l > 0 ? l + c : l) >= o
}
function eK(t, e, n = {}) {
  if (!e) return Lu(t, null, n) || nv(t, null, n)
  const r = Om(e, t.schema)
  return r === 'node' ? Lu(t, e, n) : r === 'mark' ? nv(t, e, n) : !1
}
function ZS(t, e) {
  const { nodeExtensions: n } = Cm(e),
    r = n.find((o) => o.name === t)
  if (!r) return !1
  const i = { name: r.name, options: r.options, storage: r.storage },
    s = Ve(ce(r, 'group', i))
  return typeof s != 'string' ? !1 : s.split(' ').includes('list')
}
function tK(t) {
  var e
  const n = (e = t.type.createAndFill()) === null || e === void 0 ? void 0 : e.toJSON(),
    r = t.toJSON()
  return JSON.stringify(n) === JSON.stringify(r)
}
function nK(t, e, n) {
  var r
  const { selection: i } = e
  let s = null
  if ((SM(i) && (s = i.$cursor), s)) {
    const a = (r = t.storedMarks) !== null && r !== void 0 ? r : s.marks()
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n))
  }
  const { ranges: o } = i
  return o.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1
    return (
      t.doc.nodesBetween(a.pos, l.pos, (u, h, d) => {
        if (c) return !1
        if (u.isInline) {
          const f = !d || d.type.allowsMarkType(n),
            p = !!n.isInSet(u.marks) || !u.marks.some((m) => m.type.excludes(n))
          c = f && p
        }
        return !c
      }),
      c
    )
  })
}
const rK =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: i }) => {
      const { selection: s } = n,
        { empty: o, ranges: a } = s,
        l = ro(t, r.schema)
      if (i)
        if (o) {
          const c = Nm(r, l)
          n.addStoredMark(l.create({ ...c, ...e }))
        } else
          a.forEach((c) => {
            const u = c.$from.pos,
              h = c.$to.pos
            r.doc.nodesBetween(u, h, (d, f) => {
              const p = Math.max(f, u),
                m = Math.min(f + d.nodeSize, h)
              d.marks.find((_) => _.type === l)
                ? d.marks.forEach((_) => {
                    l === _.type && n.addMark(p, m, l.create({ ..._.attrs, ...e }))
                  })
                : n.addMark(p, m, l.create(e))
            })
          })
      return nK(r, n, l)
    },
  iK =
    (t, e) =>
    ({ tr: n }) => (n.setMeta(t, e), !0),
  sK =
    (t, e = {}) =>
    ({ state: n, dispatch: r, chain: i }) => {
      const s = an(t, n.schema)
      return s.isTextblock
        ? i()
            .command(({ commands: o }) => (qS(s, e)(n) ? !0 : o.clearNodes()))
            .command(({ state: o }) => qS(s, e)(o, r))
            .run()
        : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1)
    },
  oK =
    (t) =>
    ({ tr: e, dispatch: n }) => {
      if (n) {
        const { doc: r } = e,
          i = Ro(t, 0, r.content.size),
          s = Ee.create(r, i)
        e.setSelection(s)
      }
      return !0
    },
  aK =
    (t) =>
    ({ tr: e, dispatch: n }) => {
      if (n) {
        const { doc: r } = e,
          { from: i, to: s } = typeof t == 'number' ? { from: t, to: t } : t,
          o = Me.atStart(r).from,
          a = Me.atEnd(r).to,
          l = Ro(i, o, a),
          c = Ro(s, o, a),
          u = Me.create(r, l, c)
        e.setSelection(u)
      }
      return !0
    },
  lK =
    (t) =>
    ({ state: e, dispatch: n }) => {
      const r = an(t, e.schema)
      return HG(r)(e, n)
    }
function eI(t, e) {
  const n = t.storedMarks || (t.selection.$to.parentOffset && t.selection.$from.marks())
  if (n) {
    const r = n.filter((i) => (e == null ? void 0 : e.includes(i.type.name)))
    t.tr.ensureMarks(r)
  }
}
const cK =
    ({ keepMarks: t = !0 } = {}) =>
    ({ tr: e, state: n, dispatch: r, editor: i }) => {
      const { selection: s, doc: o } = e,
        { $from: a, $to: l } = s,
        c = i.extensionManager.attributes,
        u = Fd(c, a.node().type.name, a.node().attrs)
      if (s instanceof Ee && s.node.isBlock)
        return !a.parentOffset || !tl(o, a.pos)
          ? !1
          : (r && (t && eI(n, i.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()),
            !0)
      if (!a.parent.isBlock) return !1
      if (r) {
        const h = l.parentOffset === l.parent.content.size
        s instanceof Me && e.deleteSelection()
        const d = a.depth === 0 ? void 0 : Kq(a.node(-1).contentMatchAt(a.indexAfter(-1)))
        let f = h && d ? [{ type: d, attrs: u }] : void 0,
          p = tl(e.doc, e.mapping.map(a.pos), 1, f)
        if (
          (!f &&
            !p &&
            tl(e.doc, e.mapping.map(a.pos), 1, d ? [{ type: d }] : void 0) &&
            ((p = !0), (f = d ? [{ type: d, attrs: u }] : void 0)),
          p &&
            (e.split(e.mapping.map(a.pos), 1, f),
            d && !h && !a.parentOffset && a.parent.type !== d))
        ) {
          const m = e.mapping.map(a.before()),
            g = e.doc.resolve(m)
          a.node(-1).canReplaceWith(g.index(), g.index() + 1, d) &&
            e.setNodeMarkup(e.mapping.map(a.before()), d)
        }
        t && eI(n, i.extensionManager.splittableMarks), e.scrollIntoView()
      }
      return !0
    },
  uK =
    (t) =>
    ({ tr: e, state: n, dispatch: r, editor: i }) => {
      var s
      const o = an(t, n.schema),
        { $from: a, $to: l } = n.selection,
        c = n.selection.node
      if ((c && c.isBlock) || a.depth < 2 || !a.sameParent(l)) return !1
      const u = a.node(-1)
      if (u.type !== o) return !1
      const h = i.extensionManager.attributes
      if (a.parent.content.size === 0 && a.node(-1).childCount === a.indexAfter(-1)) {
        if (a.depth === 2 || a.node(-3).type !== o || a.index(-2) !== a.node(-2).childCount - 1)
          return !1
        if (r) {
          let g = H.empty
          const _ = a.index(-1) ? 1 : a.index(-2) ? 2 : 3
          for (let O = a.depth - _; O >= a.depth - 3; O -= 1) g = H.from(a.node(O).copy(g))
          const v =
              a.indexAfter(-1) < a.node(-2).childCount
                ? 1
                : a.indexAfter(-2) < a.node(-3).childCount
                ? 2
                : 3,
            T = Fd(h, a.node().type.name, a.node().attrs),
            S =
              ((s = o.contentMatch.defaultType) === null || s === void 0
                ? void 0
                : s.createAndFill(T)) || void 0
          g = g.append(H.from(o.createAndFill(null, S) || void 0))
          const I = a.before(a.depth - (_ - 1))
          e.replace(I, a.after(-v), new ie(g, 4 - _, 0))
          let w = -1
          e.doc.nodesBetween(I, e.doc.content.size, (O, P) => {
            if (w > -1) return !1
            O.isTextblock && O.content.size === 0 && (w = P + 1)
          }),
            w > -1 && e.setSelection(Me.near(e.doc.resolve(w))),
            e.scrollIntoView()
        }
        return !0
      }
      const d = l.pos === a.end() ? u.contentMatchAt(0).defaultType : null,
        f = Fd(h, u.type.name, u.attrs),
        p = Fd(h, a.node().type.name, a.node().attrs)
      e.delete(a.pos, l.pos)
      const m = d
        ? [
            { type: o, attrs: f },
            { type: d, attrs: p }
          ]
        : [{ type: o, attrs: f }]
      if (!tl(e.doc, a.pos, 2)) return !1
      if (r) {
        const { selection: g, storedMarks: _ } = n,
          { splittableMarks: v } = i.extensionManager,
          T = _ || (g.$to.parentOffset && g.$from.marks())
        if ((e.split(a.pos, 2, m).scrollIntoView(), !T || !r)) return !0
        const S = T.filter((I) => v.includes(I.type.name))
        e.ensureMarks(S)
      }
      return !0
    },
  ey = (t, e) => {
    const n = nb((o) => o.type === e)(t.selection)
    if (!n) return !0
    const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth)
    if (r === void 0) return !0
    const i = t.doc.nodeAt(r)
    return n.node.type === (i == null ? void 0 : i.type) && eo(t.doc, n.pos) && t.join(n.pos), !0
  },
  ty = (t, e) => {
    const n = nb((o) => o.type === e)(t.selection)
    if (!n) return !0
    const r = t.doc.resolve(n.start).after(n.depth)
    if (r === void 0) return !0
    const i = t.doc.nodeAt(r)
    return n.node.type === (i == null ? void 0 : i.type) && eo(t.doc, r) && t.join(r), !0
  },
  hK =
    (t, e, n, r = {}) =>
    ({ editor: i, tr: s, state: o, dispatch: a, chain: l, commands: c, can: u }) => {
      const { extensions: h, splittableMarks: d } = i.extensionManager,
        f = an(t, o.schema),
        p = an(e, o.schema),
        { selection: m, storedMarks: g } = o,
        { $from: _, $to: v } = m,
        T = _.blockRange(v),
        S = g || (m.$to.parentOffset && m.$from.marks())
      if (!T) return !1
      const I = nb((w) => ZS(w.type.name, h))(m)
      if (T.depth >= 1 && I && T.depth - I.depth <= 1) {
        if (I.node.type === f) return c.liftListItem(p)
        if (ZS(I.node.type.name, h) && f.validContent(I.node.content) && a)
          return l()
            .command(() => (s.setNodeMarkup(I.pos, f), !0))
            .command(() => ey(s, f))
            .command(() => ty(s, f))
            .run()
      }
      return !n || !S || !a
        ? l()
            .command(() => (u().wrapInList(f, r) ? !0 : c.clearNodes()))
            .wrapInList(f, r)
            .command(() => ey(s, f))
            .command(() => ty(s, f))
            .run()
        : l()
            .command(() => {
              const w = u().wrapInList(f, r),
                O = S.filter((P) => d.includes(P.type.name))
              return s.ensureMarks(O), w ? !0 : c.clearNodes()
            })
            .wrapInList(f, r)
            .command(() => ey(s, f))
            .command(() => ty(s, f))
            .run()
    },
  dK =
    (t, e = {}, n = {}) =>
    ({ state: r, commands: i }) => {
      const { extendEmptyMarkRange: s = !1 } = n,
        o = ro(t, r.schema)
      return nv(r, o, e) ? i.unsetMark(o, { extendEmptyMarkRange: s }) : i.setMark(o, e)
    },
  fK =
    (t, e, n = {}) =>
    ({ state: r, commands: i }) => {
      const s = an(t, r.schema),
        o = an(e, r.schema)
      return Lu(r, s, n) ? i.setNode(o) : i.setNode(s, n)
    },
  pK =
    (t, e = {}) =>
    ({ state: n, commands: r }) => {
      const i = an(t, n.schema)
      return Lu(n, i, e) ? r.lift(i) : r.wrapIn(i, e)
    },
  mK =
    () =>
    ({ state: t, dispatch: e }) => {
      const n = t.plugins
      for (let r = 0; r < n.length; r += 1) {
        const i = n[r]
        let s
        if (i.spec.isInputRules && (s = i.getState(t))) {
          if (e) {
            const o = t.tr,
              a = s.transform
            for (let l = a.steps.length - 1; l >= 0; l -= 1) o.step(a.steps[l].invert(a.docs[l]))
            if (s.text) {
              const l = o.doc.resolve(s.from).marks()
              o.replaceWith(s.from, s.to, t.schema.text(s.text, l))
            } else o.delete(s.from, s.to)
          }
          return !0
        }
      }
      return !1
    },
  gK =
    () =>
    ({ tr: t, dispatch: e }) => {
      const { selection: n } = t,
        { empty: r, ranges: i } = n
      return (
        r ||
          (e &&
            i.forEach((s) => {
              t.removeMark(s.$from.pos, s.$to.pos)
            })),
        !0
      )
    },
  yK =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: i }) => {
      var s
      const { extendEmptyMarkRange: o = !1 } = e,
        { selection: a } = n,
        l = ro(t, r.schema),
        { $from: c, empty: u, ranges: h } = a
      if (!i) return !0
      if (u && o) {
        let { from: d, to: f } = a
        const p =
            (s = c.marks().find((g) => g.type === l)) === null || s === void 0 ? void 0 : s.attrs,
          m = Z1(c, l, p)
        m && ((d = m.from), (f = m.to)), n.removeMark(d, f, l)
      } else
        h.forEach((d) => {
          n.removeMark(d.$from.pos, d.$to.pos, l)
        })
      return n.removeStoredMark(l), !0
    },
  _K =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: i }) => {
      let s = null,
        o = null
      const a = Om(typeof t == 'string' ? t : t.name, r.schema)
      return a
        ? (a === 'node' && (s = an(t, r.schema)),
          a === 'mark' && (o = ro(t, r.schema)),
          i &&
            n.selection.ranges.forEach((l) => {
              const c = l.$from.pos,
                u = l.$to.pos
              r.doc.nodesBetween(c, u, (h, d) => {
                s && s === h.type && n.setNodeMarkup(d, void 0, { ...h.attrs, ...e }),
                  o &&
                    h.marks.length &&
                    h.marks.forEach((f) => {
                      if (o === f.type) {
                        const p = Math.max(d, c),
                          m = Math.min(d + h.nodeSize, u)
                        n.addMark(p, m, o.create({ ...f.attrs, ...e }))
                      }
                    })
              })
            }),
          !0)
        : !1
    },
  vK =
    (t, e = {}) =>
    ({ state: n, dispatch: r }) => {
      const i = an(t, n.schema)
      return LG(i, e)(n, r)
    },
  bK =
    (t, e = {}) =>
    ({ state: n, dispatch: r }) => {
      const i = an(t, n.schema)
      return VG(i, e)(n, r)
    }
var EK = Object.freeze({
  __proto__: null,
  blur: iq,
  clearContent: sq,
  clearNodes: oq,
  command: aq,
  createParagraphNear: lq,
  cut: cq,
  deleteCurrentNode: uq,
  deleteNode: hq,
  deleteRange: dq,
  deleteSelection: fq,
  enter: pq,
  exitCode: mq,
  extendMarkRange: yq,
  first: _q,
  focus: vq,
  forEach: bq,
  insertContent: Eq,
  insertContentAt: Sq,
  joinUp: Iq,
  joinDown: Aq,
  joinBackward: Cq,
  joinForward: Rq,
  joinItemBackward: kq,
  joinItemForward: Oq,
  joinTextblockBackward: Nq,
  joinTextblockForward: Mq,
  keyboardShortcut: xq,
  lift: Dq,
  liftEmptyBlock: Lq,
  liftListItem: Vq,
  newlineInCode: Fq,
  resetAttributes: Bq,
  scrollIntoView: Uq,
  selectAll: $q,
  selectNodeBackward: Hq,
  selectNodeForward: zq,
  selectParentNode: jq,
  selectTextblockEnd: Wq,
  selectTextblockStart: Gq,
  setContent: qq,
  setMark: rK,
  setMeta: iK,
  setNode: sK,
  setNodeSelection: oK,
  setTextSelection: aK,
  sinkListItem: lK,
  splitBlock: cK,
  splitListItem: uK,
  toggleList: hK,
  toggleMark: dK,
  toggleNode: fK,
  toggleWrap: pK,
  undoInputRule: mK,
  unsetAllMarks: gK,
  unsetMark: yK,
  updateAttributes: _K,
  wrapIn: vK,
  wrapInList: bK
})
const TK = dr.create({
    name: 'commands',
    addCommands() {
      return { ...EK }
    }
  }),
  wK = dr.create({
    name: 'editable',
    addProseMirrorPlugins() {
      return [
        new Cr({ key: new to('editable'), props: { editable: () => this.editor.options.editable } })
      ]
    }
  }),
  SK = dr.create({
    name: 'focusEvents',
    addProseMirrorPlugins() {
      const { editor: t } = this
      return [
        new Cr({
          key: new to('focusEvents'),
          props: {
            handleDOMEvents: {
              focus: (e, n) => {
                t.isFocused = !0
                const r = t.state.tr.setMeta('focus', { event: n }).setMeta('addToHistory', !1)
                return e.dispatch(r), !1
              },
              blur: (e, n) => {
                t.isFocused = !1
                const r = t.state.tr.setMeta('blur', { event: n }).setMeta('addToHistory', !1)
                return e.dispatch(r), !1
              }
            }
          }
        })
      ]
    }
  }),
  IK = dr.create({
    name: 'keymap',
    addKeyboardShortcuts() {
      const t = () =>
          this.editor.commands.first(({ commands: o }) => [
            () => o.undoInputRule(),
            () =>
              o.command(({ tr: a }) => {
                const { selection: l, doc: c } = a,
                  { empty: u, $anchor: h } = l,
                  { pos: d, parent: f } = h,
                  p = h.parent.isTextblock && d > 0 ? a.doc.resolve(d - 1) : h,
                  m = p.parent.type.spec.isolating,
                  g = h.pos - h.parentOffset,
                  _ = m && p.parent.childCount === 1 ? g === h.pos : Fe.atStart(c).from === d
                return !u || !_ || !f.type.isTextblock || f.textContent.length ? !1 : o.clearNodes()
              }),
            () => o.deleteSelection(),
            () => o.joinBackward(),
            () => o.selectNodeBackward()
          ]),
        e = () =>
          this.editor.commands.first(({ commands: o }) => [
            () => o.deleteSelection(),
            () => o.deleteCurrentNode(),
            () => o.joinForward(),
            () => o.selectNodeForward()
          ]),
        r = {
          Enter: () =>
            this.editor.commands.first(({ commands: o }) => [
              () => o.newlineInCode(),
              () => o.createParagraphNear(),
              () => o.liftEmptyBlock(),
              () => o.splitBlock()
            ]),
          'Mod-Enter': () => this.editor.commands.exitCode(),
          Backspace: t,
          'Mod-Backspace': t,
          'Shift-Backspace': t,
          Delete: e,
          'Mod-Delete': e,
          'Mod-a': () => this.editor.commands.selectAll()
        },
        i = { ...r },
        s = {
          ...r,
          'Ctrl-h': t,
          'Alt-Backspace': t,
          'Ctrl-d': e,
          'Ctrl-Alt-Backspace': e,
          'Alt-Delete': e,
          'Alt-d': e,
          'Ctrl-a': () => this.editor.commands.selectTextblockStart(),
          'Ctrl-e': () => this.editor.commands.selectTextblockEnd()
        }
      return eb() || tb() ? s : i
    },
    addProseMirrorPlugins() {
      return [
        new Cr({
          key: new to('clearDocument'),
          appendTransaction: (t, e, n) => {
            if (!(t.some((p) => p.docChanged) && !e.doc.eq(n.doc))) return
            const { empty: i, from: s, to: o } = e.selection,
              a = Fe.atStart(e.doc).from,
              l = Fe.atEnd(e.doc).to
            if (
              i ||
              !(s === a && o === l) ||
              !(n.doc.textBetween(0, n.doc.content.size, ' ', ' ').length === 0)
            )
              return
            const h = n.tr,
              d = Im({ state: n, transaction: h }),
              { commands: f } = new Am({ editor: this.editor, state: d })
            if ((f.clearNodes(), !!h.steps.length)) return h
          }
        })
      ]
    }
  }),
  AK = dr.create({
    name: 'tabindex',
    addProseMirrorPlugins() {
      return [
        new Cr({
          key: new to('tabindex'),
          props: { attributes: this.editor.isEditable ? { tabindex: '0' } : {} }
        })
      ]
    }
  })
var CK = Object.freeze({
  __proto__: null,
  ClipboardTextSerializer: rq,
  Commands: TK,
  Editable: wK,
  FocusEvents: SK,
  Keymap: IK,
  Tabindex: AK
})
class _o {
  constructor(e, n, r = !1, i = null) {
    ;(this.currentNode = null),
      (this.actualDepth = null),
      (this.isBlock = r),
      (this.resolvedPos = e),
      (this.editor = n),
      (this.currentNode = i)
  }
  get name() {
    return this.node.type.name
  }
  get node() {
    return this.currentNode || this.resolvedPos.node()
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node
  }
  get depth() {
    var e
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth
  }
  get pos() {
    return this.resolvedPos.pos
  }
  get content() {
    return this.node.content
  }
  set content(e) {
    let n = this.from,
      r = this.to
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(
          `You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`
        )
        return
      }
      ;(n = this.from + 1), (r = this.to - 1)
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, e)
  }
  get attributes() {
    return this.node.attrs
  }
  get textContent() {
    return this.node.textContent
  }
  get size() {
    return this.node.nodeSize
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth)
  }
  get range() {
    return { from: this.from, to: this.to }
  }
  get to() {
    return this.isBlock
      ? this.pos + this.size
      : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1)
  }
  get parent() {
    if (this.depth === 0) return null
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1),
      n = this.resolvedPos.doc.resolve(e)
    return new _o(n, this.editor)
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2))
    return (
      e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)),
      new _o(e, this.editor)
    )
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1))
    return (
      e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)),
      new _o(e, this.editor)
    )
  }
  get children() {
    const e = []
    return (
      this.node.content.forEach((n, r) => {
        const i = n.isBlock && !n.isTextblock,
          s = this.pos + r + (i ? 0 : 1),
          o = this.resolvedPos.doc.resolve(s)
        if (!i && o.depth <= this.depth) return
        const a = new _o(o, this.editor, i, i ? n : null)
        i && (a.actualDepth = this.depth + 1), e.push(new _o(o, this.editor, i, i ? n : null))
      }),
      e
    )
  }
  get firstChild() {
    return this.children[0] || null
  }
  get lastChild() {
    const e = this.children
    return e[e.length - 1] || null
  }
  closest(e, n = {}) {
    let r = null,
      i = this.parent
    for (; i && !r; ) {
      if (i.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const s = i.node.attrs,
            o = Object.keys(n)
          for (let a = 0; a < o.length; a += 1) {
            const l = o[a]
            if (s[l] !== n[l]) break
          }
        } else r = i
      i = i.parent
    }
    return r
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null
  }
  querySelectorAll(e, n = {}, r = !1) {
    let i = []
    return (
      this.isBlock ||
        !this.children ||
        this.children.length === 0 ||
        this.children.forEach((s) => {
          if (s.node.type.name === e) {
            if (Object.keys(n).length > 0) {
              const o = s.node.attrs,
                a = Object.keys(n)
              for (let l = 0; l < a.length; l += 1) {
                const c = a[l]
                if (o[c] !== n[c]) return
              }
            }
            if ((i.push(s), r)) return
          }
          i = i.concat(s.querySelectorAll(e))
        }),
      i
    )
  }
  setAttribute(e) {
    const n = this.editor.state.selection
    this.editor
      .chain()
      .setTextSelection(this.from)
      .updateAttributes(this.node.type.name, e)
      .setTextSelection(n.from)
      .run()
  }
}
const RK = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`
function kK(t, e, n) {
  const r = document.querySelector(`style[data-tiptap-style${n ? `-${n}` : ''}]`)
  if (r !== null) return r
  const i = document.createElement('style')
  return (
    e && i.setAttribute('nonce', e),
    i.setAttribute(`data-tiptap-style${n ? `-${n}` : ''}`, ''),
    (i.innerHTML = t),
    document.getElementsByTagName('head')[0].appendChild(i),
    i
  )
}
let OK = class extends zG {
  constructor(e = {}) {
    super(),
      (this.isFocused = !1),
      (this.extensionStorage = {}),
      (this.options = {
        element: document.createElement('div'),
        content: '',
        injectCSS: !0,
        injectNonce: void 0,
        extensions: [],
        autofocus: !1,
        editable: !0,
        editorProps: {},
        parseOptions: {},
        enableInputRules: !0,
        enablePasteRules: !0,
        enableCoreExtensions: !0,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null
      }),
      (this.isCapturingTransaction = !1),
      (this.capturedTransaction = null),
      this.setOptions(e),
      this.createExtensionManager(),
      this.createCommandManager(),
      this.createSchema(),
      this.on('beforeCreate', this.options.onBeforeCreate),
      this.emit('beforeCreate', { editor: this }),
      this.createView(),
      this.injectCSS(),
      this.on('create', this.options.onCreate),
      this.on('update', this.options.onUpdate),
      this.on('selectionUpdate', this.options.onSelectionUpdate),
      this.on('transaction', this.options.onTransaction),
      this.on('focus', this.options.onFocus),
      this.on('blur', this.options.onBlur),
      this.on('destroy', this.options.onDestroy),
      window.setTimeout(() => {
        this.isDestroyed ||
          (this.commands.focus(this.options.autofocus), this.emit('create', { editor: this }))
      }, 0)
  }
  get storage() {
    return this.extensionStorage
  }
  get commands() {
    return this.commandManager.commands
  }
  chain() {
    return this.commandManager.chain()
  }
  can() {
    return this.commandManager.can()
  }
  injectCSS() {
    this.options.injectCSS && document && (this.css = kK(RK, this.options.injectNonce))
  }
  setOptions(e = {}) {
    ;(this.options = { ...this.options, ...e }),
      !(!this.view || !this.state || this.isDestroyed) &&
        (this.options.editorProps && this.view.setProps(this.options.editorProps),
        this.view.updateState(this.state))
  }
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }),
      n && this.emit('update', { editor: this, transaction: this.state.tr })
  }
  get isEditable() {
    return this.options.editable && this.view && this.view.editable
  }
  get state() {
    return this.view.state
  }
  registerPlugin(e, n) {
    const r = EM(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e],
      i = this.state.reconfigure({ plugins: r })
    this.view.updateState(i)
  }
  unregisterPlugin(e) {
    if (this.isDestroyed) return
    const n = typeof e == 'string' ? `${e}$` : e.key,
      r = this.state.reconfigure({
        plugins: this.state.plugins.filter((i) => !i.key.startsWith(n))
      })
    this.view.updateState(r)
  }
  createExtensionManager() {
    const n = [
      ...(this.options.enableCoreExtensions ? Object.values(CK) : []),
      ...this.options.extensions
    ].filter((r) => ['extension', 'node', 'mark'].includes(r == null ? void 0 : r.type))
    this.extensionManager = new La(n, this)
  }
  createCommandManager() {
    this.commandManager = new Am({ editor: this })
  }
  createSchema() {
    this.schema = this.extensionManager.schema
  }
  createView() {
    const e = CM(this.options.content, this.schema, this.options.parseOptions),
      n = IM(e, this.options.autofocus)
    this.view = new lG(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Da.create({ doc: e, selection: n || void 0 })
    })
    const r = this.state.reconfigure({ plugins: this.extensionManager.plugins })
    this.view.updateState(r), this.createNodeViews(), this.prependClass()
    const i = this.view.dom
    i.editor = this
  }
  createNodeViews() {
    this.view.setProps({ nodeViews: this.extensionManager.nodeViews })
  }
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`
  }
  captureTransaction(e) {
    ;(this.isCapturingTransaction = !0), e(), (this.isCapturingTransaction = !1)
    const n = this.capturedTransaction
    return (this.capturedTransaction = null), n
  }
  dispatchTransaction(e) {
    if (this.view.isDestroyed) return
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e
        return
      }
      e.steps.forEach((o) => {
        var a
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(o)
      })
      return
    }
    const n = this.state.apply(e),
      r = !this.state.selection.eq(n.selection)
    this.view.updateState(n),
      this.emit('transaction', { editor: this, transaction: e }),
      r && this.emit('selectionUpdate', { editor: this, transaction: e })
    const i = e.getMeta('focus'),
      s = e.getMeta('blur')
    i && this.emit('focus', { editor: this, event: i.event, transaction: e }),
      s && this.emit('blur', { editor: this, event: s.event, transaction: e }),
      !(!e.docChanged || e.getMeta('preventUpdate')) &&
        this.emit('update', { editor: this, transaction: e })
  }
  getAttributes(e) {
    return Zq(this.state, e)
  }
  isActive(e, n) {
    const r = typeof e == 'string' ? e : null,
      i = typeof e == 'string' ? n : e
    return eK(this.state, r, i)
  }
  getJSON() {
    return this.state.doc.toJSON()
  }
  getHTML() {
    return Jq(this.state.doc.content, this.schema)
  }
  getText(e) {
    const {
      blockSeparator: n = `

`,
      textSerializers: r = {}
    } = e || {}
    return Qq(this.state.doc, { blockSeparator: n, textSerializers: { ...wM(this.schema), ...r } })
  }
  get isEmpty() {
    return tK(this.state.doc)
  }
  getCharacterCount() {
    return (
      console.warn(
        '[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'
      ),
      this.state.doc.content.size - 2
    )
  }
  destroy() {
    this.emit('destroy'), this.view && this.view.destroy(), this.removeAllListeners()
  }
  get isDestroyed() {
    var e
    return !(!((e = this.view) === null || e === void 0) && e.docView)
  }
  $node(e, n) {
    var r
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null
  }
  $nodes(e, n) {
    var r
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null
  }
  $pos(e) {
    const n = this.state.doc.resolve(e)
    return new _o(n, this)
  }
  get $doc() {
    return this.$pos(0)
  }
}
function Ol(t) {
  return new Rm({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = Ve(t.getAttributes, void 0, r)
      if (i === !1 || i === null) return null
      const { tr: s } = e,
        o = r[r.length - 1],
        a = r[0]
      if (o) {
        const l = a.search(/\S/),
          c = n.from + a.indexOf(o),
          u = c + o.length
        if (
          RM(n.from, n.to, e.doc)
            .filter((f) => f.mark.type.excluded.find((m) => m === t.type && m !== f.mark.type))
            .filter((f) => f.to > c).length
        )
          return null
        u < n.to && s.delete(u, n.to), c > n.from && s.delete(n.from + l, c)
        const d = n.from + l + o.length
        s.addMark(n.from + l, d, t.type.create(i || {})), s.removeStoredMark(t.type)
      }
    }
  })
}
function NK(t) {
  return new Rm({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = Ve(t.getAttributes, void 0, r) || {},
        { tr: s } = e,
        o = n.from
      let a = n.to
      const l = t.type.create(i)
      if (r[1]) {
        const c = r[0].lastIndexOf(r[1])
        let u = o + c
        u > a ? (u = a) : (a = u + r[1].length)
        const h = r[0][r[0].length - 1]
        s.insertText(h, o + r[0].length - 1), s.replaceWith(u, a, l)
      } else r[0] && s.insert(o - 1, t.type.create(i)).delete(s.mapping.map(o), s.mapping.map(a))
      s.scrollIntoView()
    }
  })
}
function rv(t) {
  return new Rm({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = e.doc.resolve(n.from),
        s = Ve(t.getAttributes, void 0, r) || {}
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), t.type)) return null
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, s)
    }
  })
}
function Vu(t) {
  return new Rm({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: i }) => {
      const s = Ve(t.getAttributes, void 0, r) || {},
        o = e.tr.delete(n.from, n.to),
        l = o.doc.resolve(n.from).blockRange(),
        c = l && U1(l, t.type, s)
      if (!c) return null
      if ((o.wrap(l, c), t.keepMarks && t.editor)) {
        const { selection: h, storedMarks: d } = e,
          { splittableMarks: f } = t.editor.extensionManager,
          p = d || (h.$to.parentOffset && h.$from.marks())
        if (p) {
          const m = p.filter((g) => f.includes(g.type.name))
          o.ensureMarks(m)
        }
      }
      if (t.keepAttributes) {
        const h =
          t.type.name === 'bulletList' || t.type.name === 'orderedList' ? 'listItem' : 'taskList'
        i().updateAttributes(h, s).run()
      }
      const u = o.doc.resolve(n.from - 1).nodeBefore
      u &&
        u.type === t.type &&
        eo(o.doc, n.from - 1) &&
        (!t.joinPredicate || t.joinPredicate(r, u)) &&
        o.join(n.from - 1)
    }
  })
}
class Si {
  constructor(e = {}) {
    ;(this.type = 'mark'),
      (this.name = 'mark'),
      (this.parent = null),
      (this.child = null),
      (this.config = { name: this.name, defaultOptions: {} }),
      (this.config = { ...this.config, ...e }),
      (this.name = this.config.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions && (this.options = Ve(ce(this, 'addOptions', { name: this.name }))),
      (this.storage = Ve(ce(this, 'addStorage', { name: this.name, options: this.options })) || {})
  }
  static create(e = {}) {
    return new Si(e)
  }
  configure(e = {}) {
    const n = this.extend()
    return (
      (n.options = km(this.options, e)),
      (n.storage = Ve(ce(n, 'addStorage', { name: n.name, options: n.options }))),
      n
    )
  }
  extend(e = {}) {
    const n = new Si({ ...this.config, ...e })
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = Ve(ce(n, 'addOptions', { name: n.name }))),
      (n.storage = Ve(ce(n, 'addStorage', { name: n.name, options: n.options }))),
      n
    )
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state,
      i = e.state.selection.$from
    if (i.pos === i.end()) {
      const o = i.marks()
      if (!!!o.find((c) => (c == null ? void 0 : c.type.name) === n.name)) return !1
      const l = o.find((c) => (c == null ? void 0 : c.type.name) === n.name)
      return l && r.removeStoredMark(l), r.insertText(' ', i.pos), e.view.dispatch(r), !0
    }
    return !1
  }
}
let fr = class iv {
  constructor(e = {}) {
    ;(this.type = 'node'),
      (this.name = 'node'),
      (this.parent = null),
      (this.child = null),
      (this.config = { name: this.name, defaultOptions: {} }),
      (this.config = { ...this.config, ...e }),
      (this.name = this.config.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions && (this.options = Ve(ce(this, 'addOptions', { name: this.name }))),
      (this.storage = Ve(ce(this, 'addStorage', { name: this.name, options: this.options })) || {})
  }
  static create(e = {}) {
    return new iv(e)
  }
  configure(e = {}) {
    const n = this.extend()
    return (
      (n.options = km(this.options, e)),
      (n.storage = Ve(ce(n, 'addStorage', { name: n.name, options: n.options }))),
      n
    )
  }
  extend(e = {}) {
    const n = new iv({ ...this.config, ...e })
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = Ve(ce(n, 'addOptions', { name: n.name }))),
      (n.storage = Ve(ce(n, 'addStorage', { name: n.name, options: n.options }))),
      n
    )
  }
}
function Nl(t) {
  return new QG({
    find: t.find,
    handler: ({ state: e, range: n, match: r, pasteEvent: i }) => {
      const s = Ve(t.getAttributes, void 0, r, i)
      if (s === !1 || s === null) return null
      const { tr: o } = e,
        a = r[r.length - 1],
        l = r[0]
      let c = n.to
      if (a) {
        const u = l.search(/\S/),
          h = n.from + l.indexOf(a),
          d = h + a.length
        if (
          RM(n.from, n.to, e.doc)
            .filter((p) => p.mark.type.excluded.find((g) => g === t.type && g !== p.mark.type))
            .filter((p) => p.to > h).length
        )
          return null
        d < n.to && o.delete(d, n.to),
          h > n.from && o.delete(n.from + u, h),
          (c = n.from + u + a.length),
          o.addMark(n.from + u, c, t.type.create(s || {})),
          o.removeStoredMark(t.type)
      }
    }
  })
}
const MK = /^\s*>\s$/,
  PK = fr.create({
    name: 'blockquote',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    content: 'block+',
    group: 'block',
    defining: !0,
    parseHTML() {
      return [{ tag: 'blockquote' }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['blockquote', qt(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
      return {
        setBlockquote:
          () =>
          ({ commands: t }) =>
            t.wrapIn(this.name),
        toggleBlockquote:
          () =>
          ({ commands: t }) =>
            t.toggleWrap(this.name),
        unsetBlockquote:
          () =>
          ({ commands: t }) =>
            t.lift(this.name)
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-Shift-b': () => this.editor.commands.toggleBlockquote() }
    },
    addInputRules() {
      return [Vu({ find: MK, type: this.type })]
    }
  }),
  xK = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/,
  DK = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g,
  LK = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/,
  VK = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g,
  FK = Si.create({
    name: 'bold',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: 'strong' },
        { tag: 'b', getAttrs: (t) => t.style.fontWeight !== 'normal' && null },
        { style: 'font-weight', getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null }
      ]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['strong', qt(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
      return {
        setBold:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleBold:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetBold:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name)
      }
    },
    addKeyboardShortcuts() {
      return {
        'Mod-b': () => this.editor.commands.toggleBold(),
        'Mod-B': () => this.editor.commands.toggleBold()
      }
    },
    addInputRules() {
      return [Ol({ find: xK, type: this.type }), Ol({ find: LK, type: this.type })]
    },
    addPasteRules() {
      return [Nl({ find: DK, type: this.type }), Nl({ find: VK, type: this.type })]
    }
  }),
  BK = fr.create({
    name: 'listItem',
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: 'bulletList',
        orderedListTypeName: 'orderedList'
      }
    },
    content: 'paragraph block*',
    defining: !0,
    parseHTML() {
      return [{ tag: 'li' }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['li', qt(this.options.HTMLAttributes, t), 0]
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        'Shift-Tab': () => this.editor.commands.liftListItem(this.name)
      }
    }
  }),
  tI = Si.create({
    name: 'textStyle',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [{ tag: 'span', getAttrs: (t) => (t.hasAttribute('style') ? {} : !1) }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['span', qt(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
      return {
        removeEmptyTextStyle:
          () =>
          ({ state: t, commands: e }) => {
            const n = Nm(t, this.type)
            return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name)
          }
      }
    }
  }),
  nI = /^\s*([-+*])\s$/,
  UK = fr.create({
    name: 'bulletList',
    addOptions() {
      return { itemTypeName: 'listItem', HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 }
    },
    group: 'block list',
    content() {
      return `${this.options.itemTypeName}+`
    },
    parseHTML() {
      return [{ tag: 'ul' }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['ul', qt(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
      return {
        toggleBulletList:
          () =>
          ({ commands: t, chain: e }) =>
            this.options.keepAttributes
              ? e()
                  .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
                  .updateAttributes(BK.name, this.editor.getAttributes(tI.name))
                  .run()
              : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-Shift-8': () => this.editor.commands.toggleBulletList() }
    },
    addInputRules() {
      let t = Vu({ find: nI, type: this.type })
      return (
        (this.options.keepMarks || this.options.keepAttributes) &&
          (t = Vu({
            find: nI,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: () => this.editor.getAttributes(tI.name),
            editor: this.editor
          })),
        [t]
      )
    }
  }),
  $K = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/,
  HK = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g,
  zK = Si.create({
    name: 'code',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    excludes: '_',
    code: !0,
    exitable: !0,
    parseHTML() {
      return [{ tag: 'code' }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['code', qt(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
      return {
        setCode:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleCode:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetCode:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name)
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-e': () => this.editor.commands.toggleCode() }
    },
    addInputRules() {
      return [Ol({ find: $K, type: this.type })]
    },
    addPasteRules() {
      return [Nl({ find: HK, type: this.type })]
    }
  }),
  jK = /^```([a-z]+)?[\s\n]$/,
  WK = /^~~~([a-z]+)?[\s\n]$/,
  GK = fr.create({
    name: 'codeBlock',
    addOptions() {
      return {
        languageClassPrefix: 'language-',
        exitOnTripleEnter: !0,
        exitOnArrowDown: !0,
        HTMLAttributes: {}
      }
    },
    content: 'text*',
    marks: '',
    group: 'block',
    code: !0,
    defining: !0,
    addAttributes() {
      return {
        language: {
          default: null,
          parseHTML: (t) => {
            var e
            const { languageClassPrefix: n } = this.options,
              s = [
                ...(((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) ||
                  [])
              ]
                .filter((o) => o.startsWith(n))
                .map((o) => o.replace(n, ''))[0]
            return s || null
          },
          rendered: !1
        }
      }
    },
    parseHTML() {
      return [{ tag: 'pre', preserveWhitespace: 'full' }]
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
      return [
        'pre',
        qt(this.options.HTMLAttributes, e),
        [
          'code',
          { class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null },
          0
        ]
      ]
    },
    addCommands() {
      return {
        setCodeBlock:
          (t) =>
          ({ commands: e }) =>
            e.setNode(this.name, t),
        toggleCodeBlock:
          (t) =>
          ({ commands: e }) =>
            e.toggleNode(this.name, 'paragraph', t)
      }
    },
    addKeyboardShortcuts() {
      return {
        'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),
        Backspace: () => {
          const { empty: t, $anchor: e } = this.editor.state.selection,
            n = e.pos === 1
          return !t || e.parent.type.name !== this.name
            ? !1
            : n || !e.parent.textContent.length
            ? this.editor.commands.clearNodes()
            : !1
        },
        Enter: ({ editor: t }) => {
          if (!this.options.exitOnTripleEnter) return !1
          const { state: e } = t,
            { selection: n } = e,
            { $from: r, empty: i } = n
          if (!i || r.parent.type !== this.type) return !1
          const s = r.parentOffset === r.parent.nodeSize - 2,
            o = r.parent.textContent.endsWith(`

`)
          return !s || !o
            ? !1
            : t
                .chain()
                .command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0))
                .exitCode()
                .run()
        },
        ArrowDown: ({ editor: t }) => {
          if (!this.options.exitOnArrowDown) return !1
          const { state: e } = t,
            { selection: n, doc: r } = e,
            { $from: i, empty: s } = n
          if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
            return !1
          const a = i.after()
          return a === void 0 || r.nodeAt(a) ? !1 : t.commands.exitCode()
        }
      }
    },
    addInputRules() {
      return [
        rv({ find: jK, type: this.type, getAttributes: (t) => ({ language: t[1] }) }),
        rv({ find: WK, type: this.type, getAttributes: (t) => ({ language: t[1] }) })
      ]
    },
    addProseMirrorPlugins() {
      return [
        new Cr({
          key: new to('codeBlockVSCodeHandler'),
          props: {
            handlePaste: (t, e) => {
              if (!e.clipboardData || this.editor.isActive(this.type.name)) return !1
              const n = e.clipboardData.getData('text/plain'),
                r = e.clipboardData.getData('vscode-editor-data'),
                i = r ? JSON.parse(r) : void 0,
                s = i == null ? void 0 : i.mode
              if (!n || !s) return !1
              const { tr: o } = t.state
              return (
                o.replaceSelectionWith(this.type.create({ language: s })),
                o.setSelection(Me.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))),
                o.insertText(
                  n.replace(
                    /\r\n?/g,
                    `
`
                  )
                ),
                o.setMeta('paste', !0),
                t.dispatch(o),
                !0
              )
            }
          }
        })
      ]
    }
  }),
  qK = fr.create({ name: 'doc', topNode: !0, content: 'block+' })
function KK(t = {}) {
  return new Cr({
    view(e) {
      return new YK(e, t)
    }
  })
}
class YK {
  constructor(e, n) {
    var r
    ;(this.editorView = e),
      (this.cursorPos = null),
      (this.element = null),
      (this.timeout = -1),
      (this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
      (this.color = n.color === !1 ? void 0 : n.color || 'black'),
      (this.class = n.class),
      (this.handlers = ['dragover', 'dragend', 'drop', 'dragleave'].map((i) => {
        let s = (o) => {
          this[i](o)
        }
        return e.dom.addEventListener(i, s), { name: i, handler: s }
      }))
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) =>
      this.editorView.dom.removeEventListener(e, n)
    )
  }
  update(e, n) {
    this.cursorPos != null &&
      n.doc != e.state.doc &&
      (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay())
  }
  setCursor(e) {
    e != this.cursorPos &&
      ((this.cursorPos = e),
      e == null
        ? (this.element.parentNode.removeChild(this.element), (this.element = null))
        : this.updateOverlay())
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos),
      n = !e.parent.inlineContent,
      r
    if (n) {
      let a = e.nodeBefore,
        l = e.nodeAfter
      if (a || l) {
        let c = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0))
        if (c) {
          let u = c.getBoundingClientRect(),
            h = a ? u.bottom : u.top
          a &&
            l &&
            (h = (h + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2),
            (r = {
              left: u.left,
              right: u.right,
              top: h - this.width / 2,
              bottom: h + this.width / 2
            })
        }
      }
    }
    if (!r) {
      let a = this.editorView.coordsAtPos(this.cursorPos)
      r = {
        left: a.left - this.width / 2,
        right: a.left + this.width / 2,
        top: a.top,
        bottom: a.bottom
      }
    }
    let i = this.editorView.dom.offsetParent
    this.element ||
      ((this.element = i.appendChild(document.createElement('div'))),
      this.class && (this.element.className = this.class),
      (this.element.style.cssText = 'position: absolute; z-index: 50; pointer-events: none;'),
      this.color && (this.element.style.backgroundColor = this.color)),
      this.element.classList.toggle('prosemirror-dropcursor-block', n),
      this.element.classList.toggle('prosemirror-dropcursor-inline', !n)
    let s, o
    if (!i || (i == document.body && getComputedStyle(i).position == 'static'))
      (s = -pageXOffset), (o = -pageYOffset)
    else {
      let a = i.getBoundingClientRect()
      ;(s = a.left - i.scrollLeft), (o = a.top - i.scrollTop)
    }
    ;(this.element.style.left = r.left - s + 'px'),
      (this.element.style.top = r.top - o + 'px'),
      (this.element.style.width = r.right - r.left + 'px'),
      (this.element.style.height = r.bottom - r.top + 'px')
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), (this.timeout = setTimeout(() => this.setCursor(null), e))
  }
  dragover(e) {
    if (!this.editorView.editable) return
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }),
      r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside),
      i = r && r.type.spec.disableDropCursor,
      s = typeof i == 'function' ? i(this.editorView, n, e) : i
    if (n && !s) {
      let o = n.pos
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = CN(this.editorView.state.doc, o, this.editorView.dragging.slice)
        a != null && (o = a)
      }
      this.setCursor(o), this.scheduleRemoval(5e3)
    }
  }
  dragend() {
    this.scheduleRemoval(20)
  }
  drop() {
    this.scheduleRemoval(20)
  }
  dragleave(e) {
    ;(e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) &&
      this.setCursor(null)
  }
}
const JK = dr.create({
  name: 'dropCursor',
  addOptions() {
    return { color: 'currentColor', width: 1, class: void 0 }
  },
  addProseMirrorPlugins() {
    return [KK(this.options)]
  }
})
class Ot extends Fe {
  constructor(e) {
    super(e, e)
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head))
    return Ot.valid(r) ? new Ot(r) : Fe.near(r)
  }
  content() {
    return ie.empty
  }
  eq(e) {
    return e instanceof Ot && e.head == this.head
  }
  toJSON() {
    return { type: 'gapcursor', pos: this.head }
  }
  static fromJSON(e, n) {
    if (typeof n.pos != 'number') throw new RangeError('Invalid input for GapCursor.fromJSON')
    return new Ot(e.resolve(n.pos))
  }
  getBookmark() {
    return new rb(this.anchor)
  }
  static valid(e) {
    let n = e.parent
    if (n.isTextblock || !QK(e) || !XK(e)) return !1
    let r = n.type.spec.allowGapCursor
    if (r != null) return r
    let i = n.contentMatchAt(e.index()).defaultType
    return i && i.isTextblock
  }
  static findGapCursorFrom(e, n, r = !1) {
    e: for (;;) {
      if (!r && Ot.valid(e)) return e
      let i = e.pos,
        s = null
      for (let o = e.depth; ; o--) {
        let a = e.node(o)
        if (n > 0 ? e.indexAfter(o) < a.childCount : e.index(o) > 0) {
          s = a.child(n > 0 ? e.indexAfter(o) : e.index(o) - 1)
          break
        } else if (o == 0) return null
        i += n
        let l = e.doc.resolve(i)
        if (Ot.valid(l)) return l
      }
      for (;;) {
        let o = n > 0 ? s.firstChild : s.lastChild
        if (!o) {
          if (s.isAtom && !s.isText && !Ee.isSelectable(s)) {
            ;(e = e.doc.resolve(i + s.nodeSize * n)), (r = !1)
            continue e
          }
          break
        }
        ;(s = o), (i += n)
        let a = e.doc.resolve(i)
        if (Ot.valid(a)) return a
      }
      return null
    }
  }
}
Ot.prototype.visible = !1
Ot.findFrom = Ot.findGapCursorFrom
Fe.jsonID('gapcursor', Ot)
class rb {
  constructor(e) {
    this.pos = e
  }
  map(e) {
    return new rb(e.map(this.pos))
  }
  resolve(e) {
    let n = e.resolve(this.pos)
    return Ot.valid(n) ? new Ot(n) : Fe.near(n)
  }
}
function QK(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e),
      r = t.node(e)
    if (n == 0) {
      if (r.type.spec.isolating) return !0
      continue
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if ((i.childCount == 0 && !i.inlineContent) || i.isAtom || i.type.spec.isolating) return !0
      if (i.inlineContent) return !1
    }
  }
  return !0
}
function XK(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e),
      r = t.node(e)
    if (n == r.childCount) {
      if (r.type.spec.isolating) return !0
      continue
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if ((i.childCount == 0 && !i.inlineContent) || i.isAtom || i.type.spec.isolating) return !0
      if (i.inlineContent) return !1
    }
  }
  return !0
}
function ZK() {
  return new Cr({
    props: {
      decorations: rY,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && Ot.valid(n) ? new Ot(n) : null
      },
      handleClick: tY,
      handleKeyDown: eY,
      handleDOMEvents: { beforeinput: nY }
    }
  })
}
const eY = fM({
  ArrowLeft: ld('horiz', -1),
  ArrowRight: ld('horiz', 1),
  ArrowUp: ld('vert', -1),
  ArrowDown: ld('vert', 1)
})
function ld(t, e) {
  const n = t == 'vert' ? (e > 0 ? 'down' : 'up') : e > 0 ? 'right' : 'left'
  return function (r, i, s) {
    let o = r.selection,
      a = e > 0 ? o.$to : o.$from,
      l = o.empty
    if (o instanceof Me) {
      if (!s.endOfTextblock(n) || a.depth == 0) return !1
      ;(l = !1), (a = r.doc.resolve(e > 0 ? a.after() : a.before()))
    }
    let c = Ot.findGapCursorFrom(a, e, l)
    return c ? (i && i(r.tr.setSelection(new Ot(c))), !0) : !1
  }
}
function tY(t, e, n) {
  if (!t || !t.editable) return !1
  let r = t.state.doc.resolve(e)
  if (!Ot.valid(r)) return !1
  let i = t.posAtCoords({ left: n.clientX, top: n.clientY })
  return i && i.inside > -1 && Ee.isSelectable(t.state.doc.nodeAt(i.inside))
    ? !1
    : (t.dispatch(t.state.tr.setSelection(new Ot(r))), !0)
}
function nY(t, e) {
  if (e.inputType != 'insertCompositionText' || !(t.state.selection instanceof Ot)) return !1
  let { $from: n } = t.state.selection,
    r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text)
  if (!r) return !1
  let i = H.empty
  for (let o = r.length - 1; o >= 0; o--) i = H.from(r[o].createAndFill(null, i))
  let s = t.state.tr.replace(n.pos, n.pos, new ie(i, 0, 0))
  return s.setSelection(Me.near(s.doc.resolve(n.pos + 1))), t.dispatch(s), !1
}
function rY(t) {
  if (!(t.selection instanceof Ot)) return null
  let e = document.createElement('div')
  return (
    (e.className = 'ProseMirror-gapcursor'),
    zt.create(t.doc, [wr.widget(t.selection.head, e, { key: 'gapcursor' })])
  )
}
const iY = dr.create({
    name: 'gapCursor',
    addProseMirrorPlugins() {
      return [ZK()]
    },
    extendNodeSchema(t) {
      var e
      const n = { name: t.name, options: t.options, storage: t.storage }
      return {
        allowGapCursor: (e = Ve(ce(t, 'allowGapCursor', n))) !== null && e !== void 0 ? e : null
      }
    }
  }),
  sY = fr.create({
    name: 'hardBreak',
    addOptions() {
      return { keepMarks: !0, HTMLAttributes: {} }
    },
    inline: !0,
    group: 'inline',
    selectable: !1,
    parseHTML() {
      return [{ tag: 'br' }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['br', qt(this.options.HTMLAttributes, t)]
    },
    renderText() {
      return `
`
    },
    addCommands() {
      return {
        setHardBreak:
          () =>
          ({ commands: t, chain: e, state: n, editor: r }) =>
            t.first([
              () => t.exitCode(),
              () =>
                t.command(() => {
                  const { selection: i, storedMarks: s } = n
                  if (i.$from.parent.type.spec.isolating) return !1
                  const { keepMarks: o } = this.options,
                    { splittableMarks: a } = r.extensionManager,
                    l = s || (i.$to.parentOffset && i.$from.marks())
                  return e()
                    .insertContent({ type: this.name })
                    .command(({ tr: c, dispatch: u }) => {
                      if (u && l && o) {
                        const h = l.filter((d) => a.includes(d.type.name))
                        c.ensureMarks(h)
                      }
                      return !0
                    })
                    .run()
                })
            ])
      }
    },
    addKeyboardShortcuts() {
      return {
        'Mod-Enter': () => this.editor.commands.setHardBreak(),
        'Shift-Enter': () => this.editor.commands.setHardBreak()
      }
    }
  }),
  oY = fr.create({
    name: 'heading',
    addOptions() {
      return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} }
    },
    content: 'inline*',
    group: 'block',
    defining: !0,
    addAttributes() {
      return { level: { default: 1, rendered: !1 } }
    },
    parseHTML() {
      return this.options.levels.map((t) => ({ tag: `h${t}`, attrs: { level: t } }))
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
      return [
        `h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`,
        qt(this.options.HTMLAttributes, e),
        0
      ]
    },
    addCommands() {
      return {
        setHeading:
          (t) =>
          ({ commands: e }) =>
            this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
        toggleHeading:
          (t) =>
          ({ commands: e }) =>
            this.options.levels.includes(t.level) ? e.toggleNode(this.name, 'paragraph', t) : !1
      }
    },
    addKeyboardShortcuts() {
      return this.options.levels.reduce(
        (t, e) => ({
          ...t,
          [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
        }),
        {}
      )
    },
    addInputRules() {
      return this.options.levels.map((t) =>
        rv({ find: new RegExp(`^(#{1,${t}})\\s$`), type: this.type, getAttributes: { level: t } })
      )
    }
  })
var np = 200,
  nn = function () {}
nn.prototype.append = function (e) {
  return e.length
    ? ((e = nn.from(e)),
      (!this.length && e) ||
        (e.length < np && this.leafAppend(e)) ||
        (this.length < np && e.leafPrepend(this)) ||
        this.appendInner(e))
    : this
}
nn.prototype.prepend = function (e) {
  return e.length ? nn.from(e).append(this) : this
}
nn.prototype.appendInner = function (e) {
  return new aY(this, e)
}
nn.prototype.slice = function (e, n) {
  return (
    e === void 0 && (e = 0),
    n === void 0 && (n = this.length),
    e >= n ? nn.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n))
  )
}
nn.prototype.get = function (e) {
  if (!(e < 0 || e >= this.length)) return this.getInner(e)
}
nn.prototype.forEach = function (e, n, r) {
  n === void 0 && (n = 0),
    r === void 0 && (r = this.length),
    n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0)
}
nn.prototype.map = function (e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length)
  var i = []
  return (
    this.forEach(
      function (s, o) {
        return i.push(e(s, o))
      },
      n,
      r
    ),
    i
  )
}
nn.from = function (e) {
  return e instanceof nn ? e : e && e.length ? new kM(e) : nn.empty
}
var kM = (function (t) {
  function e(r) {
    t.call(this), (this.values = r)
  }
  t && (e.__proto__ = t),
    (e.prototype = Object.create(t && t.prototype)),
    (e.prototype.constructor = e)
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } }
  return (
    (e.prototype.flatten = function () {
      return this.values
    }),
    (e.prototype.sliceInner = function (i, s) {
      return i == 0 && s == this.length ? this : new e(this.values.slice(i, s))
    }),
    (e.prototype.getInner = function (i) {
      return this.values[i]
    }),
    (e.prototype.forEachInner = function (i, s, o, a) {
      for (var l = s; l < o; l++) if (i(this.values[l], a + l) === !1) return !1
    }),
    (e.prototype.forEachInvertedInner = function (i, s, o, a) {
      for (var l = s - 1; l >= o; l--) if (i(this.values[l], a + l) === !1) return !1
    }),
    (e.prototype.leafAppend = function (i) {
      if (this.length + i.length <= np) return new e(this.values.concat(i.flatten()))
    }),
    (e.prototype.leafPrepend = function (i) {
      if (this.length + i.length <= np) return new e(i.flatten().concat(this.values))
    }),
    (n.length.get = function () {
      return this.values.length
    }),
    (n.depth.get = function () {
      return 0
    }),
    Object.defineProperties(e.prototype, n),
    e
  )
})(nn)
nn.empty = new kM([])
var aY = (function (t) {
  function e(n, r) {
    t.call(this),
      (this.left = n),
      (this.right = r),
      (this.length = n.length + r.length),
      (this.depth = Math.max(n.depth, r.depth) + 1)
  }
  return (
    t && (e.__proto__ = t),
    (e.prototype = Object.create(t && t.prototype)),
    (e.prototype.constructor = e),
    (e.prototype.flatten = function () {
      return this.left.flatten().concat(this.right.flatten())
    }),
    (e.prototype.getInner = function (r) {
      return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length)
    }),
    (e.prototype.forEachInner = function (r, i, s, o) {
      var a = this.left.length
      if (
        (i < a && this.left.forEachInner(r, i, Math.min(s, a), o) === !1) ||
        (s > a &&
          this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, s) - a, o + a) ===
            !1)
      )
        return !1
    }),
    (e.prototype.forEachInvertedInner = function (r, i, s, o) {
      var a = this.left.length
      if (
        (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(s, a) - a, o + a) === !1) ||
        (s < a && this.left.forEachInvertedInner(r, Math.min(i, a), s, o) === !1)
      )
        return !1
    }),
    (e.prototype.sliceInner = function (r, i) {
      if (r == 0 && i == this.length) return this
      var s = this.left.length
      return i <= s
        ? this.left.slice(r, i)
        : r >= s
        ? this.right.slice(r - s, i - s)
        : this.left.slice(r, s).append(this.right.slice(0, i - s))
    }),
    (e.prototype.leafAppend = function (r) {
      var i = this.right.leafAppend(r)
      if (i) return new e(this.left, i)
    }),
    (e.prototype.leafPrepend = function (r) {
      var i = this.left.leafPrepend(r)
      if (i) return new e(i, this.right)
    }),
    (e.prototype.appendInner = function (r) {
      return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
        ? new e(this.left, new e(this.right, r))
        : new e(this, r)
    }),
    e
  )
})(nn)
const lY = 500
class xr {
  constructor(e, n) {
    ;(this.items = e), (this.eventCount = n)
  }
  popEvent(e, n) {
    if (this.eventCount == 0) return null
    let r = this.items.length
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r
        break
      }
    let i, s
    n && ((i = this.remapping(r, this.items.length)), (s = i.maps.length))
    let o = e.tr,
      a,
      l,
      c = [],
      u = []
    return (
      this.items.forEach(
        (h, d) => {
          if (!h.step) {
            i || ((i = this.remapping(r, d + 1)), (s = i.maps.length)), s--, u.push(h)
            return
          }
          if (i) {
            u.push(new Yr(h.map))
            let f = h.step.map(i.slice(s)),
              p
            f &&
              o.maybeStep(f).doc &&
              ((p = o.mapping.maps[o.mapping.maps.length - 1]),
              c.push(new Yr(p, void 0, void 0, c.length + u.length))),
              s--,
              p && i.appendMap(p, s)
          } else o.maybeStep(h.step)
          if (h.selection)
            return (
              (a = i ? h.selection.map(i.slice(s)) : h.selection),
              (l = new xr(
                this.items.slice(0, r).append(u.reverse().concat(c)),
                this.eventCount - 1
              )),
              !1
            )
        },
        this.items.length,
        0
      ),
      { remaining: l, transform: o, selection: a }
    )
  }
  addTransform(e, n, r, i) {
    let s = [],
      o = this.eventCount,
      a = this.items,
      l = !i && a.length ? a.get(a.length - 1) : null
    for (let u = 0; u < e.steps.length; u++) {
      let h = e.steps[u].invert(e.docs[u]),
        d = new Yr(e.mapping.maps[u], h, n),
        f
      ;(f = l && l.merge(d)) && ((d = f), u ? s.pop() : (a = a.slice(0, a.length - 1))),
        s.push(d),
        n && (o++, (n = void 0)),
        i || (l = d)
    }
    let c = o - r.depth
    return c > uY && ((a = cY(a, c)), (o -= c)), new xr(a.append(s), o)
  }
  remapping(e, n) {
    let r = new el()
    return (
      this.items.forEach(
        (i, s) => {
          let o =
            i.mirrorOffset != null && s - i.mirrorOffset >= e
              ? r.maps.length - i.mirrorOffset
              : void 0
          r.appendMap(i.map, o)
        },
        e,
        n
      ),
      r
    )
  }
  addMaps(e) {
    return this.eventCount == 0
      ? this
      : new xr(this.items.append(e.map((n) => new Yr(n))), this.eventCount)
  }
  rebased(e, n) {
    if (!this.eventCount) return this
    let r = [],
      i = Math.max(0, this.items.length - n),
      s = e.mapping,
      o = e.steps.length,
      a = this.eventCount
    this.items.forEach((d) => {
      d.selection && a--
    }, i)
    let l = n
    this.items.forEach((d) => {
      let f = s.getMirror(--l)
      if (f == null) return
      o = Math.min(o, f)
      let p = s.maps[f]
      if (d.step) {
        let m = e.steps[f].invert(e.docs[f]),
          g = d.selection && d.selection.map(s.slice(l + 1, f))
        g && a++, r.push(new Yr(p, m, g))
      } else r.push(new Yr(p))
    }, i)
    let c = []
    for (let d = n; d < o; d++) c.push(new Yr(s.maps[d]))
    let u = this.items.slice(0, i).append(c).append(r),
      h = new xr(u, a)
    return h.emptyItemCount() > lY && (h = h.compress(this.items.length - r.length)), h
  }
  emptyItemCount() {
    let e = 0
    return (
      this.items.forEach((n) => {
        n.step || e++
      }),
      e
    )
  }
  compress(e = this.items.length) {
    let n = this.remapping(0, e),
      r = n.maps.length,
      i = [],
      s = 0
    return (
      this.items.forEach(
        (o, a) => {
          if (a >= e) i.push(o), o.selection && s++
          else if (o.step) {
            let l = o.step.map(n.slice(r)),
              c = l && l.getMap()
            if ((r--, c && n.appendMap(c, r), l)) {
              let u = o.selection && o.selection.map(n.slice(r))
              u && s++
              let h = new Yr(c.invert(), l, u),
                d,
                f = i.length - 1
              ;(d = i.length && i[f].merge(h)) ? (i[f] = d) : i.push(h)
            }
          } else o.map && r--
        },
        this.items.length,
        0
      ),
      new xr(nn.from(i.reverse()), s)
    )
  }
}
xr.empty = new xr(nn.empty, 0)
function cY(t, e) {
  let n
  return (
    t.forEach((r, i) => {
      if (r.selection && e-- == 0) return (n = i), !1
    }),
    t.slice(n)
  )
}
class Yr {
  constructor(e, n, r, i) {
    ;(this.map = e), (this.step = n), (this.selection = r), (this.mirrorOffset = i)
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step)
      if (n) return new Yr(n.getMap().invert(), n, this.selection)
    }
  }
}
class gs {
  constructor(e, n, r, i, s) {
    ;(this.done = e),
      (this.undone = n),
      (this.prevRanges = r),
      (this.prevTime = i),
      (this.prevComposition = s)
  }
}
const uY = 20
function hY(t, e, n, r) {
  let i = n.getMeta(jo),
    s
  if (i) return i.historyState
  n.getMeta(pY) && (t = new gs(t.done, t.undone, null, 0, -1))
  let o = n.getMeta('appendedTransaction')
  if (n.steps.length == 0) return t
  if (o && o.getMeta(jo))
    return o.getMeta(jo).redo
      ? new gs(
          t.done.addTransform(n, void 0, r, Bd(e)),
          t.undone,
          rI(n.mapping.maps[n.steps.length - 1]),
          t.prevTime,
          t.prevComposition
        )
      : new gs(
          t.done,
          t.undone.addTransform(n, void 0, r, Bd(e)),
          null,
          t.prevTime,
          t.prevComposition
        )
  if (n.getMeta('addToHistory') !== !1 && !(o && o.getMeta('addToHistory') === !1)) {
    let a = n.getMeta('composition'),
      l =
        t.prevTime == 0 ||
        (!o &&
          t.prevComposition != a &&
          (t.prevTime < (n.time || 0) - r.newGroupDelay || !dY(n, t.prevRanges))),
      c = o ? ny(t.prevRanges, n.mapping) : rI(n.mapping.maps[n.steps.length - 1])
    return new gs(
      t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, r, Bd(e)),
      xr.empty,
      c,
      n.time,
      a ?? t.prevComposition
    )
  } else
    return (s = n.getMeta('rebased'))
      ? new gs(
          t.done.rebased(n, s),
          t.undone.rebased(n, s),
          ny(t.prevRanges, n.mapping),
          t.prevTime,
          t.prevComposition
        )
      : new gs(
          t.done.addMaps(n.mapping.maps),
          t.undone.addMaps(n.mapping.maps),
          ny(t.prevRanges, n.mapping),
          t.prevTime,
          t.prevComposition
        )
}
function dY(t, e) {
  if (!e) return !1
  if (!t.docChanged) return !0
  let n = !1
  return (
    t.mapping.maps[0].forEach((r, i) => {
      for (let s = 0; s < e.length; s += 2) r <= e[s + 1] && i >= e[s] && (n = !0)
    }),
    n
  )
}
function rI(t) {
  let e = []
  return t.forEach((n, r, i, s) => e.push(i, s)), e
}
function ny(t, e) {
  if (!t) return null
  let n = []
  for (let r = 0; r < t.length; r += 2) {
    let i = e.map(t[r], 1),
      s = e.map(t[r + 1], -1)
    i <= s && n.push(i, s)
  }
  return n
}
function fY(t, e, n) {
  let r = Bd(e),
    i = jo.get(e).spec.config,
    s = (n ? t.undone : t.done).popEvent(e, r)
  if (!s) return null
  let o = s.selection.resolve(s.transform.doc),
    a = (n ? t.done : t.undone).addTransform(s.transform, e.selection.getBookmark(), i, r),
    l = new gs(n ? a : s.remaining, n ? s.remaining : a, null, 0, -1)
  return s.transform.setSelection(o).setMeta(jo, { redo: n, historyState: l })
}
let ry = !1,
  iI = null
function Bd(t) {
  let e = t.plugins
  if (iI != e) {
    ;(ry = !1), (iI = e)
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        ry = !0
        break
      }
  }
  return ry
}
const jo = new to('history'),
  pY = new to('closeHistory')
function mY(t = {}) {
  return (
    (t = { depth: t.depth || 100, newGroupDelay: t.newGroupDelay || 500 }),
    new Cr({
      key: jo,
      state: {
        init() {
          return new gs(xr.empty, xr.empty, null, 0, -1)
        },
        apply(e, n, r) {
          return hY(n, r, e, t)
        }
      },
      config: t,
      props: {
        handleDOMEvents: {
          beforeinput(e, n) {
            let r = n.inputType,
              i = r == 'historyUndo' ? NM : r == 'historyRedo' ? MM : null
            return i ? (n.preventDefault(), i(e.state, e.dispatch)) : !1
          }
        }
      }
    })
  )
}
function OM(t, e) {
  return (n, r) => {
    let i = jo.getState(n)
    if (!i || (t ? i.undone : i.done).eventCount == 0) return !1
    if (r) {
      let s = fY(i, n, t)
      s && r(e ? s.scrollIntoView() : s)
    }
    return !0
  }
}
const NM = OM(!1, !0),
  MM = OM(!0, !0),
  gY = dr.create({
    name: 'history',
    addOptions() {
      return { depth: 100, newGroupDelay: 500 }
    },
    addCommands() {
      return {
        undo:
          () =>
          ({ state: t, dispatch: e }) =>
            NM(t, e),
        redo:
          () =>
          ({ state: t, dispatch: e }) =>
            MM(t, e)
      }
    },
    addProseMirrorPlugins() {
      return [mY(this.options)]
    },
    addKeyboardShortcuts() {
      return {
        'Mod-z': () => this.editor.commands.undo(),
        'Shift-Mod-z': () => this.editor.commands.redo(),
        'Mod-y': () => this.editor.commands.redo(),
        'Mod-я': () => this.editor.commands.undo(),
        'Shift-Mod-я': () => this.editor.commands.redo()
      }
    }
  }),
  yY = fr.create({
    name: 'horizontalRule',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    group: 'block',
    parseHTML() {
      return [{ tag: 'hr' }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['hr', qt(this.options.HTMLAttributes, t)]
    },
    addCommands() {
      return {
        setHorizontalRule:
          () =>
          ({ chain: t, state: e }) => {
            const { $to: n } = e.selection,
              r = t()
            return (
              n.parentOffset === 0
                ? r.insertContentAt(Math.max(n.pos - 2, 0), { type: this.name })
                : r.insertContent({ type: this.name }),
              r
                .command(({ tr: i, dispatch: s }) => {
                  var o
                  if (s) {
                    const { $to: a } = i.selection,
                      l = a.end()
                    if (a.nodeAfter)
                      a.nodeAfter.isTextblock
                        ? i.setSelection(Me.create(i.doc, a.pos + 1))
                        : a.nodeAfter.isBlock
                        ? i.setSelection(Ee.create(i.doc, a.pos))
                        : i.setSelection(Me.create(i.doc, a.pos))
                    else {
                      const c =
                        (o = a.parent.type.contentMatch.defaultType) === null || o === void 0
                          ? void 0
                          : o.create()
                      c && (i.insert(l, c), i.setSelection(Me.create(i.doc, l + 1)))
                    }
                    i.scrollIntoView()
                  }
                  return !0
                })
                .run()
            )
          }
      }
    },
    addInputRules() {
      return [NK({ find: /^(?:---|—-|___\s|\*\*\*\s)$/, type: this.type })]
    }
  }),
  _Y = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/,
  vY = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g,
  bY = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/,
  EY = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g,
  TY = Si.create({
    name: 'italic',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: 'em' },
        { tag: 'i', getAttrs: (t) => t.style.fontStyle !== 'normal' && null },
        { style: 'font-style=italic' }
      ]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['em', qt(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
      return {
        setItalic:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleItalic:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetItalic:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name)
      }
    },
    addKeyboardShortcuts() {
      return {
        'Mod-i': () => this.editor.commands.toggleItalic(),
        'Mod-I': () => this.editor.commands.toggleItalic()
      }
    },
    addInputRules() {
      return [Ol({ find: _Y, type: this.type }), Ol({ find: bY, type: this.type })]
    },
    addPasteRules() {
      return [Nl({ find: vY, type: this.type }), Nl({ find: EY, type: this.type })]
    }
  }),
  wY = fr.create({
    name: 'listItem',
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: 'bulletList',
        orderedListTypeName: 'orderedList'
      }
    },
    content: 'paragraph block*',
    defining: !0,
    parseHTML() {
      return [{ tag: 'li' }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['li', qt(this.options.HTMLAttributes, t), 0]
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        'Shift-Tab': () => this.editor.commands.liftListItem(this.name)
      }
    }
  }),
  SY = fr.create({
    name: 'listItem',
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: 'bulletList',
        orderedListTypeName: 'orderedList'
      }
    },
    content: 'paragraph block*',
    defining: !0,
    parseHTML() {
      return [{ tag: 'li' }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['li', qt(this.options.HTMLAttributes, t), 0]
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        'Shift-Tab': () => this.editor.commands.liftListItem(this.name)
      }
    }
  }),
  sI = Si.create({
    name: 'textStyle',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [{ tag: 'span', getAttrs: (t) => (t.hasAttribute('style') ? {} : !1) }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['span', qt(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
      return {
        removeEmptyTextStyle:
          () =>
          ({ state: t, commands: e }) => {
            const n = Nm(t, this.type)
            return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name)
          }
      }
    }
  }),
  oI = /^(\d+)\.\s$/,
  IY = fr.create({
    name: 'orderedList',
    addOptions() {
      return { itemTypeName: 'listItem', HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 }
    },
    group: 'block list',
    content() {
      return `${this.options.itemTypeName}+`
    },
    addAttributes() {
      return {
        start: {
          default: 1,
          parseHTML: (t) =>
            t.hasAttribute('start') ? parseInt(t.getAttribute('start') || '', 10) : 1
        }
      }
    },
    parseHTML() {
      return [{ tag: 'ol' }]
    },
    renderHTML({ HTMLAttributes: t }) {
      const { start: e, ...n } = t
      return e === 1
        ? ['ol', qt(this.options.HTMLAttributes, n), 0]
        : ['ol', qt(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
      return {
        toggleOrderedList:
          () =>
          ({ commands: t, chain: e }) =>
            this.options.keepAttributes
              ? e()
                  .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
                  .updateAttributes(SY.name, this.editor.getAttributes(sI.name))
                  .run()
              : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-Shift-7': () => this.editor.commands.toggleOrderedList() }
    },
    addInputRules() {
      let t = Vu({
        find: oI,
        type: this.type,
        getAttributes: (e) => ({ start: +e[1] }),
        joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
      })
      return (
        (this.options.keepMarks || this.options.keepAttributes) &&
          (t = Vu({
            find: oI,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(sI.name) }),
            joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
            editor: this.editor
          })),
        [t]
      )
    }
  }),
  AY = fr.create({
    name: 'paragraph',
    priority: 1e3,
    addOptions() {
      return { HTMLAttributes: {} }
    },
    group: 'block',
    content: 'inline*',
    parseHTML() {
      return [{ tag: 'p' }]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['p', qt(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
      return {
        setParagraph:
          () =>
          ({ commands: t }) =>
            t.setNode(this.name)
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-Alt-0': () => this.editor.commands.setParagraph() }
    }
  }),
  CY = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/,
  RY = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g,
  kY = Si.create({
    name: 'strike',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: 's' },
        { tag: 'del' },
        { tag: 'strike' },
        {
          style: 'text-decoration',
          consuming: !1,
          getAttrs: (t) => (t.includes('line-through') ? {} : !1)
        }
      ]
    },
    renderHTML({ HTMLAttributes: t }) {
      return ['s', qt(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
      return {
        setStrike:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleStrike:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetStrike:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name)
      }
    },
    addKeyboardShortcuts() {
      const t = {}
      return (
        tb()
          ? (t['Mod-Shift-s'] = () => this.editor.commands.toggleStrike())
          : (t['Ctrl-Shift-s'] = () => this.editor.commands.toggleStrike()),
        t
      )
    },
    addInputRules() {
      return [Ol({ find: CY, type: this.type })]
    },
    addPasteRules() {
      return [Nl({ find: RY, type: this.type })]
    }
  }),
  OY = fr.create({ name: 'text', group: 'inline' }),
  NY = dr.create({
    name: 'starterKit',
    addExtensions() {
      var t, e, n, r, i, s, o, a, l, c, u, h, d, f, p, m, g, _
      const v = []
      return (
        this.options.blockquote !== !1 &&
          v.push(PK.configure((t = this.options) === null || t === void 0 ? void 0 : t.blockquote)),
        this.options.bold !== !1 &&
          v.push(FK.configure((e = this.options) === null || e === void 0 ? void 0 : e.bold)),
        this.options.bulletList !== !1 &&
          v.push(UK.configure((n = this.options) === null || n === void 0 ? void 0 : n.bulletList)),
        this.options.code !== !1 &&
          v.push(zK.configure((r = this.options) === null || r === void 0 ? void 0 : r.code)),
        this.options.codeBlock !== !1 &&
          v.push(GK.configure((i = this.options) === null || i === void 0 ? void 0 : i.codeBlock)),
        this.options.document !== !1 &&
          v.push(qK.configure((s = this.options) === null || s === void 0 ? void 0 : s.document)),
        this.options.dropcursor !== !1 &&
          v.push(JK.configure((o = this.options) === null || o === void 0 ? void 0 : o.dropcursor)),
        this.options.gapcursor !== !1 &&
          v.push(iY.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)),
        this.options.hardBreak !== !1 &&
          v.push(sY.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)),
        this.options.heading !== !1 &&
          v.push(oY.configure((c = this.options) === null || c === void 0 ? void 0 : c.heading)),
        this.options.history !== !1 &&
          v.push(gY.configure((u = this.options) === null || u === void 0 ? void 0 : u.history)),
        this.options.horizontalRule !== !1 &&
          v.push(
            yY.configure((h = this.options) === null || h === void 0 ? void 0 : h.horizontalRule)
          ),
        this.options.italic !== !1 &&
          v.push(TY.configure((d = this.options) === null || d === void 0 ? void 0 : d.italic)),
        this.options.listItem !== !1 &&
          v.push(wY.configure((f = this.options) === null || f === void 0 ? void 0 : f.listItem)),
        this.options.orderedList !== !1 &&
          v.push(
            IY.configure((p = this.options) === null || p === void 0 ? void 0 : p.orderedList)
          ),
        this.options.paragraph !== !1 &&
          v.push(AY.configure((m = this.options) === null || m === void 0 ? void 0 : m.paragraph)),
        this.options.strike !== !1 &&
          v.push(kY.configure((g = this.options) === null || g === void 0 ? void 0 : g.strike)),
        this.options.text !== !1 &&
          v.push(OY.configure((_ = this.options) === null || _ === void 0 ? void 0 : _.text)),
        v
      )
    }
  })
function aI(t) {
  return cA((e, n) => ({
    get() {
      return e(), t
    },
    set(r) {
      ;(t = r),
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            n()
          })
        })
    }
  }))
}
class MY extends OK {
  constructor(e = {}) {
    return (
      super(e),
      (this.vueRenderers = ju(new Map())),
      (this.contentComponent = null),
      (this.reactiveState = aI(this.view.state)),
      (this.reactiveExtensionStorage = aI(this.extensionStorage)),
      this.on('transaction', () => {
        ;(this.reactiveState.value = this.view.state),
          (this.reactiveExtensionStorage.value = this.extensionStorage)
      }),
      pp(this)
    )
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage
  }
  registerPlugin(e, n) {
    super.registerPlugin(e, n), (this.reactiveState.value = this.view.state)
  }
  unregisterPlugin(e) {
    super.unregisterPlugin(e), (this.reactiveState.value = this.view.state)
  }
}
const PY = Wr({
    name: 'EditorContent',
    props: { editor: { default: null, type: Object } },
    setup(t) {
      const e = Ue(),
        n = ca()
      return (
        Ex(() => {
          const r = t.editor
          r &&
            r.options.element &&
            e.value &&
            Pl(() => {
              if (!e.value || !r.options.element.firstChild) return
              const i = Xe(e.value)
              e.value.append(...r.options.element.childNodes),
                (r.contentComponent = n.ctx._),
                r.setOptions({ element: i }),
                r.createNodeViews()
            })
        }),
        qu(() => {
          const r = t.editor
          if (
            !r ||
            (r.isDestroyed || r.view.setProps({ nodeViews: {} }),
            (r.contentComponent = null),
            !r.options.element.firstChild)
          )
            return
          const i = document.createElement('div')
          i.append(...r.options.element.childNodes), r.setOptions({ element: i })
        }),
        { rootEl: e }
      )
    },
    render() {
      const t = []
      return (
        this.editor &&
          this.editor.vueRenderers.forEach((e) => {
            const n = Do(
              tD,
              { to: e.teleportElement, key: e.id },
              Do(e.component, { ref: e.id, ...e.props })
            )
            t.push(n)
          }),
        Do(
          'div',
          {
            ref: (e) => {
              this.rootEl = e
            }
          },
          ...t
        )
      )
    }
  }),
  xY = { class: 'editor' },
  DY = { class: 'controlls' },
  LY = {
    __name: 'tiptapEditor.vapor',
    props: { modelValue: { type: String, default: '' } },
    emits: ['update:modelValue'],
    setup(t, { emit: e }) {
      const n = t,
        r = e,
        i = Ue(null)
      return (
        Bi(
          () => n.modelValue,
          (s) => {
            i.value.getHTML() !== s && i.value.commands.setContent(s, !1)
          }
        ),
        Gu(() => {
          i.value = new MY({
            extensions: [NY],
            content: n.modelValue,
            onUpdate: () => {
              r('update:modelValue', i.value.getHTML())
            }
          })
        }),
        qu(() => {
          i.value.destroy()
        }),
        (s, o) => (
          de(),
          De('div', xY, [
            Be(Xe(PY), { editor: i.value, class: 'editor-content' }, null, 8, ['editor']),
            C('div', DY, [
              C(
                'button',
                {
                  icon: '',
                  big: '',
                  onClick: o[0] || (o[0] = (a) => i.value.chain().focus().toggleBold().run())
                },
                'format_bold'
              ),
              C(
                'button',
                {
                  icon: '',
                  big: '',
                  onClick: o[1] || (o[1] = (a) => i.value.chain().focus().toggleItalic().run())
                },
                'format_italic'
              ),
              C(
                'button',
                {
                  icon: '',
                  big: '',
                  onClick: o[2] || (o[2] = (a) => i.value.chain().focus().toggleBulletList().run())
                },
                ' format_list_bulleted '
              ),
              C(
                'button',
                {
                  icon: '',
                  big: '',
                  onClick: o[3] || (o[3] = (a) => i.value.chain().focus().toggleOrderedList().run())
                },
                ' format_list_numbered '
              )
            ])
          ])
        )
      )
    }
  },
  VY = ga(LY, [['__scopeId', 'data-v-4b690c27']]),
  FY = { class: 'header' },
  BY = { class: 'body' },
  UY = { class: 'controls' },
  $Y = Wr({
    __name: 'modal.vapor',
    setup(t, { expose: e }) {
      const n = Ue()
      return (
        e({
          showModal: () => {
            n.value && n.value.showModal()
          },
          closeModal: () => {
            n.value && n.value.close()
          }
        }),
        (s, o) => (
          de(),
          De(
            'dialog',
            { ref_key: 'dialog', ref: n, class: 'danger' },
            [
              C('div', FY, [Jt(s.$slots, 'header', {}, void 0, !0)]),
              C('div', BY, [Jt(s.$slots, 'body', {}, void 0, !0)]),
              C('div', UY, [Jt(s.$slots, 'controls', {}, void 0, !0)])
            ],
            512
          )
        )
      )
    }
  }),
  HY = ga($Y, [['__scopeId', 'data-v-3eb9aebc']])
function iy(t) {
  return t === 0 ? !1 : Array.isArray(t) && t.length === 0 ? !0 : !t
}
function zY(t) {
  return (...e) => !t(...e)
}
function jY(t, e) {
  return (
    t === void 0 && (t = 'undefined'),
    t === null && (t = 'null'),
    t === !1 && (t = 'false'),
    t.toString().toLowerCase().indexOf(e.trim()) !== -1
  )
}
function PM(t, e, n, r) {
  return e ? t.filter((i) => jY(r(i, n), e)).sort((i, s) => r(i, n).length - r(s, n).length) : t
}
function WY(t) {
  return t.filter((e) => !e.$isLabel)
}
function sy(t, e) {
  return (n) =>
    n.reduce(
      (r, i) =>
        i[t] && i[t].length ? (r.push({ $groupLabel: i[e], $isLabel: !0 }), r.concat(i[t])) : r,
      []
    )
}
function GY(t, e, n, r, i) {
  return (s) =>
    s.map((o) => {
      if (!o[n])
        return (
          console.warn(
            'Options passed to vue-multiselect do not contain groups, despite the config.'
          ),
          []
        )
      const a = PM(o[n], t, e, i)
      return a.length ? { [r]: o[r], [n]: a } : []
    })
}
const lI =
  (...t) =>
  (e) =>
    t.reduce((n, r) => r(n), e)
var qY = {
    data() {
      return {
        search: '',
        isOpen: !1,
        preferredOpenDirection: 'below',
        optimizedHeight: this.maxHeight
      }
    },
    props: {
      internalSearch: { type: Boolean, default: !0 },
      options: { type: Array, required: !0 },
      multiple: { type: Boolean, default: !1 },
      trackBy: { type: String },
      label: { type: String },
      searchable: { type: Boolean, default: !0 },
      clearOnSelect: { type: Boolean, default: !0 },
      hideSelected: { type: Boolean, default: !1 },
      placeholder: { type: String, default: 'Select option' },
      allowEmpty: { type: Boolean, default: !0 },
      resetAfter: { type: Boolean, default: !1 },
      closeOnSelect: { type: Boolean, default: !0 },
      customLabel: {
        type: Function,
        default(t, e) {
          return iy(t) ? '' : e ? t[e] : t
        }
      },
      taggable: { type: Boolean, default: !1 },
      tagPlaceholder: { type: String, default: 'Press enter to create a tag' },
      tagPosition: { type: String, default: 'top' },
      max: { type: [Number, Boolean], default: !1 },
      id: { default: null },
      optionsLimit: { type: Number, default: 1e3 },
      groupValues: { type: String },
      groupLabel: { type: String },
      groupSelect: { type: Boolean, default: !1 },
      blockKeys: {
        type: Array,
        default() {
          return []
        }
      },
      preserveSearch: { type: Boolean, default: !1 },
      preselectFirst: { type: Boolean, default: !1 },
      preventAutofocus: { type: Boolean, default: !1 }
    },
    mounted() {
      !this.multiple &&
        this.max &&
        console.warn(
          '[Vue-Multiselect warn]: Max prop should not be used when prop Multiple equals false.'
        ),
        this.preselectFirst &&
          !this.internalValue.length &&
          this.options.length &&
          this.select(this.filteredOptions[0])
    },
    computed: {
      internalValue() {
        return this.modelValue || this.modelValue === 0
          ? Array.isArray(this.modelValue)
            ? this.modelValue
            : [this.modelValue]
          : []
      },
      filteredOptions() {
        const t = this.search || '',
          e = t.toLowerCase().trim()
        let n = this.options.concat()
        return (
          this.internalSearch
            ? (n = this.groupValues
                ? this.filterAndFlat(n, e, this.label)
                : PM(n, e, this.label, this.customLabel))
            : (n = this.groupValues ? sy(this.groupValues, this.groupLabel)(n) : n),
          (n = this.hideSelected ? n.filter(zY(this.isSelected)) : n),
          this.taggable &&
            e.length &&
            !this.isExistingOption(e) &&
            (this.tagPosition === 'bottom'
              ? n.push({ isTag: !0, label: t })
              : n.unshift({ isTag: !0, label: t })),
          n.slice(0, this.optionsLimit)
        )
      },
      valueKeys() {
        return this.trackBy ? this.internalValue.map((t) => t[this.trackBy]) : this.internalValue
      },
      optionKeys() {
        return (this.groupValues ? this.flatAndStrip(this.options) : this.options).map((e) =>
          this.customLabel(e, this.label).toString().toLowerCase()
        )
      },
      currentOptionLabel() {
        return this.multiple
          ? this.searchable
            ? ''
            : this.placeholder
          : this.internalValue.length
          ? this.getOptionLabel(this.internalValue[0])
          : this.searchable
          ? ''
          : this.placeholder
      }
    },
    watch: {
      internalValue: {
        handler() {
          this.resetAfter &&
            this.internalValue.length &&
            ((this.search = ''), this.$emit('update:modelValue', this.multiple ? [] : null))
        },
        deep: !0
      },
      search() {
        this.$emit('search-change', this.search)
      }
    },
    emits: ['open', 'search-change', 'close', 'select', 'update:modelValue', 'remove', 'tag'],
    methods: {
      getValue() {
        return this.multiple
          ? this.internalValue
          : this.internalValue.length === 0
          ? null
          : this.internalValue[0]
      },
      filterAndFlat(t, e, n) {
        return lI(
          GY(e, n, this.groupValues, this.groupLabel, this.customLabel),
          sy(this.groupValues, this.groupLabel)
        )(t)
      },
      flatAndStrip(t) {
        return lI(sy(this.groupValues, this.groupLabel), WY)(t)
      },
      updateSearch(t) {
        this.search = t
      },
      isExistingOption(t) {
        return this.options ? this.optionKeys.indexOf(t) > -1 : !1
      },
      isSelected(t) {
        const e = this.trackBy ? t[this.trackBy] : t
        return this.valueKeys.indexOf(e) > -1
      },
      isOptionDisabled(t) {
        return !!t.$isDisabled
      },
      getOptionLabel(t) {
        if (iy(t)) return ''
        if (t.isTag) return t.label
        if (t.$isLabel) return t.$groupLabel
        const e = this.customLabel(t, this.label)
        return iy(e) ? '' : e
      },
      select(t, e) {
        if (t.$isLabel && this.groupSelect) {
          this.selectGroup(t)
          return
        }
        if (
          !(this.blockKeys.indexOf(e) !== -1 || this.disabled || t.$isDisabled || t.$isLabel) &&
          !(this.max && this.multiple && this.internalValue.length === this.max) &&
          !(e === 'Tab' && !this.pointerDirty)
        ) {
          if (t.isTag)
            this.$emit('tag', t.label, this.id),
              (this.search = ''),
              this.closeOnSelect && !this.multiple && this.deactivate()
          else {
            if (this.isSelected(t)) {
              e !== 'Tab' && this.removeElement(t)
              return
            }
            this.multiple
              ? this.$emit('update:modelValue', this.internalValue.concat([t]))
              : this.$emit('update:modelValue', t),
              this.$emit('select', t, this.id),
              this.clearOnSelect && (this.search = '')
          }
          this.closeOnSelect && this.deactivate()
        }
      },
      selectGroup(t) {
        const e = this.options.find((n) => n[this.groupLabel] === t.$groupLabel)
        if (e) {
          if (this.wholeGroupSelected(e)) {
            this.$emit('remove', e[this.groupValues], this.id)
            const n = this.internalValue.filter((r) => e[this.groupValues].indexOf(r) === -1)
            this.$emit('update:modelValue', n)
          } else {
            let n = e[this.groupValues].filter(
              (r) => !(this.isOptionDisabled(r) || this.isSelected(r))
            )
            this.max && n.splice(this.max - this.internalValue.length),
              this.$emit('select', n, this.id),
              this.$emit('update:modelValue', this.internalValue.concat(n))
          }
          this.closeOnSelect && this.deactivate()
        }
      },
      wholeGroupSelected(t) {
        return t[this.groupValues].every((e) => this.isSelected(e) || this.isOptionDisabled(e))
      },
      wholeGroupDisabled(t) {
        return t[this.groupValues].every(this.isOptionDisabled)
      },
      removeElement(t, e = !0) {
        if (this.disabled || t.$isDisabled) return
        if (!this.allowEmpty && this.internalValue.length <= 1) {
          this.deactivate()
          return
        }
        const n =
          typeof t == 'object' ? this.valueKeys.indexOf(t[this.trackBy]) : this.valueKeys.indexOf(t)
        if (this.multiple) {
          const r = this.internalValue.slice(0, n).concat(this.internalValue.slice(n + 1))
          this.$emit('update:modelValue', r)
        } else this.$emit('update:modelValue', null)
        this.$emit('remove', t, this.id), this.closeOnSelect && e && this.deactivate()
      },
      removeLastElement() {
        this.blockKeys.indexOf('Delete') === -1 &&
          this.search.length === 0 &&
          Array.isArray(this.internalValue) &&
          this.internalValue.length &&
          this.removeElement(this.internalValue[this.internalValue.length - 1], !1)
      },
      activate() {
        this.isOpen ||
          this.disabled ||
          (this.adjustPosition(),
          this.groupValues &&
            this.pointer === 0 &&
            this.filteredOptions.length &&
            (this.pointer = 1),
          (this.isOpen = !0),
          this.searchable
            ? (this.preserveSearch || (this.search = ''),
              this.preventAutofocus ||
                this.$nextTick(() => this.$refs.search && this.$refs.search.focus()))
            : this.preventAutofocus || (typeof this.$el < 'u' && this.$el.focus()),
          this.$emit('open', this.id))
      },
      deactivate() {
        this.isOpen &&
          ((this.isOpen = !1),
          this.searchable
            ? this.$refs.search !== null &&
              typeof this.$refs.search < 'u' &&
              this.$refs.search.blur()
            : typeof this.$el < 'u' && this.$el.blur(),
          this.preserveSearch || (this.search = ''),
          this.$emit('close', this.getValue(), this.id))
      },
      toggle() {
        this.isOpen ? this.deactivate() : this.activate()
      },
      adjustPosition() {
        if (typeof window > 'u') return
        const t = this.$el.getBoundingClientRect().top,
          e = window.innerHeight - this.$el.getBoundingClientRect().bottom
        e > this.maxHeight ||
        e > t ||
        this.openDirection === 'below' ||
        this.openDirection === 'bottom'
          ? ((this.preferredOpenDirection = 'below'),
            (this.optimizedHeight = Math.min(e - 40, this.maxHeight)))
          : ((this.preferredOpenDirection = 'above'),
            (this.optimizedHeight = Math.min(t - 40, this.maxHeight)))
      }
    }
  },
  KY = {
    data() {
      return { pointer: 0, pointerDirty: !1 }
    },
    props: {
      showPointer: { type: Boolean, default: !0 },
      optionHeight: { type: Number, default: 40 }
    },
    computed: {
      pointerPosition() {
        return this.pointer * this.optionHeight
      },
      visibleElements() {
        return this.optimizedHeight / this.optionHeight
      }
    },
    watch: {
      filteredOptions() {
        this.pointerAdjust()
      },
      isOpen() {
        this.pointerDirty = !1
      },
      pointer() {
        this.$refs.search &&
          this.$refs.search.setAttribute(
            'aria-activedescendant',
            this.id + '-' + this.pointer.toString()
          )
      }
    },
    methods: {
      optionHighlight(t, e) {
        return {
          'multiselect__option--highlight': t === this.pointer && this.showPointer,
          'multiselect__option--selected': this.isSelected(e)
        }
      },
      groupHighlight(t, e) {
        if (!this.groupSelect)
          return ['multiselect__option--disabled', { 'multiselect__option--group': e.$isLabel }]
        const n = this.options.find((r) => r[this.groupLabel] === e.$groupLabel)
        return n && !this.wholeGroupDisabled(n)
          ? [
              'multiselect__option--group',
              { 'multiselect__option--highlight': t === this.pointer && this.showPointer },
              { 'multiselect__option--group-selected': this.wholeGroupSelected(n) }
            ]
          : 'multiselect__option--disabled'
      },
      addPointerElement({ key: t } = 'Enter') {
        this.filteredOptions.length > 0 && this.select(this.filteredOptions[this.pointer], t),
          this.pointerReset()
      },
      pointerForward() {
        this.pointer < this.filteredOptions.length - 1 &&
          (this.pointer++,
          this.$refs.list.scrollTop <=
            this.pointerPosition - (this.visibleElements - 1) * this.optionHeight &&
            (this.$refs.list.scrollTop =
              this.pointerPosition - (this.visibleElements - 1) * this.optionHeight),
          this.filteredOptions[this.pointer] &&
            this.filteredOptions[this.pointer].$isLabel &&
            !this.groupSelect &&
            this.pointerForward()),
          (this.pointerDirty = !0)
      },
      pointerBackward() {
        this.pointer > 0
          ? (this.pointer--,
            this.$refs.list.scrollTop >= this.pointerPosition &&
              (this.$refs.list.scrollTop = this.pointerPosition),
            this.filteredOptions[this.pointer] &&
              this.filteredOptions[this.pointer].$isLabel &&
              !this.groupSelect &&
              this.pointerBackward())
          : this.filteredOptions[this.pointer] &&
            this.filteredOptions[0].$isLabel &&
            !this.groupSelect &&
            this.pointerForward(),
          (this.pointerDirty = !0)
      },
      pointerReset() {
        this.closeOnSelect &&
          ((this.pointer = 0), this.$refs.list && (this.$refs.list.scrollTop = 0))
      },
      pointerAdjust() {
        this.pointer >= this.filteredOptions.length - 1 &&
          (this.pointer = this.filteredOptions.length ? this.filteredOptions.length - 1 : 0),
          this.filteredOptions.length > 0 &&
            this.filteredOptions[this.pointer].$isLabel &&
            !this.groupSelect &&
            this.pointerForward()
      },
      pointerSet(t) {
        ;(this.pointer = t), (this.pointerDirty = !0)
      }
    }
  },
  Ud = {
    name: 'vue-multiselect',
    mixins: [qY, KY],
    compatConfig: { MODE: 3, ATTR_ENUMERATED_COERCION: !1 },
    props: {
      name: { type: String, default: '' },
      modelValue: {
        type: null,
        default() {
          return []
        }
      },
      selectLabel: { type: String, default: 'Press enter to select' },
      selectGroupLabel: { type: String, default: 'Press enter to select group' },
      selectedLabel: { type: String, default: 'Selected' },
      deselectLabel: { type: String, default: 'Press enter to remove' },
      deselectGroupLabel: { type: String, default: 'Press enter to deselect group' },
      showLabels: { type: Boolean, default: !0 },
      limit: { type: Number, default: 99999 },
      maxHeight: { type: Number, default: 300 },
      limitText: { type: Function, default: (t) => `and ${t} more` },
      loading: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      openDirection: { type: String, default: '' },
      showNoOptions: { type: Boolean, default: !0 },
      showNoResults: { type: Boolean, default: !0 },
      tabindex: { type: Number, default: 0 }
    },
    computed: {
      hasOptionGroup() {
        return this.groupValues && this.groupLabel && this.groupSelect
      },
      isSingleLabelVisible() {
        return (
          (this.singleValue || this.singleValue === 0) &&
          (!this.isOpen || !this.searchable) &&
          !this.visibleValues.length
        )
      },
      isPlaceholderVisible() {
        return !this.internalValue.length && (!this.searchable || !this.isOpen)
      },
      visibleValues() {
        return this.multiple ? this.internalValue.slice(0, this.limit) : []
      },
      singleValue() {
        return this.internalValue[0]
      },
      deselectLabelText() {
        return this.showLabels ? this.deselectLabel : ''
      },
      deselectGroupLabelText() {
        return this.showLabels ? this.deselectGroupLabel : ''
      },
      selectLabelText() {
        return this.showLabels ? this.selectLabel : ''
      },
      selectGroupLabelText() {
        return this.showLabels ? this.selectGroupLabel : ''
      },
      selectedLabelText() {
        return this.showLabels ? this.selectedLabel : ''
      },
      inputStyle() {
        return this.searchable || (this.multiple && this.modelValue && this.modelValue.length)
          ? this.isOpen
            ? { width: '100%' }
            : { width: '0', position: 'absolute', padding: '0' }
          : ''
      },
      contentStyle() {
        return this.options.length ? { display: 'inline-block' } : { display: 'block' }
      },
      isAbove() {
        return this.openDirection === 'above' || this.openDirection === 'top'
          ? !0
          : this.openDirection === 'below' || this.openDirection === 'bottom'
          ? !1
          : this.preferredOpenDirection === 'above'
      },
      showSearchInput() {
        return (
          this.searchable &&
          (this.hasSingleSelectedSlot && (this.visibleSingleValue || this.visibleSingleValue === 0)
            ? this.isOpen
            : !0)
        )
      }
    }
  }
const YY = { ref: 'tags', class: 'multiselect__tags' },
  JY = { class: 'multiselect__tags-wrap' },
  QY = { class: 'multiselect__spinner' },
  XY = { key: 0 },
  ZY = { class: 'multiselect__option' },
  eJ = { class: 'multiselect__option' },
  tJ = dt('No elements found. Consider changing the search query.'),
  nJ = { class: 'multiselect__option' },
  rJ = dt('List is empty.')
function iJ(t, e, n, r, i, s) {
  return (
    de(),
    dn(
      'div',
      {
        tabindex: t.searchable ? -1 : n.tabindex,
        class: [
          {
            'multiselect--active': t.isOpen,
            'multiselect--disabled': n.disabled,
            'multiselect--above': s.isAbove,
            'multiselect--has-options-group': s.hasOptionGroup
          },
          'multiselect'
        ],
        onFocus: e[14] || (e[14] = (o) => t.activate()),
        onBlur: e[15] || (e[15] = (o) => (t.searchable ? !1 : t.deactivate())),
        onKeydown: [
          e[16] ||
            (e[16] = Kr(
              ht((o) => t.pointerForward(), ['self', 'prevent']),
              ['down']
            )),
          e[17] ||
            (e[17] = Kr(
              ht((o) => t.pointerBackward(), ['self', 'prevent']),
              ['up']
            ))
        ],
        onKeypress:
          e[18] ||
          (e[18] = Kr(
            ht((o) => t.addPointerElement(o), ['stop', 'self']),
            ['enter', 'tab']
          )),
        onKeyup: e[19] || (e[19] = Kr((o) => t.deactivate(), ['esc'])),
        role: 'combobox',
        'aria-owns': 'listbox-' + t.id
      },
      [
        Jt(t.$slots, 'caret', { toggle: t.toggle }, () => [
          Be(
            'div',
            {
              onMousedown: e[1] || (e[1] = ht((o) => t.toggle(), ['prevent', 'stop'])),
              class: 'multiselect__select'
            },
            null,
            32
          )
        ]),
        Jt(t.$slots, 'clear', { search: t.search }),
        Be(
          'div',
          YY,
          [
            Jt(
              t.$slots,
              'selection',
              {
                search: t.search,
                remove: t.removeElement,
                values: s.visibleValues,
                isOpen: t.isOpen
              },
              () => [
                Sn(
                  Be(
                    'div',
                    JY,
                    [
                      (de(!0),
                      dn(
                        pt,
                        null,
                        Fs(s.visibleValues, (o, a) =>
                          Jt(
                            t.$slots,
                            'tag',
                            { option: o, search: t.search, remove: t.removeElement },
                            () => [
                              (de(),
                              dn('span', { class: 'multiselect__tag', key: a }, [
                                Be('span', { textContent: It(t.getOptionLabel(o)) }, null, 8, [
                                  'textContent'
                                ]),
                                Be(
                                  'i',
                                  {
                                    tabindex: '1',
                                    onKeypress: Kr(
                                      ht((l) => t.removeElement(o), ['prevent']),
                                      ['enter']
                                    ),
                                    onMousedown: ht((l) => t.removeElement(o), ['prevent']),
                                    class: 'multiselect__tag-icon'
                                  },
                                  null,
                                  40,
                                  ['onKeypress', 'onMousedown']
                                )
                              ]))
                            ]
                          )
                        ),
                        256
                      ))
                    ],
                    512
                  ),
                  [[Ql, s.visibleValues.length > 0]]
                ),
                t.internalValue && t.internalValue.length > n.limit
                  ? Jt(t.$slots, 'limit', { key: 0 }, () => [
                      Be(
                        'strong',
                        {
                          class: 'multiselect__strong',
                          textContent: It(n.limitText(t.internalValue.length - n.limit))
                        },
                        null,
                        8,
                        ['textContent']
                      )
                    ])
                  : ft('v-if', !0)
              ]
            ),
            Be(
              Jd,
              { name: 'multiselect__loading' },
              {
                default: xo(() => [
                  Jt(t.$slots, 'loading', {}, () => [
                    Sn(Be('div', QY, null, 512), [[Ql, n.loading]])
                  ])
                ]),
                _: 3
              }
            ),
            t.searchable
              ? (de(),
                dn(
                  'input',
                  {
                    key: 0,
                    ref: 'search',
                    name: n.name,
                    id: t.id,
                    type: 'text',
                    autocomplete: 'off',
                    spellcheck: !1,
                    placeholder: t.placeholder,
                    style: s.inputStyle,
                    value: t.search,
                    disabled: n.disabled,
                    tabindex: n.tabindex,
                    onInput: e[2] || (e[2] = (o) => t.updateSearch(o.target.value)),
                    onFocus: e[3] || (e[3] = ht((o) => t.activate(), ['prevent'])),
                    onBlur: e[4] || (e[4] = ht((o) => t.deactivate(), ['prevent'])),
                    onKeyup: e[5] || (e[5] = Kr((o) => t.deactivate(), ['esc'])),
                    onKeydown: [
                      e[6] ||
                        (e[6] = Kr(
                          ht((o) => t.pointerForward(), ['prevent']),
                          ['down']
                        )),
                      e[7] ||
                        (e[7] = Kr(
                          ht((o) => t.pointerBackward(), ['prevent']),
                          ['up']
                        )),
                      e[9] ||
                        (e[9] = Kr(
                          ht((o) => t.removeLastElement(), ['stop']),
                          ['delete']
                        ))
                    ],
                    onKeypress:
                      e[8] ||
                      (e[8] = Kr(
                        ht((o) => t.addPointerElement(o), ['prevent', 'stop', 'self']),
                        ['enter']
                      )),
                    class: 'multiselect__input',
                    'aria-controls': 'listbox-' + t.id
                  },
                  null,
                  44,
                  ['name', 'id', 'placeholder', 'value', 'disabled', 'tabindex', 'aria-controls']
                ))
              : ft('v-if', !0),
            s.isSingleLabelVisible
              ? (de(),
                dn(
                  'span',
                  {
                    key: 1,
                    class: 'multiselect__single',
                    onMousedown:
                      e[10] || (e[10] = ht((...o) => t.toggle && t.toggle(...o), ['prevent']))
                  },
                  [
                    Jt(t.$slots, 'singleLabel', { option: s.singleValue }, () => [
                      dt(It(t.currentOptionLabel), 1)
                    ])
                  ],
                  32
                ))
              : ft('v-if', !0),
            s.isPlaceholderVisible
              ? (de(),
                dn(
                  'span',
                  {
                    key: 2,
                    class: 'multiselect__placeholder',
                    onMousedown:
                      e[11] || (e[11] = ht((...o) => t.toggle && t.toggle(...o), ['prevent']))
                  },
                  [Jt(t.$slots, 'placeholder', {}, () => [dt(It(t.placeholder), 1)])],
                  32
                ))
              : ft('v-if', !0)
          ],
          512
        ),
        Be(
          Jd,
          { name: 'multiselect' },
          {
            default: xo(() => [
              Sn(
                Be(
                  'div',
                  {
                    class: 'multiselect__content-wrapper',
                    onFocus: e[12] || (e[12] = (...o) => t.activate && t.activate(...o)),
                    tabindex: '-1',
                    onMousedown: e[13] || (e[13] = ht(() => {}, ['prevent'])),
                    style: { maxHeight: t.optimizedHeight + 'px' },
                    ref: 'list'
                  },
                  [
                    Be(
                      'ul',
                      {
                        class: 'multiselect__content',
                        style: s.contentStyle,
                        role: 'listbox',
                        id: 'listbox-' + t.id
                      },
                      [
                        Jt(t.$slots, 'beforeList'),
                        t.multiple && t.max === t.internalValue.length
                          ? (de(),
                            dn('li', XY, [
                              Be('span', ZY, [
                                Jt(t.$slots, 'maxElements', {}, () => [
                                  dt(
                                    'Maximum of ' +
                                      It(t.max) +
                                      ' options selected. First remove a selected option to select another.',
                                    1
                                  )
                                ])
                              ])
                            ]))
                          : ft('v-if', !0),
                        !t.max || t.internalValue.length < t.max
                          ? (de(!0),
                            dn(
                              pt,
                              { key: 1 },
                              Fs(
                                t.filteredOptions,
                                (o, a) => (
                                  de(),
                                  dn(
                                    'li',
                                    {
                                      class: 'multiselect__element',
                                      key: a,
                                      id: t.id + '-' + a,
                                      role: o && (o.$isLabel || o.$isDisabled) ? null : 'option'
                                    },
                                    [
                                      o && (o.$isLabel || o.$isDisabled)
                                        ? ft('v-if', !0)
                                        : (de(),
                                          dn(
                                            'span',
                                            {
                                              key: 0,
                                              class: [
                                                t.optionHighlight(a, o),
                                                'multiselect__option'
                                              ],
                                              onClick: ht((l) => t.select(o), ['stop']),
                                              onMouseenter: ht((l) => t.pointerSet(a), ['self']),
                                              'data-select':
                                                o && o.isTag ? t.tagPlaceholder : s.selectLabelText,
                                              'data-selected': s.selectedLabelText,
                                              'data-deselect': s.deselectLabelText
                                            },
                                            [
                                              Jt(
                                                t.$slots,
                                                'option',
                                                { option: o, search: t.search, index: a },
                                                () => [Be('span', null, It(t.getOptionLabel(o)), 1)]
                                              )
                                            ],
                                            42,
                                            [
                                              'onClick',
                                              'onMouseenter',
                                              'data-select',
                                              'data-selected',
                                              'data-deselect'
                                            ]
                                          )),
                                      o && (o.$isLabel || o.$isDisabled)
                                        ? (de(),
                                          dn(
                                            'span',
                                            {
                                              key: 1,
                                              'data-select':
                                                t.groupSelect && s.selectGroupLabelText,
                                              'data-deselect':
                                                t.groupSelect && s.deselectGroupLabelText,
                                              class: [
                                                t.groupHighlight(a, o),
                                                'multiselect__option'
                                              ],
                                              onMouseenter: ht(
                                                (l) => t.groupSelect && t.pointerSet(a),
                                                ['self']
                                              ),
                                              onMousedown: ht((l) => t.selectGroup(o), ['prevent'])
                                            },
                                            [
                                              Jt(
                                                t.$slots,
                                                'option',
                                                { option: o, search: t.search, index: a },
                                                () => [Be('span', null, It(t.getOptionLabel(o)), 1)]
                                              )
                                            ],
                                            42,
                                            [
                                              'data-select',
                                              'data-deselect',
                                              'onMouseenter',
                                              'onMousedown'
                                            ]
                                          ))
                                        : ft('v-if', !0)
                                    ],
                                    8,
                                    ['id', 'role']
                                  )
                                )
                              ),
                              128
                            ))
                          : ft('v-if', !0),
                        Sn(
                          Be(
                            'li',
                            null,
                            [
                              Be('span', eJ, [
                                Jt(t.$slots, 'noResult', { search: t.search }, () => [tJ])
                              ])
                            ],
                            512
                          ),
                          [
                            [
                              Ql,
                              n.showNoResults &&
                                t.filteredOptions.length === 0 &&
                                t.search &&
                                !n.loading
                            ]
                          ]
                        ),
                        Sn(
                          Be(
                            'li',
                            null,
                            [Be('span', nJ, [Jt(t.$slots, 'noOptions', {}, () => [rJ])])],
                            512
                          ),
                          [
                            [
                              Ql,
                              n.showNoOptions &&
                                (t.options.length === 0 ||
                                  (s.hasOptionGroup === !0 && t.filteredOptions.length === 0)) &&
                                !t.search &&
                                !n.loading
                            ]
                          ]
                        ),
                        Jt(t.$slots, 'afterList')
                      ],
                      12,
                      ['id']
                    )
                  ],
                  36
                ),
                [[Ql, t.isOpen]]
              )
            ]),
            _: 3
          }
        )
      ],
      42,
      ['tabindex', 'aria-owns']
    )
  )
}
Ud.render = iJ
const xt = (t) => (yp('data-v-7cf22b12'), (t = t()), _p(), t),
  sJ = { id: 'board-info' },
  oJ = { key: 0 },
  aJ = { key: 0, id: 'controlls-are-editing' },
  lJ = { key: 1, id: 'controlls-are-viewing' },
  cJ = ['src'],
  uJ = ['onClick'],
  hJ = ['onClick'],
  dJ = { key: 0 },
  fJ = xt(() => C('h3', { class: 'font-size-S' }, 'Description', -1)),
  pJ = xt(() => C('h3', { class: 'font-size-S' }, 'Image', -1)),
  mJ = ['src'],
  gJ = xt(() => C('br', null, null, -1)),
  yJ = xt(() => C('h3', { class: 'font-size-S' }, 'Tile type', -1)),
  _J = xt(() => C('p', null, 'Choose any of the different tile types.', -1)),
  vJ = xt(() => C('hr', null, null, -1)),
  bJ = xt(() => C('h3', { class: 'font-size-S' }, 'Metric', -1)),
  EJ = xt(() =>
    C('p', null, 'Search and select the metric you want to associate with this tile.', -1)
  ),
  TJ = xt(() => C('hr', null, null, -1)),
  wJ = { key: 0 },
  SJ = xt(() => C('h3', { class: 'font-size-S' }, 'Repeatable tile', -1)),
  IJ = xt(() =>
    C(
      'p',
      null,
      'Can the competitors complete the tile multiple times and gain points each time?',
      -1
    )
  ),
  AJ = xt(() => C('hr', null, null, -1)),
  CJ = xt(() => C('h3', { class: 'font-size-S' }, 'Points and count', -1)),
  RJ = xt(() =>
    C('p', null, 'the points the competitors will get when they complete the tile', -1)
  ),
  kJ = xt(() =>
    C(
      'p',
      null,
      [
        dt(' amount that is needed to complete the tile '),
        C('br'),
        C('em', null, 'a.e. 200.000.000 slayer exp or 5 unique barrows items')
      ],
      -1
    )
  ),
  OJ = xt(() =>
    C(
      'p',
      null,
      [
        dt(' this is the minimum required amount for the tile'),
        C('br'),
        C(
          'em',
          null,
          'a.e. if the count is 5 and you want the team to collect at least one of each item, the minimum would be 1'
        )
      ],
      -1
    )
  ),
  NJ = xt(() =>
    C(
      'p',
      null,
      [
        dt(' this is the maximum amount for the tile'),
        C('br'),
        C(
          'em',
          null,
          'a.e. if the count is 5 and you want the team to collect at most two of each item, the maximum would be 2'
        )
      ],
      -1
    )
  ),
  MJ = { key: 1 },
  PJ = { key: 2 },
  xJ = xt(() => C('h3', { class: 'font-size-S' }, 'Drops', -1)),
  DJ = xt(() => C('p', null, 'add drops to the list of valid drops', -1)),
  LJ = ['onClick'],
  VJ = { key: 3 },
  FJ = xt(() => C('h3', { class: 'font-size-S' }, 'Need Any or All?', -1)),
  BJ = xt(() =>
    C(
      'p',
      null,
      'do the competors need to achieve all of the requirements to complete the tile?',
      -1
    )
  ),
  UJ = Wr({
    __name: 'editBoard.vapor',
    async setup(t) {
      var tt, st
      let e, n
      const r = x1()
      r.value = 'Edit board - Bingo Bongo'
      const i = Ue(HH.filter((me) => !['ehb', 'ehp', 'league_points'].includes(me))),
        s = Ue(),
        o = Ue(!1),
        a = Ue(),
        l = Ue(),
        c = Ue(null),
        u = Ue(),
        h = Ue(0),
        d = () => {
          a.value && a.value.showModal && a.value.showModal()
        },
        f = () => {
          a.value && a.value.closeModal && a.value.closeModal()
        },
        p = () => {
          c.value &&
            (c.value.drops
              ? c.value.drops.push({ id: xg(), name: u.value })
              : (c.value.drops = [{ id: xg(), name: u.value }]))
        },
        m = (me) => {
          c.value &&
            c.value.drops &&
            c.value.drops.indexOf(me) > -1 &&
            c.value.drops.splice(c.value.drops.indexOf(me), 1)
        }
      window.addEventListener('keydown', (me) => {
        switch (me.key) {
          case 'Escape':
            a.value &&
              a.value.closeModal &&
              (a.value.closeModal(),
              l.value.close(),
              (s.value = null),
              (c.value = null),
              (o.value = !1),
              (o.value = !1))
            break
        }
      })
      const g = Ue(null),
        _ = Ue(),
        v = Ue(!1),
        T = P1(),
        { data: S, promise: I } = bO(_r(rr, 'Boards', T.params.boardUUID))
      ;([e, n] = qd(() => I.value)), await e, n()
      const w = Ue(((tt = S.value) == null ? void 0 : tt.boardWidth) || 5)
      let O = Ue([]),
        P = []
      const { data: k, promise: U } = Eg(mc(rr, 'Boards', T.params.boardUUID, 'Tiles'))
      ;([e, n] = qd(() => U.value)), await e, n()
      const F = Ue(k.value)
      ;(st = S.value) != null && st.orderOfList
        ? (O.value = S.value.orderOfList)
        : (O.value = F.value.map((me) => me.id))
      const $ = Bt(() =>
        F.value === void 0
          ? []
          : F.value.toSorted((me, G) => O.value.indexOf(me.id) - O.value.indexOf(G.id))
      )
      xz(g, $, {
        inverted: !0,
        handle: '.handle',
        ghostClass: 'blue-background-class',
        onUpdate: (me) => {
          iN($.value, me.oldIndex, me.newIndex),
            Pl(() => {
              O.value = $.value.map((G) => G.id)
            })
        }
      })
      const pe = () => {
          const me = xg(),
            G = Dz()
          F.value.push({
            id: me,
            title: G,
            description: 'a sample description',
            image:
              'https://oldschool.runescape.wiki/images/Frog_%28Ruins_of_Camdozaal%29.png?6ae5e',
            type: 'drop',
            needAny: !1,
            points: 0,
            count: 0,
            repeatable: !1
          }),
            O.value.push(me)
        },
        q = () => {
          s.value &&
            ((F.value = F.value.filter((me) => me.id !== s.value.id)),
            (O.value = $.value.map((me) => me.id)),
            f())
        },
        z = () => {
          ;(s.value = null), f()
        },
        N = (me) => {
          var G
          me === 'add'
            ? (w.value = Math.min(w.value + 1, 12))
            : me === 'remove' && (w.value = Math.max(w.value - 1, 3)),
            (G = g.value) == null || G.style.setProperty('--width', w.value.toString())
        },
        B = async () => {
          v.value = !1
          try {
            const me = _r(rr, 'Boards', T.params.boardUUID),
              G = mc(me, 'Tiles'),
              R = iU(rr)
            R.update(me, { orderOfList: O.value, boardWidth: w.value })
            const X = await fO(G),
              W = {}
            X.forEach((ve) => {
              const y = ve.id
              W[y] = !0
              const E = ve.data(),
                A = F.value.find((x) => x.id === y)
              if (A) {
                if (JSON.stringify(A) !== JSON.stringify(E)) {
                  const x = _r(G, y)
                  R.set(x, {
                    id: A.id,
                    title: A.title,
                    description: A.description,
                    image: A.image,
                    type: A.type,
                    needAny: A.needAny,
                    points: A.points,
                    count: A.count
                  })
                }
              } else {
                const x = _r(G, y)
                R.delete(x)
              }
            }),
              F.value.forEach((ve) => {
                if (!W[ve.id]) {
                  const y = _r(G, ve.id)
                  R.set(y, {
                    id: ve.id,
                    title: ve.title,
                    description: ve.description,
                    image: ve.image,
                    type: ve.type,
                    needAny: ve.needAny,
                    points: ve.points,
                    count: ve.count
                  })
                }
              }),
              await R.commit()
            const { data: J, promise: Te } = Eg(mc(rr, 'Boards', T.params.boardUUID, 'Tiles'), {
              once: !0
            })
            await Te.value, (F.value = J.value)
          } catch (me) {
            console.error('Error synchronizing tiles:', me)
          }
        },
        D = async () => {
          ;(F.value = k.value), (w.value = h.value), (v.value = !1), (O.value = P)
        },
        se = () => {
          const me = [...k.value]
          ;(F.value = me), (P = O.value), (h.value = w.value), (v.value = !0)
        },
        he = async () => {
          I_(_r(rr, 'Boards', T.params.boardUUID, 'Tiles', c.value.id), { ...c.value }),
            (o.value = !1),
            l.value.close(),
            (s.value = c.value)
          const { data: me, promise: G } = Eg(mc(rr, 'Boards', T.params.boardUUID, 'Tiles'), {
            once: !0
          })
          await G.value, (F.value = me.value)
        },
        Ie = () => {
          ;(o.value = !1), l.value.close(), (c.value = null), (s.value = null)
        },
        xe = () => {
          const me = { ...s.value }
          ;(c.value = me), (o.value = !0), l.value.showModal()
        }
      return (me, G) => {
        var R, X, W, J, Te, ve
        return (
          de(),
          De(
            pt,
            null,
            [
              C('section', sJ, [
                Xe(S) ? (de(), De('h1', oJ, It(Xe(S).name), 1)) : ft('', !0),
                C('code', null, ' Board ID: ' + It(Xe(T).params.boardUUID), 1)
              ]),
              v.value
                ? (de(),
                  De('section', aJ, [
                    C('button', { onClick: G[0] || (G[0] = (y) => N('remove')) }, '-'),
                    Sn(
                      C(
                        'input',
                        {
                          id: 'widthInputElement',
                          ref_key: 'widthInputForm',
                          ref: _,
                          class: 'widthInput',
                          'onUpdate:modelValue': G[1] || (G[1] = (y) => (w.value = y)),
                          type: 'number',
                          min: '3',
                          max: '12',
                          onBlur:
                            G[2] ||
                            (G[2] = () => {
                              ;(w.value = Math.min(w.value, 12)), (w.value = Math.max(w.value, 3))
                            })
                        },
                        null,
                        544
                      ),
                      [[ki, w.value]]
                    ),
                    C('button', { onClick: G[3] || (G[3] = (y) => N('add')) }, '+'),
                    C('button', { submit: '', onClick: G[4] || (G[4] = (y) => B()) }, 'save'),
                    C('button', { cancel: '', onClick: G[5] || (G[5] = (y) => D()) }, 'cancel')
                  ]))
                : (de(),
                  De('section', lJ, [
                    C('button', { onClick: G[6] || (G[6] = (y) => se()) }, 'edit')
                  ])),
              C(
                'section',
                {
                  ref_key: 'el',
                  ref: g,
                  class: 'board',
                  style: No({ '--width': w.value, position: 'relative' })
                },
                [
                  (de(!0),
                  De(
                    pt,
                    null,
                    Fs(
                      $.value,
                      (y) => (
                        de(),
                        De(
                          'div',
                          {
                            class: hp(['tile', { handle: v.value }]),
                            style: No({ '--_image': `url('${y.image}')` }),
                            key: y.id
                          },
                          [
                            C('img', { class: 'tile--image', src: y.image }, null, 8, cJ),
                            v.value
                              ? (de(),
                                De(
                                  'button',
                                  {
                                    key: 0,
                                    icon: '',
                                    cancel: '',
                                    onClick: () => {
                                      ;(s.value = y), d()
                                    }
                                  },
                                  ' delete ',
                                  8,
                                  uJ
                                ))
                              : ft('', !0),
                            v.value
                              ? (de(),
                                De(
                                  'button',
                                  {
                                    key: 1,
                                    icon: '',
                                    onClick: () => {
                                      ;(s.value = y), xe()
                                    }
                                  },
                                  ' edit ',
                                  8,
                                  hJ
                                ))
                              : ft('', !0)
                          ],
                          6
                        )
                      )
                    ),
                    128
                  )),
                  F.value.length < 100
                    ? (de(),
                      De(
                        'button',
                        {
                          key: 0,
                          class: 'add_tile',
                          icon: '',
                          onClick: G[7] || (G[7] = (y) => pe()),
                          style: No({ order: $.value.length + 1 })
                        },
                        ' add_box ',
                        4
                      ))
                    : ft('', !0)
                ],
                4
              ),
              Be(
                HY,
                { ref_key: 'modalEle', ref: a },
                {
                  header: xo(() => {
                    var y
                    return [dt(' Delete tile: ' + It((y = s.value) == null ? void 0 : y.title), 1)]
                  }),
                  body: xo(() => {
                    var y
                    return [
                      dt(
                        ' are you sure you want to delete the tile ' +
                          It((y = s.value) == null ? void 0 : y.title),
                        1
                      )
                    ]
                  }),
                  controls: xo(() => [
                    C('button', { submit: '', onClick: q }, 'REMOVE'),
                    C('button', { cancel: '', onClick: z }, 'Cancel')
                  ]),
                  _: 1
                },
                512
              ),
              C(
                'dialog',
                { ref_key: 'asideModalEle', ref: l },
                [
                  s.value && c.value
                    ? (de(),
                      De('div', dJ, [
                        C('div', null, [
                          C('h2', null, [
                            dt(
                              ' Edit tile: ' + It((R = c.value) == null ? void 0 : R.title) + ' ',
                              1
                            ),
                            C('small', null, [
                              C('code', null, It((X = c.value) == null ? void 0 : X.id), 1)
                            ])
                          ]),
                          Sn(
                            C(
                              'input',
                              {
                                type: 'text',
                                'onUpdate:modelValue': G[8] || (G[8] = (y) => (c.value.title = y))
                              },
                              null,
                              512
                            ),
                            [[ki, c.value.title]]
                          ),
                          fJ,
                          Be(
                            VY,
                            {
                              class: 'editable',
                              modelValue: c.value.description,
                              'onUpdate:modelValue':
                                G[9] || (G[9] = (y) => (c.value.description = y))
                            },
                            null,
                            8,
                            ['modelValue']
                          )
                        ]),
                        C('div', null, [
                          pJ,
                          C('img', { src: c.value.image }, null, 8, mJ),
                          gJ,
                          C('label', null, [
                            dt('Image URL: '),
                            Sn(
                              C(
                                'input',
                                {
                                  required: '',
                                  type: 'url',
                                  'onUpdate:modelValue':
                                    G[10] || (G[10] = (y) => (c.value.image = y))
                                },
                                null,
                                512
                              ),
                              [[ki, c.value.image]]
                            )
                          ])
                        ]),
                        C('div', null, [
                          yJ,
                          _J,
                          Be(
                            Xe(Ud),
                            {
                              modelValue: c.value.type,
                              'onUpdate:modelValue': G[11] || (G[11] = (y) => (c.value.type = y)),
                              options: ['drop', 'exp', 'kc'],
                              'close-on-select': !0,
                              'clear-on-select': !1,
                              'allow-empty': !0,
                              placeholder: 'Choose a tile Type'
                            },
                            null,
                            8,
                            ['modelValue']
                          )
                        ]),
                        vJ,
                        C('div', null, [
                          bJ,
                          EJ,
                          ((W = c.value) == null ? void 0 : W.type) !== 'exp'
                            ? (de(),
                              dn(
                                Xe(Ud),
                                {
                                  key: 0,
                                  modelValue: c.value.metric,
                                  'onUpdate:modelValue':
                                    G[12] || (G[12] = (y) => (c.value.metric = y)),
                                  options: i.value,
                                  'close-on-select': !0,
                                  'clear-on-select': !1,
                                  'allow-empty': !0,
                                  placeholder: 'Choose a metric to track progress'
                                },
                                null,
                                8,
                                ['modelValue', 'options']
                              ))
                            : (de(),
                              dn(
                                Xe(Ud),
                                {
                                  key: 1,
                                  modelValue: c.value.metric,
                                  'onUpdate:modelValue':
                                    G[13] || (G[13] = (y) => (c.value.metric = y)),
                                  options: Xe(Th),
                                  'close-on-select': !0,
                                  'clear-on-select': !1,
                                  'allow-empty': !0,
                                  placeholder: 'Choose a metric to track progress'
                                },
                                null,
                                8,
                                ['modelValue', 'options']
                              ))
                        ]),
                        TJ,
                        c.value && (J = c.value.repeatable) != null && J.toString()
                          ? (de(),
                            De('div', wJ, [
                              SJ,
                              IJ,
                              C('label', null, [
                                dt('Repeatable '),
                                Sn(
                                  C(
                                    'input',
                                    {
                                      type: 'checkbox',
                                      'onUpdate:modelValue':
                                        G[14] || (G[14] = (y) => (c.value.repeatable = y))
                                    },
                                    null,
                                    512
                                  ),
                                  [[sE, c.value.repeatable]]
                                ),
                                dt(' ' + It(c.value.repeatable), 1)
                              ])
                            ]))
                          : ft('', !0),
                        AJ,
                        C('div', null, [
                          CJ,
                          RJ,
                          C('label', null, [
                            dt('points value: '),
                            Sn(
                              C(
                                'input',
                                {
                                  type: 'number',
                                  min: '0',
                                  'onUpdate:modelValue':
                                    G[15] || (G[15] = (y) => (c.value.points = y))
                                },
                                null,
                                512
                              ),
                              [[ki, c.value.points]]
                            )
                          ]),
                          kJ,
                          C('label', null, [
                            dt('count: '),
                            Sn(
                              C(
                                'input',
                                {
                                  type: 'number',
                                  min: '0',
                                  'onUpdate:modelValue':
                                    G[16] || (G[16] = (y) => (c.value.count = y))
                                },
                                null,
                                512
                              ),
                              [[ki, c.value.count]]
                            )
                          ]),
                          OJ,
                          C('label', null, [
                            dt('minimum count: '),
                            c.value !== null
                              ? Sn(
                                  (de(),
                                  De(
                                    'input',
                                    {
                                      key: 0,
                                      placeholder: 'unset',
                                      type: 'number',
                                      min: '0',
                                      onBlur:
                                        G[17] ||
                                        (G[17] = () => {
                                          c.value &&
                                            c.value.min != null &&
                                            (c.value.min = c.value.min < 0 ? 0 : c.value.min)
                                        }),
                                      'onUpdate:modelValue':
                                        G[18] || (G[18] = (y) => (c.value.min = y))
                                    },
                                    null,
                                    544
                                  )),
                                  [[ki, c.value.min]]
                                )
                              : ft('', !0)
                          ]),
                          NJ,
                          C('label', null, [
                            dt('maximum count: '),
                            Sn(
                              C(
                                'input',
                                {
                                  placeholder: 'unset',
                                  type: 'number',
                                  min: '0',
                                  onBlur:
                                    G[19] ||
                                    (G[19] = () => {
                                      c.value &&
                                        c.value.max != null &&
                                        (c.value.max = c.value.max < 0 ? 0 : c.value.max)
                                    }),
                                  'onUpdate:modelValue': G[20] || (G[20] = (y) => (c.value.max = y))
                                },
                                null,
                                544
                              ),
                              [[ki, c.value.max]]
                            )
                          ])
                        ]),
                        ((Te = c.value) == null ? void 0 : Te.type) == 'drop'
                          ? (de(), De('hr', MJ))
                          : ft('', !0),
                        ((ve = c.value) == null ? void 0 : ve.type) == 'drop'
                          ? (de(),
                            De('div', PJ, [
                              xJ,
                              DJ,
                              C('ul', null, [
                                (de(!0),
                                De(
                                  pt,
                                  null,
                                  Fs(
                                    c.value.drops,
                                    (y) => (
                                      de(),
                                      De('li', null, [
                                        dt(It(y) + ' ', 1),
                                        C(
                                          'button',
                                          { icon: '', cancel: '', onClick: (E) => m(y) },
                                          'delete',
                                          8,
                                          LJ
                                        )
                                      ])
                                    )
                                  ),
                                  256
                                )),
                                C('li', null, [
                                  Sn(
                                    C(
                                      'input',
                                      {
                                        type: 'text',
                                        'onUpdate:modelValue':
                                          G[21] || (G[21] = (y) => (u.value = y))
                                      },
                                      null,
                                      512
                                    ),
                                    [[ki, u.value]]
                                  ),
                                  C('button', { onClick: p }, 'Add Drop')
                                ])
                              ])
                            ]))
                          : ft('', !0),
                        c.value && c.value.needAny.toString()
                          ? (de(),
                            De('div', VJ, [
                              FJ,
                              BJ,
                              C('label', null, [
                                dt('All'),
                                Sn(
                                  C(
                                    'input',
                                    {
                                      type: 'checkbox',
                                      choice: '',
                                      'onUpdate:modelValue':
                                        G[22] || (G[22] = (y) => (c.value.needAny = y))
                                    },
                                    null,
                                    512
                                  ),
                                  [[sE, c.value.needAny]]
                                ),
                                dt('Any')
                              ])
                            ]))
                          : ft('', !0)
                      ]))
                    : ft('', !0),
                  C('button', { submit: '', onClick: he }, 'Save changes'),
                  C('button', { cancel: '', onClick: Ie }, 'Cancel')
                ],
                512
              )
            ],
            64
          )
        )
      }
    }
  }),
  $J = ga(UJ, [['__scopeId', 'data-v-7cf22b12']]),
  HJ = {},
  xM = (t) => (yp('data-v-9b1c0c5b'), (t = t()), _p(), t),
  zJ = iD(
    '<h1 data-v-9b1c0c5b>Theme preview page</h1><section data-v-9b1c0c5b><h2 data-v-9b1c0c5b>Colors</h2><div class="wrapper" data-v-9b1c0c5b><div class="block bg-background border" data-v-9b1c0c5b>background</div><div class="block bg-bgalt" data-v-9b1c0c5b>alt bg</div><div class="block bg-bgaccent" data-v-9b1c0c5b>accent bg</div><div class="block bg-primary-100" data-v-9b1c0c5b>primary-100</div><div class="block bg-primary" data-v-9b1c0c5b>primary</div><div class="block bg-primary-900" data-v-9b1c0c5b>primary-900</div><div class="block bg-secondary-100" data-v-9b1c0c5b>secondary-100</div><div class="block bg-secondary" data-v-9b1c0c5b>secondary</div><div class="block bg-secondary-900" data-v-9b1c0c5b>secondary-900</div><div class="block bg-accent-100" data-v-9b1c0c5b>accent-100</div><div class="block bg-accent" data-v-9b1c0c5b>accent</div><div class="block bg-accent-900" data-v-9b1c0c5b>accent-900</div></div></section><section data-v-9b1c0c5b><h2 data-v-9b1c0c5b>This is a Heading</h2><h3 data-v-9b1c0c5b>This is a Heading</h3><h4 data-v-9b1c0c5b>This is a Heading</h4><h5 data-v-9b1c0c5b>This is a Heading</h5><p data-v-9b1c0c5b>This is a paragraph.</p><p data-v-9b1c0c5b><code data-v-9b1c0c5b>this is code</code></p><p data-v-9b1c0c5b><a href="https://www.example.com" data-v-9b1c0c5b>This is a link</a></p><p data-v-9b1c0c5b><a href="https://www.example.com" target="_blank" data-v-9b1c0c5b>This is an external link</a></p></section><section data-v-9b1c0c5b><h2 data-v-9b1c0c5b>Unordered lists</h2><ul data-v-9b1c0c5b><li data-v-9b1c0c5b>List Item 1</li><li data-v-9b1c0c5b>List Item 2</li><li data-v-9b1c0c5b>List Item 3</li></ul></section><section data-v-9b1c0c5b><h2 data-v-9b1c0c5b>Ordered lists</h2><ol data-v-9b1c0c5b><li data-v-9b1c0c5b>List Item 1</li><li data-v-9b1c0c5b>List Item 2</li><li data-v-9b1c0c5b>List Item 3</li></ol></section><section data-v-9b1c0c5b><h2 data-v-9b1c0c5b>Table</h2><table data-v-9b1c0c5b><tr data-v-9b1c0c5b><th data-v-9b1c0c5b>Header 1</th><th data-v-9b1c0c5b>Header 2</th></tr><tr data-v-9b1c0c5b><td data-v-9b1c0c5b>Data 1</td><td data-v-9b1c0c5b>Data 2</td></tr></table></section>',
    6
  ),
  jJ = xM(() =>
    C(
      'section',
      null,
      [
        C('h2', null, 'Inputs'),
        C('section', null, [
          C('div', null, [C('label', { for: 'input-text' }, 'Input Text:')]),
          C('input', { type: 'text', id: 'input-text', name: 'input-text' })
        ]),
        C('label', null, 'Input Radio:'),
        C('br'),
        C('input', { type: 'radio', id: 'input-radio1', name: 'input-radio', value: 'radio1' }),
        C('label', { for: 'input-radio1' }, 'Radio 1'),
        C('br'),
        C('input', { type: 'radio', id: 'input-radio2', name: 'input-radio', value: 'radio2' }),
        C('label', { for: 'input-radio2' }, 'Radio 2'),
        C('br'),
        C('div', null, [
          C('label', { for: 'input-checkbox' }, 'Input Checkbox:'),
          C('br'),
          C('input', {
            type: 'checkbox',
            id: 'input-checkbox',
            name: 'input-checkbox',
            value: 'checkbox1'
          }),
          dt('Checkbox 1'),
          C('br'),
          C('input', {
            type: 'checkbox',
            checked: '',
            id: 'input-checkbox',
            name: 'input-checkbox',
            value: 'checkbox2'
          }),
          dt('Checkbox 2'),
          C('br')
        ]),
        C('button', null, 'Button'),
        C('button', { outline: '' }, 'outline'),
        C('button', { cancel: '' }, 'cancel'),
        C('button', { submit: '' }, 'submit')
      ],
      -1
    )
  ),
  WJ = xM(() =>
    C(
      'section',
      null,
      [
        C('h2', null, 'Combination elements'),
        C('section', null, [
          C('button', null, 'add'),
          C('input', { type: 'text', class: 'width-2' }),
          C('button', null, 'subtract')
        ]),
        C('section', null, [
          C('span', { type: 'text', class: 'input width-10', contenteditable: '' }),
          C('button', null, 'subtract')
        ])
      ],
      -1
    )
  )
function GJ(t, e) {
  return de(), De(pt, null, [zJ, jJ, WJ], 64)
}
const qJ = ga(HJ, [
    ['render', GJ],
    ['__scopeId', 'data-v-9b1c0c5b']
  ]),
  KJ = q$({
    history: T$(),
    routes: [
      { path: '/new', name: 'createNewBingo', component: ZH },
      { path: '/login', name: 'loginScreen', component: az },
      { path: '/edit/:boardUUID', name: 'editBoard', component: $J },
      { path: '/color/', name: 'color', component: qJ },
      { path: '/', name: 'Home', component: bH }
    ]
  })
function cI(t, e) {
  var n = Object.keys(t)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function oe(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? cI(Object(n), !0).forEach(function (r) {
          Kt(t, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : cI(Object(n)).forEach(function (r) {
          Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
        })
  }
  return t
}
function rp(t) {
  '@babel/helpers - typeof'
  return (
    (rp =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (e) {
            return typeof e
          }
        : function (e) {
            return e &&
              typeof Symbol == 'function' &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? 'symbol'
              : typeof e
          }),
    rp(t)
  )
}
function YJ(t, e) {
  if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
}
function uI(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(t, r.key, r)
  }
}
function JJ(t, e, n) {
  return (
    e && uI(t.prototype, e),
    n && uI(t, n),
    Object.defineProperty(t, 'prototype', { writable: !1 }),
    t
  )
}
function Kt(t, e, n) {
  return (
    e in t
      ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (t[e] = n),
    t
  )
}
function ib(t, e) {
  return XJ(t) || eQ(t, e) || DM(t, e) || nQ()
}
function Rh(t) {
  return QJ(t) || ZJ(t) || DM(t) || tQ()
}
function QJ(t) {
  if (Array.isArray(t)) return sv(t)
}
function XJ(t) {
  if (Array.isArray(t)) return t
}
function ZJ(t) {
  if ((typeof Symbol < 'u' && t[Symbol.iterator] != null) || t['@@iterator'] != null)
    return Array.from(t)
}
function eQ(t, e) {
  var n = t == null ? null : (typeof Symbol < 'u' && t[Symbol.iterator]) || t['@@iterator']
  if (n != null) {
    var r = [],
      i = !0,
      s = !1,
      o,
      a
    try {
      for (
        n = n.call(t);
        !(i = (o = n.next()).done) && (r.push(o.value), !(e && r.length === e));
        i = !0
      );
    } catch (l) {
      ;(s = !0), (a = l)
    } finally {
      try {
        !i && n.return != null && n.return()
      } finally {
        if (s) throw a
      }
    }
    return r
  }
}
function DM(t, e) {
  if (t) {
    if (typeof t == 'string') return sv(t, e)
    var n = Object.prototype.toString.call(t).slice(8, -1)
    if ((n === 'Object' && t.constructor && (n = t.constructor.name), n === 'Map' || n === 'Set'))
      return Array.from(t)
    if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sv(t, e)
  }
}
function sv(t, e) {
  ;(e == null || e > t.length) && (e = t.length)
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
  return r
}
function tQ() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function nQ() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var hI = function () {},
  sb = {},
  LM = {},
  VM = null,
  FM = { mark: hI, measure: hI }
try {
  typeof window < 'u' && (sb = window),
    typeof document < 'u' && (LM = document),
    typeof MutationObserver < 'u' && (VM = MutationObserver),
    typeof performance < 'u' && (FM = performance)
} catch {}
var rQ = sb.navigator || {},
  dI = rQ.userAgent,
  fI = dI === void 0 ? '' : dI,
  Gs = sb,
  Et = LM,
  pI = VM,
  cd = FM
Gs.document
var Zi =
    !!Et.documentElement &&
    !!Et.head &&
    typeof Et.addEventListener == 'function' &&
    typeof Et.createElement == 'function',
  BM = ~fI.indexOf('MSIE') || ~fI.indexOf('Trident/'),
  ud,
  hd,
  dd,
  fd,
  pd,
  qi = '___FONT_AWESOME___',
  ov = 16,
  UM = 'fa',
  $M = 'svg-inline--fa',
  ia = 'data-fa-i2svg',
  av = 'data-fa-pseudo-element',
  iQ = 'data-fa-pseudo-element-pending',
  ob = 'data-prefix',
  ab = 'data-icon',
  mI = 'fontawesome-i2svg',
  sQ = 'async',
  oQ = ['HTML', 'HEAD', 'STYLE', 'SCRIPT'],
  HM = (function () {
    try {
      return !0
    } catch {
      return !1
    }
  })(),
  vt = 'classic',
  Nt = 'sharp',
  lb = [vt, Nt]
function kh(t) {
  return new Proxy(t, {
    get: function (n, r) {
      return r in n ? n[r] : n[vt]
    }
  })
}
var Fu = kh(
    ((ud = {}),
    Kt(ud, vt, {
      fa: 'solid',
      fas: 'solid',
      'fa-solid': 'solid',
      far: 'regular',
      'fa-regular': 'regular',
      fal: 'light',
      'fa-light': 'light',
      fat: 'thin',
      'fa-thin': 'thin',
      fad: 'duotone',
      'fa-duotone': 'duotone',
      fab: 'brands',
      'fa-brands': 'brands',
      fak: 'kit',
      fakd: 'kit',
      'fa-kit': 'kit',
      'fa-kit-duotone': 'kit'
    }),
    Kt(ud, Nt, {
      fa: 'solid',
      fass: 'solid',
      'fa-solid': 'solid',
      fasr: 'regular',
      'fa-regular': 'regular',
      fasl: 'light',
      'fa-light': 'light',
      fast: 'thin',
      'fa-thin': 'thin'
    }),
    ud)
  ),
  Bu = kh(
    ((hd = {}),
    Kt(hd, vt, {
      solid: 'fas',
      regular: 'far',
      light: 'fal',
      thin: 'fat',
      duotone: 'fad',
      brands: 'fab',
      kit: 'fak'
    }),
    Kt(hd, Nt, { solid: 'fass', regular: 'fasr', light: 'fasl', thin: 'fast' }),
    hd)
  ),
  Uu = kh(
    ((dd = {}),
    Kt(dd, vt, {
      fab: 'fa-brands',
      fad: 'fa-duotone',
      fak: 'fa-kit',
      fal: 'fa-light',
      far: 'fa-regular',
      fas: 'fa-solid',
      fat: 'fa-thin'
    }),
    Kt(dd, Nt, { fass: 'fa-solid', fasr: 'fa-regular', fasl: 'fa-light', fast: 'fa-thin' }),
    dd)
  ),
  aQ = kh(
    ((fd = {}),
    Kt(fd, vt, {
      'fa-brands': 'fab',
      'fa-duotone': 'fad',
      'fa-kit': 'fak',
      'fa-light': 'fal',
      'fa-regular': 'far',
      'fa-solid': 'fas',
      'fa-thin': 'fat'
    }),
    Kt(fd, Nt, { 'fa-solid': 'fass', 'fa-regular': 'fasr', 'fa-light': 'fasl', 'fa-thin': 'fast' }),
    fd)
  ),
  lQ = /fa(s|r|l|t|d|b|k|ss|sr|sl|st)?[\-\ ]/,
  zM = 'fa-layers-text',
  cQ = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i,
  uQ = kh(
    ((pd = {}),
    Kt(pd, vt, { 900: 'fas', 400: 'far', normal: 'far', 300: 'fal', 100: 'fat' }),
    Kt(pd, Nt, { 900: 'fass', 400: 'fasr', 300: 'fasl', 100: 'fast' }),
    pd)
  ),
  jM = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  hQ = jM.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]),
  dQ = ['class', 'data-prefix', 'data-icon', 'data-fa-transform', 'data-fa-mask'],
  ko = {
    GROUP: 'duotone-group',
    SWAP_OPACITY: 'swap-opacity',
    PRIMARY: 'primary',
    SECONDARY: 'secondary'
  },
  $u = new Set()
Object.keys(Bu[vt]).map($u.add.bind($u))
Object.keys(Bu[Nt]).map($u.add.bind($u))
var fQ = []
    .concat(lb, Rh($u), [
      '2xs',
      'xs',
      'sm',
      'lg',
      'xl',
      '2xl',
      'beat',
      'border',
      'fade',
      'beat-fade',
      'bounce',
      'flip-both',
      'flip-horizontal',
      'flip-vertical',
      'flip',
      'fw',
      'inverse',
      'layers-counter',
      'layers-text',
      'layers',
      'li',
      'pull-left',
      'pull-right',
      'pulse',
      'rotate-180',
      'rotate-270',
      'rotate-90',
      'rotate-by',
      'shake',
      'spin-pulse',
      'spin-reverse',
      'spin',
      'stack-1x',
      'stack-2x',
      'stack',
      'ul',
      ko.GROUP,
      ko.SWAP_OPACITY,
      ko.PRIMARY,
      ko.SECONDARY
    ])
    .concat(
      jM.map(function (t) {
        return ''.concat(t, 'x')
      })
    )
    .concat(
      hQ.map(function (t) {
        return 'w-'.concat(t)
      })
    ),
  Xc = Gs.FontAwesomeConfig || {}
function pQ(t) {
  var e = Et.querySelector('script[' + t + ']')
  if (e) return e.getAttribute(t)
}
function mQ(t) {
  return t === '' ? !0 : t === 'false' ? !1 : t === 'true' ? !0 : t
}
if (Et && typeof Et.querySelector == 'function') {
  var gQ = [
    ['data-family-prefix', 'familyPrefix'],
    ['data-css-prefix', 'cssPrefix'],
    ['data-family-default', 'familyDefault'],
    ['data-style-default', 'styleDefault'],
    ['data-replacement-class', 'replacementClass'],
    ['data-auto-replace-svg', 'autoReplaceSvg'],
    ['data-auto-add-css', 'autoAddCss'],
    ['data-auto-a11y', 'autoA11y'],
    ['data-search-pseudo-elements', 'searchPseudoElements'],
    ['data-observe-mutations', 'observeMutations'],
    ['data-mutate-approach', 'mutateApproach'],
    ['data-keep-original-source', 'keepOriginalSource'],
    ['data-measure-performance', 'measurePerformance'],
    ['data-show-missing-icons', 'showMissingIcons']
  ]
  gQ.forEach(function (t) {
    var e = ib(t, 2),
      n = e[0],
      r = e[1],
      i = mQ(pQ(n))
    i != null && (Xc[r] = i)
  })
}
var WM = {
  styleDefault: 'solid',
  familyDefault: 'classic',
  cssPrefix: UM,
  replacementClass: $M,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: 'async',
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
}
Xc.familyPrefix && (Xc.cssPrefix = Xc.familyPrefix)
var Ml = oe(oe({}, WM), Xc)
Ml.autoReplaceSvg || (Ml.observeMutations = !1)
var fe = {}
Object.keys(WM).forEach(function (t) {
  Object.defineProperty(fe, t, {
    enumerable: !0,
    set: function (n) {
      ;(Ml[t] = n),
        Zc.forEach(function (r) {
          return r(fe)
        })
    },
    get: function () {
      return Ml[t]
    }
  })
})
Object.defineProperty(fe, 'familyPrefix', {
  enumerable: !0,
  set: function (e) {
    ;(Ml.cssPrefix = e),
      Zc.forEach(function (n) {
        return n(fe)
      })
  },
  get: function () {
    return Ml.cssPrefix
  }
})
Gs.FontAwesomeConfig = fe
var Zc = []
function yQ(t) {
  return (
    Zc.push(t),
    function () {
      Zc.splice(Zc.indexOf(t), 1)
    }
  )
}
var as = ov,
  ai = { size: 16, x: 0, y: 0, rotate: 0, flipX: !1, flipY: !1 }
function _Q(t) {
  if (!(!t || !Zi)) {
    var e = Et.createElement('style')
    e.setAttribute('type', 'text/css'), (e.innerHTML = t)
    for (var n = Et.head.childNodes, r = null, i = n.length - 1; i > -1; i--) {
      var s = n[i],
        o = (s.tagName || '').toUpperCase()
      ;['STYLE', 'LINK'].indexOf(o) > -1 && (r = s)
    }
    return Et.head.insertBefore(e, r), t
  }
}
var vQ = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
function Hu() {
  for (var t = 12, e = ''; t-- > 0; ) e += vQ[(Math.random() * 62) | 0]
  return e
}
function Kl(t) {
  for (var e = [], n = (t || []).length >>> 0; n--; ) e[n] = t[n]
  return e
}
function cb(t) {
  return t.classList
    ? Kl(t.classList)
    : (t.getAttribute('class') || '').split(' ').filter(function (e) {
        return e
      })
}
function GM(t) {
  return ''
    .concat(t)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
}
function bQ(t) {
  return Object.keys(t || {})
    .reduce(function (e, n) {
      return e + ''.concat(n, '="').concat(GM(t[n]), '" ')
    }, '')
    .trim()
}
function Mm(t) {
  return Object.keys(t || {}).reduce(function (e, n) {
    return e + ''.concat(n, ': ').concat(t[n].trim(), ';')
  }, '')
}
function ub(t) {
  return (
    t.size !== ai.size ||
    t.x !== ai.x ||
    t.y !== ai.y ||
    t.rotate !== ai.rotate ||
    t.flipX ||
    t.flipY
  )
}
function EQ(t) {
  var e = t.transform,
    n = t.containerWidth,
    r = t.iconWidth,
    i = { transform: 'translate('.concat(n / 2, ' 256)') },
    s = 'translate('.concat(e.x * 32, ', ').concat(e.y * 32, ') '),
    o = 'scale('
      .concat((e.size / 16) * (e.flipX ? -1 : 1), ', ')
      .concat((e.size / 16) * (e.flipY ? -1 : 1), ') '),
    a = 'rotate('.concat(e.rotate, ' 0 0)'),
    l = { transform: ''.concat(s, ' ').concat(o, ' ').concat(a) },
    c = { transform: 'translate('.concat((r / 2) * -1, ' -256)') }
  return { outer: i, inner: l, path: c }
}
function TQ(t) {
  var e = t.transform,
    n = t.width,
    r = n === void 0 ? ov : n,
    i = t.height,
    s = i === void 0 ? ov : i,
    o = t.startCentered,
    a = o === void 0 ? !1 : o,
    l = ''
  return (
    a && BM
      ? (l += 'translate('.concat(e.x / as - r / 2, 'em, ').concat(e.y / as - s / 2, 'em) '))
      : a
      ? (l += 'translate(calc(-50% + '
          .concat(e.x / as, 'em), calc(-50% + ')
          .concat(e.y / as, 'em)) '))
      : (l += 'translate('.concat(e.x / as, 'em, ').concat(e.y / as, 'em) ')),
    (l += 'scale('
      .concat((e.size / as) * (e.flipX ? -1 : 1), ', ')
      .concat((e.size / as) * (e.flipY ? -1 : 1), ') ')),
    (l += 'rotate('.concat(e.rotate, 'deg) ')),
    l
  )
}
var wQ = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-counter-scale, 0.25));
          transform: scale(var(--fa-counter-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(var(--fa-li-width, 2em) * -1);
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  -webkit-animation-name: fa-beat;
          animation-name: fa-beat;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  -webkit-animation-name: fa-bounce;
          animation-name: fa-bounce;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  -webkit-animation-name: fa-fade;
          animation-name: fa-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  -webkit-animation-name: fa-beat-fade;
          animation-name: fa-beat-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  -webkit-animation-name: fa-flip;
          animation-name: fa-flip;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  -webkit-animation-name: fa-shake;
          animation-name: fa-shake;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 2s);
          animation-duration: var(--fa-animation-duration, 2s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));
          animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    -webkit-animation-delay: -1ms;
            animation-delay: -1ms;
    -webkit-animation-duration: 1ms;
            animation-duration: 1ms;
    -webkit-animation-iteration-count: 1;
            animation-iteration-count: 1;
    -webkit-transition-delay: 0s;
            transition-delay: 0s;
    -webkit-transition-duration: 0s;
            transition-duration: 0s;
  }
}
@-webkit-keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@-webkit-keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@-webkit-keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@-webkit-keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@-webkit-keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@-webkit-keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

.fa-rotate-by {
  -webkit-transform: rotate(var(--fa-rotate-angle, none));
          transform: rotate(var(--fa-rotate-angle, none));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse,
.fa-duotone.fa-inverse {
  color: var(--fa-inverse, #fff);
}`
function qM() {
  var t = UM,
    e = $M,
    n = fe.cssPrefix,
    r = fe.replacementClass,
    i = wQ
  if (n !== t || r !== e) {
    var s = new RegExp('\\.'.concat(t, '\\-'), 'g'),
      o = new RegExp('\\--'.concat(t, '\\-'), 'g'),
      a = new RegExp('\\.'.concat(e), 'g')
    i = i.replace(s, '.'.concat(n, '-')).replace(o, '--'.concat(n, '-')).replace(a, '.'.concat(r))
  }
  return i
}
var gI = !1
function oy() {
  fe.autoAddCss && !gI && (_Q(qM()), (gI = !0))
}
var SQ = {
    mixout: function () {
      return { dom: { css: qM, insertCss: oy } }
    },
    hooks: function () {
      return {
        beforeDOMElementCreation: function () {
          oy()
        },
        beforeI2svg: function () {
          oy()
        }
      }
    }
  },
  Ki = Gs || {}
Ki[qi] || (Ki[qi] = {})
Ki[qi].styles || (Ki[qi].styles = {})
Ki[qi].hooks || (Ki[qi].hooks = {})
Ki[qi].shims || (Ki[qi].shims = [])
var Vr = Ki[qi],
  KM = [],
  IQ = function t() {
    Et.removeEventListener('DOMContentLoaded', t),
      (ip = 1),
      KM.map(function (e) {
        return e()
      })
  },
  ip = !1
Zi &&
  ((ip = (Et.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(Et.readyState)),
  ip || Et.addEventListener('DOMContentLoaded', IQ))
function AQ(t) {
  Zi && (ip ? setTimeout(t, 0) : KM.push(t))
}
function Oh(t) {
  var e = t.tag,
    n = t.attributes,
    r = n === void 0 ? {} : n,
    i = t.children,
    s = i === void 0 ? [] : i
  return typeof t == 'string'
    ? GM(t)
    : '<'.concat(e, ' ').concat(bQ(r), '>').concat(s.map(Oh).join(''), '</').concat(e, '>')
}
function yI(t, e, n) {
  if (t && t[e] && t[e][n]) return { prefix: e, iconName: n, icon: t[e][n] }
}
var CQ = function (e, n) {
    return function (r, i, s, o) {
      return e.call(n, r, i, s, o)
    }
  },
  ay = function (e, n, r, i) {
    var s = Object.keys(e),
      o = s.length,
      a = i !== void 0 ? CQ(n, i) : n,
      l,
      c,
      u
    for (r === void 0 ? ((l = 1), (u = e[s[0]])) : ((l = 0), (u = r)); l < o; l++)
      (c = s[l]), (u = a(u, e[c], c, e))
    return u
  }
function RQ(t) {
  for (var e = [], n = 0, r = t.length; n < r; ) {
    var i = t.charCodeAt(n++)
    if (i >= 55296 && i <= 56319 && n < r) {
      var s = t.charCodeAt(n++)
      ;(s & 64512) == 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), n--)
    } else e.push(i)
  }
  return e
}
function lv(t) {
  var e = RQ(t)
  return e.length === 1 ? e[0].toString(16) : null
}
function kQ(t, e) {
  var n = t.length,
    r = t.charCodeAt(e),
    i
  return r >= 55296 &&
    r <= 56319 &&
    n > e + 1 &&
    ((i = t.charCodeAt(e + 1)), i >= 56320 && i <= 57343)
    ? (r - 55296) * 1024 + i - 56320 + 65536
    : r
}
function _I(t) {
  return Object.keys(t).reduce(function (e, n) {
    var r = t[n],
      i = !!r.icon
    return i ? (e[r.iconName] = r.icon) : (e[n] = r), e
  }, {})
}
function cv(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    r = n.skipHooks,
    i = r === void 0 ? !1 : r,
    s = _I(e)
  typeof Vr.hooks.addPack == 'function' && !i
    ? Vr.hooks.addPack(t, _I(e))
    : (Vr.styles[t] = oe(oe({}, Vr.styles[t] || {}), s)),
    t === 'fas' && cv('fa', e)
}
var md,
  gd,
  yd,
  Va = Vr.styles,
  OQ = Vr.shims,
  NQ = ((md = {}), Kt(md, vt, Object.values(Uu[vt])), Kt(md, Nt, Object.values(Uu[Nt])), md),
  hb = null,
  YM = {},
  JM = {},
  QM = {},
  XM = {},
  ZM = {},
  MQ = ((gd = {}), Kt(gd, vt, Object.keys(Fu[vt])), Kt(gd, Nt, Object.keys(Fu[Nt])), gd)
function PQ(t) {
  return ~fQ.indexOf(t)
}
function xQ(t, e) {
  var n = e.split('-'),
    r = n[0],
    i = n.slice(1).join('-')
  return r === t && i !== '' && !PQ(i) ? i : null
}
var eP = function () {
  var e = function (s) {
    return ay(
      Va,
      function (o, a, l) {
        return (o[l] = ay(a, s, {})), o
      },
      {}
    )
  }
  ;(YM = e(function (i, s, o) {
    if ((s[3] && (i[s[3]] = o), s[2])) {
      var a = s[2].filter(function (l) {
        return typeof l == 'number'
      })
      a.forEach(function (l) {
        i[l.toString(16)] = o
      })
    }
    return i
  })),
    (JM = e(function (i, s, o) {
      if (((i[o] = o), s[2])) {
        var a = s[2].filter(function (l) {
          return typeof l == 'string'
        })
        a.forEach(function (l) {
          i[l] = o
        })
      }
      return i
    })),
    (ZM = e(function (i, s, o) {
      var a = s[2]
      return (
        (i[o] = o),
        a.forEach(function (l) {
          i[l] = o
        }),
        i
      )
    }))
  var n = 'far' in Va || fe.autoFetchSvg,
    r = ay(
      OQ,
      function (i, s) {
        var o = s[0],
          a = s[1],
          l = s[2]
        return (
          a === 'far' && !n && (a = 'fas'),
          typeof o == 'string' && (i.names[o] = { prefix: a, iconName: l }),
          typeof o == 'number' && (i.unicodes[o.toString(16)] = { prefix: a, iconName: l }),
          i
        )
      },
      { names: {}, unicodes: {} }
    )
  ;(QM = r.names), (XM = r.unicodes), (hb = Pm(fe.styleDefault, { family: fe.familyDefault }))
}
yQ(function (t) {
  hb = Pm(t.styleDefault, { family: fe.familyDefault })
})
eP()
function db(t, e) {
  return (YM[t] || {})[e]
}
function DQ(t, e) {
  return (JM[t] || {})[e]
}
function Oo(t, e) {
  return (ZM[t] || {})[e]
}
function tP(t) {
  return QM[t] || { prefix: null, iconName: null }
}
function LQ(t) {
  var e = XM[t],
    n = db('fas', t)
  return e || (n ? { prefix: 'fas', iconName: n } : null) || { prefix: null, iconName: null }
}
function qs() {
  return hb
}
var fb = function () {
  return { prefix: null, iconName: null, rest: [] }
}
function Pm(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = e.family,
    r = n === void 0 ? vt : n,
    i = Fu[r][t],
    s = Bu[r][t] || Bu[r][i],
    o = t in Vr.styles ? t : null
  return s || o || null
}
var vI = ((yd = {}), Kt(yd, vt, Object.keys(Uu[vt])), Kt(yd, Nt, Object.keys(Uu[Nt])), yd)
function xm(t) {
  var e,
    n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = n.skipLookups,
    i = r === void 0 ? !1 : r,
    s =
      ((e = {}),
      Kt(e, vt, ''.concat(fe.cssPrefix, '-').concat(vt)),
      Kt(e, Nt, ''.concat(fe.cssPrefix, '-').concat(Nt)),
      e),
    o = null,
    a = vt
  ;(t.includes(s[vt]) ||
    t.some(function (c) {
      return vI[vt].includes(c)
    })) &&
    (a = vt),
    (t.includes(s[Nt]) ||
      t.some(function (c) {
        return vI[Nt].includes(c)
      })) &&
      (a = Nt)
  var l = t.reduce(function (c, u) {
    var h = xQ(fe.cssPrefix, u)
    if (
      (Va[u]
        ? ((u = NQ[a].includes(u) ? aQ[a][u] : u), (o = u), (c.prefix = u))
        : MQ[a].indexOf(u) > -1
        ? ((o = u), (c.prefix = Pm(u, { family: a })))
        : h
        ? (c.iconName = h)
        : u !== fe.replacementClass && u !== s[vt] && u !== s[Nt] && c.rest.push(u),
      !i && c.prefix && c.iconName)
    ) {
      var d = o === 'fa' ? tP(c.iconName) : {},
        f = Oo(c.prefix, c.iconName)
      d.prefix && (o = null),
        (c.iconName = d.iconName || f || c.iconName),
        (c.prefix = d.prefix || c.prefix),
        c.prefix === 'far' && !Va.far && Va.fas && !fe.autoFetchSvg && (c.prefix = 'fas')
    }
    return c
  }, fb())
  return (
    (t.includes('fa-brands') || t.includes('fab')) && (l.prefix = 'fab'),
    (t.includes('fa-duotone') || t.includes('fad')) && (l.prefix = 'fad'),
    !l.prefix &&
      a === Nt &&
      (Va.fass || fe.autoFetchSvg) &&
      ((l.prefix = 'fass'), (l.iconName = Oo(l.prefix, l.iconName) || l.iconName)),
    (l.prefix === 'fa' || o === 'fa') && (l.prefix = qs() || 'fas'),
    l
  )
}
var VQ = (function () {
    function t() {
      YJ(this, t), (this.definitions = {})
    }
    return (
      JJ(t, [
        {
          key: 'add',
          value: function () {
            for (var n = this, r = arguments.length, i = new Array(r), s = 0; s < r; s++)
              i[s] = arguments[s]
            var o = i.reduce(this._pullDefinitions, {})
            Object.keys(o).forEach(function (a) {
              ;(n.definitions[a] = oe(oe({}, n.definitions[a] || {}), o[a])), cv(a, o[a])
              var l = Uu[vt][a]
              l && cv(l, o[a]), eP()
            })
          }
        },
        {
          key: 'reset',
          value: function () {
            this.definitions = {}
          }
        },
        {
          key: '_pullDefinitions',
          value: function (n, r) {
            var i = r.prefix && r.iconName && r.icon ? { 0: r } : r
            return (
              Object.keys(i).map(function (s) {
                var o = i[s],
                  a = o.prefix,
                  l = o.iconName,
                  c = o.icon,
                  u = c[2]
                n[a] || (n[a] = {}),
                  u.length > 0 &&
                    u.forEach(function (h) {
                      typeof h == 'string' && (n[a][h] = c)
                    }),
                  (n[a][l] = c)
              }),
              n
            )
          }
        }
      ]),
      t
    )
  })(),
  bI = [],
  Fa = {},
  il = {},
  FQ = Object.keys(il)
function BQ(t, e) {
  var n = e.mixoutsTo
  return (
    (bI = t),
    (Fa = {}),
    Object.keys(il).forEach(function (r) {
      FQ.indexOf(r) === -1 && delete il[r]
    }),
    bI.forEach(function (r) {
      var i = r.mixout ? r.mixout() : {}
      if (
        (Object.keys(i).forEach(function (o) {
          typeof i[o] == 'function' && (n[o] = i[o]),
            rp(i[o]) === 'object' &&
              Object.keys(i[o]).forEach(function (a) {
                n[o] || (n[o] = {}), (n[o][a] = i[o][a])
              })
        }),
        r.hooks)
      ) {
        var s = r.hooks()
        Object.keys(s).forEach(function (o) {
          Fa[o] || (Fa[o] = []), Fa[o].push(s[o])
        })
      }
      r.provides && r.provides(il)
    }),
    n
  )
}
function uv(t, e) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
    r[i - 2] = arguments[i]
  var s = Fa[t] || []
  return (
    s.forEach(function (o) {
      e = o.apply(null, [e].concat(r))
    }),
    e
  )
}
function sa(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r]
  var i = Fa[t] || []
  i.forEach(function (s) {
    s.apply(null, n)
  })
}
function Yi() {
  var t = arguments[0],
    e = Array.prototype.slice.call(arguments, 1)
  return il[t] ? il[t].apply(null, e) : void 0
}
function hv(t) {
  t.prefix === 'fa' && (t.prefix = 'fas')
  var e = t.iconName,
    n = t.prefix || qs()
  if (e) return (e = Oo(n, e) || e), yI(nP.definitions, n, e) || yI(Vr.styles, n, e)
}
var nP = new VQ(),
  UQ = function () {
    ;(fe.autoReplaceSvg = !1), (fe.observeMutations = !1), sa('noAuto')
  },
  $Q = {
    i2svg: function () {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
      return Zi
        ? (sa('beforeI2svg', e), Yi('pseudoElements2svg', e), Yi('i2svg', e))
        : Promise.reject('Operation requires a DOM of some kind.')
    },
    watch: function () {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        n = e.autoReplaceSvgRoot
      fe.autoReplaceSvg === !1 && (fe.autoReplaceSvg = !0),
        (fe.observeMutations = !0),
        AQ(function () {
          zQ({ autoReplaceSvgRoot: n }), sa('watch', e)
        })
    }
  },
  HQ = {
    icon: function (e) {
      if (e === null) return null
      if (rp(e) === 'object' && e.prefix && e.iconName)
        return { prefix: e.prefix, iconName: Oo(e.prefix, e.iconName) || e.iconName }
      if (Array.isArray(e) && e.length === 2) {
        var n = e[1].indexOf('fa-') === 0 ? e[1].slice(3) : e[1],
          r = Pm(e[0])
        return { prefix: r, iconName: Oo(r, n) || n }
      }
      if (typeof e == 'string' && (e.indexOf(''.concat(fe.cssPrefix, '-')) > -1 || e.match(lQ))) {
        var i = xm(e.split(' '), { skipLookups: !0 })
        return { prefix: i.prefix || qs(), iconName: Oo(i.prefix, i.iconName) || i.iconName }
      }
      if (typeof e == 'string') {
        var s = qs()
        return { prefix: s, iconName: Oo(s, e) || e }
      }
    }
  },
  pr = {
    noAuto: UQ,
    config: fe,
    dom: $Q,
    parse: HQ,
    library: nP,
    findIconDefinition: hv,
    toHtml: Oh
  },
  zQ = function () {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      n = e.autoReplaceSvgRoot,
      r = n === void 0 ? Et : n
    ;(Object.keys(Vr.styles).length > 0 || fe.autoFetchSvg) &&
      Zi &&
      fe.autoReplaceSvg &&
      pr.dom.i2svg({ node: r })
  }
function Dm(t, e) {
  return (
    Object.defineProperty(t, 'abstract', { get: e }),
    Object.defineProperty(t, 'html', {
      get: function () {
        return t.abstract.map(function (r) {
          return Oh(r)
        })
      }
    }),
    Object.defineProperty(t, 'node', {
      get: function () {
        if (Zi) {
          var r = Et.createElement('div')
          return (r.innerHTML = t.html), r.children
        }
      }
    }),
    t
  )
}
function jQ(t) {
  var e = t.children,
    n = t.main,
    r = t.mask,
    i = t.attributes,
    s = t.styles,
    o = t.transform
  if (ub(o) && n.found && !r.found) {
    var a = n.width,
      l = n.height,
      c = { x: a / l / 2, y: 0.5 }
    i.style = Mm(
      oe(
        oe({}, s),
        {},
        { 'transform-origin': ''.concat(c.x + o.x / 16, 'em ').concat(c.y + o.y / 16, 'em') }
      )
    )
  }
  return [{ tag: 'svg', attributes: i, children: e }]
}
function WQ(t) {
  var e = t.prefix,
    n = t.iconName,
    r = t.children,
    i = t.attributes,
    s = t.symbol,
    o = s === !0 ? ''.concat(e, '-').concat(fe.cssPrefix, '-').concat(n) : s
  return [
    {
      tag: 'svg',
      attributes: { style: 'display: none;' },
      children: [{ tag: 'symbol', attributes: oe(oe({}, i), {}, { id: o }), children: r }]
    }
  ]
}
function pb(t) {
  var e = t.icons,
    n = e.main,
    r = e.mask,
    i = t.prefix,
    s = t.iconName,
    o = t.transform,
    a = t.symbol,
    l = t.title,
    c = t.maskId,
    u = t.titleId,
    h = t.extra,
    d = t.watchable,
    f = d === void 0 ? !1 : d,
    p = r.found ? r : n,
    m = p.width,
    g = p.height,
    _ = i === 'fak',
    v = [fe.replacementClass, s ? ''.concat(fe.cssPrefix, '-').concat(s) : '']
      .filter(function (k) {
        return h.classes.indexOf(k) === -1
      })
      .filter(function (k) {
        return k !== '' || !!k
      })
      .concat(h.classes)
      .join(' '),
    T = {
      children: [],
      attributes: oe(
        oe({}, h.attributes),
        {},
        {
          'data-prefix': i,
          'data-icon': s,
          class: v,
          role: h.attributes.role || 'img',
          xmlns: 'http://www.w3.org/2000/svg',
          viewBox: '0 0 '.concat(m, ' ').concat(g)
        }
      )
    },
    S = _ && !~h.classes.indexOf('fa-fw') ? { width: ''.concat((m / g) * 16 * 0.0625, 'em') } : {}
  f && (T.attributes[ia] = ''),
    l &&
      (T.children.push({
        tag: 'title',
        attributes: { id: T.attributes['aria-labelledby'] || 'title-'.concat(u || Hu()) },
        children: [l]
      }),
      delete T.attributes.title)
  var I = oe(
      oe({}, T),
      {},
      {
        prefix: i,
        iconName: s,
        main: n,
        mask: r,
        maskId: c,
        transform: o,
        symbol: a,
        styles: oe(oe({}, S), h.styles)
      }
    ),
    w =
      r.found && n.found
        ? Yi('generateAbstractMask', I) || { children: [], attributes: {} }
        : Yi('generateAbstractIcon', I) || { children: [], attributes: {} },
    O = w.children,
    P = w.attributes
  return (I.children = O), (I.attributes = P), a ? WQ(I) : jQ(I)
}
function EI(t) {
  var e = t.content,
    n = t.width,
    r = t.height,
    i = t.transform,
    s = t.title,
    o = t.extra,
    a = t.watchable,
    l = a === void 0 ? !1 : a,
    c = oe(oe(oe({}, o.attributes), s ? { title: s } : {}), {}, { class: o.classes.join(' ') })
  l && (c[ia] = '')
  var u = oe({}, o.styles)
  ub(i) &&
    ((u.transform = TQ({ transform: i, startCentered: !0, width: n, height: r })),
    (u['-webkit-transform'] = u.transform))
  var h = Mm(u)
  h.length > 0 && (c.style = h)
  var d = []
  return (
    d.push({ tag: 'span', attributes: c, children: [e] }),
    s && d.push({ tag: 'span', attributes: { class: 'sr-only' }, children: [s] }),
    d
  )
}
function GQ(t) {
  var e = t.content,
    n = t.title,
    r = t.extra,
    i = oe(oe(oe({}, r.attributes), n ? { title: n } : {}), {}, { class: r.classes.join(' ') }),
    s = Mm(r.styles)
  s.length > 0 && (i.style = s)
  var o = []
  return (
    o.push({ tag: 'span', attributes: i, children: [e] }),
    n && o.push({ tag: 'span', attributes: { class: 'sr-only' }, children: [n] }),
    o
  )
}
var ly = Vr.styles
function dv(t) {
  var e = t[0],
    n = t[1],
    r = t.slice(4),
    i = ib(r, 1),
    s = i[0],
    o = null
  return (
    Array.isArray(s)
      ? (o = {
          tag: 'g',
          attributes: { class: ''.concat(fe.cssPrefix, '-').concat(ko.GROUP) },
          children: [
            {
              tag: 'path',
              attributes: {
                class: ''.concat(fe.cssPrefix, '-').concat(ko.SECONDARY),
                fill: 'currentColor',
                d: s[0]
              }
            },
            {
              tag: 'path',
              attributes: {
                class: ''.concat(fe.cssPrefix, '-').concat(ko.PRIMARY),
                fill: 'currentColor',
                d: s[1]
              }
            }
          ]
        })
      : (o = { tag: 'path', attributes: { fill: 'currentColor', d: s } }),
    { found: !0, width: e, height: n, icon: o }
  )
}
var qQ = { found: !1, width: 512, height: 512 }
function KQ(t, e) {
  !HM &&
    !fe.showMissingIcons &&
    t &&
    console.error('Icon with name "'.concat(t, '" and prefix "').concat(e, '" is missing.'))
}
function fv(t, e) {
  var n = e
  return (
    e === 'fa' && fe.styleDefault !== null && (e = qs()),
    new Promise(function (r, i) {
      if ((Yi('missingIconAbstract'), n === 'fa')) {
        var s = tP(t) || {}
        ;(t = s.iconName || t), (e = s.prefix || e)
      }
      if (t && e && ly[e] && ly[e][t]) {
        var o = ly[e][t]
        return r(dv(o))
      }
      KQ(t, e),
        r(
          oe(
            oe({}, qQ),
            {},
            { icon: fe.showMissingIcons && t ? Yi('missingIconAbstract') || {} : {} }
          )
        )
    })
  )
}
var TI = function () {},
  pv = fe.measurePerformance && cd && cd.mark && cd.measure ? cd : { mark: TI, measure: TI },
  wc = 'FA "6.5.1"',
  YQ = function (e) {
    return (
      pv.mark(''.concat(wc, ' ').concat(e, ' begins')),
      function () {
        return rP(e)
      }
    )
  },
  rP = function (e) {
    pv.mark(''.concat(wc, ' ').concat(e, ' ends')),
      pv.measure(
        ''.concat(wc, ' ').concat(e),
        ''.concat(wc, ' ').concat(e, ' begins'),
        ''.concat(wc, ' ').concat(e, ' ends')
      )
  },
  mb = { begin: YQ, end: rP },
  $d = function () {}
function wI(t) {
  var e = t.getAttribute ? t.getAttribute(ia) : null
  return typeof e == 'string'
}
function JQ(t) {
  var e = t.getAttribute ? t.getAttribute(ob) : null,
    n = t.getAttribute ? t.getAttribute(ab) : null
  return e && n
}
function QQ(t) {
  return t && t.classList && t.classList.contains && t.classList.contains(fe.replacementClass)
}
function XQ() {
  if (fe.autoReplaceSvg === !0) return Hd.replace
  var t = Hd[fe.autoReplaceSvg]
  return t || Hd.replace
}
function ZQ(t) {
  return Et.createElementNS('http://www.w3.org/2000/svg', t)
}
function eX(t) {
  return Et.createElement(t)
}
function iP(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = e.ceFn,
    r = n === void 0 ? (t.tag === 'svg' ? ZQ : eX) : n
  if (typeof t == 'string') return Et.createTextNode(t)
  var i = r(t.tag)
  Object.keys(t.attributes || []).forEach(function (o) {
    i.setAttribute(o, t.attributes[o])
  })
  var s = t.children || []
  return (
    s.forEach(function (o) {
      i.appendChild(iP(o, { ceFn: r }))
    }),
    i
  )
}
function tX(t) {
  var e = ' '.concat(t.outerHTML, ' ')
  return (e = ''.concat(e, 'Font Awesome fontawesome.com ')), e
}
var Hd = {
  replace: function (e) {
    var n = e[0]
    if (n.parentNode)
      if (
        (e[1].forEach(function (i) {
          n.parentNode.insertBefore(iP(i), n)
        }),
        n.getAttribute(ia) === null && fe.keepOriginalSource)
      ) {
        var r = Et.createComment(tX(n))
        n.parentNode.replaceChild(r, n)
      } else n.remove()
  },
  nest: function (e) {
    var n = e[0],
      r = e[1]
    if (~cb(n).indexOf(fe.replacementClass)) return Hd.replace(e)
    var i = new RegExp(''.concat(fe.cssPrefix, '-.*'))
    if ((delete r[0].attributes.id, r[0].attributes.class)) {
      var s = r[0].attributes.class.split(' ').reduce(
        function (a, l) {
          return l === fe.replacementClass || l.match(i) ? a.toSvg.push(l) : a.toNode.push(l), a
        },
        { toNode: [], toSvg: [] }
      )
      ;(r[0].attributes.class = s.toSvg.join(' ')),
        s.toNode.length === 0
          ? n.removeAttribute('class')
          : n.setAttribute('class', s.toNode.join(' '))
    }
    var o = r.map(function (a) {
      return Oh(a)
    }).join(`
`)
    n.setAttribute(ia, ''), (n.innerHTML = o)
  }
}
function SI(t) {
  t()
}
function sP(t, e) {
  var n = typeof e == 'function' ? e : $d
  if (t.length === 0) n()
  else {
    var r = SI
    fe.mutateApproach === sQ && (r = Gs.requestAnimationFrame || SI),
      r(function () {
        var i = XQ(),
          s = mb.begin('mutate')
        t.map(i), s(), n()
      })
  }
}
var gb = !1
function oP() {
  gb = !0
}
function mv() {
  gb = !1
}
var sp = null
function II(t) {
  if (pI && fe.observeMutations) {
    var e = t.treeCallback,
      n = e === void 0 ? $d : e,
      r = t.nodeCallback,
      i = r === void 0 ? $d : r,
      s = t.pseudoElementsCallback,
      o = s === void 0 ? $d : s,
      a = t.observeMutationsRoot,
      l = a === void 0 ? Et : a
    ;(sp = new pI(function (c) {
      if (!gb) {
        var u = qs()
        Kl(c).forEach(function (h) {
          if (
            (h.type === 'childList' &&
              h.addedNodes.length > 0 &&
              !wI(h.addedNodes[0]) &&
              (fe.searchPseudoElements && o(h.target), n(h.target)),
            h.type === 'attributes' &&
              h.target.parentNode &&
              fe.searchPseudoElements &&
              o(h.target.parentNode),
            h.type === 'attributes' && wI(h.target) && ~dQ.indexOf(h.attributeName))
          )
            if (h.attributeName === 'class' && JQ(h.target)) {
              var d = xm(cb(h.target)),
                f = d.prefix,
                p = d.iconName
              h.target.setAttribute(ob, f || u), p && h.target.setAttribute(ab, p)
            } else QQ(h.target) && i(h.target)
        })
      }
    })),
      Zi && sp.observe(l, { childList: !0, attributes: !0, characterData: !0, subtree: !0 })
  }
}
function nX() {
  sp && sp.disconnect()
}
function rX(t) {
  var e = t.getAttribute('style'),
    n = []
  return (
    e &&
      (n = e.split(';').reduce(function (r, i) {
        var s = i.split(':'),
          o = s[0],
          a = s.slice(1)
        return o && a.length > 0 && (r[o] = a.join(':').trim()), r
      }, {})),
    n
  )
}
function iX(t) {
  var e = t.getAttribute('data-prefix'),
    n = t.getAttribute('data-icon'),
    r = t.innerText !== void 0 ? t.innerText.trim() : '',
    i = xm(cb(t))
  return (
    i.prefix || (i.prefix = qs()),
    e && n && ((i.prefix = e), (i.iconName = n)),
    (i.iconName && i.prefix) ||
      (i.prefix &&
        r.length > 0 &&
        (i.iconName = DQ(i.prefix, t.innerText) || db(i.prefix, lv(t.innerText))),
      !i.iconName &&
        fe.autoFetchSvg &&
        t.firstChild &&
        t.firstChild.nodeType === Node.TEXT_NODE &&
        (i.iconName = t.firstChild.data)),
    i
  )
}
function sX(t) {
  var e = Kl(t.attributes).reduce(function (i, s) {
      return i.name !== 'class' && i.name !== 'style' && (i[s.name] = s.value), i
    }, {}),
    n = t.getAttribute('title'),
    r = t.getAttribute('data-fa-title-id')
  return (
    fe.autoA11y &&
      (n
        ? (e['aria-labelledby'] = ''.concat(fe.replacementClass, '-title-').concat(r || Hu()))
        : ((e['aria-hidden'] = 'true'), (e.focusable = 'false'))),
    e
  )
}
function oX() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: ai,
    symbol: !1,
    mask: { iconName: null, prefix: null, rest: [] },
    maskId: null,
    extra: { classes: [], styles: {}, attributes: {} }
  }
}
function AI(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { styleParser: !0 },
    n = iX(t),
    r = n.iconName,
    i = n.prefix,
    s = n.rest,
    o = sX(t),
    a = uv('parseNodeAttributes', {}, t),
    l = e.styleParser ? rX(t) : []
  return oe(
    {
      iconName: r,
      title: t.getAttribute('title'),
      titleId: t.getAttribute('data-fa-title-id'),
      prefix: i,
      transform: ai,
      mask: { iconName: null, prefix: null, rest: [] },
      maskId: null,
      symbol: !1,
      extra: { classes: s, styles: l, attributes: o }
    },
    a
  )
}
var aX = Vr.styles
function aP(t) {
  var e = fe.autoReplaceSvg === 'nest' ? AI(t, { styleParser: !1 }) : AI(t)
  return ~e.extra.classes.indexOf(zM)
    ? Yi('generateLayersText', t, e)
    : Yi('generateSvgReplacementMutation', t, e)
}
var Ks = new Set()
lb.map(function (t) {
  Ks.add('fa-'.concat(t))
})
Object.keys(Fu[vt]).map(Ks.add.bind(Ks))
Object.keys(Fu[Nt]).map(Ks.add.bind(Ks))
Ks = Rh(Ks)
function CI(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null
  if (!Zi) return Promise.resolve()
  var n = Et.documentElement.classList,
    r = function (h) {
      return n.add(''.concat(mI, '-').concat(h))
    },
    i = function (h) {
      return n.remove(''.concat(mI, '-').concat(h))
    },
    s = fe.autoFetchSvg
      ? Ks
      : lb
          .map(function (u) {
            return 'fa-'.concat(u)
          })
          .concat(Object.keys(aX))
  s.includes('fa') || s.push('fa')
  var o = ['.'.concat(zM, ':not([').concat(ia, '])')]
    .concat(
      s.map(function (u) {
        return '.'.concat(u, ':not([').concat(ia, '])')
      })
    )
    .join(', ')
  if (o.length === 0) return Promise.resolve()
  var a = []
  try {
    a = Kl(t.querySelectorAll(o))
  } catch {}
  if (a.length > 0) r('pending'), i('complete')
  else return Promise.resolve()
  var l = mb.begin('onTree'),
    c = a.reduce(function (u, h) {
      try {
        var d = aP(h)
        d && u.push(d)
      } catch (f) {
        HM || (f.name === 'MissingIcon' && console.error(f))
      }
      return u
    }, [])
  return new Promise(function (u, h) {
    Promise.all(c)
      .then(function (d) {
        sP(d, function () {
          r('active'), r('complete'), i('pending'), typeof e == 'function' && e(), l(), u()
        })
      })
      .catch(function (d) {
        l(), h(d)
      })
  })
}
function lX(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null
  aP(t).then(function (n) {
    n && sP([n], e)
  })
}
function cX(t) {
  return function (e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      r = (e || {}).icon ? e : hv(e || {}),
      i = n.mask
    return i && (i = (i || {}).icon ? i : hv(i || {})), t(r, oe(oe({}, n), {}, { mask: i }))
  }
}
var uX = function (e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      r = n.transform,
      i = r === void 0 ? ai : r,
      s = n.symbol,
      o = s === void 0 ? !1 : s,
      a = n.mask,
      l = a === void 0 ? null : a,
      c = n.maskId,
      u = c === void 0 ? null : c,
      h = n.title,
      d = h === void 0 ? null : h,
      f = n.titleId,
      p = f === void 0 ? null : f,
      m = n.classes,
      g = m === void 0 ? [] : m,
      _ = n.attributes,
      v = _ === void 0 ? {} : _,
      T = n.styles,
      S = T === void 0 ? {} : T
    if (e) {
      var I = e.prefix,
        w = e.iconName,
        O = e.icon
      return Dm(oe({ type: 'icon' }, e), function () {
        return (
          sa('beforeDOMElementCreation', { iconDefinition: e, params: n }),
          fe.autoA11y &&
            (d
              ? (v['aria-labelledby'] = ''.concat(fe.replacementClass, '-title-').concat(p || Hu()))
              : ((v['aria-hidden'] = 'true'), (v.focusable = 'false'))),
          pb({
            icons: {
              main: dv(O),
              mask: l ? dv(l.icon) : { found: !1, width: null, height: null, icon: {} }
            },
            prefix: I,
            iconName: w,
            transform: oe(oe({}, ai), i),
            symbol: o,
            title: d,
            maskId: u,
            titleId: p,
            extra: { attributes: v, styles: S, classes: g }
          })
        )
      })
    }
  },
  hX = {
    mixout: function () {
      return { icon: cX(uX) }
    },
    hooks: function () {
      return {
        mutationObserverCallbacks: function (n) {
          return (n.treeCallback = CI), (n.nodeCallback = lX), n
        }
      }
    },
    provides: function (e) {
      ;(e.i2svg = function (n) {
        var r = n.node,
          i = r === void 0 ? Et : r,
          s = n.callback,
          o = s === void 0 ? function () {} : s
        return CI(i, o)
      }),
        (e.generateSvgReplacementMutation = function (n, r) {
          var i = r.iconName,
            s = r.title,
            o = r.titleId,
            a = r.prefix,
            l = r.transform,
            c = r.symbol,
            u = r.mask,
            h = r.maskId,
            d = r.extra
          return new Promise(function (f, p) {
            Promise.all([
              fv(i, a),
              u.iconName
                ? fv(u.iconName, u.prefix)
                : Promise.resolve({ found: !1, width: 512, height: 512, icon: {} })
            ])
              .then(function (m) {
                var g = ib(m, 2),
                  _ = g[0],
                  v = g[1]
                f([
                  n,
                  pb({
                    icons: { main: _, mask: v },
                    prefix: a,
                    iconName: i,
                    transform: l,
                    symbol: c,
                    maskId: h,
                    title: s,
                    titleId: o,
                    extra: d,
                    watchable: !0
                  })
                ])
              })
              .catch(p)
          })
        }),
        (e.generateAbstractIcon = function (n) {
          var r = n.children,
            i = n.attributes,
            s = n.main,
            o = n.transform,
            a = n.styles,
            l = Mm(a)
          l.length > 0 && (i.style = l)
          var c
          return (
            ub(o) &&
              (c = Yi('generateAbstractTransformGrouping', {
                main: s,
                transform: o,
                containerWidth: s.width,
                iconWidth: s.width
              })),
            r.push(c || s.icon),
            { children: r, attributes: i }
          )
        })
    }
  },
  dX = {
    mixout: function () {
      return {
        layer: function (n) {
          var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            i = r.classes,
            s = i === void 0 ? [] : i
          return Dm({ type: 'layer' }, function () {
            sa('beforeDOMElementCreation', { assembler: n, params: r })
            var o = []
            return (
              n(function (a) {
                Array.isArray(a)
                  ? a.map(function (l) {
                      o = o.concat(l.abstract)
                    })
                  : (o = o.concat(a.abstract))
              }),
              [
                {
                  tag: 'span',
                  attributes: {
                    class: [''.concat(fe.cssPrefix, '-layers')].concat(Rh(s)).join(' ')
                  },
                  children: o
                }
              ]
            )
          })
        }
      }
    }
  },
  fX = {
    mixout: function () {
      return {
        counter: function (n) {
          var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            i = r.title,
            s = i === void 0 ? null : i,
            o = r.classes,
            a = o === void 0 ? [] : o,
            l = r.attributes,
            c = l === void 0 ? {} : l,
            u = r.styles,
            h = u === void 0 ? {} : u
          return Dm({ type: 'counter', content: n }, function () {
            return (
              sa('beforeDOMElementCreation', { content: n, params: r }),
              GQ({
                content: n.toString(),
                title: s,
                extra: {
                  attributes: c,
                  styles: h,
                  classes: [''.concat(fe.cssPrefix, '-layers-counter')].concat(Rh(a))
                }
              })
            )
          })
        }
      }
    }
  },
  pX = {
    mixout: function () {
      return {
        text: function (n) {
          var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            i = r.transform,
            s = i === void 0 ? ai : i,
            o = r.title,
            a = o === void 0 ? null : o,
            l = r.classes,
            c = l === void 0 ? [] : l,
            u = r.attributes,
            h = u === void 0 ? {} : u,
            d = r.styles,
            f = d === void 0 ? {} : d
          return Dm({ type: 'text', content: n }, function () {
            return (
              sa('beforeDOMElementCreation', { content: n, params: r }),
              EI({
                content: n,
                transform: oe(oe({}, ai), s),
                title: a,
                extra: {
                  attributes: h,
                  styles: f,
                  classes: [''.concat(fe.cssPrefix, '-layers-text')].concat(Rh(c))
                }
              })
            )
          })
        }
      }
    },
    provides: function (e) {
      e.generateLayersText = function (n, r) {
        var i = r.title,
          s = r.transform,
          o = r.extra,
          a = null,
          l = null
        if (BM) {
          var c = parseInt(getComputedStyle(n).fontSize, 10),
            u = n.getBoundingClientRect()
          ;(a = u.width / c), (l = u.height / c)
        }
        return (
          fe.autoA11y && !i && (o.attributes['aria-hidden'] = 'true'),
          Promise.resolve([
            n,
            EI({
              content: n.innerHTML,
              width: a,
              height: l,
              transform: s,
              title: i,
              extra: o,
              watchable: !0
            })
          ])
        )
      }
    }
  },
  mX = new RegExp('"', 'ug'),
  RI = [1105920, 1112319]
function gX(t) {
  var e = t.replace(mX, ''),
    n = kQ(e, 0),
    r = n >= RI[0] && n <= RI[1],
    i = e.length === 2 ? e[0] === e[1] : !1
  return { value: lv(i ? e[0] : e), isSecondary: r || i }
}
function kI(t, e) {
  var n = ''.concat(iQ).concat(e.replace(':', '-'))
  return new Promise(function (r, i) {
    if (t.getAttribute(n) !== null) return r()
    var s = Kl(t.children),
      o = s.filter(function (O) {
        return O.getAttribute(av) === e
      })[0],
      a = Gs.getComputedStyle(t, e),
      l = a.getPropertyValue('font-family').match(cQ),
      c = a.getPropertyValue('font-weight'),
      u = a.getPropertyValue('content')
    if (o && !l) return t.removeChild(o), r()
    if (l && u !== 'none' && u !== '') {
      var h = a.getPropertyValue('content'),
        d = ~['Sharp'].indexOf(l[2]) ? Nt : vt,
        f = ~['Solid', 'Regular', 'Light', 'Thin', 'Duotone', 'Brands', 'Kit'].indexOf(l[2])
          ? Bu[d][l[2].toLowerCase()]
          : uQ[d][c],
        p = gX(h),
        m = p.value,
        g = p.isSecondary,
        _ = l[0].startsWith('FontAwesome'),
        v = db(f, m),
        T = v
      if (_) {
        var S = LQ(m)
        S.iconName && S.prefix && ((v = S.iconName), (f = S.prefix))
      }
      if (v && !g && (!o || o.getAttribute(ob) !== f || o.getAttribute(ab) !== T)) {
        t.setAttribute(n, T), o && t.removeChild(o)
        var I = oX(),
          w = I.extra
        ;(w.attributes[av] = e),
          fv(v, f)
            .then(function (O) {
              var P = pb(
                  oe(
                    oe({}, I),
                    {},
                    {
                      icons: { main: O, mask: fb() },
                      prefix: f,
                      iconName: T,
                      extra: w,
                      watchable: !0
                    }
                  )
                ),
                k = Et.createElementNS('http://www.w3.org/2000/svg', 'svg')
              e === '::before' ? t.insertBefore(k, t.firstChild) : t.appendChild(k),
                (k.outerHTML = P.map(function (U) {
                  return Oh(U)
                }).join(`
`)),
                t.removeAttribute(n),
                r()
            })
            .catch(i)
      } else r()
    } else r()
  })
}
function yX(t) {
  return Promise.all([kI(t, '::before'), kI(t, '::after')])
}
function _X(t) {
  return (
    t.parentNode !== document.head &&
    !~oQ.indexOf(t.tagName.toUpperCase()) &&
    !t.getAttribute(av) &&
    (!t.parentNode || t.parentNode.tagName !== 'svg')
  )
}
function OI(t) {
  if (Zi)
    return new Promise(function (e, n) {
      var r = Kl(t.querySelectorAll('*')).filter(_X).map(yX),
        i = mb.begin('searchPseudoElements')
      oP(),
        Promise.all(r)
          .then(function () {
            i(), mv(), e()
          })
          .catch(function () {
            i(), mv(), n()
          })
    })
}
var vX = {
    hooks: function () {
      return {
        mutationObserverCallbacks: function (n) {
          return (n.pseudoElementsCallback = OI), n
        }
      }
    },
    provides: function (e) {
      e.pseudoElements2svg = function (n) {
        var r = n.node,
          i = r === void 0 ? Et : r
        fe.searchPseudoElements && OI(i)
      }
    }
  },
  NI = !1,
  bX = {
    mixout: function () {
      return {
        dom: {
          unwatch: function () {
            oP(), (NI = !0)
          }
        }
      }
    },
    hooks: function () {
      return {
        bootstrap: function () {
          II(uv('mutationObserverCallbacks', {}))
        },
        noAuto: function () {
          nX()
        },
        watch: function (n) {
          var r = n.observeMutationsRoot
          NI ? mv() : II(uv('mutationObserverCallbacks', { observeMutationsRoot: r }))
        }
      }
    }
  },
  MI = function (e) {
    var n = { size: 16, x: 0, y: 0, flipX: !1, flipY: !1, rotate: 0 }
    return e
      .toLowerCase()
      .split(' ')
      .reduce(function (r, i) {
        var s = i.toLowerCase().split('-'),
          o = s[0],
          a = s.slice(1).join('-')
        if (o && a === 'h') return (r.flipX = !0), r
        if (o && a === 'v') return (r.flipY = !0), r
        if (((a = parseFloat(a)), isNaN(a))) return r
        switch (o) {
          case 'grow':
            r.size = r.size + a
            break
          case 'shrink':
            r.size = r.size - a
            break
          case 'left':
            r.x = r.x - a
            break
          case 'right':
            r.x = r.x + a
            break
          case 'up':
            r.y = r.y - a
            break
          case 'down':
            r.y = r.y + a
            break
          case 'rotate':
            r.rotate = r.rotate + a
            break
        }
        return r
      }, n)
  },
  EX = {
    mixout: function () {
      return {
        parse: {
          transform: function (n) {
            return MI(n)
          }
        }
      }
    },
    hooks: function () {
      return {
        parseNodeAttributes: function (n, r) {
          var i = r.getAttribute('data-fa-transform')
          return i && (n.transform = MI(i)), n
        }
      }
    },
    provides: function (e) {
      e.generateAbstractTransformGrouping = function (n) {
        var r = n.main,
          i = n.transform,
          s = n.containerWidth,
          o = n.iconWidth,
          a = { transform: 'translate('.concat(s / 2, ' 256)') },
          l = 'translate('.concat(i.x * 32, ', ').concat(i.y * 32, ') '),
          c = 'scale('
            .concat((i.size / 16) * (i.flipX ? -1 : 1), ', ')
            .concat((i.size / 16) * (i.flipY ? -1 : 1), ') '),
          u = 'rotate('.concat(i.rotate, ' 0 0)'),
          h = { transform: ''.concat(l, ' ').concat(c, ' ').concat(u) },
          d = { transform: 'translate('.concat((o / 2) * -1, ' -256)') },
          f = { outer: a, inner: h, path: d }
        return {
          tag: 'g',
          attributes: oe({}, f.outer),
          children: [
            {
              tag: 'g',
              attributes: oe({}, f.inner),
              children: [
                {
                  tag: r.icon.tag,
                  children: r.icon.children,
                  attributes: oe(oe({}, r.icon.attributes), f.path)
                }
              ]
            }
          ]
        }
      }
    }
  },
  cy = { x: 0, y: 0, width: '100%', height: '100%' }
function PI(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
  return t.attributes && (t.attributes.fill || e) && (t.attributes.fill = 'black'), t
}
function TX(t) {
  return t.tag === 'g' ? t.children : [t]
}
var wX = {
    hooks: function () {
      return {
        parseNodeAttributes: function (n, r) {
          var i = r.getAttribute('data-fa-mask'),
            s = i
              ? xm(
                  i.split(' ').map(function (o) {
                    return o.trim()
                  })
                )
              : fb()
          return (
            s.prefix || (s.prefix = qs()),
            (n.mask = s),
            (n.maskId = r.getAttribute('data-fa-mask-id')),
            n
          )
        }
      }
    },
    provides: function (e) {
      e.generateAbstractMask = function (n) {
        var r = n.children,
          i = n.attributes,
          s = n.main,
          o = n.mask,
          a = n.maskId,
          l = n.transform,
          c = s.width,
          u = s.icon,
          h = o.width,
          d = o.icon,
          f = EQ({ transform: l, containerWidth: h, iconWidth: c }),
          p = { tag: 'rect', attributes: oe(oe({}, cy), {}, { fill: 'white' }) },
          m = u.children ? { children: u.children.map(PI) } : {},
          g = {
            tag: 'g',
            attributes: oe({}, f.inner),
            children: [PI(oe({ tag: u.tag, attributes: oe(oe({}, u.attributes), f.path) }, m))]
          },
          _ = { tag: 'g', attributes: oe({}, f.outer), children: [g] },
          v = 'mask-'.concat(a || Hu()),
          T = 'clip-'.concat(a || Hu()),
          S = {
            tag: 'mask',
            attributes: oe(
              oe({}, cy),
              {},
              { id: v, maskUnits: 'userSpaceOnUse', maskContentUnits: 'userSpaceOnUse' }
            ),
            children: [p, _]
          },
          I = {
            tag: 'defs',
            children: [{ tag: 'clipPath', attributes: { id: T }, children: TX(d) }, S]
          }
        return (
          r.push(I, {
            tag: 'rect',
            attributes: oe(
              {
                fill: 'currentColor',
                'clip-path': 'url(#'.concat(T, ')'),
                mask: 'url(#'.concat(v, ')')
              },
              cy
            )
          }),
          { children: r, attributes: i }
        )
      }
    }
  },
  SX = {
    provides: function (e) {
      var n = !1
      Gs.matchMedia && (n = Gs.matchMedia('(prefers-reduced-motion: reduce)').matches),
        (e.missingIconAbstract = function () {
          var r = [],
            i = { fill: 'currentColor' },
            s = { attributeType: 'XML', repeatCount: 'indefinite', dur: '2s' }
          r.push({
            tag: 'path',
            attributes: oe(
              oe({}, i),
              {},
              {
                d: 'M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z'
              }
            )
          })
          var o = oe(oe({}, s), {}, { attributeName: 'opacity' }),
            a = {
              tag: 'circle',
              attributes: oe(oe({}, i), {}, { cx: '256', cy: '364', r: '28' }),
              children: []
            }
          return (
            n ||
              a.children.push(
                {
                  tag: 'animate',
                  attributes: oe(
                    oe({}, s),
                    {},
                    { attributeName: 'r', values: '28;14;28;28;14;28;' }
                  )
                },
                { tag: 'animate', attributes: oe(oe({}, o), {}, { values: '1;0;1;1;0;1;' }) }
              ),
            r.push(a),
            r.push({
              tag: 'path',
              attributes: oe(
                oe({}, i),
                {},
                {
                  opacity: '1',
                  d: 'M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z'
                }
              ),
              children: n
                ? []
                : [{ tag: 'animate', attributes: oe(oe({}, o), {}, { values: '1;0;0;0;0;1;' }) }]
            }),
            n ||
              r.push({
                tag: 'path',
                attributes: oe(
                  oe({}, i),
                  {},
                  {
                    opacity: '0',
                    d: 'M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z'
                  }
                ),
                children: [
                  { tag: 'animate', attributes: oe(oe({}, o), {}, { values: '0;0;1;1;0;0;' }) }
                ]
              }),
            { tag: 'g', attributes: { class: 'missing' }, children: r }
          )
        })
    }
  },
  IX = {
    hooks: function () {
      return {
        parseNodeAttributes: function (n, r) {
          var i = r.getAttribute('data-fa-symbol'),
            s = i === null ? !1 : i === '' ? !0 : i
          return (n.symbol = s), n
        }
      }
    }
  },
  AX = [SQ, hX, dX, fX, pX, vX, bX, EX, wX, SX, IX]
BQ(AX, { mixoutsTo: pr })
pr.noAuto
pr.config
var We = pr.library
pr.dom
var gv = pr.parse
pr.findIconDefinition
pr.toHtml
var CX = pr.icon
pr.layer
pr.text
pr.counter
var RX = {
    prefix: 'fas',
    iconName: 'right-from-bracket',
    icon: [
      512,
      512,
      ['sign-out-alt'],
      'f2f5',
      'M377.9 105.9L500.7 228.7c7.2 7.2 11.3 17.1 11.3 27.3s-4.1 20.1-11.3 27.3L377.9 406.1c-6.4 6.4-15 9.9-24 9.9c-18.7 0-33.9-15.2-33.9-33.9l0-62.1-128 0c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32l128 0 0-62.1c0-18.7 15.2-33.9 33.9-33.9c9 0 17.6 3.6 24 9.9zM160 96L96 96c-17.7 0-32 14.3-32 32l0 256c0 17.7 14.3 32 32 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-64 0c-53 0-96-43-96-96L0 128C0 75 43 32 96 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32z'
    ]
  },
  kX = {
    prefix: 'fas',
    iconName: 'users-rectangle',
    icon: [
      640,
      512,
      [],
      'e594',
      'M96 0C43 0 0 43 0 96V416c0 53 43 96 96 96H544c53 0 96-43 96-96V96c0-53-43-96-96-96H96zM64 96c0-17.7 14.3-32 32-32H544c17.7 0 32 14.3 32 32V416c0 17.7-14.3 32-32 32H96c-17.7 0-32-14.3-32-32V96zm159.8 80a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM96 309.3c0 14.7 11.9 26.7 26.7 26.7h56.1c8-34.1 32.8-61.7 65.2-73.6c-7.5-4.1-16.2-6.4-25.3-6.4H149.3C119.9 256 96 279.9 96 309.3zM461.2 336h56.1c14.7 0 26.7-11.9 26.7-26.7c0-29.5-23.9-53.3-53.3-53.3H421.3c-9.2 0-17.8 2.3-25.3 6.4c32.4 11.9 57.2 39.5 65.2 73.6zM372 289c-3.9-.7-7.9-1-12-1H280c-4.1 0-8.1 .3-12 1c-26 4.4-47.3 22.7-55.9 47c-2.7 7.5-4.1 15.6-4.1 24c0 13.3 10.7 24 24 24H408c13.3 0 24-10.7 24-24c0-8.4-1.4-16.5-4.1-24c-8.6-24.3-29.9-42.6-55.9-47zM512 176a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM320 256a64 64 0 1 0 0-128 64 64 0 1 0 0 128z'
    ]
  },
  OX = {
    prefix: 'fas',
    iconName: 'spaghetti-monster-flying',
    icon: [
      640,
      512,
      ['pastafarianism'],
      'f67b',
      'M208 64a16 16 0 1 0 -32 0 16 16 0 1 0 32 0zm48 0c0 16.2-6 31.1-16 42.3l15.6 31.2c18.7-6 39.9-9.5 64.4-9.5s45.8 3.5 64.4 9.5L400 106.3C390 95.1 384 80.2 384 64c0-35.3 28.7-64 64-64s64 28.7 64 64s-28.7 64-64 64c-1.7 0-3.4-.1-5.1-.2L427.8 158c21.1 13.6 37.7 30.2 51.4 46.4c7.1 8.3 13.5 16.6 19.3 24l1.4 1.8c6.3 8.1 11.6 14.8 16.7 20.4C527.3 262.3 532.7 264 536 264c2.5 0 4.3-.6 7.1-3.3c3.7-3.5 7.1-8.8 12.5-17.4l.6-.9c4.6-7.4 11-17.6 19.4-25.7c9.7-9.3 22.9-16.7 40.4-16.7c13.3 0 24 10.7 24 24s-10.7 24-24 24c-2.5 0-4.3 .6-7.1 3.3c-3.7 3.5-7.1 8.8-12.5 17.4l-.6 .9c-4.6 7.4-11 17.6-19.4 25.7c-9.7 9.3-22.9 16.7-40.4 16.7c-18.5 0-32.9-8.5-44.3-18.6c-3.1 4-6.6 8.3-10.5 12.7c1.4 4.3 2.8 8.5 4 12.5c.9 3 1.8 5.8 2.6 8.6c3 9.8 5.5 18.2 8.6 25.9c3.9 9.8 7.4 15.4 10.8 18.5c2.6 2.4 5.9 4.3 12.8 4.3c8.7 0 16.9-4.2 33.7-13.2c15-8 35.7-18.8 62.3-18.8c13.3 0 24 10.7 24 24s-10.7 24-24 24c-13.4 0-24.7 5.2-39.7 13.2c-1 .6-2.1 1.1-3.2 1.7C559.9 414 541.4 424 520 424c-18.4 0-33.6-6.1-45.5-17.2c-11.1-10.3-17.9-23.7-22.7-36c-3.6-9-6.7-19.1-9.5-28.5c-16.4 12.3-36.1 23.6-58.9 31.3c3.6 10.8 8.4 23.5 14.4 36.2c7.5 15.9 16.2 30.4 25.8 40.5C433 460.5 441.2 464 448 464c13.3 0 24 10.7 24 24s-10.7 24-24 24c-25.2 0-45-13.5-59.5-28.8c-14.5-15.4-25.7-34.9-34.2-53c-8-17-14.1-33.8-18.3-46.9c-5.2 .4-10.6 .6-16 .6s-10.8-.2-16-.6c-4.2 13-10.3 29.9-18.3 46.9c-8.5 18.1-19.8 37.6-34.2 53C237 498.5 217.2 512 192 512c-13.3 0-24-10.7-24-24s10.7-24 24-24c6.8 0 15-3.5 24.5-13.7c9.5-10.1 18.3-24.6 25.8-40.5c5.9-12.6 10.7-25.4 14.4-36.2c-22.8-7.7-42.5-19-58.9-31.3c-2.9 9.4-6 19.5-9.5 28.5c-4.8 12.2-11.6 25.6-22.7 36C153.6 417.9 138.4 424 120 424c-21.4 0-39.9-10-53.1-17.1l0 0c-1.1-.6-2.2-1.2-3.2-1.7c-15-8-26.3-13.2-39.7-13.2c-13.3 0-24-10.7-24-24s10.7-24 24-24c26.6 0 47.3 10.8 62.3 18.8c16.8 9 25 13.2 33.7 13.2c6.8 0 10.2-1.9 12.8-4.3c3.4-3.2 7-8.8 10.8-18.5c3-7.7 5.6-16.1 8.6-25.9c.8-2.7 1.7-5.6 2.6-8.6c1.2-4 2.6-8.2 4-12.5c-3.9-4.5-7.4-8.8-10.5-12.7C136.9 303.5 122.5 312 104 312c-17.5 0-30.7-7.4-40.4-16.7c-8.4-8.1-14.8-18.3-19.4-25.7l-.6-.9c-5.4-8.6-8.8-13.9-12.5-17.4c-2.8-2.7-4.6-3.3-7.1-3.3c-13.3 0-24-10.7-24-24s10.7-24 24-24c17.5 0 30.7 7.4 40.4 16.7c8.4 8.1 14.8 18.3 19.4 25.7l.6 .9c5.4 8.6 8.8 13.9 12.5 17.4c2.8 2.7 4.6 3.3 7.1 3.3c3.3 0 8.7-1.7 19.4-13.4c5.1-5.6 10.4-12.3 16.7-20.4l1.4-1.8c5.8-7.4 12.2-15.7 19.3-24c13.8-16.2 30.3-32.8 51.4-46.4l-15.1-30.2c-1.7 .1-3.4 .2-5.1 .2c-35.3 0-64-28.7-64-64s28.7-64 64-64s64 28.7 64 64zm208 0a16 16 0 1 0 -32 0 16 16 0 1 0 32 0z'
    ]
  },
  NX = {
    prefix: 'fas',
    iconName: 'spoon',
    icon: [
      512,
      512,
      [129348, 61873, 'utensil-spoon'],
      'f2e5',
      'M245.8 220.9c-14.5-17.6-21.8-39.2-21.8-60.8C224 80 320 0 416 0c53 0 96 43 96 96c0 96-80 192-160.2 192c-21.6 0-43.2-7.3-60.8-21.8L54.6 502.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L245.8 220.9z'
    ]
  },
  MX = {
    prefix: 'fas',
    iconName: 'caret-right',
    icon: [
      256,
      512,
      [],
      'f0da',
      'M246.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-9.2-9.2-22.9-11.9-34.9-6.9s-19.8 16.6-19.8 29.6l0 256c0 12.9 7.8 24.6 19.8 29.6s25.7 2.2 34.9-6.9l128-128z'
    ]
  },
  PX = {
    prefix: 'fas',
    iconName: 'paw',
    icon: [
      512,
      512,
      [],
      'f1b0',
      'M226.5 92.9c14.3 42.9-.3 86.2-32.6 96.8s-70.1-15.6-84.4-58.5s.3-86.2 32.6-96.8s70.1 15.6 84.4 58.5zM100.4 198.6c18.9 32.4 14.3 70.1-10.2 84.1s-59.7-.9-78.5-33.3S-2.7 179.3 21.8 165.3s59.7 .9 78.5 33.3zM69.2 401.2C121.6 259.9 214.7 224 256 224s134.4 35.9 186.8 177.2c3.6 9.7 5.2 20.1 5.2 30.5v1.6c0 25.8-20.9 46.7-46.7 46.7c-11.5 0-22.9-1.4-34-4.2l-88-22c-15.3-3.8-31.3-3.8-46.6 0l-88 22c-11.1 2.8-22.5 4.2-34 4.2C84.9 480 64 459.1 64 433.3v-1.6c0-10.4 1.6-20.8 5.2-30.5zM421.8 282.7c-24.5-14-29.1-51.7-10.2-84.1s54-47.3 78.5-33.3s29.1 51.7 10.2 84.1s-54 47.3-78.5 33.3zM310.1 189.7c-32.3-10.6-46.9-53.9-32.6-96.8s52.1-69.1 84.4-58.5s46.9 53.9 32.6 96.8s-52.1 69.1-84.4 58.5z'
    ]
  },
  xX = {
    prefix: 'fas',
    iconName: 'square-check',
    icon: [
      448,
      512,
      [9745, 9989, 61510, 'check-square'],
      'f14a',
      'M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zM337 209L209 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L303 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z'
    ]
  },
  DX = {
    prefix: 'fas',
    iconName: 'ghost',
    icon: [
      384,
      512,
      [128123],
      'f6e2',
      'M40.1 467.1l-11.2 9c-3.2 2.5-7.1 3.9-11.1 3.9C8 480 0 472 0 462.2V192C0 86 86 0 192 0S384 86 384 192V462.2c0 9.8-8 17.8-17.8 17.8c-4 0-7.9-1.4-11.1-3.9l-11.2-9c-13.4-10.7-32.8-9-44.1 3.9L269.3 506c-3.3 3.8-8.2 6-13.3 6s-9.9-2.2-13.3-6l-26.6-30.5c-12.7-14.6-35.4-14.6-48.2 0L141.3 506c-3.3 3.8-8.2 6-13.3 6s-9.9-2.2-13.3-6L84.2 471c-11.3-12.9-30.7-14.6-44.1-3.9zM160 192a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zm96 32a32 32 0 1 0 0-64 32 32 0 1 0 0 64z'
    ]
  },
  LX = {
    prefix: 'fas',
    iconName: 'tree',
    icon: [
      448,
      512,
      [127794],
      'f1bb',
      'M210.6 5.9L62 169.4c-3.9 4.2-6 9.8-6 15.5C56 197.7 66.3 208 79.1 208H104L30.6 281.4c-4.2 4.2-6.6 10-6.6 16C24 309.9 34.1 320 46.6 320H80L5.4 409.5C1.9 413.7 0 419 0 424.5c0 13 10.5 23.5 23.5 23.5H192v32c0 17.7 14.3 32 32 32s32-14.3 32-32V448H424.5c13 0 23.5-10.5 23.5-23.5c0-5.5-1.9-10.8-5.4-15L368 320h33.4c12.5 0 22.6-10.1 22.6-22.6c0-6-2.4-11.8-6.6-16L344 208h24.9c12.7 0 23.1-10.3 23.1-23.1c0-5.7-2.1-11.3-6-15.5L237.4 5.9C234 2.1 229.1 0 224 0s-10 2.1-13.4 5.9z'
    ]
  },
  VX = {
    prefix: 'fas',
    iconName: 'pen-to-square',
    icon: [
      512,
      512,
      ['edit'],
      'f044',
      'M471.6 21.7c-21.9-21.9-57.3-21.9-79.2 0L362.3 51.7l97.9 97.9 30.1-30.1c21.9-21.9 21.9-57.3 0-79.2L471.6 21.7zm-299.2 220c-6.1 6.1-10.8 13.6-13.5 21.9l-29.6 88.8c-2.9 8.6-.6 18.1 5.8 24.6s15.9 8.7 24.6 5.8l88.8-29.6c8.2-2.7 15.7-7.4 21.9-13.5L437.7 172.3 339.7 74.3 172.4 241.7zM96 64C43 64 0 107 0 160V416c0 53 43 96 96 96H352c53 0 96-43 96-96V320c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 17.7-14.3 32-32 32H96c-17.7 0-32-14.3-32-32V160c0-17.7 14.3-32 32-32h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H96z'
    ]
  },
  FX = {
    prefix: 'fas',
    iconName: 'shapes',
    icon: [
      512,
      512,
      ['triangle-circle-square'],
      'f61f',
      'M315.4 15.5C309.7 5.9 299.2 0 288 0s-21.7 5.9-27.4 15.5l-96 160c-5.9 9.9-6.1 22.2-.4 32.2s16.3 16.2 27.8 16.2H384c11.5 0 22.2-6.2 27.8-16.2s5.5-22.3-.4-32.2l-96-160zM288 312V456c0 22.1 17.9 40 40 40H472c22.1 0 40-17.9 40-40V312c0-22.1-17.9-40-40-40H328c-22.1 0-40 17.9-40 40zM128 512a128 128 0 1 0 0-256 128 128 0 1 0 0 256z'
    ]
  },
  BX = {
    prefix: 'fas',
    iconName: 'right-to-bracket',
    icon: [
      512,
      512,
      ['sign-in-alt'],
      'f2f6',
      'M217.9 105.9L340.7 228.7c7.2 7.2 11.3 17.1 11.3 27.3s-4.1 20.1-11.3 27.3L217.9 406.1c-6.4 6.4-15 9.9-24 9.9c-18.7 0-33.9-15.2-33.9-33.9l0-62.1L32 320c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32l128 0 0-62.1c0-18.7 15.2-33.9 33.9-33.9c9 0 17.6 3.6 24 9.9zM352 416l64 0c17.7 0 32-14.3 32-32l0-256c0-17.7-14.3-32-32-32l-64 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l64 0c53 0 96 43 96 96l0 256c0 53-43 96-96 96l-64 0c-17.7 0-32-14.3-32-32s14.3-32 32-32z'
    ]
  },
  UX = {
    prefix: 'fas',
    iconName: 'user-group',
    icon: [
      640,
      512,
      [128101, 'user-friends'],
      'f500',
      'M96 128a128 128 0 1 1 256 0A128 128 0 1 1 96 128zM0 482.3C0 383.8 79.8 304 178.3 304h91.4C368.2 304 448 383.8 448 482.3c0 16.4-13.3 29.7-29.7 29.7H29.7C13.3 512 0 498.7 0 482.3zM609.3 512H471.4c5.4-9.4 8.6-20.3 8.6-32v-8c0-60.7-27.1-115.2-69.8-151.8c2.4-.1 4.7-.2 7.1-.2h61.4C567.8 320 640 392.2 640 481.3c0 17-13.8 30.7-30.7 30.7zM432 256c-31 0-59-12.6-79.3-32.9C372.4 196.5 384 163.6 384 128c0-26.8-6.6-52.1-18.3-74.3C384.3 40.1 407.2 32 432 32c61.9 0 112 50.1 112 112s-50.1 112-112 112z'
    ]
  },
  $X = {
    prefix: 'fas',
    iconName: 'fire',
    icon: [
      448,
      512,
      [128293],
      'f06d',
      'M159.3 5.4c7.8-7.3 19.9-7.2 27.7 .1c27.6 25.9 53.5 53.8 77.7 84c11-14.4 23.5-30.1 37-42.9c7.9-7.4 20.1-7.4 28 .1c34.6 33 63.9 76.6 84.5 118c20.3 40.8 33.8 82.5 33.8 111.9C448 404.2 348.2 512 224 512C98.4 512 0 404.1 0 276.5c0-38.4 17.8-85.3 45.4-131.7C73.3 97.7 112.7 48.6 159.3 5.4zM225.7 416c25.3 0 47.7-7 68.8-21c42.1-29.4 53.4-88.2 28.1-134.4c-4.5-9-16-9.6-22.5-2l-25.2 29.3c-6.6 7.6-18.5 7.4-24.7-.5c-16.5-21-46-58.5-62.8-79.8c-6.3-8-18.3-8.1-24.7-.1c-33.8 42.5-50.8 69.3-50.8 99.4C112 375.4 162.6 416 225.7 416z'
    ]
  },
  HX = {
    prefix: 'fas',
    iconName: 'eye-low-vision',
    icon: [
      640,
      512,
      ['low-vision'],
      'f2a8',
      'M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223 149.5c48.6-44.3 123-50.8 179.3-11.7c60.8 42.4 78.9 123.2 44.2 186.9L408 294.5c8.4-19.3 10.6-41.4 4.8-63.3c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3c0 10.2-2.4 19.8-6.6 28.3L223 149.5zm-139.9 12c-11 14.4-20.5 28.7-28.4 42.2l339 265.7c18.7-5.5 36.2-13 52.6-21.8L83.1 161.5zm-50 86.3c-1.8 6.8-1.3 14 1.4 20.5c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c3.1 0 6.1-.1 9.2-.2L33.1 247.8z'
    ]
  },
  zX = {
    prefix: 'fas',
    iconName: 'crow',
    icon: [
      640,
      512,
      [],
      'f520',
      'M456 0c-48.6 0-88 39.4-88 88v29.2L12.5 390.6c-14 10.8-16.6 30.9-5.9 44.9s30.9 16.6 44.9 5.9L126.1 384H259.2l46.6 113.1c5 12.3 19.1 18.1 31.3 13.1s18.1-19.1 13.1-31.3L311.1 384H352c1.1 0 2.1 0 3.2 0l46.6 113.2c5 12.3 19.1 18.1 31.3 13.1s18.1-19.1 13.1-31.3l-42-102C484.9 354.1 544 280 544 192V128v-8l80.5-20.1c8.6-2.1 13.8-10.8 11.6-19.4C629 52 603.4 32 574 32H523.9C507.7 12.5 483.3 0 456 0zm0 64a24 24 0 1 1 0 48 24 24 0 1 1 0-48z'
    ]
  },
  jX = {
    prefix: 'fas',
    iconName: 'frog',
    icon: [
      576,
      512,
      [],
      'f52e',
      'M368 32c41.7 0 75.9 31.8 79.7 72.5l85.6 26.3c25.4 7.8 42.8 31.3 42.8 57.9c0 21.8-11.7 41.9-30.7 52.7L400.8 323.5 493.3 416H544c17.7 0 32 14.3 32 32s-14.3 32-32 32H480c-8.5 0-16.6-3.4-22.6-9.4L346.9 360.2c11.7-36 3.2-77.1-25.4-105.7c-40.6-40.6-106.3-40.6-146.9-.1L101 324.4c-6.4 6.1-6.7 16.2-.6 22.6s16.2 6.6 22.6 .6l73.8-70.2 .1-.1 .1-.1c3.5-3.5 7.3-6.6 11.3-9.2c27.9-18.5 65.9-15.4 90.5 9.2c24.7 24.7 27.7 62.9 9 90.9c-2.6 3.8-5.6 7.5-9 10.9L261.8 416H352c17.7 0 32 14.3 32 32s-14.3 32-32 32H64c-35.3 0-64-28.7-64-64C0 249.6 127 112.9 289.3 97.5C296.2 60.2 328.8 32 368 32zm0 104a24 24 0 1 0 0-48 24 24 0 1 0 0 48z'
    ]
  },
  WX = {
    prefix: 'fas',
    iconName: 'feather-pointed',
    icon: [
      512,
      512,
      ['feather-alt'],
      'f56b',
      'M278.5 215.6L23 471c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l74.8-74.8c7.4 4.6 15.3 8.2 23.8 10.5C200.3 452.8 270 454.5 338 409.4c12.2-8.1 5.8-25.4-8.8-25.4l-16.1 0c-5.1 0-9.2-4.1-9.2-9.2c0-4.1 2.7-7.6 6.5-8.8l97.7-29.3c3.4-1 6.4-3.1 8.4-6.1c4.4-6.4 8.6-12.9 12.6-19.6c6.2-10.3-1.5-23-13.5-23l-38.6 0c-5.1 0-9.2-4.1-9.2-9.2c0-4.1 2.7-7.6 6.5-8.8l80.9-24.3c4.6-1.4 8.4-4.8 10.2-9.3C494.5 163 507.8 86.1 511.9 36.8c.8-9.9-3-19.6-10-26.6s-16.7-10.8-26.6-10C391.5 7 228.5 40.5 137.4 131.6C57.3 211.7 56.7 302.3 71.3 356.4c2.1 7.9 12 9.6 17.8 3.8L253.6 195.8c6.2-6.2 16.4-6.2 22.6 0c5.4 5.4 6.1 13.6 2.2 19.8z'
    ]
  },
  GX = {
    prefix: 'fas',
    iconName: 'heart',
    icon: [
      512,
      512,
      [128153, 128154, 128155, 128156, 128420, 129293, 129294, 129505, 9829, 10084, 61578],
      'f004',
      'M47.6 300.4L228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6 0 115.2 0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z'
    ]
  },
  qX = {
    prefix: 'fas',
    iconName: 'hat-cowboy',
    icon: [
      640,
      512,
      [],
      'f8c0',
      'M320 64c14.4 0 22.3-7 30.8-14.4C360.4 41.1 370.7 32 392 32c49.3 0 84.4 152.2 97.9 221.9C447.8 272.1 390.9 288 320 288s-127.8-15.9-169.9-34.1C163.6 184.2 198.7 32 248 32c21.3 0 31.6 9.1 41.2 17.6C297.7 57 305.6 64 320 64zM111.1 270.7c47.2 24.5 117.5 49.3 209 49.3s161.8-24.8 208.9-49.3c24.8-12.9 49.8-28.3 70.1-47.7c7.9-7.9 20.2-9.2 29.6-3.3c9.5 5.9 13.5 17.9 9.9 28.5c-13.5 37.7-38.4 72.3-66.1 100.6C523.7 398.9 443.6 448 320 448s-203.6-49.1-252.5-99.2C39.8 320.4 14.9 285.8 1.4 248.1c-3.6-10.6 .4-22.6 9.9-28.5c9.5-5.9 21.7-4.5 29.6 3.3c20.4 19.4 45.3 34.8 70.1 47.7z'
    ]
  },
  KX = {
    prefix: 'fas',
    iconName: 'cat',
    icon: [
      576,
      512,
      [128008],
      'f6be',
      'M320 192h17.1c22.1 38.3 63.5 64 110.9 64c11 0 21.8-1.4 32-4v4 32V480c0 17.7-14.3 32-32 32s-32-14.3-32-32V339.2L280 448h56c17.7 0 32 14.3 32 32s-14.3 32-32 32H192c-53 0-96-43-96-96V192.5c0-16.1-12-29.8-28-31.8l-7.9-1c-17.5-2.2-30-18.2-27.8-35.7s18.2-30 35.7-27.8l7.9 1c48 6 84.1 46.8 84.1 95.3v85.3c34.4-51.7 93.2-85.8 160-85.8zm160 26.5v0c-10 3.5-20.8 5.5-32 5.5c-28.4 0-54-12.4-71.6-32h0c-3.7-4.1-7-8.5-9.9-13.2C357.3 164 352 146.6 352 128v0V32 12 10.7C352 4.8 356.7 .1 362.6 0h.2c3.3 0 6.4 1.6 8.4 4.2l0 .1L384 21.3l27.2 36.3L416 64h64l4.8-6.4L512 21.3 524.8 4.3l0-.1c2-2.6 5.1-4.2 8.4-4.2h.2C539.3 .1 544 4.8 544 10.7V12 32v96c0 17.3-4.6 33.6-12.6 47.6c-11.3 19.8-29.6 35.2-51.4 42.9zM432 128a16 16 0 1 0 -32 0 16 16 0 1 0 32 0zm48 16a16 16 0 1 0 0-32 16 16 0 1 0 0 32z'
    ]
  },
  YX = {
    prefix: 'fas',
    iconName: 'eye',
    icon: [
      576,
      512,
      [128065],
      'f06e',
      'M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z'
    ]
  },
  JX = {
    prefix: 'fas',
    iconName: 'pen',
    icon: [
      512,
      512,
      [128394],
      'f304',
      'M362.7 19.3L314.3 67.7 444.3 197.7l48.4-48.4c25-25 25-65.5 0-90.5L453.3 19.3c-25-25-65.5-25-90.5 0zm-71 71L58.6 323.5c-10.4 10.4-18 23.3-22.2 37.4L1 481.2C-1.5 489.7 .8 498.8 7 505s15.3 8.5 23.7 6.1l120.3-35.4c14.1-4.2 27-11.8 37.4-22.2L421.7 220.3 291.7 90.3z'
    ]
  },
  QX = {
    prefix: 'fas',
    iconName: 'hat-wizard',
    icon: [
      512,
      512,
      [],
      'f6e8',
      'M64 416L168.6 180.7c15.3-34.4 40.3-63.5 72-83.7l146.9-94c3-1.9 6.5-2.9 10-2.9C407.7 0 416 8.3 416 18.6v1.6c0 2.6-.5 5.1-1.4 7.5L354.8 176.9c-1.9 4.7-2.8 9.7-2.8 14.7c0 5.5 1.2 11 3.4 16.1L448 416H240.9l11.8-35.4 40.4-13.5c6.5-2.2 10.9-8.3 10.9-15.2s-4.4-13-10.9-15.2l-40.4-13.5-13.5-40.4C237 276.4 230.9 272 224 272s-13 4.4-15.2 10.9l-13.5 40.4-40.4 13.5C148.4 339 144 345.1 144 352s4.4 13 10.9 15.2l40.4 13.5L207.1 416H64zM279.6 141.5c-1.1-3.3-4.1-5.5-7.6-5.5s-6.5 2.2-7.6 5.5l-6.7 20.2-20.2 6.7c-3.3 1.1-5.5 4.1-5.5 7.6s2.2 6.5 5.5 7.6l20.2 6.7 6.7 20.2c1.1 3.3 4.1 5.5 7.6 5.5s6.5-2.2 7.6-5.5l6.7-20.2 20.2-6.7c3.3-1.1 5.5-4.1 5.5-7.6s-2.2-6.5-5.5-7.6l-20.2-6.7-6.7-20.2zM32 448H480c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32z'
    ]
  },
  XX = {
    prefix: 'fas',
    iconName: 'table-cells-large',
    icon: [
      512,
      512,
      ['th-large'],
      'f009',
      'M448 96V224H288V96H448zm0 192V416H288V288H448zM224 224H64V96H224V224zM64 288H224V416H64V288zM64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64z'
    ]
  },
  ZX = {
    prefix: 'fas',
    iconName: 'dove',
    icon: [
      512,
      512,
      [128330],
      'f4ba',
      'M160.8 96.5c14 17 31 30.9 49.5 42.2c25.9 15.8 53.7 25.9 77.7 31.6V138.8C265.8 108.5 250 71.5 248.6 28c-.4-11.3-7.5-21.5-18.4-24.4c-7.6-2-15.8-.2-21 5.8c-13.3 15.4-32.7 44.6-48.4 87.2zM320 144v30.6l0 0v1.3l0 0 0 32.1c-60.8-5.1-185-43.8-219.3-157.2C97.4 40 87.9 32 76.6 32c-7.9 0-15.3 3.9-18.8 11C46.8 65.9 32 112.1 32 176c0 116.9 80.1 180.5 118.4 202.8L11.8 416.6C6.7 418 2.6 421.8 .9 426.8s-.8 10.6 2.3 14.8C21.7 466.2 77.3 512 160 512c3.6 0 7.2-1.2 10-3.5L245.6 448H320c88.4 0 160-71.6 160-160V128l29.9-44.9c1.3-2 2.1-4.4 2.1-6.8c0-6.8-5.5-12.3-12.3-12.3H400c-44.2 0-80 35.8-80 80zm80-16a16 16 0 1 1 0 32 16 16 0 1 1 0-32z'
    ]
  },
  eZ = {
    prefix: 'fas',
    iconName: 'list-ul',
    icon: [
      512,
      512,
      ['list-dots'],
      'f0ca',
      'M64 144a48 48 0 1 0 0-96 48 48 0 1 0 0 96zM192 64c-17.7 0-32 14.3-32 32s14.3 32 32 32H480c17.7 0 32-14.3 32-32s-14.3-32-32-32H192zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32H480c17.7 0 32-14.3 32-32s-14.3-32-32-32H192zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32H480c17.7 0 32-14.3 32-32s-14.3-32-32-32H192zM64 464a48 48 0 1 0 0-96 48 48 0 1 0 0 96zm48-208a48 48 0 1 0 -96 0 48 48 0 1 0 96 0z'
    ]
  },
  tZ = {
    prefix: 'fas',
    iconName: 'xmark',
    icon: [
      384,
      512,
      [128473, 10005, 10006, 10060, 215, 'close', 'multiply', 'remove', 'times'],
      'f00d',
      'M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z'
    ]
  },
  nZ = {
    prefix: 'fas',
    iconName: 'users-line',
    icon: [
      640,
      512,
      [],
      'e592',
      'M211.2 96a64 64 0 1 0 -128 0 64 64 0 1 0 128 0zM32 256c0 17.7 14.3 32 32 32h85.6c10.1-39.4 38.6-71.5 75.8-86.6c-9.7-6-21.2-9.4-33.4-9.4H96c-35.3 0-64 28.7-64 64zm461.6 32H576c17.7 0 32-14.3 32-32c0-35.3-28.7-64-64-64H448c-11.7 0-22.7 3.1-32.1 8.6c38.1 14.8 67.4 47.3 77.7 87.4zM391.2 226.4c-6.9-1.6-14.2-2.4-21.6-2.4h-96c-8.5 0-16.7 1.1-24.5 3.1c-30.8 8.1-55.6 31.1-66.1 60.9c-3.5 10-5.5 20.8-5.5 32c0 17.7 14.3 32 32 32h224c17.7 0 32-14.3 32-32c0-11.2-1.9-22-5.5-32c-10.8-30.7-36.8-54.2-68.9-61.6zM563.2 96a64 64 0 1 0 -128 0 64 64 0 1 0 128 0zM321.6 192a80 80 0 1 0 0-160 80 80 0 1 0 0 160zM32 416c-17.7 0-32 14.3-32 32s14.3 32 32 32H608c17.7 0 32-14.3 32-32s-14.3-32-32-32H32z'
    ]
  },
  rZ = {
    prefix: 'fas',
    iconName: 'rocket',
    icon: [
      512,
      512,
      [],
      'f135',
      'M156.6 384.9L125.7 354c-8.5-8.5-11.5-20.8-7.7-32.2c3-8.9 7-20.5 11.8-33.8L24 288c-8.6 0-16.6-4.6-20.9-12.1s-4.2-16.7 .2-24.1l52.5-88.5c13-21.9 36.5-35.3 61.9-35.3l82.3 0c2.4-4 4.8-7.7 7.2-11.3C289.1-4.1 411.1-8.1 483.9 5.3c11.6 2.1 20.6 11.2 22.8 22.8c13.4 72.9 9.3 194.8-111.4 276.7c-3.5 2.4-7.3 4.8-11.3 7.2v82.3c0 25.4-13.4 49-35.3 61.9l-88.5 52.5c-7.4 4.4-16.6 4.5-24.1 .2s-12.1-12.2-12.1-20.9V380.8c-14.1 4.9-26.4 8.9-35.7 11.9c-11.2 3.6-23.4 .5-31.8-7.8zM384 168a40 40 0 1 0 0-80 40 40 0 1 0 0 80z'
    ]
  },
  iZ = {
    prefix: 'fas',
    iconName: 'disease',
    icon: [
      512,
      512,
      [],
      'f7fa',
      'M236.4 61.4L227 75.5c-21.3 32-59.4 48.5-97.3 42.1l-59.6-9.9C33.4 101.6 0 129.9 .1 167.1c0 15.9 6.4 31.2 17.6 42.5l29.2 29.2c11 11 17.2 25.9 17.2 41.5c0 15.8-6.4 30.9-17.7 42L33.3 335.1C22.2 345.9 16 360.7 16 376.2c0 36.8 34.1 64.2 70.1 56.2l62.3-13.8c7.7-1.7 15.7-2.6 23.6-2.6h10c27.2 0 53.7 9.3 75 26.3L287.8 467c10.5 8.4 23.6 13 37 13c32.7 0 59.3-26.5 59.3-59.3l0-25.2c0-34.9 21.4-66.2 53.9-78.8l36.9-14.3c22.4-8.7 37.2-30.3 37.2-54.3c0-28.1-20.1-52.3-47.8-57.3l-28-5.1c-36.5-6.7-65.4-34.5-73.6-70.7l-7.1-31.5C348.9 53.4 322.1 32 291.3 32c-22 0-42.6 11-54.9 29.4zM160 192a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm128 16a16 16 0 1 1 32 0 16 16 0 1 1 -32 0zm0 80a32 32 0 1 1 0 64 32 32 0 1 1 0-64z'
    ]
  },
  sZ = {
    prefix: 'fas',
    iconName: 'shield',
    icon: [
      512,
      512,
      [128737, 'shield-blank'],
      'f132',
      'M256 0c4.6 0 9.2 1 13.4 2.9L457.7 82.8c22 9.3 38.4 31 38.3 57.2c-.5 99.2-41.3 280.7-213.6 363.2c-16.7 8-36.1 8-52.8 0C57.3 420.7 16.5 239.2 16 140c-.1-26.2 16.3-47.9 38.3-57.2L242.7 2.9C246.8 1 251.4 0 256 0z'
    ]
  },
  oZ = {
    prefix: 'fas',
    iconName: 'hippo',
    icon: [
      640,
      512,
      [129435],
      'f6ed',
      'M407 47c9.4-9.4 24.6-9.4 33.9 0l17.2 17.2c1.9-.1 3.9-.2 5.8-.2h32c11.2 0 21.9 2.3 31.6 6.5L543 55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9L564 101.9c7.6 12.2 12 26.7 12 42.1c0 10.2 7.4 18.8 16.7 23c27.9 12.5 47.3 40.5 47.3 73c0 26.2-12.6 49.4-32 64v32c0 8.8-7.2 16-16 16H560c-8.8 0-16-7.2-16-16V320H480v16c0 8.8-7.2 16-16 16H432c-8.8 0-16-7.2-16-16V318.4c-11.8-2.4-22.7-7.4-32-14.4c-1.5-1.1-2.9-2.3-4.3-3.5c-17-14.7-27.7-36.4-27.7-60.5c0-8.8-7.2-16-16-16s-16 7.2-16 16c0 44.7 26.2 83.2 64 101.2V352c0 17.7 14.3 32 32 32h32v64c0 17.7-14.3 32-32 32H352c-17.7 0-32-14.3-32-32V372c-19.8 7.7-41.4 12-64 12s-44.2-4.3-64-12v76c0 17.7-14.3 32-32 32H96c-17.7 0-32-14.3-32-32V329.1L45.9 369.7c-5.4 12.1-19.6 17.6-31.7 12.2S-3.3 362.4 2.1 350.3L24 300.9c5.3-11.9 8-24.7 8-37.7C32 155.7 117.2 68 223.8 64.1l.2-.1h7.2H256h32c41.7 0 83.4 12.1 117.2 25.7c1.7-1.8 3.5-3.6 5.3-5.2L407 81c-9.4-9.4-9.4-24.6 0-33.9zm73 185a24 24 0 1 0 -48 0 24 24 0 1 0 48 0zm88 24a24 24 0 1 0 0-48 24 24 0 1 0 0 48zM480 144a16 16 0 1 0 -32 0 16 16 0 1 0 32 0zm48 16a16 16 0 1 0 0-32 16 16 0 1 0 0 32z'
    ]
  },
  aZ = {
    prefix: 'fas',
    iconName: 'hand-fist',
    icon: [
      448,
      512,
      [9994, 'fist-raised'],
      'f6de',
      'M192 0c17.7 0 32 14.3 32 32V144H160V32c0-17.7 14.3-32 32-32zM64 64c0-17.7 14.3-32 32-32s32 14.3 32 32v80H64V64zm192 0c0-17.7 14.3-32 32-32s32 14.3 32 32v96c0 17.7-14.3 32-32 32s-32-14.3-32-32V64zm96 64c0-17.7 14.3-32 32-32s32 14.3 32 32v64c0 17.7-14.3 32-32 32s-32-14.3-32-32V128zm-96 88l0-.6c9.4 5.4 20.3 8.6 32 8.6c13.2 0 25.4-4 35.6-10.8c8.7 24.9 32.5 42.8 60.4 42.8c11.7 0 22.6-3.1 32-8.6V256c0 52.3-25.1 98.8-64 128v96c0 17.7-14.3 32-32 32H160c-17.7 0-32-14.3-32-32V401.6c-17.3-7.9-33.2-18.8-46.9-32.5L69.5 357.5C45.5 333.5 32 300.9 32 267V240c0-35.3 28.7-64 64-64h88c22.1 0 40 17.9 40 40s-17.9 40-40 40H128c-8.8 0-16 7.2-16 16s7.2 16 16 16h56c39.8 0 72-32.2 72-72z'
    ]
  },
  lZ = {
    prefix: 'fas',
    iconName: 'users-gear',
    icon: [
      640,
      512,
      ['users-cog'],
      'f509',
      'M144 160A80 80 0 1 0 144 0a80 80 0 1 0 0 160zm368 0A80 80 0 1 0 512 0a80 80 0 1 0 0 160zM0 298.7C0 310.4 9.6 320 21.3 320H234.7c.2 0 .4 0 .7 0c-26.6-23.5-43.3-57.8-43.3-96c0-7.6 .7-15 1.9-22.3c-13.6-6.3-28.7-9.7-44.6-9.7H106.7C47.8 192 0 239.8 0 298.7zM320 320c24 0 45.9-8.8 62.7-23.3c2.5-3.7 5.2-7.3 8-10.7c2.7-3.3 5.7-6.1 9-8.3C410 262.3 416 243.9 416 224c0-53-43-96-96-96s-96 43-96 96s43 96 96 96zm65.4 60.2c-10.3-5.9-18.1-16.2-20.8-28.2H261.3C187.7 352 128 411.7 128 485.3c0 14.7 11.9 26.7 26.7 26.7H455.2c-2.1-5.2-3.2-10.9-3.2-16.4v-3c-1.3-.7-2.7-1.5-4-2.3l-2.6 1.5c-16.8 9.7-40.5 8-54.7-9.7c-4.5-5.6-8.6-11.5-12.4-17.6l-.1-.2-.1-.2-2.4-4.1-.1-.2-.1-.2c-3.4-6.2-6.4-12.6-9-19.3c-8.2-21.2 2.2-42.6 19-52.3l2.7-1.5c0-.8 0-1.5 0-2.3s0-1.5 0-2.3l-2.7-1.5zM533.3 192H490.7c-15.9 0-31 3.5-44.6 9.7c1.3 7.2 1.9 14.7 1.9 22.3c0 17.4-3.5 33.9-9.7 49c2.5 .9 4.9 2 7.1 3.3l2.6 1.5c1.3-.8 2.6-1.6 4-2.3v-3c0-19.4 13.3-39.1 35.8-42.6c7.9-1.2 16-1.9 24.2-1.9s16.3 .6 24.2 1.9c22.5 3.5 35.8 23.2 35.8 42.6v3c1.3 .7 2.7 1.5 4 2.3l2.6-1.5c16.8-9.7 40.5-8 54.7 9.7c2.3 2.8 4.5 5.8 6.6 8.7c-2.1-57.1-49-102.7-106.6-102.7zm91.3 163.9c6.3-3.6 9.5-11.1 6.8-18c-2.1-5.5-4.6-10.8-7.4-15.9l-2.3-4c-3.1-5.1-6.5-9.9-10.2-14.5c-4.6-5.7-12.7-6.7-19-3l-2.9 1.7c-9.2 5.3-20.4 4-29.6-1.3s-16.1-14.5-16.1-25.1v-3.4c0-7.3-4.9-13.8-12.1-14.9c-6.5-1-13.1-1.5-19.9-1.5s-13.4 .5-19.9 1.5c-7.2 1.1-12.1 7.6-12.1 14.9v3.4c0 10.6-6.9 19.8-16.1 25.1s-20.4 6.6-29.6 1.3l-2.9-1.7c-6.3-3.6-14.4-2.6-19 3c-3.7 4.6-7.1 9.5-10.2 14.6l-2.3 3.9c-2.8 5.1-5.3 10.4-7.4 15.9c-2.6 6.8 .5 14.3 6.8 17.9l2.9 1.7c9.2 5.3 13.7 15.8 13.7 26.4s-4.5 21.1-13.7 26.4l-3 1.7c-6.3 3.6-9.5 11.1-6.8 17.9c2.1 5.5 4.6 10.7 7.4 15.8l2.4 4.1c3 5.1 6.4 9.9 10.1 14.5c4.6 5.7 12.7 6.7 19 3l2.9-1.7c9.2-5.3 20.4-4 29.6 1.3s16.1 14.5 16.1 25.1v3.4c0 7.3 4.9 13.8 12.1 14.9c6.5 1 13.1 1.5 19.9 1.5s13.4-.5 19.9-1.5c7.2-1.1 12.1-7.6 12.1-14.9v-3.4c0-10.6 6.9-19.8 16.1-25.1s20.4-6.6 29.6-1.3l2.9 1.7c6.3 3.6 14.4 2.6 19-3c3.7-4.6 7.1-9.4 10.1-14.5l2.4-4.2c2.8-5.1 5.3-10.3 7.4-15.8c2.6-6.8-.5-14.3-6.8-17.9l-3-1.7c-9.2-5.3-13.7-15.8-13.7-26.4s4.5-21.1 13.7-26.4l3-1.7zM472 384a40 40 0 1 1 80 0 40 40 0 1 1 -80 0z'
    ]
  }
function xI(t, e) {
  var n = Object.keys(t)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Pi(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? xI(Object(n), !0).forEach(function (r) {
          Wn(t, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : xI(Object(n)).forEach(function (r) {
          Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
        })
  }
  return t
}
function op(t) {
  '@babel/helpers - typeof'
  return (
    (op =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (e) {
            return typeof e
          }
        : function (e) {
            return e &&
              typeof Symbol == 'function' &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? 'symbol'
              : typeof e
          }),
    op(t)
  )
}
function Wn(t, e, n) {
  return (
    (e = dZ(e)),
    e in t
      ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (t[e] = n),
    t
  )
}
function cZ(t, e) {
  if (t == null) return {}
  var n = {},
    r = Object.keys(t),
    i,
    s
  for (s = 0; s < r.length; s++) (i = r[s]), !(e.indexOf(i) >= 0) && (n[i] = t[i])
  return n
}
function uZ(t, e) {
  if (t == null) return {}
  var n = cZ(t, e),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(t)
    for (i = 0; i < s.length; i++)
      (r = s[i]),
        !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
  }
  return n
}
function hZ(t, e) {
  if (typeof t != 'object' || t === null) return t
  var n = t[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(t, e || 'default')
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (e === 'string' ? String : Number)(t)
}
function dZ(t) {
  var e = hZ(t, 'string')
  return typeof e == 'symbol' ? e : String(e)
}
var fZ =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : typeof self < 'u'
      ? self
      : {},
  lP = { exports: {} }
;(function (t) {
  ;(function (e) {
    var n = function (_, v, T) {
        if (!c(v) || h(v) || d(v) || f(v) || l(v)) return v
        var S,
          I = 0,
          w = 0
        if (u(v)) for (S = [], w = v.length; I < w; I++) S.push(n(_, v[I], T))
        else {
          S = {}
          for (var O in v)
            Object.prototype.hasOwnProperty.call(v, O) && (S[_(O, T)] = n(_, v[O], T))
        }
        return S
      },
      r = function (_, v) {
        v = v || {}
        var T = v.separator || '_',
          S = v.split || /(?=[A-Z])/
        return _.split(S).join(T)
      },
      i = function (_) {
        return p(_)
          ? _
          : ((_ = _.replace(/[\-_\s]+(.)?/g, function (v, T) {
              return T ? T.toUpperCase() : ''
            })),
            _.substr(0, 1).toLowerCase() + _.substr(1))
      },
      s = function (_) {
        var v = i(_)
        return v.substr(0, 1).toUpperCase() + v.substr(1)
      },
      o = function (_, v) {
        return r(_, v).toLowerCase()
      },
      a = Object.prototype.toString,
      l = function (_) {
        return typeof _ == 'function'
      },
      c = function (_) {
        return _ === Object(_)
      },
      u = function (_) {
        return a.call(_) == '[object Array]'
      },
      h = function (_) {
        return a.call(_) == '[object Date]'
      },
      d = function (_) {
        return a.call(_) == '[object RegExp]'
      },
      f = function (_) {
        return a.call(_) == '[object Boolean]'
      },
      p = function (_) {
        return (_ = _ - 0), _ === _
      },
      m = function (_, v) {
        var T = v && 'process' in v ? v.process : v
        return typeof T != 'function'
          ? _
          : function (S, I) {
              return T(S, _, I)
            }
      },
      g = {
        camelize: i,
        decamelize: o,
        pascalize: s,
        depascalize: o,
        camelizeKeys: function (_, v) {
          return n(m(i, v), _)
        },
        decamelizeKeys: function (_, v) {
          return n(m(o, v), _, v)
        },
        pascalizeKeys: function (_, v) {
          return n(m(s, v), _)
        },
        depascalizeKeys: function () {
          return this.decamelizeKeys.apply(this, arguments)
        }
      }
    t.exports ? (t.exports = g) : (e.humps = g)
  })(fZ)
})(lP)
var pZ = lP.exports,
  mZ = ['class', 'style']
function gZ(t) {
  return t
    .split(';')
    .map(function (e) {
      return e.trim()
    })
    .filter(function (e) {
      return e
    })
    .reduce(function (e, n) {
      var r = n.indexOf(':'),
        i = pZ.camelize(n.slice(0, r)),
        s = n.slice(r + 1).trim()
      return (e[i] = s), e
    }, {})
}
function yZ(t) {
  return t.split(/\s+/).reduce(function (e, n) {
    return (e[n] = !0), e
  }, {})
}
function cP(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
  if (typeof t == 'string') return t
  var r = (t.children || []).map(function (l) {
      return cP(l)
    }),
    i = Object.keys(t.attributes || {}).reduce(
      function (l, c) {
        var u = t.attributes[c]
        switch (c) {
          case 'class':
            l.class = yZ(u)
            break
          case 'style':
            l.style = gZ(u)
            break
          default:
            l.attrs[c] = u
        }
        return l
      },
      { attrs: {}, class: {}, style: {} }
    )
  n.class
  var s = n.style,
    o = s === void 0 ? {} : s,
    a = uZ(n, mZ)
  return Do(
    t.tag,
    Pi(Pi(Pi({}, e), {}, { class: i.class, style: Pi(Pi({}, i.style), o) }, i.attrs), a),
    r
  )
}
var uP = !1
try {
  uP = !0
} catch {}
function _Z() {
  if (!uP && console && typeof console.error == 'function') {
    var t
    ;(t = console).error.apply(t, arguments)
  }
}
function uy(t, e) {
  return (Array.isArray(e) && e.length > 0) || (!Array.isArray(e) && e) ? Wn({}, t, e) : {}
}
function vZ(t) {
  var e,
    n =
      ((e = {
        'fa-spin': t.spin,
        'fa-pulse': t.pulse,
        'fa-fw': t.fixedWidth,
        'fa-border': t.border,
        'fa-li': t.listItem,
        'fa-inverse': t.inverse,
        'fa-flip': t.flip === !0,
        'fa-flip-horizontal': t.flip === 'horizontal' || t.flip === 'both',
        'fa-flip-vertical': t.flip === 'vertical' || t.flip === 'both'
      }),
      Wn(e, 'fa-'.concat(t.size), t.size !== null),
      Wn(e, 'fa-rotate-'.concat(t.rotation), t.rotation !== null),
      Wn(e, 'fa-pull-'.concat(t.pull), t.pull !== null),
      Wn(e, 'fa-swap-opacity', t.swapOpacity),
      Wn(e, 'fa-bounce', t.bounce),
      Wn(e, 'fa-shake', t.shake),
      Wn(e, 'fa-beat', t.beat),
      Wn(e, 'fa-fade', t.fade),
      Wn(e, 'fa-beat-fade', t.beatFade),
      Wn(e, 'fa-flash', t.flash),
      Wn(e, 'fa-spin-pulse', t.spinPulse),
      Wn(e, 'fa-spin-reverse', t.spinReverse),
      e)
  return Object.keys(n)
    .map(function (r) {
      return n[r] ? r : null
    })
    .filter(function (r) {
      return r
    })
}
function DI(t) {
  if (t && op(t) === 'object' && t.prefix && t.iconName && t.icon) return t
  if (gv.icon) return gv.icon(t)
  if (t === null) return null
  if (op(t) === 'object' && t.prefix && t.iconName) return t
  if (Array.isArray(t) && t.length === 2) return { prefix: t[0], iconName: t[1] }
  if (typeof t == 'string') return { prefix: 'fas', iconName: t }
}
var bZ = Wr({
  name: 'FontAwesomeIcon',
  props: {
    border: { type: Boolean, default: !1 },
    fixedWidth: { type: Boolean, default: !1 },
    flip: {
      type: [Boolean, String],
      default: !1,
      validator: function (e) {
        return [!0, !1, 'horizontal', 'vertical', 'both'].indexOf(e) > -1
      }
    },
    icon: { type: [Object, Array, String], required: !0 },
    mask: { type: [Object, Array, String], default: null },
    maskId: { type: String, default: null },
    listItem: { type: Boolean, default: !1 },
    pull: {
      type: String,
      default: null,
      validator: function (e) {
        return ['right', 'left'].indexOf(e) > -1
      }
    },
    pulse: { type: Boolean, default: !1 },
    rotation: {
      type: [String, Number],
      default: null,
      validator: function (e) {
        return [90, 180, 270].indexOf(Number.parseInt(e, 10)) > -1
      }
    },
    swapOpacity: { type: Boolean, default: !1 },
    size: {
      type: String,
      default: null,
      validator: function (e) {
        return (
          [
            '2xs',
            'xs',
            'sm',
            'lg',
            'xl',
            '2xl',
            '1x',
            '2x',
            '3x',
            '4x',
            '5x',
            '6x',
            '7x',
            '8x',
            '9x',
            '10x'
          ].indexOf(e) > -1
        )
      }
    },
    spin: { type: Boolean, default: !1 },
    transform: { type: [String, Object], default: null },
    symbol: { type: [Boolean, String], default: !1 },
    title: { type: String, default: null },
    titleId: { type: String, default: null },
    inverse: { type: Boolean, default: !1 },
    bounce: { type: Boolean, default: !1 },
    shake: { type: Boolean, default: !1 },
    beat: { type: Boolean, default: !1 },
    fade: { type: Boolean, default: !1 },
    beatFade: { type: Boolean, default: !1 },
    flash: { type: Boolean, default: !1 },
    spinPulse: { type: Boolean, default: !1 },
    spinReverse: { type: Boolean, default: !1 }
  },
  setup: function (e, n) {
    var r = n.attrs,
      i = Bt(function () {
        return DI(e.icon)
      }),
      s = Bt(function () {
        return uy('classes', vZ(e))
      }),
      o = Bt(function () {
        return uy(
          'transform',
          typeof e.transform == 'string' ? gv.transform(e.transform) : e.transform
        )
      }),
      a = Bt(function () {
        return uy('mask', DI(e.mask))
      }),
      l = Bt(function () {
        return CX(
          i.value,
          Pi(
            Pi(Pi(Pi({}, s.value), o.value), a.value),
            {},
            { symbol: e.symbol, title: e.title, titleId: e.titleId, maskId: e.maskId }
          )
        )
      })
    Bi(
      l,
      function (u) {
        if (!u) return _Z('Could not find one or more icon(s)', i.value, a.value)
      },
      { immediate: !0 }
    )
    var c = Bt(function () {
      return l.value ? cP(l.value.abstract[0], {}, r) : null
    })
    return function () {
      return c.value
    }
  }
})
We.add(UX)
We.add(JX)
We.add(VX)
We.add(YX)
We.add(HX)
We.add(eZ)
We.add(BX)
We.add(RX)
We.add(kX)
We.add(xX)
We.add(XX)
We.add(FX)
We.add(nZ)
We.add(lZ)
We.add(tZ)
We.add(MX)
We.add(sZ)
We.add(rZ)
We.add(OX)
We.add(PX)
We.add(oZ)
We.add(zX)
We.add(jX)
We.add(WX)
We.add(iZ)
We.add(KX)
We.add(ZX)
We.add(NX)
We.add(DX)
We.add(GX)
We.add(aZ)
We.add(QX)
We.add(qX)
We.add(LX)
We.add($X)
const Nh = qD(tH)
Nh.use(XD())
Nh.use(jU, { firebaseApp: zO, modules: [UU()] })
Nh.use(KJ)
Nh.component('FontAwesomeIcon', bZ)
Nh.mount('#app')
